; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?frustum_aabb_remap@@3PAY05IA			; frustum_aabb_remap
EXTRN	__imp__copysign:PROC
EXTRN	__imp_?Memory@@3VxrMemory@@A:BYTE
?frustum_aabb_remap@@3PAY05IA DD 03H			; frustum_aabb_remap
	DD	04H
	DD	05H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	02H
	DD	00H
	DD	01H
	DD	05H
	DD	03H
	DD	01H
	DD	05H
	DD	00H
	DD	04H
	DD	02H
	DD	03H
	DD	01H
	DD	02H
	DD	00H
	DD	04H
	DD	05H
	DD	00H
	DD	04H
	DD	05H
	DD	03H
	DD	01H
	DD	02H
	DD	00H
	DD	04H
	DD	02H
	DD	03H
	DD	01H
	DD	05H
	DD	00H
	DD	01H
	DD	05H
	DD	03H
	DD	04H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
EPS_S	DD	033d6bf95r			; 1e-007
PUBLIC	?positive@@YA_NM@Z				; positive
PUBLIC	?_abs@@YAMM@Z					; _abs
PUBLIC	fabsf
PUBLIC	?max@?$numeric_limits@M@std@@SAMXZ		; std::numeric_limits<float>::max
PUBLIC	?negative@@YA_NM@Z				; negative
PUBLIC	??$_min@M@@YAMMM@Z				; _min<float>
PUBLIC	??$_max@M@@YAMMM@Z				; _max<float>
PUBLIC	??$_Move@AEAPEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YA$$QEAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAPEAV1@@Z ; std::_Move<svector<_vector3<float>,48> * __ptr64 & __ptr64>
PUBLIC	??$_Unchecked@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z ; std::_Unchecked<_vector3<float> * __ptr64>
PUBLIC	??$swap@PEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YAXAEAPEAV?$svector@U?$_vector3@M@@$0DA@@@0@Z ; std::swap<svector<_vector3<float>,48> * __ptr64>
PUBLIC	?inc@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ	; svector<_vector3<float>,48>::inc
PUBLIC	?last@?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@XZ ; svector<_vector3<float>,48>::last
PUBLIC	??A?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@I@Z ; svector<_vector3<float>,48>::operator[]
PUBLIC	?push_back@?$svector@U?$_vector3@M@@$0DA@@@QEAAXU?$_vector3@M@@@Z ; svector<_vector3<float>,48>::push_back
PUBLIC	?clear@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ	; svector<_vector3<float>,48>::clear
PUBLIC	?size@?$svector@U?$_vector3@M@@$0DA@@@QEBAIXZ	; svector<_vector3<float>,48>::size
PUBLIC	??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@XZ	; svector<_vector3<float>,48>::svector<_vector3<float>,48>
PUBLIC	?classify@?$_plane@M@@QEBAMAEBU?$_vector3@M@@@Z	; _plane<float>::classify
PUBLIC	?crossproduct@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z	; _vector3<float>::crossproduct
PUBLIC	?dotproduct@?$_vector3@M@@QEBAMAEBU1@@Z		; _vector3<float>::dotproduct
PUBLIC	?mad@?$_vector3@M@@QEAAAEAU1@AEBU1@0M@Z		; _vector3<float>::mad
PUBLIC	?similar@?$_vector3@M@@QEBAHAEBU1@M@Z		; _vector3<float>::similar
PUBLIC	?sub@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z		; _vector3<float>::sub
PUBLIC	?set@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z		; _vector3<float>::set
PUBLIC	?set@?$_vector3@M@@QEAAAEAU1@MMM@Z		; _vector3<float>::set
PUBLIC	?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ; CFrustum::ClipPoly
PUBLIC	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB
PUBLIC	?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z ; CFrustum::AABB_OverlapPlane
PUBLIC	__real@00000000
PUBLIC	__real@33d6bf95
PUBLIC	__real@34000000
PUBLIC	__real@3727c5ac
PUBLIC	__real@3a83126f
PUBLIC	__real@3d2aaaab
PUBLIC	__real@3d800000
PUBLIC	__real@3eaaaaab
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@41800000
PUBLIC	__real@41c00000
PUBLIC	__real@46fffe00
PUBLIC	__real@7f7fffff
PUBLIC	__real@b727c5ac
PUBLIC	__real@bf800000
PUBLIC	__real@ff7fffff
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__RTCastToVoid:PROC
EXTRN	__chkstk:PROC
EXTRN	logf:PROC
EXTRN	memcpy:PROC
EXTRN	_fltused:DWORD
pdata	SEGMENT
$pdata$?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z DD imagerel $LN171
	DD	imagerel $LN171+801
	DD	imagerel $unwind$?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z
$pdata$?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z DD imagerel $LN35
	DD	imagerel $LN35+313
	DD	imagerel $unwind$?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z DD imagerel $LN18
	DD	imagerel $LN18+177
	DD	imagerel $unwind$?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@ff7fffff
CONST	SEGMENT
__real@ff7fffff DD 0ff7fffffr			; -3.40282e+038
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@b727c5ac
CONST	SEGMENT
__real@b727c5ac DD 0b727c5acr			; -1e-005
CONST	ENDS
;	COMDAT __real@7f7fffff
CONST	SEGMENT
__real@7f7fffff DD 07f7fffffr			; 3.40282e+038
CONST	ENDS
;	COMDAT __real@46fffe00
CONST	SEGMENT
__real@46fffe00 DD 046fffe00r			; 32767
CONST	ENDS
;	COMDAT __real@41c00000
CONST	SEGMENT
__real@41c00000 DD 041c00000r			; 24
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3eaaaaab
CONST	SEGMENT
__real@3eaaaaab DD 03eaaaaabr			; 0.333333
CONST	ENDS
;	COMDAT __real@3d800000
CONST	SEGMENT
__real@3d800000 DD 03d800000r			; 0.0625
CONST	ENDS
;	COMDAT __real@3d2aaaab
CONST	SEGMENT
__real@3d2aaaab DD 03d2aaaabr			; 0.0416667
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@3727c5ac
CONST	SEGMENT
__real@3727c5ac DD 03727c5acr			; 1e-005
CONST	ENDS
;	COMDAT __real@34000000
CONST	SEGMENT
__real@34000000 DD 034000000r			; 1.19209e-007
CONST	ENDS
;	COMDAT __real@33d6bf95
CONST	SEGMENT
__real@33d6bf95 DD 033d6bf95r			; 1e-007
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z DD 031b01H
	DD	0681bH
	DD	02204H
xdata	ENDS
xdata	SEGMENT
$unwind$?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z DD 0154501H
	DD	0ca845H
	DD	0d9840H
	DD	0e883bH
	DD	0f7823H
	DD	010681fH
	DD	028641bH
	DD	027541bH
	DD	026341bH
	DD	022011bH
	DD	0e012f014H
	DD	07010H
$unwind$?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z DD 0e2901H
	DD	07829H
	DD	016822H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
;	COMDAT ?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z
_TEXT	SEGMENT
this$dead$ = 32
P$ = 40
mM$ = 48
?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z PROC ; CFrustum::AABB_OverlapPlane, COMDAT

; 49   : 	{

$LN18:
	sub	rsp, 24

; 51   : 		u32*	id		= frustum_aabb_remap[P.aabb_overlap_id];

	mov	eax, DWORD PTR [rdx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm4, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 51   : 		u32*	id		= frustum_aabb_remap[P.aabb_overlap_id];

	lea	r11, OFFSET FLAT:?frustum_aabb_remap@@3PAY05IA ; frustum_aabb_remap
	movaps	XMMWORD PTR [rsp], xmm6
	lea	r10, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm2, xmm3
	movss	xmm5, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	movss	xmm6, DWORD PTR [rdx+12]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 54   : 		Neg.set			(mM[id[3]],mM[id[4]],mM[id[5]]);

	mov	eax, DWORD PTR [r11+r10*8+12]
	mov	ecx, DWORD PTR [r11+r10*8+16]
	mov	r9d, DWORD PTR [r11+r10*8+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR [r8+rax*4]
	mulss	xmm0, DWORD PTR [r8+rcx*4]
	mulss	xmm1, DWORD PTR [r8+r9*4]
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm2, xmm6
	xorps	xmm0, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 55   : 		if				(P.classify(Neg) > 0)	return	fcvNone;

	comiss	xmm2, xmm0
	jbe	SHORT $LN2@AABB_Overl
	xor	eax, eax

; 62   : 	}

	movaps	xmm6, XMMWORD PTR [rsp]
	add	rsp, 24
	ret	0
$LN2@AABB_Overl:

; 56   : 
; 57   : 		Fvector			Pos;
; 58   : 		Pos.set			(mM[id[0]],mM[id[1]],mM[id[2]]);

	mov	eax, DWORD PTR [r11+r10*8]
	mov	ecx, DWORD PTR [r11+r10*8+4]
	mov	edx, DWORD PTR [r11+r10*8+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm3, DWORD PTR [r8+rax*4]
	mulss	xmm4, DWORD PTR [r8+rcx*4]
	mulss	xmm5, DWORD PTR [r8+rdx*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 59   : 		if				(P.classify(Pos) <= 0)	return	fcvFully;

	xor	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm4
	addss	xmm3, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm3, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 62   : 	}

	movaps	xmm6, XMMWORD PTR [rsp]
	comiss	xmm3, xmm0
	setbe	al
	inc	eax
	add	rsp, 24
	ret	0
?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z ENDP ; CFrustum::AABB_OverlapPlane
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
_TEXT	SEGMENT
this$ = 48
mM$ = 56
test_mask$ = 64
?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z PROC ; CFrustum::testAABB

; 96   : {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 97   : 	// go for trivial rejection or acceptance using "faster overlap test"
; 98   : 	u32		bit = 1;
; 99   : 
; 100  : 	for (int i=0; i<p_count; i++, bit<<=1)

	xor	r10d, r10d
	movaps	XMMWORD PTR [rsp+16], xmm6
	mov	rbx, r8
	movaps	XMMWORD PTR [rsp], xmm7
	mov	rsi, rdx
	mov	rbp, rcx
	mov	r9d, 1
	cmp	DWORD PTR [rcx+240], r10d
	jle	$LN5@testAABB
	lea	r11, QWORD PTR [rcx+4]
	lea	r14, OFFSET FLAT:?frustum_aabb_remap@@3PAY05IA ; frustum_aabb_remap
	xorps	xmm7, xmm7
$LL7@testAABB:

; 101  : 	{
; 102  : 		if (test_mask&bit) {

	mov	r8d, DWORD PTR [rbx]
	test	r8d, r9d
	je	$LN6@testAABB
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 51   : 		u32*	id		= frustum_aabb_remap[P.aabb_overlap_id];

	mov	eax, DWORD PTR [r11+12]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm4, DWORD PTR [r11]
	movss	xmm3, DWORD PTR [r11-4]
	movss	xmm5, DWORD PTR [r11+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	movss	xmm6, DWORD PTR [r11+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm2, xmm3
	movaps	xmm0, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 51   : 		u32*	id		= frustum_aabb_remap[P.aabb_overlap_id];

	lea	rdi, QWORD PTR [rax+rax*2]

; 52   : 
; 53   : 		Fvector			Neg;
; 54   : 		Neg.set			(mM[id[3]],mM[id[4]],mM[id[5]]);

	mov	eax, DWORD PTR [r14+rdi*8+12]
	mov	ecx, DWORD PTR [r14+rdi*8+16]
	mov	edx, DWORD PTR [r14+rdi*8+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm1, xmm5
	mulss	xmm2, DWORD PTR [rsi+rax*4]
	mulss	xmm0, DWORD PTR [rsi+rcx*4]
	mulss	xmm1, DWORD PTR [rsi+rdx*4]
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm2, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 55   : 		if				(P.classify(Neg) > 0)	return	fcvNone;

	comiss	xmm2, xmm7
	ja	SHORT $LN27@testAABB

; 56   : 
; 57   : 		Fvector			Pos;
; 58   : 		Pos.set			(mM[id[0]],mM[id[1]],mM[id[2]]);

	mov	eax, DWORD PTR [r14+rdi*8]
	mov	ecx, DWORD PTR [r14+rdi*8+4]
	mov	edx, DWORD PTR [r14+rdi*8+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm3, DWORD PTR [rsi+rax*4]
	mulss	xmm4, DWORD PTR [rsi+rcx*4]
	mulss	xmm5, DWORD PTR [rsi+rdx*4]
	addss	xmm3, xmm4
	addss	xmm3, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm3, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 59   : 		if				(P.classify(Pos) <= 0)	return	fcvFully;

	comiss	xmm3, xmm7
	ja	SHORT $LN6@testAABB
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 104  : 			if (fcvFully==r)	test_mask&=~bit;					// fully - no need to test this plane

	mov	eax, r9d
	not	eax
	and	eax, r8d
	mov	DWORD PTR [rbx], eax
$LN6@testAABB:

; 97   : 	// go for trivial rejection or acceptance using "faster overlap test"
; 98   : 	u32		bit = 1;
; 99   : 
; 100  : 	for (int i=0; i<p_count; i++, bit<<=1)

	inc	r10d
	add	r11, 20
	add	r9d, r9d
	cmp	r10d, DWORD PTR [rbp+240]
	jl	$LL7@testAABB
$LN5@testAABB:

; 106  : 		}
; 107  : 	}
; 108  : 	return test_mask ? fcvPartial:fcvFully;

	mov	eax, DWORD PTR [rbx]
	neg	eax
	sbb	eax, eax
	add	eax, 2
$LN8@testAABB:

; 109  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+16]
	movaps	xmm7, XMMWORD PTR [rsp]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN27@testAABB:

; 105  : 			else if (fcvNone==r){ test_mask=0; return fcvNone;	}	// none - return

	mov	DWORD PTR [rbx], 0
	xor	eax, eax
	jmp	SHORT $LN8@testAABB
?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ENDP ; CFrustum::testAABB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
_TEXT	SEGMENT
cls$1 = 0
this$ = 304
S$ = 312
D$ = 320
?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z PROC ; CFrustum::ClipPoly

; 284  : {

$LN171:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 272				; 00000110H
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7

; 285  : 	sPoly*	src		= &D;
; 286  : 	sPoly*	dest	= &S;
; 287  : 	for (int i=0; i<p_count; i++)

	xor	r15d, r15d
	lea	r14, QWORD PTR [rcx+240]
	mov	rbp, rdx
	mov	rbx, rcx
	mov	esi, r15d
	movaps	XMMWORD PTR [rax-72], xmm8
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	XMMWORD PTR [rax-104], xmm10
	cmp	DWORD PTR [r14], r15d
	jle	$LN15@ClipPoly
	movss	xmm8, DWORD PTR __real@33d6bf95
	movss	xmm10, DWORD PTR __xmm@80000000800000008000000080000000
	movss	xmm9, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	xorps	xmm7, xmm7
	npad	4
$LL17@ClipPoly:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	r9, r8

; 53   : 	_Left = _Move(_Right);

	mov	r8, rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 31   : 	IC void		clear()						{ count=0;								}

	mov	DWORD PTR [r9+576], r15d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 296  : 		for (u32 j=0; j<src->size(); j++) cls[j]=P.classify((*src)[j]);

	mov	r10d, DWORD PTR [r8+576]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 54   : 	_Right = _Move(_Tmp);

	mov	rbp, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 296  : 		for (u32 j=0; j<src->size(); j++) cls[j]=P.classify((*src)[j]);

	test	r10d, r10d
	je	SHORT $LN12@ClipPoly
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	movss	xmm3, DWORD PTR [rbx+12]
	movss	xmm4, DWORD PTR [rbx+4]
	movss	xmm5, DWORD PTR [rbx]
	lea	rcx, QWORD PTR cls$1[rsp]
	lea	rax, QWORD PTR [r8+8]
	mov	edx, r10d
	movss	xmm6, DWORD PTR [rbx+8]
	npad	6
$LL14@ClipPoly:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm2, xmm5
	movaps	xmm0, xmm4
	movaps	xmm1, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 296  : 		for (u32 j=0; j<src->size(); j++) cls[j]=P.classify((*src)[j]);

	add	rcx, 4
	add	rax, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, DWORD PTR [rax-20]
	mulss	xmm0, DWORD PTR [rax-16]
	mulss	xmm1, DWORD PTR [rax-12]
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm2, xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 296  : 		for (u32 j=0; j<src->size(); j++) cls[j]=P.classify((*src)[j]);

	movss	DWORD PTR [rcx-4], xmm2
	dec	rdx
	jne	SHORT $LL14@ClipPoly
$LN12@ClipPoly:

; 299  : 		cls[src->size()] = cls[0];

	movss	xmm0, DWORD PTR cls$1[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	lea	rcx, QWORD PTR [r10+r10*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 299  : 		cls[src->size()] = cls[0];

	movss	DWORD PTR cls$1[rsp+r10*4], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [r8+rcx*4], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [r8+rcx*4+8], eax
	inc	DWORD PTR [r8+576]
	mov	eax, DWORD PTR [r8+576]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 302  : 		for (j=0; j<src->size()-1; j++)

	mov	ecx, r15d
	dec	eax
	je	$LN9@ClipPoly
$LL11@ClipPoly:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, ecx
	lea	edi, DWORD PTR [rcx+1]
	lea	rdx, QWORD PTR [rax+rax*2]
	lea	r10, QWORD PTR [rdi+rdi*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm0, DWORD PTR [r8+rdx*4]
	subss	xmm0, DWORD PTR [r8+r10*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm8
	jae	SHORT $LN67@ClipPoly
	movss	xmm0, DWORD PTR [r8+rdx*4+4]
	subss	xmm0, DWORD PTR [r8+r10*4+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm8
	jae	SHORT $LN67@ClipPoly
	movss	xmm0, DWORD PTR [r8+rdx*4+8]
	subss	xmm0, DWORD PTR [r8+r10*4+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm8
	jb	$LN10@ClipPoly
$LN67@ClipPoly:
	movss	xmm2, DWORD PTR cls$1[rsp+rax*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	comiss	xmm2, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 306  : 			if (negative(cls[j]))

	jae	$LN7@ClipPoly
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	eax, DWORD PTR [r9+576]
	movsdx	xmm0, QWORD PTR [r8+rdx*4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	QWORD PTR [r9+rcx*4], xmm0
	mov	eax, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [r9+rcx*4+8], eax
	mov	eax, DWORD PTR [r9+576]
	inc	eax
	mov	DWORD PTR [r9+576], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 21   : 	IC bool positive(const float f)		{ return f>=0;	}

	comiss	xmm7, DWORD PTR cls$1[rsp+rdi*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 309  : 				if (positive(cls[j+1]))

	ja	$LN10@ClipPoly
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [r8+r10*4]
	movss	xmm5, DWORD PTR [r8+r10*4+4]
	movss	xmm6, DWORD PTR [r8+r10*4+8]
	subss	xmm4, DWORD PTR [r8+rdx*4]
	subss	xmm5, DWORD PTR [r8+rdx*4+4]
	subss	xmm6, DWORD PTR [r8+rdx*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm5
	movaps	xmm0, xmm4
	movaps	xmm1, xmm6
	mulss	xmm3, DWORD PTR [rbx+4]
	mulss	xmm0, DWORD PTR [rbx]
	mulss	xmm1, DWORD PTR [rbx+8]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 314  : 					if (denum!=0) {

	ucomiss	xmm3, xmm7
	je	$LN10@ClipPoly

; 315  : 						t = -cls[j]/denum; //VERIFY(t<=1.f && t>=0);
; 316  : 						dest->last().mad((*src)[j],D,t);
; 317  : 						dest->inc();
; 318  : 					}
; 319  : 				}
; 320  : 			} else {

	jmp	SHORT $LN169@ClipPoly
$LN7@ClipPoly:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	comiss	xmm7, DWORD PTR cls$1[rsp+rdi*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 322  : 				if (negative(cls[j+1]))

	jbe	$LN10@ClipPoly
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [r8+r10*4]
	movss	xmm5, DWORD PTR [r8+r10*4+4]
	movss	xmm6, DWORD PTR [r8+r10*4+8]
	subss	xmm4, DWORD PTR [r8+rdx*4]
	subss	xmm5, DWORD PTR [r8+rdx*4+4]
	subss	xmm6, DWORD PTR [r8+rdx*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm5
	movaps	xmm0, xmm4
	movaps	xmm1, xmm6
	mulss	xmm3, DWORD PTR [rbx+4]
	mulss	xmm0, DWORD PTR [rbx]
	mulss	xmm1, DWORD PTR [rbx+8]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 328  : 					if (denum!=0) {

	ucomiss	xmm3, xmm7
	je	SHORT $LN10@ClipPoly
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 43   : 	IC reference		last()				{ VERIFY(count<dim); return array[count];}

	mov	eax, DWORD PTR [r9+576]
$LN169@ClipPoly:
	lea	rcx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 329  : 						t = -cls[j]/denum; //VERIFY(t<=1.f && t>=0);

	divss	xmm2, xmm3
	xorps	xmm2, xmm10
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 144  : 		x = p.x + d.x*m;

	mulss	xmm4, xmm2

; 145  : 		y = p.y + d.y*m;

	mulss	xmm5, xmm2

; 146  : 		z = p.z + d.z*m;

	mulss	xmm6, xmm2
	addss	xmm4, DWORD PTR [r8+rdx*4]
	movss	DWORD PTR [r9+rcx*4], xmm4
	addss	xmm5, DWORD PTR [r8+rdx*4+4]
	movss	DWORD PTR [r9+rcx*4+4], xmm5
	addss	xmm6, DWORD PTR [r8+rdx*4+8]
	movss	DWORD PTR [r9+rcx*4+8], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 47   : 	IC void		inc	()						{ count++; }

	inc	DWORD PTR [r9+576]
$LN10@ClipPoly:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp

; 302  : 		for (j=0; j<src->size()-1; j++)

	mov	eax, DWORD PTR [r8+576]
	mov	ecx, edi
	dec	eax
	cmp	edi, eax
	jb	$LL11@ClipPoly
$LN9@ClipPoly:

; 330  : 						dest->last().mad((*src)[j],D,t);
; 331  : 						dest->inc();
; 332  : 					}
; 333  : 				}
; 334  : 			}
; 335  : 		}
; 336  : 
; 337  : 		// here we end up with complete polygon in 'dest' which is inside plane #i
; 338  : 		if (dest->size()<3) return 0;

	cmp	DWORD PTR [r9+576], 3
	jb	SHORT $LN158@ClipPoly

; 285  : 	sPoly*	src		= &D;
; 286  : 	sPoly*	dest	= &S;
; 287  : 	for (int i=0; i<p_count; i++)

	inc	esi
	add	rbx, 20
	cmp	esi, DWORD PTR [r14]
	jl	$LL17@ClipPoly
$LN15@ClipPoly:

; 339  : 	}
; 340  : 	return dest;

	mov	rax, rbp
$LN18@ClipPoly:

; 341  : }

	lea	r11, QWORD PTR [rsp+272]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
$LN158@ClipPoly:

; 330  : 						dest->last().mad((*src)[j],D,t);
; 331  : 						dest->inc();
; 332  : 					}
; 333  : 				}
; 334  : 			}
; 335  : 		}
; 336  : 
; 337  : 		// here we end up with complete polygon in 'dest' which is inside plane #i
; 338  : 		if (dest->size()<3) return 0;

	xor	eax, eax
	jmp	SHORT $LN18@ClipPoly
?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ENDP ; CFrustum::ClipPoly
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?set@?$_vector3@M@@QEAAAEAU1@MMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
?set@?$_vector3@M@@QEAAAEAU1@MMM@Z PROC			; _vector3<float>::set, COMDAT

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3
	mov	rax, rcx
	ret	0
?set@?$_vector3@M@@QEAAAEAU1@MMM@Z ENDP			; _vector3<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?set@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?set@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z PROC		; _vector3<float>::set, COMDAT

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx
	ret	0
?set@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z ENDP		; _vector3<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?sub@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z
_TEXT	SEGMENT
this$ = 8
a$ = 16
v$ = 24
?sub@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z PROC		; _vector3<float>::sub, COMDAT

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	subss	xmm0, DWORD PTR [r8]
	movss	DWORD PTR [rcx], xmm0
	movss	xmm1, DWORD PTR [rdx+4]
	subss	xmm1, DWORD PTR [r8+4]
	movss	DWORD PTR [rcx+4], xmm1
	movss	xmm0, DWORD PTR [rdx+8]
	subss	xmm0, DWORD PTR [r8+8]
	movss	DWORD PTR [rcx+8], xmm0
	ret	0
?sub@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z ENDP		; _vector3<float>::sub
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?similar@?$_vector3@M@@QEBAHAEBU1@M@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
E$ = 24
?similar@?$_vector3@M@@QEBAHAEBU1@M@Z PROC		; _vector3<float>::similar, COMDAT

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm0, DWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	subss	xmm0, DWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm2
	jae	SHORT $LN3@similar
	movss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, DWORD PTR [rdx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm2
	jae	SHORT $LN3@similar
	movss	xmm0, DWORD PTR [rcx+8]
	subss	xmm0, DWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm2
	jae	SHORT $LN3@similar
	mov	eax, 1
	ret	0
$LN3@similar:
	xor	eax, eax
	ret	0
?similar@?$_vector3@M@@QEBAHAEBU1@M@Z ENDP		; _vector3<float>::similar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?mad@?$_vector3@M@@QEAAAEAU1@AEBU1@0M@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
d$ = 24
m$ = 32
?mad@?$_vector3@M@@QEAAAEAU1@AEBU1@0M@Z PROC		; _vector3<float>::mad, COMDAT

; 144  : 		x = p.x + d.x*m;

	movaps	xmm0, xmm3

; 145  : 		y = p.y + d.y*m;

	movaps	xmm1, xmm3

; 146  : 		z = p.z + d.z*m;
; 147  : 		return *this;	

	mov	rax, rcx
	mulss	xmm0, DWORD PTR [r8]
	addss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx], xmm0
	mulss	xmm1, DWORD PTR [r8+4]
	addss	xmm1, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+4], xmm1
	mulss	xmm3, DWORD PTR [r8+8]
	addss	xmm3, DWORD PTR [rdx+8]
	movss	DWORD PTR [rcx+8], xmm3

; 148  : 	}

	ret	0
?mad@?$_vector3@M@@QEAAAEAU1@AEBU1@0M@Z ENDP		; _vector3<float>::mad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?dotproduct@?$_vector3@M@@QEBAMAEBU1@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?dotproduct@?$_vector3@M@@QEBAMAEBU1@@Z PROC		; _vector3<float>::dotproduct, COMDAT

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [rdx+4]
	movss	xmm1, DWORD PTR [rdx]
	movss	xmm2, DWORD PTR [rdx+8]
	mulss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm1, DWORD PTR [rcx]
	mulss	xmm2, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	addss	xmm0, xmm2
	ret	0
?dotproduct@?$_vector3@M@@QEBAMAEBU1@@Z ENDP		; _vector3<float>::dotproduct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?crossproduct@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z
_TEXT	SEGMENT
this$ = 8
v1$ = 16
v2$ = 24
?crossproduct@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z PROC	; _vector3<float>::crossproduct, COMDAT

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [r8+8]
	movss	xmm0, DWORD PTR [rdx+8]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;
; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;
; 276  : 		return *this;	

	mov	rax, rcx
	mulss	xmm0, DWORD PTR [r8+4]
	mulss	xmm1, DWORD PTR [rdx+4]
	subss	xmm1, xmm0
	movss	DWORD PTR [rcx], xmm1
	movss	xmm0, DWORD PTR [rdx]
	movss	xmm2, DWORD PTR [rdx+8]
	mulss	xmm0, DWORD PTR [r8+8]
	mulss	xmm2, DWORD PTR [r8]
	subss	xmm2, xmm0
	movss	DWORD PTR [rcx+4], xmm2
	movss	xmm1, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [r8]
	mulss	xmm1, DWORD PTR [r8+4]
	mulss	xmm0, DWORD PTR [rdx+4]
	subss	xmm1, xmm0
	movss	DWORD PTR [rcx+8], xmm1

; 277  : 	}

	ret	0
?crossproduct@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z ENDP	; _vector3<float>::crossproduct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
;	COMDAT ?classify@?$_plane@M@@QEBAMAEBU?$_vector3@M@@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?classify@?$_plane@M@@QEBAMAEBU?$_vector3@M@@@Z PROC	; _plane<float>::classify, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [rdx+4]
	movss	xmm1, DWORD PTR [rdx]
	movss	xmm2, DWORD PTR [rdx+8]
	mulss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm1, DWORD PTR [rcx]
	mulss	xmm2, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	addss	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h

; 57   : 		return n.dotproduct(v)+d;

	addss	xmm0, DWORD PTR [rcx+12]

; 58   : 	}

	ret	0
?classify@?$_plane@M@@QEBAMAEBU?$_vector3@M@@@Z ENDP	; _plane<float>::classify
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
;	COMDAT ??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@XZ PROC		; svector<_vector3<float>,48>::svector<_vector3<float>,48>, COMDAT

; 22   : 	{}

	mov	DWORD PTR [rcx+576], 0
	mov	rax, rcx
	ret	0
??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@XZ ENDP		; svector<_vector3<float>,48>::svector<_vector3<float>,48>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
;	COMDAT ?size@?$svector@U?$_vector3@M@@$0DA@@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?size@?$svector@U?$_vector3@M@@$0DA@@@QEBAIXZ PROC	; svector<_vector3<float>,48>::size, COMDAT

; 30   : 	IC u32		size()		const			{ return count;							}

	mov	eax, DWORD PTR [rcx+576]
	ret	0
?size@?$svector@U?$_vector3@M@@$0DA@@@QEBAIXZ ENDP	; svector<_vector3<float>,48>::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
;	COMDAT ?clear@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ PROC	; svector<_vector3<float>,48>::clear, COMDAT

; 31   : 	IC void		clear()						{ count=0;								}

	mov	DWORD PTR [rcx+576], 0
	ret	0
?clear@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ ENDP	; svector<_vector3<float>,48>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
;	COMDAT ?push_back@?$svector@U?$_vector3@M@@$0DA@@@QEAAXU?$_vector3@M@@@Z
_TEXT	SEGMENT
this$ = 8
e$ = 16
?push_back@?$svector@U?$_vector3@M@@$0DA@@@QEAAXU?$_vector3@M@@@Z PROC ; svector<_vector3<float>,48>::push_back, COMDAT

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	eax, DWORD PTR [rcx+576]
	movsdx	xmm0, QWORD PTR [rdx]
	lea	r8, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [rdx+8]
	movsdx	QWORD PTR [rcx+r8*4], xmm0
	mov	DWORD PTR [rcx+r8*4+8], eax
	inc	DWORD PTR [rcx+576]
	ret	0
?push_back@?$svector@U?$_vector3@M@@$0DA@@@QEAAXU?$_vector3@M@@@Z ENDP ; svector<_vector3<float>,48>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
;	COMDAT ??A?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@I@Z
_TEXT	SEGMENT
this$ = 8
id$ = 16
??A?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@I@Z PROC ; svector<_vector3<float>,48>::operator[], COMDAT

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rcx+rdx*4]
	ret	0
??A?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@I@Z ENDP ; svector<_vector3<float>,48>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
;	COMDAT ?last@?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
?last@?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@XZ PROC ; svector<_vector3<float>,48>::last, COMDAT

; 43   : 	IC reference		last()				{ VERIFY(count<dim); return array[count];}

	mov	eax, DWORD PTR [rcx+576]
	lea	rdx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rcx+rdx*4]
	ret	0
?last@?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@XZ ENDP ; svector<_vector3<float>,48>::last
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
;	COMDAT ?inc@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?inc@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ PROC	; svector<_vector3<float>,48>::inc, COMDAT

; 47   : 	IC void		inc	()						{ count++; }

	inc	DWORD PTR [rcx+576]
	ret	0
?inc@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ ENDP	; svector<_vector3<float>,48>::inc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@PEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YAXAEAPEAV?$svector@U?$_vector3@M@@$0DA@@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YAXAEAPEAV?$svector@U?$_vector3@M@@$0DA@@@0@Z PROC ; std::swap<svector<_vector3<float>,48> * __ptr64>, COMDAT

; 52   : 	_Ty _Tmp = _Move(_Left);
; 53   : 	_Left = _Move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 55   : 	}

	ret	0
??$swap@PEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YAXAEAPEAV?$svector@U?$_vector3@M@@$0DA@@@0@Z ENDP ; std::swap<svector<_vector3<float>,48> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z PROC ; std::_Unchecked<_vector3<float> * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z ENDP ; std::_Unchecked<_vector3<float> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YA$$QEAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YA$$QEAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAPEAV1@@Z PROC ; std::_Move<svector<_vector3<float>,48> * __ptr64 & __ptr64>, COMDAT

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, rcx

; 1529 : 	}

	ret	0
??$_Move@AEAPEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YA$$QEAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAPEAV1@@Z ENDP ; std::_Move<svector<_vector3<float>,48> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ??$_max@M@@YAMMM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$_max@M@@YAMMM@Z PROC					; _max<float>, COMDAT

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN4@max
	movaps	xmm0, xmm1
$LN4@max:
	ret	0
??$_max@M@@YAMMM@Z ENDP					; _max<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ??$_min@M@@YAMMM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$_min@M@@YAMMM@Z PROC					; _min<float>, COMDAT

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm0, xmm1
	jb	SHORT $LN4@min
	movaps	xmm0, xmm1
$LN4@min:
	ret	0
??$_min@M@@YAMMM@Z ENDP					; _min<float>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?negative@@YA_NM@Z
_TEXT	SEGMENT
f$ = 8
?negative@@YA_NM@Z PROC					; negative, COMDAT

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	setb	al
	ret	0
?negative@@YA_NM@Z ENDP					; negative
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\limits
;	COMDAT ?max@?$numeric_limits@M@std@@SAMXZ
_TEXT	SEGMENT
?max@?$numeric_limits@M@std@@SAMXZ PROC			; std::numeric_limits<float>::max, COMDAT

; 1071 : 		{	// return maximum value
; 1072 : 		return (FLT_MAX);

	movss	xmm0, DWORD PTR __real@7f7fffff

; 1073 : 		}

	ret	0
?max@?$numeric_limits@M@std@@SAMXZ ENDP			; std::numeric_limits<float>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 8
fabsf	PROC						; COMDAT

; 687  :     return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff

; 688  : }

	ret	0
fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ?_abs@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?_abs@@YAMM@Z PROC					; _abs, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 98   : IC float	_abs	(float x)		{ return fabsf(x); }

	ret	0
?_abs@@YAMM@Z ENDP					; _abs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?positive@@YA_NM@Z
_TEXT	SEGMENT
f$ = 8
?positive@@YA_NM@Z PROC					; positive, COMDAT

; 21   : 	IC bool positive(const float f)		{ return f>=0;	}

	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	setae	al
	ret	0
?positive@@YA_NM@Z ENDP					; positive
_TEXT	ENDS
END
