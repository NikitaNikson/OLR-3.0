; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z ; CFrustum::AABB_OverlapPlane
PUBLIC	?set@?$_plane@M@@QEAAAEAV1@AEAV1@@Z		; _plane<float>::set
PUBLIC	?_abs@@YANN@Z					; _abs
PUBLIC	?_sqrt@@YANN@Z					; _sqrt
PUBLIC	?rsqrt@@YANN@Z					; rsqrt
PUBLIC	?exact_normalize@@YAHPEAM@Z			; exact_normalize
PUBLIC	?exact_normalize@@YAHAEAU?$_vector3@M@@@Z	; exact_normalize
PUBLIC	?build_precise@?$_plane@M@@QEAAAEAV1@AEBU?$_vector3@M@@00@Z ; _plane<float>::build_precise
PUBLIC	?end@?$svector@U?$_vector3@M@@$0DA@@@QEAAPEAU?$_vector3@M@@XZ ; svector<_vector3<float>,48>::end
PUBLIC	??$_Unchecked@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z ; std::_Unchecked<_vector3<float> * __ptr64>
PUBLIC	??$_Iter_cat@PEAU?$_vector3@M@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAU?$_vector3@M@@@Z ; std::_Iter_cat<_vector3<float> * __ptr64>
PUBLIC	??$_Move@AEAU?$_vector3@M@@@std@@YA$$QEAU?$_vector3@M@@AEAU1@@Z ; std::_Move<_vector3<float> & __ptr64>
PUBLIC	??$swap@U?$_vector3@M@@@std@@YAXAEAU?$_vector3@M@@0@Z ; std::swap<_vector3<float> >
PUBLIC	??$iter_swap@PEAU?$_vector3@M@@PEAU1@@std@@YAXPEAU?$_vector3@M@@0@Z ; std::iter_swap<_vector3<float> * __ptr64,_vector3<float> * __ptr64>
PUBLIC	??$_Reverse@PEAU?$_vector3@M@@@std@@YAXPEAU?$_vector3@M@@0Ubidirectional_iterator_tag@0@@Z ; std::_Reverse<_vector3<float> * __ptr64>
PUBLIC	??$reverse@PEAU?$_vector3@M@@@std@@YAXPEAU?$_vector3@M@@0@Z ; std::reverse<_vector3<float> * __ptr64>
PUBLIC	?set@?$_vector3@M@@QEAAAEAU1@MMM@Z		; _vector3<float>::set
PUBLIC	?set@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z		; _vector3<float>::set
PUBLIC	?invert@?$_matrix@M@@QEAAAEAU1@AEBU1@@Z		; _matrix<float>::invert
PUBLIC	?add@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z		; _vector3<float>::add
PUBLIC	?mul@?$_vector3@M@@QEAAAEAU1@AEBU1@M@Z		; _vector3<float>::mul
PUBLIC	?normalize@?$_vector3@M@@QEAAAEAU1@XZ		; _vector3<float>::normalize
PUBLIC	?crossproduct@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z	; _vector3<float>::crossproduct
PUBLIC	?build_camera_dir@?$_matrix@M@@QEAAAEAU1@AEBU?$_vector3@M@@00@Z ; _matrix<float>::build_camera_dir
PUBLIC	?transform_tiny32@?$_matrix@M@@QEBAXAEAU?$_vector2@M@@AEBU?$_vector3@M@@@Z ; _matrix<float>::transform_tiny32
PUBLIC	?transform_tiny23@?$_matrix@M@@QEBAXAEAU?$_vector3@M@@AEBU?$_vector2@M@@@Z ; _matrix<float>::transform_tiny23
PUBLIC	?set@?$_vector2@M@@QEAAAEAU1@MM@Z		; _vector2<float>::set
PUBLIC	??$_min@M@@YAMMM@Z				; _min<float>
PUBLIC	?min@?$_vector2@M@@QEAAAEAU1@MM@Z		; _vector2<float>::min
PUBLIC	??$_max@M@@YAMMM@Z				; _max<float>
PUBLIC	?max@?$_vector2@M@@QEAAAEAU1@MM@Z		; _vector2<float>::max
PUBLIC	?_clear@CFrustum@@QEAAXXZ			; CFrustum::_clear
PUBLIC	?negative@@YA_NM@Z				; negative
PUBLIC	?positive@@YA_NM@Z				; positive
PUBLIC	?sub@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z		; _vector3<float>::sub
PUBLIC	fabsf
PUBLIC	?_abs@@YAMM@Z					; _abs
PUBLIC	?similar@?$_vector3@M@@QEBAHAEBU1@M@Z		; _vector3<float>::similar
PUBLIC	?mad@?$_vector3@M@@QEAAAEAU1@AEBU1@0M@Z		; _vector3<float>::mad
PUBLIC	?dotproduct@?$_vector3@M@@QEBAMAEBU1@@Z		; _vector3<float>::dotproduct
PUBLIC	?classify@?$_plane@M@@QEBAMAEBU?$_vector3@M@@@Z	; _plane<float>::classify
PUBLIC	?clear@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ	; svector<_vector3<float>,48>::clear
PUBLIC	?push_back@?$svector@U?$_vector3@M@@$0DA@@@QEAAXU?$_vector3@M@@@Z ; svector<_vector3<float>,48>::push_back
PUBLIC	??A?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@I@Z ; svector<_vector3<float>,48>::operator[]
PUBLIC	?last@?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@XZ ; svector<_vector3<float>,48>::last
PUBLIC	?inc@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ	; svector<_vector3<float>,48>::inc
PUBLIC	??$_Move@AEAPEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YA$$QEAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAPEAV1@@Z ; std::_Move<svector<_vector3<float>,48> * __ptr64 & __ptr64>
PUBLIC	??$swap@PEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YAXAEAPEAV?$svector@U?$_vector3@M@@$0DA@@@0@Z ; std::swap<svector<_vector3<float>,48> * __ptr64>
PUBLIC	??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@XZ	; svector<_vector3<float>,48>::svector<_vector3<float>,48>
PUBLIC	?assign@?$svector@U?$_vector3@M@@$0DA@@@QEAAXPEAU?$_vector3@M@@H@Z ; svector<_vector3<float>,48>::assign
PUBLIC	??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@PEAU?$_vector3@M@@H@Z ; svector<_vector3<float>,48>::svector<_vector3<float>,48>
PUBLIC	?begin@?$svector@U?$_vector3@M@@$0DA@@@QEAAPEAU?$_vector3@M@@XZ ; svector<_vector3<float>,48>::begin
PUBLIC	?size@?$svector@U?$_vector3@M@@$0DA@@@QEBAIXZ	; svector<_vector3<float>,48>::size
PUBLIC	?_sqrt@@YAMM@Z					; _sqrt
PUBLIC	?square_magnitude@?$_vector3@M@@QEBAMXZ		; _vector3<float>::square_magnitude
PUBLIC	?magnitude@?$_vector3@M@@QEBAMXZ		; _vector3<float>::magnitude
PUBLIC	?frustum_aabb_remap@@3PAY05IA			; frustum_aabb_remap
EXTRN	__imp__copysign:PROC
EXTRN	__imp_?max@?$numeric_limits@M@std@@SAMXZ:PROC
EXTRN	__imp_?Memory@@3VxrMemory@@A:BYTE
EPS_S	DD	033d6bf95r			; 1e-007
	ORG $+15
?frustum_aabb_remap@@3PAY05IA DD 03H			; frustum_aabb_remap
	DD	04H
	DD	05H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	02H
	DD	00H
	DD	01H
	DD	05H
	DD	03H
	DD	01H
	DD	05H
	DD	00H
	DD	04H
	DD	02H
	DD	03H
	DD	01H
	DD	02H
	DD	00H
	DD	04H
	DD	05H
	DD	00H
	DD	04H
	DD	05H
	DD	03H
	DD	01H
	DD	02H
	DD	00H
	DD	04H
	DD	02H
	DD	03H
	DD	01H
	DD	05H
	DD	00H
	DD	01H
	DD	05H
	DD	03H
	DD	04H
	DD	02H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?positive@@YA_NM@Z
_TEXT	SEGMENT
f$ = 8
?positive@@YA_NM@Z PROC					; positive, COMDAT

; 21   : 	IC bool positive(const float f)		{ return f>=0;	}

	comiss	xmm0, DWORD PTR __real@00000000
	jb	SHORT $LN3@positive
	mov	al, 1
	ret	0
$LN3@positive:
	xor	al, al
	ret	0
?positive@@YA_NM@Z ENDP					; positive
_TEXT	ENDS
PUBLIC	__mask@@AbsFloat@
;	COMDAT __mask@@AbsFloat@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__mask@@AbsFloat@ DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 8
fabsf	PROC						; COMDAT

; 395  :         {return ((float)fabs((double)_X)); }

	andps	xmm0, DWORD PTR __mask@@AbsFloat@
	ret	0
fabsf	ENDP
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
_TEXT	ENDS
;	COMDAT ?negative@@YA_NM@Z
_TEXT	SEGMENT
f$ = 8
?negative@@YA_NM@Z PROC					; negative, COMDAT

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	comiss	xmm0, DWORD PTR __real@00000000
	jae	SHORT $LN3@negative
	mov	al, 1
	ret	0
$LN3@negative:
	xor	al, al
	ret	0
?negative@@YA_NM@Z ENDP					; negative
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
_TEXT	ENDS
;	COMDAT ??$_min@M@@YAMMM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$_min@M@@YAMMM@Z PROC					; _min<float>, COMDAT

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	comiss	xmm0, xmm1
	jb	SHORT $LN4@min
	movaps	xmm0, xmm1
$LN4@min:
	fatret	0
??$_min@M@@YAMMM@Z ENDP					; _min<float>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_max@M@@YAMMM@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$_max@M@@YAMMM@Z PROC					; _max<float>, COMDAT

; 94   : template <class T>	IC T		_max	(T a, T b)	{ return a>b?a:b;	}

	comiss	xmm0, xmm1
	ja	SHORT $LN4@max
	movaps	xmm0, xmm1
$LN4@max:
	fatret	0
??$_max@M@@YAMMM@Z ENDP					; _max<float>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$_Move@AEAPEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YA$$QEAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YA$$QEAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAPEAV1@@Z PROC ; std::_Move<svector<_vector3<float>,48> * __ptr64 & __ptr64>, COMDAT

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

	mov	rax, rcx

; 96   : 	}

	ret	0
??$_Move@AEAPEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YA$$QEAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAPEAV1@@Z ENDP ; std::_Move<svector<_vector3<float>,48> * __ptr64 & __ptr64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$swap@PEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YAXAEAPEAV?$svector@U?$_vector3@M@@$0DA@@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YAXAEAPEAV?$svector@U?$_vector3@M@@$0DA@@@0@Z PROC ; std::swap<svector<_vector3<float>,48> * __ptr64>, COMDAT

; 102  : 	_Ty _Tmp = _Move(_Left);
; 103  : 	_Left = _Move(_Right);

	mov	rax, QWORD PTR [rdx]
	mov	r8, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], rax

; 104  : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [rdx], r8

; 105  : 	}

	ret	0
??$swap@PEAV?$svector@U?$_vector3@M@@$0DA@@@@std@@YAXAEAPEAV?$svector@U?$_vector3@M@@$0DA@@@0@Z ENDP ; std::swap<svector<_vector3<float>,48> * __ptr64>
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
_TEXT	ENDS
;	COMDAT ?inc@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?inc@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ PROC	; svector<_vector3<float>,48>::inc, COMDAT

; 47   : 	IC void		inc	()						{ count++; }

	inc	DWORD PTR [rcx+576]
	ret	0
?inc@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ ENDP	; svector<_vector3<float>,48>::inc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?last@?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
?last@?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@XZ PROC ; svector<_vector3<float>,48>::last, COMDAT

; 43   : 	IC reference		last()				{ VERIFY(count<dim); return array[count];}

	mov	eax, DWORD PTR [rcx+576]
	lea	rdx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rcx+rdx*4]
	ret	0
?last@?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@XZ ENDP ; svector<_vector3<float>,48>::last
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??A?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@I@Z
_TEXT	SEGMENT
this$ = 8
id$ = 16
??A?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@I@Z PROC ; svector<_vector3<float>,48>::operator[], COMDAT

; 38   : 	IC reference		operator[] (u32 id)			{ VERIFY(id<count); return array[id];	}

	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR [rcx+rdx*4]
	ret	0
??A?$svector@U?$_vector3@M@@$0DA@@@QEAAAEAU?$_vector3@M@@I@Z ENDP ; svector<_vector3<float>,48>::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$svector@U?$_vector3@M@@$0DA@@@QEAAXU?$_vector3@M@@@Z
_TEXT	SEGMENT
this$ = 8
e$ = 16
?push_back@?$svector@U?$_vector3@M@@$0DA@@@QEAAXU?$_vector3@M@@@Z PROC ; svector<_vector3<float>,48>::push_back, COMDAT

; 35   : 	IC void		push_back(value_type e)		{ VERIFY(count<dim); array[count++]=e;	}

	mov	eax, DWORD PTR [rcx+576]
	lea	r8, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx+r8*4], rax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+r8*4+8], eax
	inc	DWORD PTR [rcx+576]
	ret	0
?push_back@?$svector@U?$_vector3@M@@$0DA@@@QEAAXU?$_vector3@M@@@Z ENDP ; svector<_vector3<float>,48>::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ PROC	; svector<_vector3<float>,48>::clear, COMDAT

; 31   : 	IC void		clear()						{ count=0;								}

	mov	DWORD PTR [rcx+576], 0
	ret	0
?clear@?$svector@U?$_vector3@M@@$0DA@@@QEAAXXZ ENDP	; svector<_vector3<float>,48>::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$svector@U?$_vector3@M@@$0DA@@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?size@?$svector@U?$_vector3@M@@$0DA@@@QEBAIXZ PROC	; svector<_vector3<float>,48>::size, COMDAT

; 30   : 	IC u32		size()		const			{ return count;							}

	mov	eax, DWORD PTR [rcx+576]
	ret	0
?size@?$svector@U?$_vector3@M@@$0DA@@@QEBAIXZ ENDP	; svector<_vector3<float>,48>::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@XZ PROC		; svector<_vector3<float>,48>::svector<_vector3<float>,48>, COMDAT

; 22   : 	{}

	mov	DWORD PTR [rcx+576], 0
	mov	rax, rcx
	ret	0
??0?$svector@U?$_vector3@M@@$0DA@@@QEAA@XZ ENDP		; svector<_vector3<float>,48>::svector<_vector3<float>,48>
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
_TEXT	ENDS
;	COMDAT ?crossproduct@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z
_TEXT	SEGMENT
this$ = 8
v1$ = 16
v2$ = 24
?crossproduct@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z PROC	; _vector3<float>::crossproduct, COMDAT

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [r8+8]
	movss	xmm0, DWORD PTR [rdx+8]

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;
; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;
; 276  : 		return *this;	

	mov	rax, rcx
	mulss	xmm0, DWORD PTR [r8+4]
	mulss	xmm1, DWORD PTR [rdx+4]
	subss	xmm1, xmm0
	movss	DWORD PTR [rcx], xmm1
	movss	xmm2, DWORD PTR [rdx+8]
	movss	xmm0, DWORD PTR [rdx]
	mulss	xmm0, DWORD PTR [r8+8]
	mulss	xmm2, DWORD PTR [r8]
	subss	xmm2, xmm0
	movss	DWORD PTR [rcx+4], xmm2
	movss	xmm1, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [r8]
	mulss	xmm1, DWORD PTR [r8+4]
	mulss	xmm0, DWORD PTR [rdx+4]
	subss	xmm1, xmm0
	movss	DWORD PTR [rcx+8], xmm1

; 277  : 	}

	ret	0
?crossproduct@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z ENDP	; _vector3<float>::crossproduct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?dotproduct@?$_vector3@M@@QEBAMAEBU1@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?dotproduct@?$_vector3@M@@QEBAMAEBU1@@Z PROC		; _vector3<float>::dotproduct, COMDAT

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movss	xmm0, DWORD PTR [rdx+4]
	movss	xmm1, DWORD PTR [rdx]
	movss	xmm2, DWORD PTR [rdx+8]
	mulss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm1, DWORD PTR [rcx]
	mulss	xmm2, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	addss	xmm0, xmm2
	ret	0
?dotproduct@?$_vector3@M@@QEBAMAEBU1@@Z ENDP		; _vector3<float>::dotproduct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?mad@?$_vector3@M@@QEAAAEAU1@AEBU1@0M@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
d$ = 24
m$ = 32
?mad@?$_vector3@M@@QEAAAEAU1@AEBU1@0M@Z PROC		; _vector3<float>::mad, COMDAT

; 144  : 		x = p.x + d.x*m;

	movaps	xmm0, xmm3

; 145  : 		y = p.y + d.y*m;

	movaps	xmm1, xmm3

; 146  : 		z = p.z + d.z*m;
; 147  : 		return *this;	

	mov	rax, rcx
	mulss	xmm0, DWORD PTR [r8]
	addss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx], xmm0
	mulss	xmm1, DWORD PTR [r8+4]
	addss	xmm1, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+4], xmm1
	mulss	xmm3, DWORD PTR [r8+8]
	addss	xmm3, DWORD PTR [rdx+8]
	movss	DWORD PTR [rcx+8], xmm3

; 148  : 	}

	ret	0
?mad@?$_vector3@M@@QEAAAEAU1@AEBU1@0M@Z ENDP		; _vector3<float>::mad
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?sub@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z
_TEXT	SEGMENT
this$ = 8
a$ = 16
v$ = 24
?sub@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z PROC		; _vector3<float>::sub, COMDAT

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm0, DWORD PTR [rdx]
	mov	rax, rcx
	subss	xmm0, DWORD PTR [r8]
	movss	DWORD PTR [rcx], xmm0
	movss	xmm1, DWORD PTR [rdx+4]
	subss	xmm1, DWORD PTR [r8+4]
	movss	DWORD PTR [rcx+4], xmm1
	movss	xmm0, DWORD PTR [rdx+8]
	subss	xmm0, DWORD PTR [r8+8]
	movss	DWORD PTR [rcx+8], xmm0
	ret	0
?sub@?$_vector3@M@@QEAAAEAU1@AEBU1@0@Z ENDP		; _vector3<float>::sub
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?set@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?set@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z PROC		; _vector3<float>::set, COMDAT

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
	mov	rax, rcx
	ret	0
?set@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z ENDP		; _vector3<float>::set
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?set@?$_vector3@M@@QEAAAEAU1@MMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
?set@?$_vector3@M@@QEAAAEAU1@MMM@Z PROC			; _vector3<float>::set, COMDAT

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [rcx], xmm1
	movss	DWORD PTR [rcx+4], xmm2
	movss	DWORD PTR [rcx+8], xmm3
	mov	rax, rcx
	ret	0
?set@?$_vector3@M@@QEAAAEAU1@MMM@Z ENDP			; _vector3<float>::set
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ?_abs@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?_abs@@YAMM@Z PROC					; _abs, COMDAT

; 98   : IC float	_abs	(float x)		{ return fabsf(x); }

	andps	xmm0, DWORD PTR __mask@@AbsFloat@
	ret	0
?_abs@@YAMM@Z ENDP					; _abs
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_plane.h
_TEXT	ENDS
;	COMDAT ?classify@?$_plane@M@@QEBAMAEBU?$_vector3@M@@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?classify@?$_plane@M@@QEBAMAEBU?$_vector3@M@@@Z PROC	; _plane<float>::classify, COMDAT

; 57   : 		return n.dotproduct(v)+d;

	movss	xmm0, DWORD PTR [rdx+4]
	movss	xmm1, DWORD PTR [rdx]
	movss	xmm2, DWORD PTR [rdx+8]
	mulss	xmm0, DWORD PTR [rcx+4]
	mulss	xmm1, DWORD PTR [rcx]
	mulss	xmm2, DWORD PTR [rcx+8]
	addss	xmm0, xmm1
	addss	xmm0, xmm2
	addss	xmm0, DWORD PTR [rcx+12]

; 58   : 	}

	ret	0
?classify@?$_plane@M@@QEBAMAEBU?$_vector3@M@@@Z ENDP	; _plane<float>::classify
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
_TEXT	ENDS
;	COMDAT ?similar@?$_vector3@M@@QEBAHAEBU1@M@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
E$ = 24
?similar@?$_vector3@M@@QEBAHAEBU1@M@Z PROC		; _vector3<float>::similar, COMDAT

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm0, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR __mask@@AbsFloat@
	subss	xmm0, DWORD PTR [rdx]
	andps	xmm0, xmm1
	comiss	xmm0, xmm2
	jae	SHORT $LN3@similar@2
	movss	xmm0, DWORD PTR [rcx+4]
	subss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm1
	comiss	xmm0, xmm2
	jae	SHORT $LN3@similar@2
	movss	xmm0, DWORD PTR [rcx+8]
	subss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm1
	comiss	xmm0, xmm2
	jae	SHORT $LN3@similar@2
	mov	eax, 1
	ret	0
$LN3@similar@2:
	xor	eax, eax
	ret	0
?similar@?$_vector3@M@@QEBAHAEBU1@M@Z ENDP		; _vector3<float>::similar
_TEXT	ENDS
PUBLIC	?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ; CFrustum::ClipPoly
pdata	SEGMENT
$pdata$?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z DD imagerel $LN173
	DD	imagerel $LN173+853
	DD	imagerel $unwind$?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z DD 0195201H
	DD	0cb852H
	DD	0da84dH
	DD	0e9848H
	DD	0f882dH
	DD	0107828H
	DD	0116824H
	DD	02b7420H
	DD	02a6420H
	DD	0295420H
	DD	0283420H
	DD	0240120H
	DD	0d017e019H
	DD	0c015H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
xdata	ENDS
_TEXT	SEGMENT
cls$94438 = 0
this$ = 320
S$ = 328
D$ = 336
?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z PROC ; CFrustum::ClipPoly

; 284  : {

$LN173:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 288				; 00000120H
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8

; 286  : 	sPoly*	dest	= &S;
; 287  : 	for (int i=0; i<p_count; i++)

	xor	r14d, r14d
	lea	r13, QWORD PTR [rcx+240]
	mov	rdi, r8
	mov	r12, rdx
	mov	rsi, rcx
	mov	ebp, r14d
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	XMMWORD PTR [rax-104], xmm10
	movaps	XMMWORD PTR [rax-120], xmm11
	cmp	DWORD PTR [r13], r14d
	jle	$LN15@ClipPoly

; 285  : 	sPoly*	src		= &D;

	movss	xmm9, DWORD PTR EPS_S
	movss	xmm10, DWORD PTR __mask@@AbsFloat@
	xorps	xmm8, xmm8
	movss	xmm11, DWORD PTR __real@bf800000
	npad	5
$LL17@ClipPoly:

; 288  : 	{
; 289  : 		// cache plane and swap lists
; 290  : 		const fplane &P = planes[i];
; 291  : 		std::swap		(src,dest);

	mov	r11, rdi
	mov	rdi, r12

; 292  : 		dest->clear		();

	mov	DWORD PTR [r11+576], r14d

; 293  : 
; 294  : 		// classify all points relative to plane #i
; 295  : 		float	cls	[FRUSTUM_SAFE];
; 296  : 		for (u32 j=0; j<src->size(); j++) cls[j]=P.classify((*src)[j]);

	mov	r8d, DWORD PTR [rdi+576]
	mov	r12, r11
	test	r8d, r8d
	je	SHORT $LN12@ClipPoly
	movss	xmm3, DWORD PTR [rsi+4]
	movss	xmm4, DWORD PTR [rsi]
	movss	xmm5, DWORD PTR [rsi+8]
	mov	edx, DWORD PTR [rdi+576]
	lea	rcx, QWORD PTR cls$94438[rsp]
	lea	rax, QWORD PTR [rdi+8]
	movss	xmm6, DWORD PTR [rsi+12]
	npad	3
$LL14@ClipPoly:
	movaps	xmm2, xmm3
	movaps	xmm0, xmm4
	movaps	xmm1, xmm5
	add	rcx, 4
	add	rax, 12
	dec	rdx
	mulss	xmm2, DWORD PTR [rax-16]
	mulss	xmm0, DWORD PTR [rax-20]
	mulss	xmm1, DWORD PTR [rax-12]
	addss	xmm2, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm6
	movss	DWORD PTR [rcx-4], xmm2
	jne	SHORT $LL14@ClipPoly
$LN12@ClipPoly:

; 300  : 		src->push_back((*src)[0]);

	mov	rcx, QWORD PTR [rdi]
	mov	edx, DWORD PTR [rdi+8]
	movss	xmm0, DWORD PTR cls$94438[rsp]
	lea	rax, QWORD PTR [r8+r8*2]

; 301  : 		Fvector D; float denum,t;
; 302  : 		for (j=0; j<src->size()-1; j++)

	mov	ebx, r14d
	movss	DWORD PTR cls$94438[rsp+r8*4], xmm0
	mov	QWORD PTR [rdi+rax*4], rcx
	mov	DWORD PTR [rdi+rax*4+8], edx
	inc	DWORD PTR [rdi+576]
	mov	eax, DWORD PTR [rdi+576]
	dec	eax
	je	$LN9@ClipPoly

; 297  : 
; 298  : 		// clip everything to this plane
; 299  : 		cls[src->size()] = cls[0];

	lea	r10, QWORD PTR cls$94438[rsp+4]
	lea	r9, QWORD PTR [rdi+20]
	npad	13
$LL11@ClipPoly:

; 303  : 		{
; 304  : 			if ((*src)[j].similar((*src)[j+1],EPS_S)) continue;

	movss	xmm6, DWORD PTR [r9-20]
	movss	xmm2, DWORD PTR [r9-8]
	movaps	xmm0, xmm6
	subss	xmm0, xmm2
	andps	xmm0, xmm10
	comiss	xmm0, xmm9
	jae	SHORT $LN67@ClipPoly
	movss	xmm0, DWORD PTR [r9-16]
	subss	xmm0, DWORD PTR [r9-4]
	andps	xmm0, xmm10
	comiss	xmm0, xmm9
	jae	SHORT $LN67@ClipPoly
	movss	xmm0, DWORD PTR [r9-12]
	subss	xmm0, DWORD PTR [r9]
	andps	xmm0, xmm10
	comiss	xmm0, xmm9
	jb	$LN10@ClipPoly
$LN67@ClipPoly:

; 305  : 
; 306  : 			if (negative(cls[j]))

	movss	xmm7, DWORD PTR [r10-4]
	comiss	xmm7, xmm8
	jae	$LN7@ClipPoly

; 307  : 			{
; 308  : 				dest->push_back((*src)[j]);

	mov	eax, DWORD PTR [r11+576]
	mov	rdx, QWORD PTR [r9-20]
	mov	r8d, DWORD PTR [r9-12]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	QWORD PTR [r11+rcx*4], rdx
	mov	DWORD PTR [r11+rcx*4+8], r8d
	mov	eax, DWORD PTR [r11+576]
	inc	eax
	mov	DWORD PTR [r11+576], eax

; 309  : 				if (positive(cls[j+1]))

	comiss	xmm8, DWORD PTR [r10]
	ja	$LN10@ClipPoly

; 310  : 				{
; 311  : 					// segment intersects plane
; 312  : 					D.sub((*src)[j+1],(*src)[j]);

	movss	xmm4, DWORD PTR [r9-4]
	movss	xmm3, DWORD PTR [r9-8]
	movss	xmm5, DWORD PTR [r9]
	movss	xmm6, DWORD PTR [r9-20]
	subss	xmm4, DWORD PTR [r9-16]
	subss	xmm5, DWORD PTR [r9-12]

; 313  : 					denum = P.n.dotproduct(D);

	movaps	xmm2, xmm4
	movaps	xmm1, xmm5
	mulss	xmm2, DWORD PTR [rsi+4]
	mulss	xmm1, DWORD PTR [rsi+8]
	subss	xmm3, xmm6
	movaps	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rsi]
	addss	xmm2, xmm0
	addss	xmm2, xmm1

; 314  : 					if (denum!=0) {

	ucomiss	xmm2, xmm8
	je	$LN10@ClipPoly

; 315  : 						t = -cls[j]/denum; //VERIFY(t<=1.f && t>=0);

	movaps	xmm0, xmm11

; 316  : 						dest->last().mad((*src)[j],D,t);

	lea	rcx, QWORD PTR [rax+rax*2]
	divss	xmm0, xmm2
	mulss	xmm0, xmm7
	mulss	xmm3, xmm0
	addss	xmm3, xmm6
	movss	DWORD PTR [r11+rcx*4], xmm3

; 317  : 						dest->inc();
; 318  : 					}
; 319  : 				}
; 320  : 			} else {

	jmp	SHORT $LN172@ClipPoly
$LN7@ClipPoly:

; 321  : 				// J - outside
; 322  : 				if (negative(cls[j+1]))

	comiss	xmm8, DWORD PTR [r10]
	jbe	$LN10@ClipPoly

; 323  : 				{
; 324  : 					// J+1  - inside
; 325  : 					// segment intersects plane
; 326  : 					D.sub((*src)[j+1],(*src)[j]);

	movss	xmm4, DWORD PTR [r9-4]
	movss	xmm5, DWORD PTR [r9]
	subss	xmm2, xmm6

; 327  : 					denum = P.n.dotproduct(D);

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rsi]
	subss	xmm4, DWORD PTR [r9-16]
	subss	xmm5, DWORD PTR [r9-12]
	movaps	xmm3, xmm4
	movaps	xmm1, xmm5
	mulss	xmm3, DWORD PTR [rsi+4]
	mulss	xmm1, DWORD PTR [rsi+8]
	addss	xmm3, xmm0
	addss	xmm3, xmm1

; 328  : 					if (denum!=0) {

	ucomiss	xmm3, xmm8
	je	SHORT $LN10@ClipPoly

; 329  : 						t = -cls[j]/denum; //VERIFY(t<=1.f && t>=0);
; 330  : 						dest->last().mad((*src)[j],D,t);

	mov	eax, DWORD PTR [r11+576]
	movaps	xmm0, xmm11
	divss	xmm0, xmm3
	lea	rcx, QWORD PTR [rax+rax*2]
	mulss	xmm0, xmm7
	mulss	xmm2, xmm0
	addss	xmm2, xmm6
	movss	DWORD PTR [r11+rcx*4], xmm2
$LN172@ClipPoly:
	mulss	xmm4, xmm0
	mulss	xmm5, xmm0
	addss	xmm4, DWORD PTR [r9-16]
	movss	DWORD PTR [r11+rcx*4+4], xmm4
	addss	xmm5, DWORD PTR [r9-12]
	movss	DWORD PTR [r11+rcx*4+8], xmm5

; 331  : 						dest->inc();

	inc	DWORD PTR [r11+576]
$LN10@ClipPoly:

; 301  : 		Fvector D; float denum,t;
; 302  : 		for (j=0; j<src->size()-1; j++)

	mov	eax, DWORD PTR [rdi+576]
	inc	ebx
	add	r10, 4
	dec	eax
	add	r9, 12
	cmp	ebx, eax
	jb	$LL11@ClipPoly
$LN9@ClipPoly:

; 332  : 					}
; 333  : 				}
; 334  : 			}
; 335  : 		}
; 336  : 
; 337  : 		// here we end up with complete polygon in 'dest' which is inside plane #i
; 338  : 		if (dest->size()<3) return 0;

	cmp	DWORD PTR [r11+576], 3
	jb	SHORT $LN164@ClipPoly

; 286  : 	sPoly*	dest	= &S;
; 287  : 	for (int i=0; i<p_count; i++)

	inc	ebp
	add	rsi, 20
	cmp	ebp, DWORD PTR [r13]
	jl	$LL17@ClipPoly
$LN15@ClipPoly:

; 339  : 	}
; 340  : 	return dest;

	mov	rax, r12
$LN18@ClipPoly:

; 341  : }

	lea	r11, QWORD PTR [rsp+288]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	mov	rdi, QWORD PTR [r11+56]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	mov	rsp, r11
	pop	r14
	pop	r13
	pop	r12
	ret	0
$LN164@ClipPoly:

; 332  : 					}
; 333  : 				}
; 334  : 			}
; 335  : 		}
; 336  : 
; 337  : 		// here we end up with complete polygon in 'dest' which is inside plane #i
; 338  : 		if (dest->size()<3) return 0;

	xor	eax, eax
	jmp	SHORT $LN18@ClipPoly
?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ENDP ; CFrustum::ClipPoly
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
pdata	SEGMENT
$pdata$?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z DD imagerel $LN17
	DD	imagerel $LN17+185
	DD	imagerel $unwind$?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z DD 031e01H
	DD	0681eH
	DD	02204H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
xdata	ENDS
;	COMDAT ?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z
_TEXT	SEGMENT
P$ = 32
mM$ = 40
?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z PROC ; CFrustum::AABB_OverlapPlane, COMDAT

; 49   : 	{

$LN17:
	sub	rsp, 24

; 50   : 		// calc extreme pts (neg,pos) along normal axis (pos in dir of norm, etc.)
; 51   : 		u32*	id		= frustum_aabb_remap[P.aabb_overlap_id];

	mov	eax, DWORD PTR [rcx+16]

; 52   : 
; 53   : 		Fvector			Neg;
; 54   : 		Neg.set			(mM[id[3]],mM[id[4]],mM[id[5]]);
; 55   : 		if				(P.classify(Neg) > 0)	return	fcvNone;

	movss	xmm3, DWORD PTR [rcx+4]
	movss	xmm4, DWORD PTR [rcx]
	mov	r10, rdx
	lea	r11, OFFSET FLAT:?frustum_aabb_remap@@3PAY05IA ; frustum_aabb_remap
	movaps	XMMWORD PTR [rsp], xmm6
	lea	rdx, QWORD PTR [rax+rax*2]
	movaps	xmm2, xmm3
	movaps	xmm0, xmm4
	movss	xmm5, DWORD PTR [rcx+8]
	movss	xmm6, DWORD PTR [rcx+12]
	movaps	xmm1, xmm5
	mov	eax, DWORD PTR [r11+rdx*8+12]
	mov	r8d, DWORD PTR [r11+rdx*8+16]
	mov	r9d, DWORD PTR [r11+rdx*8+20]
	mulss	xmm2, DWORD PTR [r10+r8*4]
	mulss	xmm0, DWORD PTR [r10+rax*4]
	mulss	xmm1, DWORD PTR [r10+r9*4]
	addss	xmm2, xmm0
	xorps	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm6
	comiss	xmm2, xmm0
	jbe	SHORT $LN2@AABB_Overl
	xor	eax, eax

; 62   : 	}

	movaps	xmm6, XMMWORD PTR [rsp]
	add	rsp, 24
	ret	0
$LN2@AABB_Overl:

; 56   : 
; 57   : 		Fvector			Pos;
; 58   : 		Pos.set			(mM[id[0]],mM[id[1]],mM[id[2]]);

	mov	eax, DWORD PTR [r11+rdx*8]
	mov	ecx, DWORD PTR [r11+rdx*8+4]
	mov	edx, DWORD PTR [r11+rdx*8+8]

; 59   : 		if				(P.classify(Pos) <= 0)	return	fcvFully;

	mulss	xmm3, DWORD PTR [r10+rcx*4]
	mulss	xmm4, DWORD PTR [r10+rax*4]
	mulss	xmm5, DWORD PTR [r10+rdx*4]
	mov	eax, 2
	addss	xmm3, xmm4
	addss	xmm3, xmm5
	addss	xmm3, xmm6
	comiss	xmm3, xmm0
	jbe	SHORT $LN3@AABB_Overl

; 60   : 
; 61   : 		return			fcvPartial;

	mov	eax, 1
$LN3@AABB_Overl:

; 62   : 	}

	movaps	xmm6, XMMWORD PTR [rsp]
	add	rsp, 24
	ret	0
?AABB_OverlapPlane@CFrustum@@QEBA?AW4EFC_Visible@@AEBUfplane@1@PEBM@Z ENDP ; CFrustum::AABB_OverlapPlane
PUBLIC	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB
pdata	SEGMENT
$pdata$?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z DD imagerel $LN32
	DD	imagerel $LN32+321
	DD	imagerel $unwind$?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z DD 0e2901H
	DD	07829H
	DD	016822H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.cpp
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
mM$ = 56
test_mask$ = 64
?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z PROC ; CFrustum::testAABB

; 96   : {

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	sub	rsp, 32					; 00000020H

; 99   : 
; 100  : 	for (int i=0; i<p_count; i++, bit<<=1)

	xor	r10d, r10d
	movaps	XMMWORD PTR [rsp+16], xmm6
	mov	r11, r8
	movaps	XMMWORD PTR [rsp], xmm7
	mov	rbp, rdx
	mov	rdi, rcx
	mov	r9d, 1
	cmp	DWORD PTR [rcx+240], r10d
	jle	$LN5@testAABB

; 97   : 	// go for trivial rejection or acceptance using "faster overlap test"
; 98   : 	u32		bit = 1;

	xorps	xmm7, xmm7
	lea	rbx, QWORD PTR [rcx+4]
	lea	r12, OFFSET FLAT:?frustum_aabb_remap@@3PAY05IA ; frustum_aabb_remap
$LL7@testAABB:

; 101  : 	{
; 102  : 		if (test_mask&bit) {

	mov	r8d, DWORD PTR [r11]
	test	r8d, r9d
	je	$LN6@testAABB

; 103  : 			EFC_Visible	r	= AABB_OverlapPlane(planes[i],mM);

	mov	eax, DWORD PTR [rbx+12]
	movss	xmm4, DWORD PTR [rbx]
	movss	xmm3, DWORD PTR [rbx-4]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm6, DWORD PTR [rbx+8]
	movaps	xmm2, xmm3
	movaps	xmm0, xmm4
	lea	rsi, QWORD PTR [rax+rax*2]
	mov	eax, DWORD PTR [r12+rsi*8+12]
	mov	ecx, DWORD PTR [r12+rsi*8+16]
	mov	edx, DWORD PTR [r12+rsi*8+20]
	movaps	xmm1, xmm5
	mulss	xmm2, DWORD PTR [rbp+rax*4]
	mulss	xmm0, DWORD PTR [rbp+rcx*4]
	mulss	xmm1, DWORD PTR [rbp+rdx*4]
	addss	xmm2, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm6
	comiss	xmm2, xmm7
	ja	$LN27@testAABB
	mov	eax, DWORD PTR [r12+rsi*8]
	mov	ecx, DWORD PTR [r12+rsi*8+4]
	mov	edx, DWORD PTR [r12+rsi*8+8]
	mulss	xmm3, DWORD PTR [rbp+rax*4]
	mulss	xmm4, DWORD PTR [rbp+rcx*4]
	mulss	xmm5, DWORD PTR [rbp+rdx*4]
	addss	xmm3, xmm4
	addss	xmm3, xmm5
	addss	xmm3, xmm6
	comiss	xmm3, xmm7

; 104  : 			if (fcvFully==r)	test_mask&=~bit;					// fully - no need to test this plane

	ja	SHORT $LN6@testAABB
	mov	eax, r9d
	not	eax
	and	eax, r8d
	mov	DWORD PTR [r11], eax
$LN6@testAABB:

; 99   : 
; 100  : 	for (int i=0; i<p_count; i++, bit<<=1)

	inc	r10d
	add	rbx, 20
	add	r9d, r9d
	cmp	r10d, DWORD PTR [rdi+240]
	jl	$LL7@testAABB
$LN5@testAABB:

; 106  : 		}
; 107  : 	}
; 108  : 	return test_mask ? fcvPartial:fcvFully;

	mov	eax, DWORD PTR [r11]
	neg	eax
	sbb	eax, eax
	add	eax, 2
$LN8@testAABB:

; 109  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+16]
	movaps	xmm7, XMMWORD PTR [rsp]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r12
	ret	0
$LN27@testAABB:

; 105  : 			else if (fcvNone==r){ test_mask=0; return fcvNone;	}	// none - return

	mov	DWORD PTR [r11], 0
	xor	eax, eax
	jmp	SHORT $LN8@testAABB
?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ENDP ; CFrustum::testAABB
END
