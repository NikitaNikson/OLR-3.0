; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CC@CPNHACKD@?$CB?5WARNING?3?5syncronized?5CDB?3?3quer@ ; `string'
PUBLIC	??_C@_0BC@GJKGJBBN@CDB?3?3MODEL?3?3build?$AA@	; `string'
PUBLIC	??_C@_09FONEFOJL@xrCDB?4cpp?$AA@		; `string'
PUBLIC	??_C@_0BB@DMGNJNBH@S_INIT?5?$DN?$DN?5status?$AA@ ; `string'
PUBLIC	??_C@_0BF@JLEIHKIA@?$CIVcnt?$DO?$DN4?$CJ?$CG?$CG?$CITcnt?$DO?$DN2?$CJ?$AA@ ; `string'
PUBLIC	??_C@_07JLJFPMN@?9mt_cdb?$AA@			; `string'
PUBLIC	??_C@_0BB@KNMADMJC@CDB?9construction?$AA@	; `string'
PUBLIC	??_C@_0CB@NBDEDBNA@?$CB?5xrCDB?3?5model?5still?5isn?8t?5ready@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	__imp_?Msg@@YAXPEBDZZ:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_?thread_spawn@@YAXP6AXPEAX@ZPEBDI0@Z:PROC
EXTRN	__imp_?Core@@3VxrCore@@A:BYTE
EXTRN	__imp_strstr:PROC
EXTRN	__imp_?Debug@@3VxrDebug@@A:BYTE
EXTRN	__imp_?fail@xrDebug@@QEAAXPEBD0H0AEA_N@Z:PROC
EXTRN	__imp_?m64r@FPU@@YAXXZ:PROC
EXTRN	__imp_?_initialize_cpu_thread@@YAXXZ:PROC
EXTRN	__imp_??1xrCriticalSection@@QEAA@XZ:PROC
EXTRN	__imp_??0xrCriticalSection@@QEAA@XZ:PROC
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QEAAXXZ:PROC
EXTRN	__imp_?Leave@xrCriticalSection@@QEAAXXZ:PROC
EXTRN	__imp_?Enter@xrCriticalSection@@QEAAXXZ:PROC
;	COMDAT ?ignore_always@?7??build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@3@HP6AX0H1HPEAX@Z2@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7??build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@3@HP6AX0H1HPEAX@Z2@Z@4_NA DB 01H DUP (?) ; `CDB::MODEL::build'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@3@HP6AX0H1HPEAX@Z2@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@3@HP6AX0H1HPEAX@Z2@Z@4_NA DB 01H DUP (?) ; `CDB::MODEL::build'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@NBDEDBNA@?$CB?5xrCDB?3?5model?5still?5isn?8t?5ready@
CONST	SEGMENT
??_C@_0CB@NBDEDBNA@?$CB?5xrCDB?3?5model?5still?5isn?8t?5ready@ DB '! xrCD'
	DB	'B: model still isn''t ready', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KNMADMJC@CDB?9construction?$AA@
CONST	SEGMENT
??_C@_0BB@KNMADMJC@CDB?9construction?$AA@ DB 'CDB-construction', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLJFPMN@?9mt_cdb?$AA@
CONST	SEGMENT
??_C@_07JLJFPMN@?9mt_cdb?$AA@ DB '-mt_cdb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JLEIHKIA@?$CIVcnt?$DO?$DN4?$CJ?$CG?$CG?$CITcnt?$DO?$DN2?$CJ?$AA@
CONST	SEGMENT
??_C@_0BF@JLEIHKIA@?$CIVcnt?$DO?$DN4?$CJ?$CG?$CG?$CITcnt?$DO?$DN2?$CJ?$AA@ DB '('
	DB	'Vcnt>=4)&&(Tcnt>=2)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DMGNJNBH@S_INIT?5?$DN?$DN?5status?$AA@
CONST	SEGMENT
??_C@_0BB@DMGNJNBH@S_INIT?5?$DN?$DN?5status?$AA@ DB 'S_INIT == status', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FONEFOJL@xrCDB?4cpp?$AA@
CONST	SEGMENT
??_C@_09FONEFOJL@xrCDB?4cpp?$AA@ DB 'xrCDB.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GJKGJBBN@CDB?3?3MODEL?3?3build?$AA@
CONST	SEGMENT
??_C@_0BC@GJKGJBBN@CDB?3?3MODEL?3?3build?$AA@ DB 'CDB::MODEL::build', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CPNHACKD@?$CB?5WARNING?3?5syncronized?5CDB?3?3quer@
CONST	SEGMENT
??_C@_0CC@CPNHACKD@?$CB?5WARNING?3?5syncronized?5CDB?3?3quer@ DB '! WARNI'
	DB	'NG: syncronized CDB::query', 00H		; `string'
PUBLIC	??1?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ		; xr_vector<unsigned int,xalloc<unsigned int> >::~xr_vector<unsigned int,xalloc<unsigned int> >
PUBLIC	??1?$vector@IV?$xalloc@I@@@std@@QEAA@XZ		; std::vector<unsigned int,xalloc<unsigned int> >::~vector<unsigned int,xalloc<unsigned int> >
PUBLIC	?_Tidy@?$vector@IV?$xalloc@I@@@std@@IEAAXXZ	; std::vector<unsigned int,xalloc<unsigned int> >::_Tidy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$xalloc@I@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@I@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >::_Getal
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAA@XZ	; std::_Wrap_alloc<xalloc<unsigned int> >::_Wrap_alloc<xalloc<unsigned int> >
PUBLIC	??0?$xalloc@I@@QEAA@XZ				; xalloc<unsigned int>::xalloc<unsigned int>
PUBLIC	?deallocate@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI_K@Z ; std::_Wrap_alloc<xalloc<unsigned int> >::deallocate
PUBLIC	?deallocate@?$xalloc@I@@QEBAXPEAI_K@Z		; xalloc<unsigned int>::deallocate
PUBLIC	??$xr_free@I@@YAXAEAPEAI@Z			; xr_free<unsigned int>
PUBLIC	?_Destroy@?$vector@IV?$xalloc@I@@@std@@IEAAXPEAI0@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Destroy
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI0AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<unsigned int> > >
PUBLIC	??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAI0@Z ; std::_Ptr_cat<unsigned int,unsigned int>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI0AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<unsigned int> > >
PUBLIC	?strstr@@YAPEADPEADPEBD@Z			; strstr
PUBLIC	?GetUsedBytes@OPCODE_Model@Opcode@@QEBAIXZ	; Opcode::OPCODE_Model::GetUsedBytes
PUBLIC	??0_Wrap_int@std@@QEAA@H@Z			; std::_Wrap_int::_Wrap_int
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??$_Construct@VTRI@CDB@@AEBV12@@std@@YAXPEAVTRI@CDB@@AEBV12@@Z ; std::_Construct<CDB::TRI,CDB::TRI const & __ptr64>
PUBLIC	??$_Construct@U?$_vector3@M@@AEBU1@@std@@YAXPEAU?$_vector3@M@@AEBU1@@Z ; std::_Construct<_vector3<float>,_vector3<float> const & __ptr64>
PUBLIC	?construct@?$xalloc@VTRI@CDB@@@@QEAAXPEAVTRI@CDB@@AEBV23@@Z ; xalloc<CDB::TRI>::construct
PUBLIC	?construct@?$xalloc@U?$_vector3@M@@@@QEAAXPEAU?$_vector3@M@@AEBU2@@Z ; xalloc<_vector3<float> >::construct
PUBLIC	??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@AEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEAV34@@Z ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@AEBV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEBV34@@Z ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI const & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@AEAU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEAU34@@Z ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@AEBU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEBU34@@Z ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT const & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@AEAU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEAU3@@Z ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@AEBU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEBU3@@Z ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> const & __ptr64>
PUBLIC	??$_Destroy@VTRI@CDB@@@std@@YAXPEAVTRI@CDB@@@Z	; std::_Destroy<CDB::TRI>
PUBLIC	??$_Destroy@URESULT@CDB@@@std@@YAXPEAURESULT@CDB@@@Z ; std::_Destroy<CDB::RESULT>
PUBLIC	??$_Destroy@U?$_vector3@M@@@std@@YAXPEAU?$_vector3@M@@@Z ; std::_Destroy<_vector3<float> >
PUBLIC	??$construct@VTRI@CDB@@AEAV12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEAV34@@Z ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI & __ptr64>
PUBLIC	??$forward@AEAVTRI@CDB@@@std@@YAAEAVTRI@CDB@@AEAV12@@Z ; std::forward<CDB::TRI & __ptr64>
PUBLIC	??$construct@VTRI@CDB@@AEBV12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEBV34@@Z ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI const & __ptr64>
PUBLIC	??$forward@AEBVTRI@CDB@@@std@@YAAEBVTRI@CDB@@AEBV12@@Z ; std::forward<CDB::TRI const & __ptr64>
PUBLIC	??$construct@URESULT@CDB@@AEAU12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEAU34@@Z ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT & __ptr64>
PUBLIC	??$forward@AEAURESULT@CDB@@@std@@YAAEAURESULT@CDB@@AEAU12@@Z ; std::forward<CDB::RESULT & __ptr64>
PUBLIC	??$construct@URESULT@CDB@@AEBU12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEBU34@@Z ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT const & __ptr64>
PUBLIC	??$construct@U?$_vector3@M@@AEAU1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEAU3@@Z ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> & __ptr64>
PUBLIC	??$forward@AEAU?$_vector3@M@@@std@@YAAEAU?$_vector3@M@@AEAU1@@Z ; std::forward<_vector3<float> & __ptr64>
PUBLIC	??$construct@U?$_vector3@M@@AEBU1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEBU3@@Z ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> const & __ptr64>
PUBLIC	??$forward@AEBU?$_vector3@M@@@std@@YAAEBU?$_vector3@M@@AEBU1@@Z ; std::forward<_vector3<float> const & __ptr64>
PUBLIC	?destroy@?$xalloc@VTRI@CDB@@@@QEAAXPEAVTRI@CDB@@@Z ; xalloc<CDB::TRI>::destroy
PUBLIC	?destroy@?$xalloc@URESULT@CDB@@@@QEAAXPEAURESULT@CDB@@@Z ; xalloc<CDB::RESULT>::destroy
PUBLIC	?destroy@?$xalloc@U?$_vector3@M@@@@QEAAXPEAU?$_vector3@M@@@Z ; xalloc<_vector3<float> >::destroy
PUBLIC	??$forward@AEBURESULT@CDB@@@std@@YAAEBURESULT@CDB@@AEBU12@@Z ; std::forward<CDB::RESULT const & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@@Z ; std::_Alloc_destroy::_Fn<xalloc<CDB::TRI>,CDB::TRI>
PUBLIC	??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@@Z ; std::_Alloc_destroy::_Fn<xalloc<CDB::RESULT>,CDB::RESULT>
PUBLIC	??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@@Z ; std::_Alloc_destroy::_Fn<xalloc<_vector3<float> >,_vector3<float> >
PUBLIC	??$construct@VTRI@CDB@@AEAV12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@AEAV23@@Z ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI & __ptr64>
PUBLIC	??$construct@VTRI@CDB@@AEBV12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@AEBV23@@Z ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI const & __ptr64>
PUBLIC	??$construct@URESULT@CDB@@AEAU12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@AEAU23@@Z ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT & __ptr64>
PUBLIC	??$construct@URESULT@CDB@@AEBU12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@AEBU23@@Z ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT const & __ptr64>
PUBLIC	??$construct@U?$_vector3@M@@AEAU1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@AEAU2@@Z ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> & __ptr64>
PUBLIC	??$construct@U?$_vector3@M@@AEBU1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@AEBU2@@Z ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> const & __ptr64>
PUBLIC	??$_Construct@URESULT@CDB@@AEBU12@@std@@YAXPEAURESULT@CDB@@AEBU12@@Z ; std::_Construct<CDB::RESULT,CDB::RESULT const & __ptr64>
PUBLIC	??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>
PUBLIC	??$_Val_type@PEAURESULT@CDB@@@std@@YAPEAURESULT@CDB@@PEAU12@@Z ; std::_Val_type<CDB::RESULT * __ptr64>
PUBLIC	??$destroy@VTRI@CDB@@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@@Z ; std::allocator_traits<xalloc<CDB::TRI> >::destroy<CDB::TRI>
PUBLIC	??$destroy@URESULT@CDB@@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@@Z ; std::allocator_traits<xalloc<CDB::RESULT> >::destroy<CDB::RESULT>
PUBLIC	??$destroy@U?$_vector3@M@@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@@Z ; std::allocator_traits<xalloc<_vector3<float> > >::destroy<_vector3<float> >
PUBLIC	??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
PUBLIC	??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
PUBLIC	??$_Ptr_cat@VTRI@CDB@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBVTRI@CDB@@PEAV23@@Z ; std::_Ptr_cat<CDB::TRI,CDB::TRI>
PUBLIC	??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
PUBLIC	??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
PUBLIC	??$_Ptr_cat@URESULT@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBURESULT@CDB@@PEAU23@@Z ; std::_Ptr_cat<CDB::RESULT,CDB::RESULT>
PUBLIC	??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
PUBLIC	??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
PUBLIC	??$_Ptr_cat@U?$_vector3@M@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBU?$_vector3@M@@PEAU2@@Z ; std::_Ptr_cat<_vector3<float>,_vector3<float> >
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAPEBVTRI@CDB@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Unchecked
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAPEBU?$_vector3@M@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Unchecked
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAPEBURESULT@CDB@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Unchecked
PUBLIC	?construct@?$xalloc@URESULT@CDB@@@@QEAAXPEAURESULT@CDB@@AEBU23@@Z ; xalloc<CDB::RESULT>::construct
PUBLIC	??$_Uninit_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
PUBLIC	??$destroy@VTRI@CDB@@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@@Z ; std::_Wrap_alloc<xalloc<CDB::TRI> >::destroy<CDB::TRI>
PUBLIC	??$destroy@URESULT@CDB@@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@@Z ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::destroy<CDB::RESULT>
PUBLIC	??$move@AEAURESULT@CDB@@@std@@YA$$QEAURESULT@CDB@@AEAU12@@Z ; std::move<CDB::RESULT & __ptr64>
PUBLIC	??$destroy@U?$_vector3@M@@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@@Z ; std::_Wrap_alloc<xalloc<_vector3<float> > >::destroy<_vector3<float> >
PUBLIC	??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
PUBLIC	??$?8VTRI@CDB@@V01@@@YA_NAEBV?$xalloc@VTRI@CDB@@@@0@Z ; operator==<CDB::TRI,CDB::TRI>
PUBLIC	??$_Rechecked@PEAVTRI@CDB@@PEAV12@@std@@YAAEAPEAVTRI@CDB@@AEAPEAV12@PEAV12@@Z ; std::_Rechecked<CDB::TRI * __ptr64,CDB::TRI * __ptr64>
PUBLIC	??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
PUBLIC	??$_Unchecked@PEAVTRI@CDB@@@std@@YAPEAVTRI@CDB@@PEAV12@@Z ; std::_Unchecked<CDB::TRI * __ptr64>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@YAPEBVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CDB::TRI> > >
PUBLIC	??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
PUBLIC	??$?8URESULT@CDB@@U01@@@YA_NAEBV?$xalloc@URESULT@CDB@@@@0@Z ; operator==<CDB::RESULT,CDB::RESULT>
PUBLIC	??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@U23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@$$QEAU34@@Z ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT>
PUBLIC	??$_Rechecked@PEAURESULT@CDB@@PEAU12@@std@@YAAEAPEAURESULT@CDB@@AEAPEAU12@PEAU12@@Z ; std::_Rechecked<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
PUBLIC	??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
PUBLIC	??$_Unchecked@PEAURESULT@CDB@@@std@@YAPEAURESULT@CDB@@PEAU12@@Z ; std::_Unchecked<CDB::RESULT * __ptr64>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@YAPEBURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
PUBLIC	??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
PUBLIC	??$?8U?$_vector3@M@@U0@@@YA_NAEBV?$xalloc@U?$_vector3@M@@@@0@Z ; operator==<_vector3<float>,_vector3<float> >
PUBLIC	??$_Rechecked@PEAU?$_vector3@M@@PEAU1@@std@@YAAEAPEAU?$_vector3@M@@AEAPEAU1@PEAU1@@Z ; std::_Rechecked<_vector3<float> * __ptr64,_vector3<float> * __ptr64>
PUBLIC	??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@YAPEBU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
PUBLIC	??$_Uninitialized_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ; std::_Uninitialized_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAXPEAVTRI@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::TRI> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAXPEAURESULT@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::RESULT> > >
PUBLIC	??$_Move@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAXPEAU?$_vector3@M@@0AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<_vector3<float> > > >
PUBLIC	??$_Uninitialized_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ; std::_Uninitialized_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
PUBLIC	??$_Copy_impl@PEAVTRI@CDB@@PEAV12@@std@@YAPEAVTRI@CDB@@PEAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<CDB::TRI * __ptr64,CDB::TRI * __ptr64>
PUBLIC	??$_Ptr_cat@VTRI@CDB@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAVTRI@CDB@@0@Z ; std::_Ptr_cat<CDB::TRI,CDB::TRI>
PUBLIC	??$?8V?$xalloc@VTRI@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0@Z ; std::operator==<xalloc<CDB::TRI>,xalloc<CDB::TRI> >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@PEAVTRI@CDB@@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@std@@YAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
PUBLIC	??$_Uninitialized_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ; std::_Uninitialized_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
PUBLIC	??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
PUBLIC	??$_Ptr_cat@URESULT@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAURESULT@CDB@@0@Z ; std::_Ptr_cat<CDB::RESULT,CDB::RESULT>
PUBLIC	??$?8V?$xalloc@URESULT@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0@Z ; std::operator==<xalloc<CDB::RESULT>,xalloc<CDB::RESULT> >
PUBLIC	??$construct@URESULT@CDB@@U12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@$$QEAU34@@Z ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT>
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@PEAURESULT@CDB@@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@std@@YAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
PUBLIC	??$_Uninitialized_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ; std::_Uninitialized_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
PUBLIC	??$_Copy_impl@PEAU?$_vector3@M@@PEAU1@@std@@YAPEAU?$_vector3@M@@PEAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<_vector3<float> * __ptr64,_vector3<float> * __ptr64>
PUBLIC	??$_Ptr_cat@U?$_vector3@M@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAU?$_vector3@M@@0@Z ; std::_Ptr_cat<_vector3<float>,_vector3<float> >
PUBLIC	??$?8V?$xalloc@U?$_vector3@M@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0@Z ; std::operator==<xalloc<_vector3<float> >,xalloc<_vector3<float> > >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@PEAU?$_vector3@M@@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@std@@YAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
PUBLIC	??_GOPCODE_Model@Opcode@@QEAAPEAXI@Z		; Opcode::OPCODE_Model::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@VOPCODE_Model@Opcode@@@@QEAAXAEAPEAVOPCODE_Model@Opcode@@@Z ; xr_special_free<0,Opcode::OPCODE_Model>::operator()
PUBLIC	?max_size@?$xalloc@VTRI@CDB@@@@QEBA_KXZ		; xalloc<CDB::TRI>::max_size
PUBLIC	?max_size@?$xalloc@URESULT@CDB@@@@QEBA_KXZ	; xalloc<CDB::RESULT>::max_size
PUBLIC	?max_size@?$xalloc@U?$_vector3@M@@@@QEBA_KXZ	; xalloc<_vector3<float> >::max_size
PUBLIC	??$_Fn@V?$xalloc@VTRI@CDB@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@VTRI@CDB@@@@@Z ; std::_Alloc_max_size::_Fn<xalloc<CDB::TRI> >
PUBLIC	??$_Fn@V?$xalloc@URESULT@CDB@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@URESULT@CDB@@@@@Z ; std::_Alloc_max_size::_Fn<xalloc<CDB::RESULT> >
PUBLIC	??$_Fn@V?$xalloc@U?$_vector3@M@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@U?$_vector3@M@@@@@Z ; std::_Alloc_max_size::_Fn<xalloc<_vector3<float> > >
PUBLIC	??$xr_alloc@URESULT@CDB@@@@YAPEAURESULT@CDB@@I@Z ; xr_alloc<CDB::RESULT>
PUBLIC	??$_Fn@V?$xalloc@VTRI@CDB@@@@@_Alloc_select@std@@SA?AV?$xalloc@VTRI@CDB@@@@U_Wrap_int@1@AEBV2@@Z ; std::_Alloc_select::_Fn<xalloc<CDB::TRI> >
PUBLIC	??$_Fn@V?$xalloc@URESULT@CDB@@@@@_Alloc_select@std@@SA?AV?$xalloc@URESULT@CDB@@@@U_Wrap_int@1@AEBV2@@Z ; std::_Alloc_select::_Fn<xalloc<CDB::RESULT> >
PUBLIC	??$xr_free@URESULT@CDB@@@@YAXAEAPEAURESULT@CDB@@@Z ; xr_free<CDB::RESULT>
PUBLIC	??$_Umove@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Umove<CDB::RESULT * __ptr64>
PUBLIC	??$_Fn@V?$xalloc@U?$_vector3@M@@@@@_Alloc_select@std@@SA?AV?$xalloc@U?$_vector3@M@@@@U_Wrap_int@1@AEBV2@@Z ; std::_Alloc_select::_Fn<xalloc<_vector3<float> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAXPEAVTRI@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::TRI> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAXPEAURESULT@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::RESULT> > >
PUBLIC	??$_Move@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z ; std::_Move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAXPEAU?$_vector3@M@@0AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<_vector3<float> > > >
PUBLIC	??$_Ucopy@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Ucopy<CDB::TRI * __ptr64>
PUBLIC	??$_Copy_impl@PEAVTRI@CDB@@PEAV12@@std@@YAPEAVTRI@CDB@@PEAV12@00@Z ; std::_Copy_impl<CDB::TRI * __ptr64,CDB::TRI * __ptr64>
PUBLIC	??$?9V?$xalloc@VTRI@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0@Z ; std::operator!=<xalloc<CDB::TRI>,xalloc<CDB::TRI> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@1@0PEAV23@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > > >
PUBLIC	??$_Ucopy@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Ucopy<CDB::RESULT * __ptr64>
PUBLIC	??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z ; std::_Copy_impl<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
PUBLIC	??$?9V?$xalloc@URESULT@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0@Z ; std::operator!=<xalloc<CDB::RESULT>,xalloc<CDB::RESULT> >
PUBLIC	??$construct@URESULT@CDB@@U12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@$$QEAU23@@Z ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT>
PUBLIC	??$forward@URESULT@CDB@@@std@@YA$$QEAURESULT@CDB@@AEAU12@@Z ; std::forward<CDB::RESULT>
PUBLIC	??$addressof@URESULT@CDB@@@std@@YAPEAURESULT@CDB@@AEAU12@@Z ; std::addressof<CDB::RESULT>
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@1@0PEAU23@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > > >
PUBLIC	??$_Ucopy@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Ucopy<_vector3<float> * __ptr64>
PUBLIC	??$_Copy_impl@PEAU?$_vector3@M@@PEAU1@@std@@YAPEAU?$_vector3@M@@PEAU1@00@Z ; std::_Copy_impl<_vector3<float> * __ptr64,_vector3<float> * __ptr64>
PUBLIC	??$?9V?$xalloc@U?$_vector3@M@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0@Z ; std::operator!=<xalloc<_vector3<float> >,xalloc<_vector3<float> > >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@0PEAU2@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > > >
PUBLIC	??$xr_new@VOPCODE_Model@Opcode@@@@YAPEAVOPCODE_Model@Opcode@@XZ ; xr_new<Opcode::OPCODE_Model>
PUBLIC	??$xr_alloc@I@@YAPEAII@Z			; xr_alloc<unsigned int>
PUBLIC	??$xr_alloc@VTRI@CDB@@@@YAPEAVTRI@CDB@@I@Z	; xr_alloc<CDB::TRI>
PUBLIC	??$xr_alloc@U?$_vector3@M@@@@YAPEAU?$_vector3@M@@I@Z ; xr_alloc<_vector3<float> >
PUBLIC	??$xr_free@U?$_vector3@M@@@@YAXAEAPEAU?$_vector3@M@@@Z ; xr_free<_vector3<float> >
PUBLIC	??$xr_free@VTRI@CDB@@@@YAXAEAPEAVTRI@CDB@@@Z	; xr_free<CDB::TRI>
PUBLIC	??$xr_delete@VOPCODE_Model@Opcode@@@@YAXAEAPEAVOPCODE_Model@Opcode@@@Z ; xr_delete<Opcode::OPCODE_Model>
PUBLIC	?max_size@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SA_KAEBV?$xalloc@VTRI@CDB@@@@@Z ; std::allocator_traits<xalloc<CDB::TRI> >::max_size
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator+=
PUBLIC	?max_size@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SA_KAEBV?$xalloc@URESULT@CDB@@@@@Z ; std::allocator_traits<xalloc<CDB::RESULT> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SA_KAEBV?$xalloc@U?$_vector3@M@@@@@Z ; std::allocator_traits<xalloc<_vector3<float> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ; std::_Wrap_alloc<xalloc<CDB::TRI> >::max_size
PUBLIC	?allocate@?$xalloc@VTRI@CDB@@@@QEBAPEAVTRI@CDB@@_KPEBX@Z ; xalloc<CDB::TRI>::allocate
PUBLIC	??0?$xalloc@VTRI@CDB@@@@QEAA@AEBV0@@Z		; xalloc<CDB::TRI>::xalloc<CDB::TRI>
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Compat
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator+=
PUBLIC	?max_size@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::max_size
PUBLIC	?allocate@?$xalloc@URESULT@CDB@@@@QEBAPEAURESULT@CDB@@_KPEBX@Z ; xalloc<CDB::RESULT>::allocate
PUBLIC	??0?$xalloc@URESULT@CDB@@@@QEAA@AEBV0@@Z	; xalloc<CDB::RESULT>::xalloc<CDB::RESULT>
PUBLIC	?max_size@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ; std::_Wrap_alloc<xalloc<_vector3<float> > >::max_size
PUBLIC	?allocate@?$xalloc@U?$_vector3@M@@@@QEBAPEAU?$_vector3@M@@_KPEBX@Z ; xalloc<_vector3<float> >::allocate
PUBLIC	??0?$xalloc@U?$_vector3@M@@@@QEAA@AEBV0@@Z	; xalloc<_vector3<float> >::xalloc<_vector3<float> >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAA@PEAVTRI@CDB@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@PEAU?$_vector3@M@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<CDB::TRI> >::_Vector_val<std::_Simple_types<CDB::TRI> >
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SA?AV?$xalloc@VTRI@CDB@@@@AEBV3@@Z ; std::allocator_traits<xalloc<CDB::TRI> >::select_on_container_copy_construction
PUBLIC	?allocate@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAPEAVTRI@CDB@@_K@Z ; std::_Wrap_alloc<xalloc<CDB::TRI> >::allocate
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV?$xalloc@VTRI@CDB@@@@@Z ; std::_Wrap_alloc<xalloc<CDB::TRI> >::_Wrap_alloc<xalloc<CDB::TRI> >
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<CDB::TRI> >::_Wrap_alloc<xalloc<CDB::TRI> >
PUBLIC	?deallocate@?$xalloc@VTRI@CDB@@@@QEBAXPEAVTRI@CDB@@_K@Z ; xalloc<CDB::TRI>::deallocate
PUBLIC	??0?$xalloc@VTRI@CDB@@@@QEAA@XZ			; xalloc<CDB::TRI>::xalloc<CDB::TRI>
PUBLIC	?_Xlen@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Xlen
PUBLIC	?max_size@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::max_size
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator!=
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator==
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAA@PEAURESULT@CDB@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator-=
PUBLIC	??0?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<CDB::RESULT> >::_Vector_val<std::_Simple_types<CDB::RESULT> >
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SA?AV?$xalloc@URESULT@CDB@@@@AEBV3@@Z ; std::allocator_traits<xalloc<CDB::RESULT> >::select_on_container_copy_construction
PUBLIC	?allocate@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAPEAURESULT@CDB@@_K@Z ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::allocate
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV?$xalloc@URESULT@CDB@@@@@Z ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::_Wrap_alloc<xalloc<CDB::RESULT> >
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::_Wrap_alloc<xalloc<CDB::RESULT> >
PUBLIC	?deallocate@?$xalloc@URESULT@CDB@@@@QEBAXPEAURESULT@CDB@@_K@Z ; xalloc<CDB::RESULT>::deallocate
PUBLIC	??0?$xalloc@URESULT@CDB@@@@QEAA@XZ		; xalloc<CDB::RESULT>::xalloc<CDB::RESULT>
PUBLIC	?_Xlen@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Xlen
PUBLIC	?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBA_K_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Grow_to
PUBLIC	?max_size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::max_size
PUBLIC	?_Make_iter@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Make_iter
PUBLIC	?_Unused_capacity@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Unused_capacity
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<_vector3<float> > >::_Vector_val<std::_Simple_types<_vector3<float> > >
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SA?AV?$xalloc@U?$_vector3@M@@@@AEBV3@@Z ; std::allocator_traits<xalloc<_vector3<float> > >::select_on_container_copy_construction
PUBLIC	?allocate@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAPEAU?$_vector3@M@@_K@Z ; std::_Wrap_alloc<xalloc<_vector3<float> > >::allocate
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV?$xalloc@U?$_vector3@M@@@@@Z ; std::_Wrap_alloc<xalloc<_vector3<float> > >::_Wrap_alloc<xalloc<_vector3<float> > >
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<_vector3<float> > >::_Wrap_alloc<xalloc<_vector3<float> > >
PUBLIC	?deallocate@?$xalloc@U?$_vector3@M@@@@QEBAXPEAU?$_vector3@M@@_K@Z ; xalloc<_vector3<float> >::deallocate
PUBLIC	??0?$xalloc@U?$_vector3@M@@@@QEAA@XZ		; xalloc<_vector3<float> >::xalloc<_vector3<float> >
PUBLIC	?_Xlen@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Xlen
PUBLIC	?max_size@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::max_size
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAAEBVTRI@CDB@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator*
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAA@PEAVTRI@CDB@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAAEBU?$_vector3@M@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator*
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@PEAU?$_vector3@M@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@_K@Z ; std::_Wrap_alloc<xalloc<CDB::TRI> >::deallocate
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AU12@XZ ; std::_Wrap_alloc<xalloc<CDB::TRI> >::select_on_container_copy_construction
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Getal
PUBLIC	?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Change_alloc
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEAA@AEBV?$xalloc@VTRI@CDB@@@@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >
PUBLIC	?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Tidy
PUBLIC	?_Destroy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXPEAVTRI@CDB@@0@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Destroy
PUBLIC	?_Buy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAA_N_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Buy
PUBLIC	?clear@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::clear
PUBLIC	?empty@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_NXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::empty
PUBLIC	?size@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::size
PUBLIC	?end@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::end
PUBLIC	?begin@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::begin
PUBLIC	?capacity@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::capacity
PUBLIC	??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >
PUBLIC	?clear_and_free@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAXXZ ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::clear_and_free
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAAEBURESULT@CDB@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator-
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAA@PEAURESULT@CDB@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@_K@Z ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::deallocate
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AU12@XZ ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::select_on_container_copy_construction
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Getal
PUBLIC	?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Change_alloc
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEAA@AEBV?$xalloc@URESULT@CDB@@@@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >
PUBLIC	?_Orphan_range@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXPEAURESULT@CDB@@0@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Orphan_range
PUBLIC	?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Tidy
PUBLIC	?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reserve
PUBLIC	?_Inside@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBA_NPEBURESULT@CDB@@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Inside
PUBLIC	?_Destroy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXPEAURESULT@CDB@@0@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Destroy
PUBLIC	?_Buy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAA_N_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Buy
PUBLIC	?clear@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear
PUBLIC	?erase@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@0@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::erase
PUBLIC	?empty@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_NXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::empty
PUBLIC	?size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::size
PUBLIC	?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end
PUBLIC	?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin
PUBLIC	?capacity@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::capacity
PUBLIC	??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@_K@Z ; std::_Wrap_alloc<xalloc<_vector3<float> > >::deallocate
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AU12@XZ ; std::_Wrap_alloc<xalloc<_vector3<float> > >::select_on_container_copy_construction
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Getal
PUBLIC	?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Change_alloc
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEAA@AEBV?$xalloc@U?$_vector3@M@@@@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >
PUBLIC	?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Tidy
PUBLIC	?_Destroy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXPEAU?$_vector3@M@@0@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Destroy
PUBLIC	?_Buy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAA_N_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Buy
PUBLIC	?clear@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::clear
PUBLIC	?empty@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_NXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::empty
PUBLIC	?size@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::size
PUBLIC	?end@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::end
PUBLIC	?begin@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::begin
PUBLIC	?capacity@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::capacity
PUBLIC	??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >
PUBLIC	?clear_and_free@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAXXZ ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::clear_and_free
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAAEAVTRI@CDB@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator*
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAAEAU?$_vector3@M@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator*
PUBLIC	?begin@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::begin
PUBLIC	??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::operator=
PUBLIC	??1?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::~vector<CDB::TRI,xalloc<CDB::TRI> >
PUBLIC	??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >
PUBLIC	?clear@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAXXZ ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::clear
PUBLIC	?size@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEBAIXZ ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::size
PUBLIC	??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::xr_vector<CDB::TRI,xalloc<CDB::TRI> >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAAEAURESULT@CDB@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*
PUBLIC	?back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAURESULT@CDB@@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::back
PUBLIC	?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end
PUBLIC	?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin
PUBLIC	??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator=
PUBLIC	??1?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::~vector<CDB::RESULT,xalloc<CDB::RESULT> >
PUBLIC	?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::push_back
PUBLIC	??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >
PUBLIC	?clear_not_free@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAXXZ ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear_not_free
PUBLIC	?clear_and_free@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAXXZ ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear_and_free
PUBLIC	?size@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEBAIXZ ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::size
PUBLIC	??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >
PUBLIC	?begin@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::begin
PUBLIC	??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::operator=
PUBLIC	??1?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::~vector<_vector3<float>,xalloc<_vector3<float> > >
PUBLIC	??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >
PUBLIC	?clear@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAXXZ ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::clear
PUBLIC	?size@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEBAIXZ ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::size
PUBLIC	??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::xr_vector<_vector3<float>,xalloc<_vector3<float> > >
PUBLIC	?r_free@COLLIDER@CDB@@QEAAXXZ			; CDB::COLLIDER::r_free
PUBLIC	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ	; CDB::COLLIDER::r_add
PUBLIC	??1COLLIDER@CDB@@QEAA@XZ			; CDB::COLLIDER::~COLLIDER
PUBLIC	??0COLLIDER@CDB@@QEAA@XZ			; CDB::COLLIDER::COLLIDER
PUBLIC	?memory@MODEL@CDB@@QEAAIXZ			; CDB::MODEL::memory
PUBLIC	?build_internal@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z ; CDB::MODEL::build_internal
PUBLIC	?build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z ; CDB::MODEL::build
PUBLIC	?build_thread@MODEL@CDB@@SAXPEAX@Z		; CDB::MODEL::build_thread
PUBLIC	??1MODEL@CDB@@QEAA@XZ				; CDB::MODEL::~MODEL
PUBLIC	??0MODEL@CDB@@QEAA@XZ				; CDB::MODEL::MODEL
PUBLIC	DllMain
PUBLIC	??1CollectorPacked@CDB@@QEAA@XZ			; CDB::CollectorPacked::~CollectorPacked
PUBLIC	?getTS@CollectorPacked@CDB@@QEAA_KXZ		; CDB::CollectorPacked::getTS
PUBLIC	?getT@CollectorPacked@CDB@@QEAAPEAVTRI@2@XZ	; CDB::CollectorPacked::getT
PUBLIC	?getVS@CollectorPacked@CDB@@QEAA_KXZ		; CDB::CollectorPacked::getVS
PUBLIC	?getV@CollectorPacked@CDB@@QEAAPEAU?$_vector3@M@@XZ ; CDB::CollectorPacked::getV
PUBLIC	?getV_Vec@CollectorPacked@CDB@@QEAAAEAV?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@XZ ; CDB::CollectorPacked::getV_Vec
PUBLIC	??4?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAV0@AEBV0@@Z ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::operator=
PUBLIC	??4?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAV0@AEBV0@@Z ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::operator=
PUBLIC	??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@AEBV0@@Z ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::xr_vector<CDB::TRI,xalloc<CDB::TRI> >
PUBLIC	??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@AEBV0@@Z ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::xr_vector<_vector3<float>,xalloc<_vector3<float> > >
PUBLIC	??1?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::~xr_vector<CDB::TRI,xalloc<CDB::TRI> >
PUBLIC	??1?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::~xr_vector<_vector3<float>,xalloc<_vector3<float> > >
PUBLIC	??4Collector@CDB@@QEAAAEAV01@AEBV01@@Z		; CDB::Collector::operator=
PUBLIC	??0Collector@CDB@@QEAA@AEBV01@@Z		; CDB::Collector::Collector
PUBLIC	??1Collector@CDB@@QEAA@XZ			; CDB::Collector::~Collector
PUBLIC	??0Collector@CDB@@QEAA@XZ			; CDB::Collector::Collector
PUBLIC	?clear@Collector@CDB@@QEAAXXZ			; CDB::Collector::clear
PUBLIC	?getTS@Collector@CDB@@QEAA_KXZ			; CDB::Collector::getTS
PUBLIC	?getT@Collector@CDB@@QEAAPEAVTRI@2@XZ		; CDB::Collector::getT
PUBLIC	?getVS@Collector@CDB@@QEAA_KXZ			; CDB::Collector::getVS
PUBLIC	?getV@Collector@CDB@@QEAAPEAU?$_vector3@M@@XZ	; CDB::Collector::getV
PUBLIC	??4?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAAEAV0@AEBV0@@Z ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator=
PUBLIC	??1?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::~xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >
PUBLIC	??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@AEBV0@@Z ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >
PUBLIC	??4COLLIDER@CDB@@QEAAAEAV01@AEBV01@@Z		; CDB::COLLIDER::operator=
PUBLIC	??0COLLIDER@CDB@@QEAA@AEBV01@@Z			; CDB::COLLIDER::COLLIDER
PUBLIC	?r_clear_compact@COLLIDER@CDB@@QEAAXXZ		; CDB::COLLIDER::r_clear_compact
PUBLIC	?r_clear@COLLIDER@CDB@@QEAAXXZ			; CDB::COLLIDER::r_clear
PUBLIC	?r_count@COLLIDER@CDB@@QEAAHXZ			; CDB::COLLIDER::r_count
PUBLIC	?r_end@COLLIDER@CDB@@QEAAPEAURESULT@2@XZ	; CDB::COLLIDER::r_end
PUBLIC	?r_begin@COLLIDER@CDB@@QEAAPEAURESULT@2@XZ	; CDB::COLLIDER::r_begin
PUBLIC	?frustum_options@COLLIDER@CDB@@QEAAXI@Z		; CDB::COLLIDER::frustum_options
PUBLIC	?box_options@COLLIDER@CDB@@QEAAXI@Z		; CDB::COLLIDER::box_options
PUBLIC	?ray_options@COLLIDER@CDB@@QEAAXI@Z		; CDB::COLLIDER::ray_options
PUBLIC	??4RESULT@CDB@@QEAAAEAU01@AEBU01@@Z		; CDB::RESULT::operator=
PUBLIC	??4MODEL@CDB@@QEAAAEAV01@AEBV01@@Z		; CDB::MODEL::operator=
PUBLIC	?syncronize@MODEL@CDB@@QEBAXXZ			; CDB::MODEL::syncronize
PUBLIC	?get_tris_count@MODEL@CDB@@QEBAHXZ		; CDB::MODEL::get_tris_count
PUBLIC	?get_tris@MODEL@CDB@@QEAAPEAVTRI@2@XZ		; CDB::MODEL::get_tris
PUBLIC	?get_verts_count@MODEL@CDB@@QEBAHXZ		; CDB::MODEL::get_verts_count
PUBLIC	?get_verts@MODEL@CDB@@QEAAPEAU?$_vector3@M@@XZ	; CDB::MODEL::get_verts
PUBLIC	??4TRI@CDB@@QEAAAEAV01@AEBV01@@Z		; CDB::TRI::operator=
PUBLIC	?IDvert@TRI@CDB@@QEAAII@Z			; CDB::TRI::IDvert
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$??1?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@IV?$xalloc@I@@@std@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+49
	DD	imagerel $unwind$??1?$vector@IV?$xalloc@I@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@IV?$xalloc@I@@@std@@IEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+49
	DD	imagerel $unwind$?_Tidy@?$vector@IV?$xalloc@I@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_free@I@@YAXAEAPEAI@Z DD imagerel $LN5
	DD	imagerel $LN5+43
	DD	imagerel $unwind$??$xr_free@I@@YAXAEAPEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+88
	DD	imagerel $unwind$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+72
	DD	imagerel $unwind$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+72
	DD	imagerel $unwind$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+88
	DD	imagerel $unwind$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+88
	DD	imagerel $unwind$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+70
	DD	imagerel $unwind$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+70
	DD	imagerel $unwind$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+14
	DD	imagerel $unwind$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+14
	DD	imagerel $unwind$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+14
	DD	imagerel $unwind$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+14
	DD	imagerel $unwind$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+14
	DD	imagerel $unwind$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+14
	DD	imagerel $unwind$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+14
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@PEAVTRI@CDB@@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@std@@YAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@PEAVTRI@CDB@@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@std@@YAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+14
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@PEAURESULT@CDB@@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@std@@YAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@PEAURESULT@CDB@@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@std@@YAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+14
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@PEAU?$_vector3@M@@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@std@@YAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@PEAU?$_vector3@M@@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@std@@YAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GOPCODE_Model@Opcode@@QEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+23
	DD	imagerel $unwind$??_GOPCODE_Model@Opcode@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$0A@VOPCODE_Model@Opcode@@@@QEAAXAEAPEAVOPCODE_Model@Opcode@@@Z DD imagerel $LN12
	DD	imagerel $LN12+39
	DD	imagerel $unwind$??R?$xr_special_free@$0A@VOPCODE_Model@Opcode@@@@QEAAXAEAPEAVOPCODE_Model@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_free@URESULT@CDB@@@@YAXAEAPEAURESULT@CDB@@@Z DD imagerel $LN5
	DD	imagerel $LN5+43
	DD	imagerel $unwind$??$xr_free@URESULT@CDB@@@@YAXAEAPEAURESULT@CDB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z DD imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??$_Umove@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z DD imagerel $LN18
	DD	imagerel $LN18+26
	DD	imagerel $unwind$??$_Ucopy@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@1@0PEAV23@@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@1@0PEAV23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z DD imagerel $LN18
	DD	imagerel $LN18+26
	DD	imagerel $unwind$??$_Ucopy@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@1@0PEAU23@@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@1@0PEAU23@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z DD imagerel $LN18
	DD	imagerel $LN18+26
	DD	imagerel $unwind$??$_Ucopy@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@0PEAU2@@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@0PEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VOPCODE_Model@Opcode@@@@YAPEAVOPCODE_Model@Opcode@@XZ DD imagerel $LN10
	DD	imagerel $LN10+58
	DD	imagerel $unwind$??$xr_new@VOPCODE_Model@Opcode@@@@YAPEAVOPCODE_Model@Opcode@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_free@U?$_vector3@M@@@@YAXAEAPEAU?$_vector3@M@@@Z DD imagerel $LN5
	DD	imagerel $LN5+43
	DD	imagerel $unwind$??$xr_free@U?$_vector3@M@@@@YAXAEAPEAU?$_vector3@M@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_free@VTRI@CDB@@@@YAXAEAPEAVTRI@CDB@@@Z DD imagerel $LN5
	DD	imagerel $LN5+43
	DD	imagerel $unwind$??$xr_free@VTRI@CDB@@@@YAXAEAPEAVTRI@CDB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@VOPCODE_Model@Opcode@@@@YAXAEAPEAVOPCODE_Model@Opcode@@@Z DD imagerel $LN15
	DD	imagerel $LN15+51
	DD	imagerel $unwind$??$xr_delete@VOPCODE_Model@Opcode@@@@YAXAEAPEAVOPCODE_Model@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD imagerel $LN58
	DD	imagerel $LN58+154
	DD	imagerel $unwind$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA+45
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+49
	DD	imagerel $unwind$?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAA_N_K@Z DD imagerel $LN32
	DD	imagerel $LN32+118
	DD	imagerel $unwind$?_Buy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+49
	DD	imagerel $unwind$?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD imagerel $LN47
	DD	imagerel $LN47+140
	DD	imagerel $unwind$?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAA_N_K@Z DD imagerel $LN32
	DD	imagerel $LN32+113
	DD	imagerel $unwind$?_Buy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+49
	DD	imagerel $unwind$?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAA_N_K@Z DD imagerel $LN32
	DD	imagerel $LN32+118
	DD	imagerel $unwind$?_Buy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAA_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN140
	DD	imagerel $LN140+444
	DD	imagerel $unwind$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA DD imagerel ?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	imagerel ?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA+32
	DD	imagerel $unwind$?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+49
	DD	imagerel $unwind$??1?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z DD imagerel $LN87
	DD	imagerel $LN87+207
	DD	imagerel $unwind$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA+32
	DD	imagerel $unwind$?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN128
	DD	imagerel $LN128+294
	DD	imagerel $unwind$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA DD imagerel ?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	imagerel ?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA+32
	DD	imagerel $unwind$?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+49
	DD	imagerel $unwind$??1?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z DD imagerel $LN75
	DD	imagerel $LN75+128
	DD	imagerel $unwind$?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z DD imagerel $LN87
	DD	imagerel $LN87+179
	DD	imagerel $unwind$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA+32
	DD	imagerel $unwind$?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN140
	DD	imagerel $LN140+441
	DD	imagerel $unwind$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA DD imagerel ?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	imagerel ?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA+32
	DD	imagerel $unwind$?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+49
	DD	imagerel $unwind$??1?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z DD imagerel $LN87
	DD	imagerel $LN87+206
	DD	imagerel $unwind$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA DD imagerel ?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	imagerel ?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA+32
	DD	imagerel $unwind$?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ DD imagerel $LN97
	DD	imagerel $LN97+75
	DD	imagerel $unwind$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ
$pdata$0$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ DD imagerel $LN97+75
	DD	imagerel $LN97+155
	DD	imagerel $chain$0$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ
$pdata$1$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ DD imagerel $LN97+155
	DD	imagerel $LN97+238
	DD	imagerel $chain$1$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ
$pdata$??1COLLIDER@CDB@@QEAA@XZ DD imagerel $LN30
	DD	imagerel $LN30+58
	DD	imagerel $unwind$??1COLLIDER@CDB@@QEAA@XZ
$pdata$?memory@MODEL@CDB@@QEAAIXZ DD imagerel $LN7
	DD	imagerel $LN7+96
	DD	imagerel $unwind$?memory@MODEL@CDB@@QEAAIXZ
$pdata$?build_internal@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z DD imagerel $LN72
	DD	imagerel $LN72+556
	DD	imagerel $unwind$?build_internal@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z
$pdata$?build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z DD imagerel $LN23
	DD	imagerel $LN23+403
	DD	imagerel $unwind$?build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z
$pdata$?build_thread@MODEL@CDB@@SAXPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+192
	DD	imagerel $unwind$?build_thread@MODEL@CDB@@SAXPEAX@Z
$pdata$??1MODEL@CDB@@QEAA@XZ DD imagerel $LN26
	DD	imagerel $LN26+156
	DD	imagerel $unwind$??1MODEL@CDB@@QEAA@XZ
$pdata$??0MODEL@CDB@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+51
	DD	imagerel $unwind$??0MODEL@CDB@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CollectorPacked@CDB@@QEAA@XZ DD imagerel $LN65
	DD	imagerel $LN65+176
	DD	imagerel $unwind$??1CollectorPacked@CDB@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAV0@AEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$??4?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAV0@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAV0@AEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$??4?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAV0@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@AEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@AEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$??1?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$??1?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4Collector@CDB@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN8
	DD	imagerel $LN8+48
	DD	imagerel $unwind$??4Collector@CDB@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Collector@CDB@@QEAA@AEBV01@@Z DD imagerel $LN8
	DD	imagerel $LN8+48
	DD	imagerel $unwind$??0Collector@CDB@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1Collector@CDB@@QEAA@XZ DD imagerel $LN40
	DD	imagerel $LN40+92
	DD	imagerel $unwind$??1Collector@CDB@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAAEAV0@AEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$??4?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAAEAV0@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$??1?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@AEBV0@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@AEBV0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4COLLIDER@CDB@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$??4COLLIDER@CDB@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0COLLIDER@CDB@@QEAA@AEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+47
	DD	imagerel $unwind$??0COLLIDER@CDB@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?syncronize@MODEL@CDB@@QEBAXXZ DD imagerel $LN5
	DD	imagerel $LN5+42
	DD	imagerel $unwind$?syncronize@MODEL@CDB@@QEBAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$?syncronize@MODEL@CDB@@QEBAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0COLLIDER@CDB@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4COLLIDER@CDB@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@AEBV0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAAEAV0@AEBV0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1Collector@CDB@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Collector@CDB@@QEAA@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4Collector@CDB@@QEAAAEAV01@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@AEBV0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@AEBV0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAV0@AEBV0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAV0@AEBV0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CollectorPacked@CDB@@QEAA@XZ DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
xdata	SEGMENT
$unwind$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ DD 040c01H
	DD	0f340cH
	DD	06008b20cH
$chain$0$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ DD 020421H
	DD	0e7404H
	DD	imagerel $LN97
	DD	imagerel $LN97+75
	DD	imagerel $unwind$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ
$chain$1$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ DD 021H
	DD	imagerel $LN97
	DD	imagerel $LN97+75
	DD	imagerel $unwind$?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ
$unwind$??1COLLIDER@CDB@@QEAA@XZ DD 020601H
	DD	030023206H
$unwind$?memory@MODEL@CDB@@QEAAIXZ DD 052b01H
	DD	04742bH
	DD	063426H
	DD	04204H
$unwind$?build_internal@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z DD 081401H
	DD	0e6414H
	DD	0d5414H
	DD	0c3414H
	DD	070109214H
$unwind$?build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z DD 0a1b01H
	DD	016641bH
	DD	015541bH
	DD	014341bH
	DD	0f014f21bH
	DD	07010e012H
$unwind$?build_thread@MODEL@CDB@@SAXPEAX@Z DD 030901H
	DD	0160109H
	DD	03002H
$unwind$??1MODEL@CDB@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$??0MODEL@CDB@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z DD imagerel ??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z+168
	DD	00H
	DD	imagerel ??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z+187
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
	DD	01H
	DD	imagerel $tryMap$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
	DD	05H
	DD	imagerel $ip2state$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z DD 061d19H
	DD	0c641dH
	DD	0b3418H
	DD	07006720aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel ??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	0ffffffffH
	DD	imagerel ??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z+397
	DD	00H
	DD	imagerel ??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z+416
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	01H
	DD	imagerel $tryMap$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	05H
	DD	imagerel $ip2state$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 082319H
	DD	0d7423H
	DD	0c641eH
	DD	0b3419H
	DD	0e007720bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z DD imagerel ??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z+141
	DD	00H
	DD	imagerel ??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z+160
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
	DD	01H
	DD	imagerel $tryMap$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
	DD	05H
	DD	imagerel $ip2state$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z DD 061d19H
	DD	0c641dH
	DD	0b3418H
	DD	07006720aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel ??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	0ffffffffH
	DD	imagerel ??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z+250
	DD	00H
	DD	imagerel ??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z+269
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	01H
	DD	imagerel $tryMap$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	05H
	DD	imagerel $ip2state$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 061d19H
	DD	0c641dH
	DD	0b3418H
	DD	07006720aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z DD imagerel ??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z+169
	DD	00H
	DD	imagerel ??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z+188
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
	DD	01H
	DD	imagerel $tryMap$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
	DD	05H
	DD	imagerel $ip2state$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z DD 061d19H
	DD	0c641dH
	DD	0b3418H
	DD	07006720aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel ??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	0ffffffffH
	DD	imagerel ??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z+400
	DD	00H
	DD	imagerel ??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z+419
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	01H
	DD	imagerel $tryMap$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	05H
	DD	imagerel $ip2state$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z DD 082319H
	DD	0d7423H
	DD	0c641eH
	DD	0b3419H
	DD	0e007720bH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAA_N_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAA_N_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAA_N_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z+63
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z+79
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z DD 081e19H
	DD	0d741eH
	DD	0c6419H
	DD	0a3414H
	DD	0e0027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@VOPCODE_Model@Opcode@@@@YAXAEAPEAVOPCODE_Model@Opcode@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@VTRI@CDB@@@@YAXAEAPEAVTRI@CDB@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@U?$_vector3@M@@@@YAXAEAPEAU?$_vector3@M@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VOPCODE_Model@Opcode@@@@YAPEAVOPCODE_Model@Opcode@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@0PEAU2@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@1@0PEAU23@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@1@0PEAV23@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ucopy@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@URESULT@CDB@@@@YAXAEAPEAURESULT@CDB@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$0A@VOPCODE_Model@Opcode@@@@QEAAXAEAPEAVOPCODE_Model@Opcode@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GOPCODE_Model@Opcode@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@PEAU?$_vector3@M@@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@std@@YAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@PEAURESULT@CDB@@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@std@@YAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@PEAVTRI@CDB@@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@std@@YAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+62
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+62
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+80
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+80
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+64
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+64
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+80
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@I@@YAXAEAPEAI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@IV?$xalloc@I@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@IV?$xalloc@I@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?IDvert@TRI@CDB@@QEAAII@Z
_TEXT	SEGMENT
this$ = 8
ID$ = 16
?IDvert@TRI@CDB@@QEAAII@Z PROC				; CDB::TRI::IDvert, COMDAT

; 64   : 		IC u32			IDvert	(u32 ID)		{ return verts[ID];	}

	mov	eax, edx
	mov	eax, DWORD PTR [rcx+rax*4]
	ret	0
?IDvert@TRI@CDB@@QEAAII@Z ENDP				; CDB::TRI::IDvert
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4TRI@CDB@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??4TRI@CDB@@QEAAAEAV01@AEBV01@@Z PROC			; CDB::TRI::operator=, COMDAT
	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	xmm1, QWORD PTR [rdx+16]
	movsdx	QWORD PTR [rcx+16], xmm1
	ret	0
??4TRI@CDB@@QEAAAEAV01@AEBV01@@Z ENDP			; CDB::TRI::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?get_verts@MODEL@CDB@@QEAAPEAU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
?get_verts@MODEL@CDB@@QEAAPEAU?$_vector3@M@@XZ PROC	; CDB::MODEL::get_verts, COMDAT

; 95   : 		IC Fvector*				get_verts		()			{ return verts;		}

	mov	rax, QWORD PTR [rcx+40]
	ret	0
?get_verts@MODEL@CDB@@QEAAPEAU?$_vector3@M@@XZ ENDP	; CDB::MODEL::get_verts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?get_verts_count@MODEL@CDB@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?get_verts_count@MODEL@CDB@@QEBAHXZ PROC		; CDB::MODEL::get_verts_count, COMDAT

; 96   : 		IC int					get_verts_count	()	const	{ return verts_count;}

	mov	eax, DWORD PTR [rcx+48]
	ret	0
?get_verts_count@MODEL@CDB@@QEBAHXZ ENDP		; CDB::MODEL::get_verts_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?get_tris@MODEL@CDB@@QEAAPEAVTRI@2@XZ
_TEXT	SEGMENT
this$ = 8
?get_tris@MODEL@CDB@@QEAAPEAVTRI@2@XZ PROC		; CDB::MODEL::get_tris, COMDAT

; 97   : 		IC TRI*					get_tris		()			{ return tris;		}

	mov	rax, QWORD PTR [rcx+24]
	ret	0
?get_tris@MODEL@CDB@@QEAAPEAVTRI@2@XZ ENDP		; CDB::MODEL::get_tris
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?get_tris_count@MODEL@CDB@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?get_tris_count@MODEL@CDB@@QEBAHXZ PROC			; CDB::MODEL::get_tris_count, COMDAT

; 98   : 		IC int					get_tris_count	()	const	{ return tris_count;}

	mov	eax, DWORD PTR [rcx+32]
	ret	0
?get_tris_count@MODEL@CDB@@QEBAHXZ ENDP			; CDB::MODEL::get_tris_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?syncronize@MODEL@CDB@@QEBAXXZ
_TEXT	SEGMENT
this$ = 48
?syncronize@MODEL@CDB@@QEBAXXZ PROC			; CDB::MODEL::syncronize, COMDAT

; 100  : 		{

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H

; 101  : 			if (S_READY!=status)

	cmp	DWORD PTR [rcx+16], 0
	mov	rbx, rcx
	je	SHORT $LN1@syncronize

; 102  : 			{
; 103  : 				Log						("! WARNING: syncronized CDB::query");
; 104  : 				xrCriticalSection*	C	= (xrCriticalSection*) &cs;
; 105  : 				C->Enter				();

	call	QWORD PTR __imp_?Enter@xrCriticalSection@@QEAAXXZ

; 106  : 				C->Leave				();

	mov	rcx, rbx

; 107  : 			}
; 108  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx

; 106  : 				C->Leave				();

	rex_jmp	QWORD PTR __imp_?Leave@xrCriticalSection@@QEAAXXZ
$LN1@syncronize:

; 107  : 			}
; 108  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?syncronize@MODEL@CDB@@QEBAXXZ ENDP			; CDB::MODEL::syncronize
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4MODEL@CDB@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??4MODEL@CDB@@QEAAAEAV01@AEBV01@@Z PROC			; CDB::MODEL::operator=, COMDAT
	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movsdx	xmm1, QWORD PTR [rdx+48]
	movsdx	QWORD PTR [rcx+48], xmm1
	ret	0
??4MODEL@CDB@@QEAAAEAV01@AEBV01@@Z ENDP			; CDB::MODEL::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4RESULT@CDB@@QEAAAEAU01@AEBU01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??4RESULT@CDB@@QEAAAEAU01@AEBU01@@Z PROC		; CDB::RESULT::operator=, COMDAT
	movups	xmm0, XMMWORD PTR [rdx]
	mov	rax, rcx
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
	ret	0
??4RESULT@CDB@@QEAAAEAU01@AEBU01@@Z ENDP		; CDB::RESULT::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?ray_options@COLLIDER@CDB@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
?ray_options@COLLIDER@CDB@@QEAAXI@Z PROC		; CDB::COLLIDER::ray_options, COMDAT

; 173  : 		ICF void		ray_options		(u32 f)	{	ray_mode = f;		}

	mov	DWORD PTR [rcx], edx
	ret	0
?ray_options@COLLIDER@CDB@@QEAAXI@Z ENDP		; CDB::COLLIDER::ray_options
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?box_options@COLLIDER@CDB@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
?box_options@COLLIDER@CDB@@QEAAXI@Z PROC		; CDB::COLLIDER::box_options, COMDAT

; 176  : 		ICF void		box_options		(u32 f)	{	box_mode = f;		}

	mov	DWORD PTR [rcx+4], edx
	ret	0
?box_options@COLLIDER@CDB@@QEAAXI@Z ENDP		; CDB::COLLIDER::box_options
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?frustum_options@COLLIDER@CDB@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
f$ = 16
?frustum_options@COLLIDER@CDB@@QEAAXI@Z PROC		; CDB::COLLIDER::frustum_options, COMDAT

; 179  : 		ICF void		frustum_options	(u32 f)	{	frustum_mode = f;	}

	mov	DWORD PTR [rcx+8], edx
	ret	0
?frustum_options@COLLIDER@CDB@@QEAAXI@Z ENDP		; CDB::COLLIDER::frustum_options
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?r_begin@COLLIDER@CDB@@QEAAPEAURESULT@2@XZ
_TEXT	SEGMENT
this$ = 8
?r_begin@COLLIDER@CDB@@QEAAPEAURESULT@2@XZ PROC		; CDB::COLLIDER::r_begin, COMDAT

; 182  : 		ICF RESULT*		r_begin			()	{	return &*rd.begin();		};

	mov	rax, QWORD PTR [rcx+16]
	ret	0
?r_begin@COLLIDER@CDB@@QEAAPEAURESULT@2@XZ ENDP		; CDB::COLLIDER::r_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?r_end@COLLIDER@CDB@@QEAAPEAURESULT@2@XZ
_TEXT	SEGMENT
this$ = 8
?r_end@COLLIDER@CDB@@QEAAPEAURESULT@2@XZ PROC		; CDB::COLLIDER::r_end, COMDAT

; 183  : 		ICF RESULT*		r_end			()	{	return &*rd.end();			};

	mov	rax, QWORD PTR [rcx+24]
	ret	0
?r_end@COLLIDER@CDB@@QEAAPEAURESULT@2@XZ ENDP		; CDB::COLLIDER::r_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?r_count@COLLIDER@CDB@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?r_count@COLLIDER@CDB@@QEAAHXZ PROC			; CDB::COLLIDER::r_count, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	ret	0
?r_count@COLLIDER@CDB@@QEAAHXZ ENDP			; CDB::COLLIDER::r_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?r_clear@COLLIDER@CDB@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?r_clear@COLLIDER@CDB@@QEAAXXZ PROC			; CDB::COLLIDER::r_clear, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+24], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 187  : 		ICF void		r_clear			()	{	rd.clear_not_free();		};

	ret	0
?r_clear@COLLIDER@CDB@@QEAAXXZ ENDP			; CDB::COLLIDER::r_clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?r_clear_compact@COLLIDER@CDB@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?r_clear_compact@COLLIDER@CDB@@QEAAXXZ PROC		; CDB::COLLIDER::r_clear_compact, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+24], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 188  : 		ICF void		r_clear_compact	()	{	rd.clear_and_free();		};

	ret	0
?r_clear_compact@COLLIDER@CDB@@QEAAXXZ ENDP		; CDB::COLLIDER::r_clear_compact
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0COLLIDER@CDB@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0COLLIDER@CDB@@QEAA@AEBV01@@Z PROC			; CDB::COLLIDER::COLLIDER, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
	add	rdx, 16
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx-12]
	add	rcx, 16
	mov	DWORD PTR [rcx-12], eax
	mov	eax, DWORD PTR [rdx-8]
	mov	DWORD PTR [rcx-8], eax
	call	??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0COLLIDER@CDB@@QEAA@AEBV01@@Z ENDP			; CDB::COLLIDER::COLLIDER
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4COLLIDER@CDB@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4COLLIDER@CDB@@QEAAAEAV01@AEBV01@@Z PROC		; CDB::COLLIDER::operator=, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	eax, DWORD PTR [rdx]
	mov	rbx, rcx
	add	rdx, 16
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx-12]
	add	rcx, 16
	mov	DWORD PTR [rcx-12], eax
	mov	eax, DWORD PTR [rdx-8]
	mov	DWORD PTR [rcx-8], eax
	call	??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator=
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4COLLIDER@CDB@@QEAAAEAV01@AEBV01@@Z ENDP		; CDB::COLLIDER::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@AEBV0@@Z PROC ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >, COMDAT
$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@AEBV0@@Z ENDP ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ PROC ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::~xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >, COMDAT
$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN5@xr_vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN5@xr_vector:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ ENDP ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::~xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAAEAV0@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAAEAV0@AEBV0@@Z PROC ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator=, COMDAT
$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator=
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAAEAV0@AEBV0@@Z ENDP ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getV@Collector@CDB@@QEAAPEAU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
?getV@Collector@CDB@@QEAAPEAU?$_vector3@M@@XZ PROC	; CDB::Collector::getV, COMDAT

; 211  : 		Fvector*		getV			()	{ return &*verts.begin();		}

	mov	rax, QWORD PTR [rcx]
	ret	0
?getV@Collector@CDB@@QEAAPEAU?$_vector3@M@@XZ ENDP	; CDB::Collector::getV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getVS@Collector@CDB@@QEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?getVS@Collector@CDB@@QEAA_KXZ PROC			; CDB::Collector::getVS, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 212  : 		size_t			getVS			() 	{ return verts.size();			}

	mov	eax, eax
	ret	0
?getVS@Collector@CDB@@QEAA_KXZ ENDP			; CDB::Collector::getVS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getT@Collector@CDB@@QEAAPEAVTRI@2@XZ
_TEXT	SEGMENT
this$ = 8
?getT@Collector@CDB@@QEAAPEAVTRI@2@XZ PROC		; CDB::Collector::getT, COMDAT

; 213  : 		TRI*			getT			()	{ return &*faces.begin();		}

	mov	rax, QWORD PTR [rcx+24]
	ret	0
?getT@Collector@CDB@@QEAAPEAVTRI@2@XZ ENDP		; CDB::Collector::getT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getTS@Collector@CDB@@QEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?getTS@Collector@CDB@@QEAA_KXZ PROC			; CDB::Collector::getTS, COMDAT

; 214  : 		size_t			getTS			()	{ return faces.size();			}

	mov	rax, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rcx+32]
	sub	rcx, QWORD PTR [rax+24]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 214  : 		size_t			getTS			()	{ return faces.size();			}

	mov	eax, eax
	ret	0
?getTS@Collector@CDB@@QEAA_KXZ ENDP			; CDB::Collector::getTS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?clear@Collector@CDB@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@Collector@CDB@@QEAAXXZ PROC			; CDB::Collector::clear, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 215  : 		void			clear			()	{ verts.clear(); faces.clear();	}

	ret	0
?clear@Collector@CDB@@QEAAXXZ ENDP			; CDB::Collector::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0Collector@CDB@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Collector@CDB@@QEAA@XZ PROC				; CDB::Collector::Collector, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx+24], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+32], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+40], rax
	mov	rax, rcx
	ret	0
??0Collector@CDB@@QEAA@XZ ENDP				; CDB::Collector::Collector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1Collector@CDB@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1Collector@CDB@@QEAA@XZ PROC				; CDB::Collector::~Collector, COMDAT
$LN40:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx+24]
	xor	edi, edi
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN7@Collector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	mov	QWORD PTR [rbx+24], rdi

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+32], rdi

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+40], rdi
$LN7@Collector:

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rbx]
	test	rdx, rdx
	je	SHORT $LN25@Collector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	mov	QWORD PTR [rbx], rdi

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rdi

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rdi
$LN25@Collector:
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1Collector@CDB@@QEAA@XZ ENDP				; CDB::Collector::~Collector
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0Collector@CDB@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0Collector@CDB@@QEAA@AEBV01@@Z PROC			; CDB::Collector::Collector, COMDAT
$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >
	lea	rdx, QWORD PTR [rbx+24]
	lea	rcx, QWORD PTR [rdi+24]
	call	??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0Collector@CDB@@QEAA@AEBV01@@Z ENDP			; CDB::Collector::Collector
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4Collector@CDB@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4Collector@CDB@@QEAAAEAV01@AEBV01@@Z PROC		; CDB::Collector::operator=, COMDAT
$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx
	call	??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::operator=
	lea	rdx, QWORD PTR [rbx+24]
	lea	rcx, QWORD PTR [rdi+24]
	call	??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::operator=
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??4Collector@CDB@@QEAAAEAV01@AEBV01@@Z ENDP		; CDB::Collector::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ PROC ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::~xr_vector<_vector3<float>,xalloc<_vector3<float> > >, COMDAT
$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN5@xr_vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN5@xr_vector:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ ENDP ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::~xr_vector<_vector3<float>,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ PROC ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::~xr_vector<CDB::TRI,xalloc<CDB::TRI> >, COMDAT
$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN5@xr_vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN5@xr_vector:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ ENDP ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::~xr_vector<CDB::TRI,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@AEBV0@@Z PROC ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::xr_vector<_vector3<float>,xalloc<_vector3<float> > >, COMDAT
$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@AEBV0@@Z ENDP ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::xr_vector<_vector3<float>,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@AEBV0@@Z PROC ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::xr_vector<CDB::TRI,xalloc<CDB::TRI> >, COMDAT
$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@AEBV0@@Z ENDP ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::xr_vector<CDB::TRI,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAV0@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAV0@AEBV0@@Z PROC ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::operator=, COMDAT
$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::operator=
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAV0@AEBV0@@Z ENDP ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??4?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAV0@AEBV0@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??4?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAV0@AEBV0@@Z PROC ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::operator=, COMDAT
$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::operator=
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??4?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAV0@AEBV0@@Z ENDP ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getV_Vec@CollectorPacked@CDB@@QEAAAEAV?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@XZ
_TEXT	SEGMENT
this$ = 8
?getV_Vec@CollectorPacked@CDB@@QEAAAEAV?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@XZ PROC ; CDB::CollectorPacked::getV_Vec, COMDAT

; 254  : 		xr_vector<Fvector>& getV_Vec()	{ return verts;				}

	mov	rax, rcx
	ret	0
?getV_Vec@CollectorPacked@CDB@@QEAAAEAV?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@XZ ENDP ; CDB::CollectorPacked::getV_Vec
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getV@CollectorPacked@CDB@@QEAAPEAU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
?getV@CollectorPacked@CDB@@QEAAPEAU?$_vector3@M@@XZ PROC ; CDB::CollectorPacked::getV, COMDAT

; 255  : 		Fvector*			getV()		{ return &*verts.begin();	}

	mov	rax, QWORD PTR [rcx]
	ret	0
?getV@CollectorPacked@CDB@@QEAAPEAU?$_vector3@M@@XZ ENDP ; CDB::CollectorPacked::getV
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getVS@CollectorPacked@CDB@@QEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?getVS@CollectorPacked@CDB@@QEAA_KXZ PROC		; CDB::CollectorPacked::getVS, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 256  : 		size_t				getVS()		{ return verts.size();		}

	mov	eax, eax
	ret	0
?getVS@CollectorPacked@CDB@@QEAA_KXZ ENDP		; CDB::CollectorPacked::getVS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getT@CollectorPacked@CDB@@QEAAPEAVTRI@2@XZ
_TEXT	SEGMENT
this$ = 8
?getT@CollectorPacked@CDB@@QEAAPEAVTRI@2@XZ PROC	; CDB::CollectorPacked::getT, COMDAT

; 257  : 		TRI*				getT()		{ return &*faces.begin();	}

	mov	rax, QWORD PTR [rcx+24]
	ret	0
?getT@CollectorPacked@CDB@@QEAAPEAVTRI@2@XZ ENDP	; CDB::CollectorPacked::getT
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ?getTS@CollectorPacked@CDB@@QEAA_KXZ
_TEXT	SEGMENT
this$ = 8
?getTS@CollectorPacked@CDB@@QEAA_KXZ PROC		; CDB::CollectorPacked::getTS, COMDAT

; 258  : 		size_t				getTS()		{ return faces.size();		}

	mov	rax, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rcx+32]
	sub	rcx, QWORD PTR [rax+24]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 258  : 		size_t				getTS()		{ return faces.size();		}

	mov	eax, eax
	ret	0
?getTS@CollectorPacked@CDB@@QEAA_KXZ ENDP		; CDB::CollectorPacked::getTS
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1CollectorPacked@CDB@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1CollectorPacked@CDB@@QEAA@XZ PROC			; CDB::CollectorPacked::~CollectorPacked, COMDAT
$LN65:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	lea	rbx, QWORD PTR [rcx+255072]
	mov	edi, 10624				; 00002980H
	xor	ebp, ebp
	npad	11
$LL4@CollectorP:

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rbx-24]
	lea	rbx, QWORD PTR [rbx-24]
	test	rdx, rdx
	je	SHORT $LN11@CollectorP
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	mov	QWORD PTR [rbx], rbp

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rbp

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rbp
$LN11@CollectorP:
	dec	edi
	jns	SHORT $LL4@CollectorP

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rsi+24]
	test	rdx, rdx
	je	SHORT $LN29@CollectorP
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	mov	QWORD PTR [rsi+24], rbp

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rsi+32], rbp

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rsi+40], rbp
$LN29@CollectorP:

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rsi]
	test	rdx, rdx
	je	SHORT $LN47@CollectorP
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	mov	QWORD PTR [rsi], rbp

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rsi+8], rbp

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rsi+16], rbp
$LN47@CollectorP:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1CollectorPacked@CDB@@QEAA@XZ ENDP			; CDB::CollectorPacked::~CollectorPacked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
hModule$ = 8
ul_reason_for_call$ = 16
lpReserved$ = 24
DllMain	PROC

; 17   :     switch (ul_reason_for_call)
; 18   : 	{
; 19   : 	case DLL_PROCESS_ATTACH:
; 20   : 	case DLL_THREAD_ATTACH:
; 21   : 	case DLL_THREAD_DETACH:
; 22   : 	case DLL_PROCESS_DETACH:
; 23   : 		break;
; 24   :     }
; 25   :     return TRUE;

	mov	eax, 1

; 26   : }

	ret	0
DllMain	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
this$ = 48
??0MODEL@CDB@@QEAA@XZ PROC				; CDB::MODEL::MODEL

; 33   : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	QWORD PTR __imp_??0xrCriticalSection@@QEAA@XZ

; 34   : 	tree		= 0;

	xor	eax, eax
	mov	QWORD PTR [rbx+8], rax

; 35   : 	tris		= 0;

	mov	QWORD PTR [rbx+24], rax

; 36   : 	tris_count	= 0;

	mov	DWORD PTR [rbx+32], eax

; 37   : 	verts		= 0;

	mov	QWORD PTR [rbx+40], rax

; 38   : 	verts_count	= 0;

	mov	DWORD PTR [rbx+48], eax

; 39   : 	status		= S_INIT;

	mov	DWORD PTR [rbx+16], 1

; 40   : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0MODEL@CDB@@QEAA@XZ ENDP				; CDB::MODEL::MODEL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
this$ = 48
??1MODEL@CDB@@QEAA@XZ PROC				; CDB::MODEL::~MODEL

; 42   : {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 101  : 			if (S_READY!=status)

	cmp	DWORD PTR [rcx+16], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 42   : {

	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 101  : 			if (S_READY!=status)

	je	SHORT $LN3@MODEL

; 102  : 			{
; 103  : 				Log						("! WARNING: syncronized CDB::query");
; 104  : 				xrCriticalSection*	C	= (xrCriticalSection*) &cs;
; 105  : 				C->Enter				();

	call	QWORD PTR __imp_?Enter@xrCriticalSection@@QEAAXXZ

; 106  : 				C->Leave				();

	mov	rcx, rbx
	call	QWORD PTR __imp_?Leave@xrCriticalSection@@QEAAXXZ
$LN3@MODEL:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 44   : 	status		= S_INIT;

	mov	DWORD PTR [rbx+16], 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	rcx, QWORD PTR [rbx+8]
	xor	edi, edi
	test	rcx, rcx
	je	SHORT $LN6@MODEL
	call	??1OPCODE_Model@Opcode@@QEAA@XZ		; Opcode::OPCODE_Model::~OPCODE_Model

; 144  : 		Memory.mem_free	(ptr);

	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = NULL;

	mov	QWORD PTR [rbx+8], rdi
$LN6@MODEL:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rbx+24]
	test	rdx, rdx
	je	SHORT $LN19@MODEL
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+24], rdi
$LN19@MODEL:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 46   : 	xr_free		(tris);		tris_count = 0;

	mov	DWORD PTR [rbx+32], edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rbx+40]
	test	rdx, rdx
	je	SHORT $LN22@MODEL
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+40], rdi
$LN22@MODEL:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 48   : }

	mov	rcx, rbx
	mov	DWORD PTR [rbx+48], edi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	rex_jmp	QWORD PTR __imp_??1xrCriticalSection@@QEAA@XZ
??1MODEL@CDB@@QEAA@XZ ENDP				; CDB::MODEL::~MODEL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
P$9$ = 64
P$8$ = 80
P$7$ = 96
P$ = 112
params$ = 192
?build_thread@MODEL@CDB@@SAXPEAX@Z PROC			; CDB::MODEL::build_thread

; 62   : {

$LN4:
	push	rbx
	sub	rsp, 176				; 000000b0H
	mov	rbx, rcx

; 63   : 	_initialize_cpu_thread		();

	call	QWORD PTR __imp_?_initialize_cpu_thread@@YAXXZ

; 64   : 	FPU::m64r					();

	call	QWORD PTR __imp_?m64r@FPU@@YAXXZ

; 65   : 	BTHREAD_params	P			= *( (BTHREAD_params*)params );

	movups	xmm0, XMMWORD PTR [rbx]
	movups	xmm1, XMMWORD PTR [rbx+16]
	movups	xmm2, xmm0
	movups	XMMWORD PTR P$7$[rsp], xmm0
	movups	xmm0, XMMWORD PTR [rbx+32]
	movups	XMMWORD PTR P$8$[rsp], xmm1
	movsdx	xmm1, QWORD PTR [rbx+48]

; 66   : 	P.M->cs.Enter				();

	movq	rbx, xmm2
	mov	rcx, rbx
	movups	XMMWORD PTR P$9$[rsp], xmm0
	movsdx	QWORD PTR P$[rsp+48], xmm1
	call	QWORD PTR __imp_?Enter@xrCriticalSection@@QEAAXXZ

; 67   : 	P.M->build_internal			(P.V,P.Vcnt,P.T,P.Tcnt,P.BC,P.BCP);

	mov	rax, QWORD PTR P$[rsp+48]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+48], rax
	movups	xmm1, XMMWORD PTR P$9$[rsp]
	movups	xmm2, XMMWORD PTR P$8$[rsp]
	movdqa	xmm0, xmm1
	movd	r8d, xmm2
	psrldq	xmm0, 8
	movq	QWORD PTR [rsp+40], xmm0
	movdqa	xmm0, xmm2
	movd	DWORD PTR [rsp+32], xmm1
	psrldq	xmm0, 8
	movq	r9, xmm0
	movups	xmm0, XMMWORD PTR P$7$[rsp]
	psrldq	xmm0, 8
	movq	rdx, xmm0
	call	?build_internal@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z ; CDB::MODEL::build_internal

; 68   : 	P.M->status					= S_READY;
; 69   : 	P.M->cs.Leave				();

	mov	rcx, rbx
	mov	DWORD PTR [rbx+16], 0

; 70   : 	//Msg						("* xrCDB: cform build completed, memory usage: %d K",P.M->memory()/1024);
; 71   : }

	add	rsp, 176				; 000000b0H
	pop	rbx

; 68   : 	P.M->status					= S_READY;
; 69   : 	P.M->cs.Leave				();

	rex_jmp	QWORD PTR __imp_?Leave@xrCriticalSection@@QEAAXXZ
?build_thread@MODEL@CDB@@SAXPEAX@Z ENDP			; CDB::MODEL::build_thread
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
P$1 = 64
this$ = 160
V$ = 168
Vcnt$ = 176
T$ = 184
Tcnt$ = 192
bc$ = 200
bcp$ = 208
?build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z PROC ; CDB::MODEL::build

; 74   : {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 128				; 00000080H

; 75   : 	R_ASSERT					(S_INIT == status);

	cmp	BYTE PTR ?ignore_always@?3??build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@3@HP6AX0H1HPEAX@Z2@Z@4_NA, 0
	mov	rbp, r9
	mov	esi, r8d
	mov	r14, rdx
	mov	rbx, rcx
	lea	r15, OFFSET FLAT:??_C@_0BC@GJKGJBBN@CDB?3?3MODEL?3?3build?$AA@
	jne	SHORT $LN12@build
	cmp	DWORD PTR [rcx+16], 1
	je	SHORT $LN12@build
	mov	rcx, QWORD PTR __imp_?Debug@@3VxrDebug@@A
	lea	rax, OFFSET FLAT:?ignore_always@?3??build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@3@HP6AX0H1HPEAX@Z2@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_09FONEFOJL@xrCDB?4cpp?$AA@
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BB@DMGNJNBH@S_INIT?5?$DN?$DN?5status?$AA@
	mov	r9d, 75					; 0000004bH
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_?fail@xrDebug@@QEAAXPEBD0H0AEA_N@Z
$LN12@build:

; 76   :     R_ASSERT					((Vcnt>=4)&&(Tcnt>=2));

	cmp	BYTE PTR ?ignore_always@?7??build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@3@HP6AX0H1HPEAX@Z2@Z@4_NA, 0
	mov	edi, DWORD PTR Tcnt$[rsp]
	jne	SHORT $LN8@build
	cmp	esi, 4
	jl	SHORT $LN5@build
	cmp	edi, 2
	jge	SHORT $LN8@build
$LN5@build:
	mov	rcx, QWORD PTR __imp_?Debug@@3VxrDebug@@A
	lea	rax, OFFSET FLAT:?ignore_always@?7??build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@3@HP6AX0H1HPEAX@Z2@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_09FONEFOJL@xrCDB?4cpp?$AA@
	mov	QWORD PTR [rsp+40], rax
	lea	rdx, OFFSET FLAT:??_C@_0BF@JLEIHKIA@?$CIVcnt?$DO?$DN4?$CJ?$CG?$CG?$CITcnt?$DO?$DN2?$CJ?$AA@
	mov	r9d, 76					; 0000004cH
	mov	QWORD PTR [rsp+32], r15
	call	QWORD PTR __imp_?fail@xrDebug@@QEAAXPEBD0H0AEA_N@Z
$LN8@build:

; 77   : 
; 78   : 	_initialize_cpu_thread		();

	call	QWORD PTR __imp_?_initialize_cpu_thread@@YAXXZ

; 82   : 	if(!strstr(Core.Params, "-mt_cdb"))

	mov	rcx, QWORD PTR __imp_?Core@@3VxrCore@@A
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_07JLJFPMN@?9mt_cdb?$AA@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 82   : 	if(!strstr(Core.Params, "-mt_cdb"))

	add	rcx, 1232				; 000004d0H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	call	QWORD PTR __imp_strstr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 82   : 	if(!strstr(Core.Params, "-mt_cdb"))

	test	rax, rax
	jne	SHORT $LN4@build

; 83   : 	{
; 84   : 		build_internal				(V,Vcnt,T,Tcnt,bc,bcp);

	mov	rax, QWORD PTR bcp$[rsp]
	mov	r9, rbp
	mov	r8d, esi
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR bc$[rsp]
	mov	rdx, r14
	mov	QWORD PTR [rsp+40], rax
	mov	rcx, rbx
	mov	DWORD PTR [rsp+32], edi
	call	?build_internal@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z ; CDB::MODEL::build_internal

; 85   : 	}else

	jmp	SHORT $LN1@build
$LN4@build:

; 86   : 	{
; 87   : 		BTHREAD_params				P = { this, V, Vcnt, T, Tcnt, bc, bcp };

	mov	rax, QWORD PTR bc$[rsp]

; 88   : 		thread_spawn				(build_thread,"CDB-construction",0,&P);

	lea	r9, QWORD PTR P$1[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0BB@KNMADMJC@CDB?9construction?$AA@
	mov	QWORD PTR P$1[rsp+40], rax
	mov	rax, QWORD PTR bcp$[rsp]
	lea	rcx, OFFSET FLAT:?build_thread@MODEL@CDB@@SAXPEAX@Z ; CDB::MODEL::build_thread
	xor	r8d, r8d
	mov	QWORD PTR P$1[rsp], rbx
	mov	QWORD PTR P$1[rsp+8], r14
	mov	QWORD PTR P$1[rsp+48], rax
	mov	DWORD PTR P$1[rsp+16], esi
	mov	QWORD PTR P$1[rsp+24], rbp
	mov	DWORD PTR P$1[rsp+32], edi
	call	QWORD PTR __imp_?thread_spawn@@YAXP6AXPEAX@ZPEBDI0@Z

; 89   : 		while						(S_INIT	== status)	Sleep	(5);

	cmp	DWORD PTR [rbx+16], 1
	jne	SHORT $LN1@build
$LL2@build:
	mov	ecx, 5
	call	QWORD PTR __imp_Sleep
	cmp	DWORD PTR [rbx+16], 1
	je	SHORT $LL2@build
$LN1@build:

; 90   : 	}
; 91   : #endif
; 92   : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?build@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z ENDP ; CDB::MODEL::build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
OPCC$ = 48
this$ = 96
V$ = 104
Vcnt$ = 112
T$ = 120
Tcnt$ = 128
bc$ = 136
bcp$ = 144
?build_internal@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z PROC ; CDB::MODEL::build_internal

; 95   : {

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	ebp, r8d
	mov	rdi, rdx
	mov	rbx, rcx

; 96   : 	// verts
; 97   : 	verts_count	= Vcnt;

	mov	DWORD PTR [rcx+48], ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	rdx, QWORD PTR [rbp*2]
	add	rdx, rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 95   : {

	mov	rsi, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	shl	rdx, 2
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 99   : 	CopyMemory	(verts,V,verts_count*sizeof(Fvector));

	movsxd	rcx, DWORD PTR [rbx+48]
	mov	rdx, rdi
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	mov	QWORD PTR [rbx+40], rax
	shl	r8, 2
	call	memcpy

; 100  : 	
; 101  : 	// tris
; 102  : 	tris_count	= Tcnt;

	mov	edi, DWORD PTR Tcnt$[rsp]
	mov	DWORD PTR [rbx+32], edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	rdx, QWORD PTR [rdi+rdi*2]
	shl	rdx, 3
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 104  : 	CopyMemory	(tris,T,tris_count*sizeof(TRI));

	movsxd	rcx, DWORD PTR [rbx+32]
	mov	rdx, rsi
	lea	r8, QWORD PTR [rcx+rcx*2]
	mov	rcx, rax
	mov	QWORD PTR [rbx+24], rax
	shl	r8, 3
	call	memcpy

; 105  : 
; 106  : 	// callback
; 107  : 	if (bc)		bc	(verts,Vcnt,tris,Tcnt,bcp);

	mov	r10, QWORD PTR bc$[rsp]
	test	r10, r10
	je	SHORT $LN6@build_inte
	mov	rax, QWORD PTR bcp$[rsp]
	mov	r8, QWORD PTR [rbx+24]
	mov	rcx, QWORD PTR [rbx+40]
	mov	r9d, edi
	mov	edx, ebp
	mov	QWORD PTR [rsp+32], rax
	call	r10
$LN6@build_inte:

; 113  : 	u32*		temp_tris	= xr_alloc<u32>	(tris_count*3);

	mov	eax, DWORD PTR [rbx+32]
	mov	DWORD PTR [rbx+16], 2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 113  : 	u32*		temp_tris	= xr_alloc<u32>	(tris_count*3);

	lea	edx, DWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	shl	rdx, 2
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	xor	edi, edi

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rsi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 114  : 	if (0==temp_tris)	{

	test	rax, rax
	jne	SHORT $LN5@build_inte
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rbx+40]
	test	rdx, rdx
	je	SHORT $LN15@build_inte
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+40], rdi
$LN15@build_inte:
	mov	rdx, QWORD PTR [rbx+24]
	test	rdx, rdx
	je	$LN63@build_inte
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+24], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 117  : 		return;

	jmp	$LN63@build_inte
$LN5@build_inte:

; 118  : 	}
; 119  : 	u32*		temp_ptr	= temp_tris;

	mov	rdx, rax

; 120  : 	for (int i=0; i<tris_count; i++)

	mov	r9d, edi
	cmp	DWORD PTR [rbx+32], edi
	jle	SHORT $LN2@build_inte
	mov	r8, rdi
$LL4@build_inte:

; 121  : 	{
; 122  : 		*temp_ptr++	= tris[i].verts[0];

	mov	rax, QWORD PTR [rbx+24]
	inc	r9d

; 123  : 		*temp_ptr++	= tris[i].verts[1];
; 124  : 		*temp_ptr++	= tris[i].verts[2];

	lea	rdx, QWORD PTR [rdx+12]
	mov	ecx, DWORD PTR [r8+rax]
	lea	r8, QWORD PTR [r8+24]
	mov	DWORD PTR [rdx-12], ecx
	mov	rax, QWORD PTR [rbx+24]
	mov	ecx, DWORD PTR [rax+r8-20]
	mov	DWORD PTR [rdx-8], ecx
	mov	rax, QWORD PTR [rbx+24]
	mov	ecx, DWORD PTR [rax+r8-16]
	mov	DWORD PTR [rdx-4], ecx
	cmp	r9d, DWORD PTR [rbx+32]
	jl	SHORT $LL4@build_inte
$LN2@build_inte:

; 130  : 	OPCC.NbVerts	= verts_count;

	mov	eax, DWORD PTR [rbx+48]
	mov	ebp, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 130  : 	OPCC.NbVerts	= verts_count;

	mov	DWORD PTR OPCC$[rsp+4], eax

; 131  : 	OPCC.Tris		= (unsigned*)temp_tris;
; 132  : 	OPCC.Verts		= (Point*)verts;

	mov	rax, QWORD PTR [rbx+40]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edx, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 135  : 	OPCC.Quantized	= false;

	mov	WORD PTR OPCC$[rsp+29], di
	mov	DWORD PTR OPCC$[rsp], ebp
	mov	QWORD PTR OPCC$[rsp+8], rsi
	mov	QWORD PTR OPCC$[rsp+16], rax
	mov	DWORD PTR OPCC$[rsp+24], 69		; 00000045H
	mov	BYTE PTR OPCC$[rsp+28], 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN25@build_inte
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 156  : {

	mov	QWORD PTR [rax], rdi
	mov	QWORD PTR [rax+8], rdi
	mov	WORD PTR [rax+16], di
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	jmp	SHORT $LN26@build_inte
$LN25@build_inte:
	mov	rax, rdi
$LN26@build_inte:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 138  : 	tree			= xr_new<OPCODE_Model> ();

	mov	QWORD PTR [rbx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 186  : 	if(!create.NbTris || !create.Tris || !create.Verts)	return false;

	test	ebp, ebp
	je	SHORT $LN70@build_inte
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 139  : 	if (!tree->Build(OPCC)) {

	lea	rdx, QWORD PTR OPCC$[rsp]
	mov	rcx, rax
	call	?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z ; Opcode::OPCODE_Model::Build
	test	al, al
	jne	SHORT $LN57@build_inte
$LN70@build_inte:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rbx+40]
	test	rdx, rdx
	je	SHORT $LN54@build_inte
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+40], rdi
$LN54@build_inte:
	mov	rdx, QWORD PTR [rbx+24]
	test	rdx, rdx
	je	SHORT $LN57@build_inte
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+24], rdi
$LN57@build_inte:
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	rdx, rsi
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN63@build_inte:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 149  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?build_internal@MODEL@CDB@@QEAAXPEAU?$_vector3@M@@HPEAVTRI@2@HP6AX0H1HPEAX@Z2@Z ENDP ; CDB::MODEL::build_internal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
this$ = 48
?memory@MODEL@CDB@@QEAAIXZ PROC				; CDB::MODEL::memory

; 152  : {

$LN7:
	sub	rsp, 40					; 00000028H

; 153  : 	if (S_BUILD==status)	{ Msg	("! xrCDB: model still isn't ready"); return 0; }

	cmp	DWORD PTR [rcx+16], 2
	jne	SHORT $LN1@memory
	lea	rcx, OFFSET FLAT:??_C@_0CB@NBDEDBNA@?$CB?5xrCDB?3?5model?5still?5isn?8t?5ready@
	call	QWORD PTR __imp_?Msg@@YAXPEBDZZ
	xor	eax, eax

; 157  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@memory:

; 154  : 	u32 V					= verts_count*sizeof(Fvector);

	mov	eax, DWORD PTR [rcx+48]
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+32], rdi
	lea	edi, DWORD PTR [rax+rax*2]

; 155  : 	u32 T					= tris_count *sizeof(TRI);

	mov	eax, DWORD PTR [rcx+32]
	lea	ebx, DWORD PTR [rax+rax*2]

; 156  : 	return tree->GetUsedBytes()+V+T+sizeof(*this)+sizeof(*tree);

	mov	rax, QWORD PTR [rcx+8]
	shl	edi, 2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.h

; 115  : 						udword				GetUsedBytes()	const	{ return mTree->GetUsedBytes();	}

	mov	rcx, QWORD PTR [rax+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 155  : 	u32 T					= tris_count *sizeof(TRI);

	shl	ebx, 3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.h

; 115  : 						udword				GetUsedBytes()	const	{ return mTree->GetUsedBytes();	}

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 156  : 	return tree->GetUsedBytes()+V+T+sizeof(*this)+sizeof(*tree);

	lea	ecx, DWORD PTR [rbx+rax]
	mov	rbx, QWORD PTR [rsp+48]
	add	ecx, edi
	mov	rdi, QWORD PTR [rsp+32]
	lea	rax, QWORD PTR [rcx+80]

; 157  : }

	add	rsp, 40					; 00000028H
	ret	0
?memory@MODEL@CDB@@QEAAIXZ ENDP				; CDB::MODEL::memory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
this$ = 8
??0COLLIDER@CDB@@QEAA@XZ PROC				; CDB::COLLIDER::COLLIDER
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+24], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+32], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 163  : 	ray_mode		= 0;

	mov	QWORD PTR [rcx], rax

; 164  : 	box_mode		= 0;
; 165  : 	frustum_mode	= 0;

	mov	DWORD PTR [rcx+8], eax

; 166  : }

	mov	rax, rcx
	ret	0
??0COLLIDER@CDB@@QEAA@XZ ENDP				; CDB::COLLIDER::COLLIDER
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
this$ = 48
??1COLLIDER@CDB@@QEAA@XZ PROC				; CDB::COLLIDER::~COLLIDER

; 169  : {

$LN30:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 169  : {

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rcx+24], rax

; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, rax
	test	rax, rax
	je	SHORT $LN15@COLLIDER
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx+16], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+24], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+32], rax
$LN15@COLLIDER:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 171  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1COLLIDER@CDB@@QEAA@XZ ENDP				; CDB::COLLIDER::~COLLIDER
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 112
?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ PROC		; CDB::COLLIDER::r_add

; 174  : {

$LN97:
	mov	r11, rsp
	mov	QWORD PTR [r11+16], rbx
	push	rsi
	sub	rsp, 96					; 00000060H

; 175  : 	rd.push_back		(RESULT());

	xor	eax, eax
	mov	rsi, rcx
	mov	QWORD PTR [r11-72], rax
	mov	QWORD PTR [r11-64], rax
	mov	QWORD PTR [r11-56], rax
	mov	QWORD PTR [r11-48], rax
	mov	QWORD PTR [r11-40], rax
	mov	QWORD PTR [r11-32], rax
	mov	QWORD PTR [r11-24], rax
	mov	QWORD PTR [r11-16], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rcx+24]
	lea	rcx, QWORD PTR [r11-72]
	cmp	rcx, rax
	jae	SHORT $LN6@r_add
	mov	rcx, QWORD PTR [rsi+16]
	lea	rdx, QWORD PTR [r11-72]
	cmp	rcx, rdx
	ja	SHORT $LN6@r_add
	mov	QWORD PTR [r11+8], rdi

; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);
; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rdi, QWORD PTR [r11-72]
	sub	rdi, rcx

; 869  : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rsi+32]
	jne	SHORT $LN5@r_add

; 870  : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+16]
	call	?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reserve
$LN5@r_add:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

	and	rdi, -64				; ffffffffffffffc0H
	add	rdi, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rax, rax
	je	SHORT $LN39@r_add
	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rdi+32]
	movups	XMMWORD PTR [rax+32], xmm0
	movups	xmm1, XMMWORD PTR [rdi+48]
	movups	XMMWORD PTR [rax+48], xmm1
$LN39@r_add:
	mov	rdi, QWORD PTR [rsp+112]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 876  : 		else

	jmp	SHORT $LN67@r_add
$LN6@r_add:

; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rsi+32]
	jne	SHORT $LN3@r_add

; 879  : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+16]
	call	?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reserve
$LN3@r_add:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+24]
	test	rax, rax
	je	SHORT $LN67@r_add
	movups	xmm0, XMMWORD PTR $T1[rsp]
	movups	xmm1, XMMWORD PTR $T1[rsp+16]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm0, XMMWORD PTR $T1[rsp+32]
	movups	XMMWORD PTR [rax+16], xmm1
	movups	xmm1, XMMWORD PTR $T1[rsp+48]
	movups	XMMWORD PTR [rax+32], xmm0
	movups	XMMWORD PTR [rax+48], xmm1
$LN67@r_add:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 883  : 			++this->_Mylast;

	add	QWORD PTR [rsi+24], 64			; 00000040H

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rsi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 177  : }

	mov	rbx, QWORD PTR [rsp+120]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	sub	rax, 64					; 00000040H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 177  : }

	add	rsp, 96					; 00000060H
	pop	rsi
	ret	0
?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ENDP		; CDB::COLLIDER::r_add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp
_TEXT	SEGMENT
this$ = 8
?r_free@COLLIDER@CDB@@QEAAXXZ PROC			; CDB::COLLIDER::r_free
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rcx+24], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.cpp

; 182  : }

	ret	0
?r_free@COLLIDER@CDB@@QEAAXXZ ENDP			; CDB::COLLIDER::r_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ PROC ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::xr_vector<_vector3<float>,xalloc<_vector3<float> > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	rax, rcx
	ret	0
??0?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAA@XZ ENDP ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::xr_vector<_vector3<float>,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?size@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEBAIXZ PROC ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::size, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEBAIXZ ENDP ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAXXZ PROC ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::clear, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 132  : 	void	clear				()									{ clear_and_free	();			}

	ret	0
?clear@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAXXZ ENDP ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >, COMDAT

; 721  : 		{	// construct by copying _Right

$LN87:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	rsi, rdx
	mov	rbx, rcx

; 482  : 		_Myfirst = pointer();

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rcx

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rbx+16], rcx

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r8, QWORD PTR [rdx+8]
	sub	r8, QWORD PTR [rdx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	r8
	mov	rdi, rdx
	sar	rdi, 1
	mov	rax, rdi
	shr	rax, 63					; 0000003fH
	add	rdi, rax

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();

	mov	QWORD PTR [rbx], rcx

; 1548 : 		this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rcx

; 1549 : 		this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rcx

; 1550 : 
; 1551 : 		if (_Capacity == 0)

	je	SHORT $LN7@vector

; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)

	mov	rax, 1537228672809129301		; 1555555555555555H
	cmp	rdi, rax
	jbe	SHORT $LN24@vector

; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN24@vector:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, edi
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 2
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rbx+8], rax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	rcx, QWORD PTR [rdi+rdi*2]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 725  : 				this->_Myfirst);

	mov	QWORD PTR [rbx+8], rax
$LN7@vector:

; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN86@vector:
??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >'::`1'::catch$0

; 726  : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z$0:

; 727  : 			_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Tidy

; 728  : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::~vector<_vector3<float>,xalloc<_vector3<float> > >, COMDAT

; 944  : 		{	// destroy the object

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]

; 944  : 		{	// destroy the object

	mov	rbx, rcx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN3@vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN3@vector:

; 945  : 		_Tidy();
; 946  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::~vector<_vector3<float>,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::operator=, COMDAT

; 949  : 		{	// assign _Right

$LN140:
	mov	QWORD PTR [rsp+8], rcx
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	rdi, rdx
	mov	rbx, rcx

; 950  : 		if (this != &_Right)

	cmp	rcx, rdx
	je	$LN16@operator

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	r10, QWORD PTR [rdx+8]
	mov	r8, QWORD PTR [rdx]
	cmp	r8, r10

; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())

	jne	SHORT $LN9@operator

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

	jmp	$LN16@operator
$LN9@operator:

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, r10
	sub	rcx, r8
	mov	r14, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rax, r14
	imul	rcx
	mov	rsi, rdx
	sar	rsi, 1
	mov	rax, rsi
	shr	rax, 63					; 0000003fH
	add	rsi, rax
	mov	r9, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	sub	rcx, r9
	mov	rax, r14
	imul	rcx
	mov	r11, rdx
	sar	r11, 1
	mov	rax, r11
	shr	rax, 63					; 0000003fH
	add	r11, rax

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

	cmp	rsi, r11
	ja	SHORT $LN7@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	r8, r10
	je	SHORT $LN66@operator
	npad	6
$LL68@operator:

; 2045 : 		*_Dest = *_First;

	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [r9], xmm0
	mov	ecx, DWORD PTR [r8+8]
	mov	DWORD PTR [r9+8], ecx

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	lea	r9, QWORD PTR [r9+12]
	add	r8, 12
	cmp	r8, r10
	jne	SHORT $LL68@operator
$LN66@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
	mov	rax, r14
	imul	rcx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

	lea	rcx, QWORD PTR [rdx+rdx*2]
	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR [rbx+8], rcx

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

	jmp	$LN16@operator
$LN7@operator:

; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rcx, QWORD PTR [rbx+16]
	sub	rcx, r9
	mov	rax, r14
	imul	rcx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

	cmp	rsi, rdx
	ja	SHORT $LN5@operator

; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();

	lea	rax, QWORD PTR [r11+r11*2]
	lea	rcx, QWORD PTR [r8+rax*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	r8, rcx
	je	SHORT $LN83@operator
	npad	7
$LL85@operator:

; 2045 : 		*_Dest = *_First;

	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [r9+8], eax

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	lea	r9, QWORD PTR [r9+12]
	add	r8, 12
	cmp	r8, rcx
	jne	SHORT $LL85@operator
$LN83@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rdi+8]
	call	??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

	mov	QWORD PTR [rbx+8], rax

; 976  : 				}
; 977  : 			else

	jmp	SHORT $LN16@operator
$LN5@operator:

; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())

	test	r9, r9
	je	SHORT $LN110@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, r9
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN110@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
	mov	rax, r14
	imul	rcx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

	mov	rcx, rbx
	call	?_Buy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAA_N_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Buy
	test	al, al
	je	SHORT $LN16@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 988  : 						this->_Myfirst);

	mov	QWORD PTR [rbx+8], rax
$LN16@operator:

; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

	mov	rax, rbx

; 996  : 		}

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN139@operator:
??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA PROC ; `std::vector<_vector3<float>,xalloc<_vector3<float> > >::operator='::`1'::catch$0

; 989  : 					_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$??4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z$0:

; 990  : 					_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Tidy

; 991  : 					_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???4?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA ENDP ; `std::vector<_vector3<float>,xalloc<_vector3<float> > >::operator='::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ PROC ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	rax, rcx
	ret	0
??0?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAA@XZ ENDP ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?size@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEBAIXZ PROC ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::size, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEBAIXZ ENDP ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear_and_free@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAXXZ PROC ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear_and_free, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	ret	0
?clear_and_free@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAXXZ ENDP ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear_not_free@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear_not_free@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAXXZ PROC ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear_not_free, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 128  : 	void	clear_not_free		()									{ erase(begin(),end());			}

	ret	0
?clear_not_free@?$xr_vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@@QEAAXXZ ENDP ; xr_vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear_not_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >, COMDAT

; 721  : 		{	// construct by copying _Right

$LN87:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	rsi, rdx
	mov	rbx, rcx

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdi, QWORD PTR [rdx+8]
	sub	rdi, QWORD PTR [rdx]
	sar	rdi, 6

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();

	mov	QWORD PTR [rcx], rax

; 1548 : 		this->_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1549 : 		this->_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 1550 : 
; 1551 : 		if (_Capacity == 0)

	test	rdi, rdi
	je	SHORT $LN7@vector

; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rdi, rax
	jbe	SHORT $LN24@vector

; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN24@vector:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, edi
	shl	rdx, 6
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rbx+8], rax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

	shl	rdi, 6
	add	rdi, rax
	mov	QWORD PTR [rbx+16], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 725  : 				this->_Myfirst);

	mov	QWORD PTR [rbx+8], rax
$LN7@vector:

; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN86@vector:
??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >'::`1'::catch$0

; 726  : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z$0:

; 727  : 			_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Tidy

; 728  : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::push_back, COMDAT

; 865  : 		{	// insert by moving into element at end

$LN75:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]

; 865  : 		{	// insert by moving into element at end

	mov	rdi, rdx
	mov	rbx, rcx

; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN4@push_back
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN4@push_back

; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)

	sub	rdi, rcx
	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN3@push_back

; 870  : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reserve
$LN3@push_back:

; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

	and	rdi, -64				; ffffffffffffffc0H
	add	rdi, QWORD PTR [rbx]

; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else

	jmp	SHORT $LN1@push_back
$LN4@push_back:

; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN1@push_back

; 879  : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	je	SHORT $LN65@push_back
	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rax], xmm0
	movups	xmm1, XMMWORD PTR [rdi+16]
	movups	XMMWORD PTR [rax+16], xmm1
	movups	xmm0, XMMWORD PTR [rdi+32]
	movups	XMMWORD PTR [rax+32], xmm0
	movups	xmm1, XMMWORD PTR [rdi+48]
	movups	XMMWORD PTR [rax+48], xmm1
$LN65@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 883  : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 64			; 00000040H

; 884  : 			}
; 885  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAX$$QEAURESULT@CDB@@@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::~vector<CDB::RESULT,xalloc<CDB::RESULT> >, COMDAT

; 944  : 		{	// destroy the object

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]

; 944  : 		{	// destroy the object

	mov	rbx, rcx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN3@vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN3@vector:

; 945  : 		_Tidy();
; 946  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::~vector<CDB::RESULT,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator=, COMDAT

; 949  : 		{	// assign _Right

$LN128:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	rdi, rdx
	mov	rbx, rcx

; 950  : 		if (this != &_Right)

	cmp	rcx, rdx
	je	$LN16@operator

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rax, QWORD PTR [rdx+8]
	mov	rcx, QWORD PTR [rdx]
	cmp	rcx, rax

; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())

	jne	SHORT $LN9@operator

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rbx]

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

	jmp	$LN127@operator
$LN9@operator:

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r8, rax
	sub	r8, rcx
	sar	r8, 6
	mov	rdx, QWORD PTR [rbx]
	mov	rsi, QWORD PTR [rbx+8]
	sub	rsi, rdx
	sar	rsi, 6

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

	cmp	r8, rsi
	ja	SHORT $LN7@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rax
	je	SHORT $LN66@operator
$LL68@operator:

; 2045 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [rcx+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [rcx+48]
	movups	XMMWORD PTR [rdx+48], xmm1

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	lea	rdx, QWORD PTR [rdx+64]
	add	rcx, 64					; 00000040H
	cmp	rcx, rax
	jne	SHORT $LL68@operator
$LN66@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rdi+8]
	sub	rax, QWORD PTR [rdi]

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

	and	rax, -64				; ffffffffffffffc0H
	add	rax, QWORD PTR [rbx]

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

	jmp	SHORT $LN127@operator
$LN7@operator:

; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rbx+16]
	sub	rax, rdx
	sar	rax, 6

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

	cmp	r8, rax
	ja	SHORT $LN5@operator

; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();

	shl	rsi, 6
	add	rsi, rcx

; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);

	mov	r8, rdx
	mov	rdx, rsi
	call	??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z ; std::_Copy_impl<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, rsi
	call	??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 977  : 			else

	jmp	SHORT $LN127@operator
$LN5@operator:

; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN101@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN101@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rdi+8]
	sub	rdx, QWORD PTR [rdi]
	sar	rdx, 6

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

	mov	rcx, rbx
	call	?_Buy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAA_N_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Buy
	test	al, al
	je	SHORT $LN16@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 988  : 						this->_Myfirst);

	mov	QWORD PTR [rbx+8], rax
	jmp	SHORT $LN16@operator
$LN127@operator:

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

	mov	QWORD PTR [rbx+8], rax
$LN16@operator:

; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

	mov	rax, rbx

; 996  : 		}

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN126@operator:
??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA PROC ; `std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator='::`1'::catch$0

; 989  : 					_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$??4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z$0:

; 990  : 					_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Tidy

; 991  : 					_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???4?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA ENDP ; `std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::operator='::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAURESULT@CDB@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAURESULT@CDB@@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::back, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, 64					; 00000040H

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

	ret	0
?back@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAAEAURESULT@CDB@@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAAEAURESULT@CDB@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAAEAURESULT@CDB@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAAEAURESULT@CDB@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ PROC ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::xr_vector<CDB::TRI,xalloc<CDB::TRI> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	rax, rcx
	ret	0
??0?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAA@XZ ENDP ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::xr_vector<CDB::TRI,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?size@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEBAIXZ PROC ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::size, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEBAIXZ ENDP ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAXXZ PROC ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::clear, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 132  : 	void	clear				()									{ clear_and_free	();			}

	ret	0
?clear@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAXXZ ENDP ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >, COMDAT

; 721  : 		{	// construct by copying _Right

$LN87:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	rsi, rdx
	mov	rbx, rcx

; 482  : 		_Myfirst = pointer();

	xor	ecx, ecx
	mov	QWORD PTR [rbx], rcx

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rcx

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rbx+16], rcx

; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r8, QWORD PTR [rdx+8]
	sub	r8, QWORD PTR [rdx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	r8
	mov	rdi, rdx
	sar	rdi, 2
	mov	rax, rdi
	shr	rax, 63					; 0000003fH
	add	rdi, rax

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();

	mov	QWORD PTR [rbx], rcx

; 1548 : 		this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rcx

; 1549 : 		this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rcx

; 1550 : 
; 1551 : 		if (_Capacity == 0)

	je	SHORT $LN7@vector

; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	rdi, rax
	jbe	SHORT $LN24@vector

; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN24@vector:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, edi
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1558 : 			this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rbx+8], rax

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	rcx, QWORD PTR [rdi+rdi*2]
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rsi+8]
	mov	rcx, QWORD PTR [rsi]
	call	??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 725  : 				this->_Myfirst);

	mov	QWORD PTR [rbx+8], rax
$LN7@vector:

; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN86@vector:
??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA PROC ; `std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >'::`1'::catch$0

; 726  : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z$0:

; 727  : 			_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Tidy

; 728  : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV01@@Z@4HA ENDP ; `std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::~vector<CDB::TRI,xalloc<CDB::TRI> >, COMDAT

; 944  : 		{	// destroy the object

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]

; 944  : 		{	// destroy the object

	mov	rbx, rcx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN3@vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN3@vector:

; 945  : 		_Tidy();
; 946  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::~vector<CDB::TRI,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::operator=, COMDAT

; 949  : 		{	// assign _Right

$LN140:
	mov	QWORD PTR [rsp+8], rcx
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+88], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	rdi, rdx
	mov	rbx, rcx

; 950  : 		if (this != &_Right)

	cmp	rcx, rdx
	je	$LN16@operator

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	r10, QWORD PTR [rdx+8]
	mov	r8, QWORD PTR [rdx]
	cmp	r8, r10

; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())

	jne	SHORT $LN9@operator

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

	jmp	$LN16@operator
$LN9@operator:

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, r10
	sub	rcx, r8
	mov	r14, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rax, r14
	imul	rcx
	mov	rsi, rdx
	sar	rsi, 2
	mov	rax, rsi
	shr	rax, 63					; 0000003fH
	add	rsi, rax
	mov	r9, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	sub	rcx, r9
	mov	rax, r14
	imul	rcx
	mov	r11, rdx
	sar	r11, 2
	mov	rax, r11
	shr	rax, 63					; 0000003fH
	add	r11, rax

; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())

	cmp	rsi, r11
	ja	SHORT $LN7@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	r8, r10
	je	SHORT $LN66@operator
	npad	4
$LL68@operator:

; 2045 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r9], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [r9+16], xmm1

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	lea	r9, QWORD PTR [r9+24]
	add	r8, 24
	cmp	r8, r10
	jne	SHORT $LL68@operator
$LN66@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
	mov	rax, r14
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();

	lea	rcx, QWORD PTR [rdx+rdx*2]
	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR [rbx+8], rcx

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

	jmp	$LN16@operator
$LN7@operator:

; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rcx, QWORD PTR [rbx+16]
	sub	rcx, r9
	mov	rax, r14
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())

	cmp	rsi, rdx
	ja	SHORT $LN5@operator

; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();

	lea	rax, QWORD PTR [r11+r11*2]
	lea	rcx, QWORD PTR [r8+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	r8, rcx
	je	SHORT $LN83@operator
	npad	3
$LL85@operator:

; 2045 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [r9], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [r9+16], xmm1

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	lea	r9, QWORD PTR [r9+24]
	add	r8, 24
	cmp	r8, rcx
	jne	SHORT $LL85@operator
$LN83@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx+8]
	mov	rdx, QWORD PTR [rdi+8]
	call	??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);

	mov	QWORD PTR [rbx+8], rax

; 976  : 				}
; 977  : 			else

	jmp	SHORT $LN16@operator
$LN5@operator:

; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())

	test	r9, r9
	je	SHORT $LN110@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, r9
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN110@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rdi+8]
	sub	rcx, QWORD PTR [rdi]
	mov	rax, r14
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))

	mov	rcx, rbx
	call	?_Buy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAA_N_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Buy
	test	al, al
	je	SHORT $LN16@operator
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, QWORD PTR [rbx]
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 988  : 						this->_Myfirst);

	mov	QWORD PTR [rbx+8], rax
$LN16@operator:

; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);

	mov	rax, rbx

; 996  : 		}

	mov	rbx, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN139@operator:
??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Right$ = 88
?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA PROC ; `std::vector<CDB::TRI,xalloc<CDB::TRI> >::operator='::`1'::catch$0

; 989  : 					_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$??4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z$0:

; 990  : 					_Tidy();

	mov	rcx, QWORD PTR this$[rbp]
	call	?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Tidy

; 991  : 					_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???4?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAV01@AEBV01@@Z@4HA ENDP ; `std::vector<CDB::TRI,xalloc<CDB::TRI> >::operator='::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAAEAU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAAEAU?$_vector3@M@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAAEAU?$_vector3@M@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAAEAVTRI@CDB@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAAEAVTRI@CDB@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAAEAVTRI@CDB@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear_and_free@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAXXZ PROC ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::clear_and_free, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	ret	0
?clear_and_free@?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAXXZ ENDP ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 681  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::vector<_vector3<float>,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::capacity, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 1011 : 		}

	ret	0
?capacity@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1030 : 		return (const_iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1031 : 		}

	ret	0
?begin@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1040 : 		return (const_iterator(this->_Mylast, this));

	mov	rax, rdx

; 1041 : 		}

	ret	0
?end@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::size, COMDAT

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 1149 : 		}

	ret	0
?size@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_NXZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::empty, COMDAT

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 1159 : 		}

	ret	0
?empty@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_NXZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXXZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::clear, COMDAT

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1511 : 		}

	ret	0
?clear@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXXZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$ = 56
?_Buy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAA_N_K@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Buy, COMDAT

; 1546 : 		{	// allocate array with _Capacity elements

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1547 : 		this->_Myfirst = pointer();

	xor	eax, eax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1548 : 		this->_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1549 : 		this->_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 1550 : 
; 1551 : 		if (_Capacity == 0)

	test	rdx, rdx
	je	SHORT $LN5@Buy

; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)

	mov	rax, 1537228672809129301		; 1555555555555555H
	cmp	rdx, rax
	jbe	SHORT $LN2@Buy

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2@Buy:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 2
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	rcx, QWORD PTR [rdi+rdi*2]
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR [rbx+16], rax

; 1560 : 			}
; 1561 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1562 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy:
?_Buy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAA_N_K@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXPEAU?$_vector3@M@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXPEAU?$_vector3@M@@0@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Destroy, COMDAT

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

	ret	0
?_Destroy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXPEAU?$_vector3@M@@0@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Tidy, COMDAT

; 1622 : 		{	// free all storage

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN1@Tidy:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAXXZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEAA@AEBV?$xalloc@U?$_vector3@M@@@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEAA@AEBV?$xalloc@U?$_vector3@M@@@@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEAA@AEBV?$xalloc@U?$_vector3@M@@@@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Change_alloc, COMDAT

; 594  : 		}

	ret	0
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Getal, COMDAT

; 642  : 		return (_Alty());

	mov	rax, rdx

; 643  : 		}

	ret	0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<_vector3<float>,xalloc<_vector3<float> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AU12@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AU12@XZ PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::select_on_container_copy_construction, COMDAT

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	rax, rdx

; 780  : 		}

	ret	0
?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA?AU12@XZ ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@_K@Z PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN5@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN5@deallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 859  : 		}

	ret	0
?deallocate@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 681  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::vector<CDB::RESULT,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::capacity, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 6

; 1011 : 		}

	ret	0
?capacity@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1030 : 		return (const_iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1031 : 		}

	ret	0
?begin@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1040 : 		return (const_iterator(this->_Mylast, this));

	mov	rax, rdx

; 1041 : 		}

	ret	0
?end@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::size, COMDAT

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 6

; 1149 : 		}

	ret	0
?size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_NXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::empty, COMDAT

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 1159 : 		}

	ret	0
?empty@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_NXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?erase@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_First_arg$ = 24
_Last_arg$ = 32
?erase@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@0@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::erase, COMDAT

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rax, QWORD PTR [rcx]

; 1463 : 		{	// erase [_First, _Last)

	mov	QWORD PTR [rsp+24], r8

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r8, rax

; 1464 : 		if (_First_arg == begin() && _Last_arg == end())

	jne	SHORT $LN4@erase

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r9, QWORD PTR [rcx+8]

; 1464 : 		if (_First_arg == begin() && _Last_arg == end())

	je	SHORT $LN67@erase
$LN4@erase:

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r8, r9

; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)

	je	SHORT $LN86@erase

; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));

	mov	r10, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, r8

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	r9, r10
	je	SHORT $LN67@erase
	npad	12
$LL69@erase:

; 2420 : 		*_Dest = _STD move(*_First);

	movups	xmm0, XMMWORD PTR [r9]
	add	r9, 64					; 00000040H
	add	rax, 64					; 00000040H
	movups	XMMWORD PTR [rax-64], xmm0
	movups	xmm1, XMMWORD PTR [r9-48]
	movups	XMMWORD PTR [rax-48], xmm1
	movups	xmm0, XMMWORD PTR [r9-32]
	movups	XMMWORD PTR [rax-32], xmm0
	movups	xmm1, XMMWORD PTR [r9-16]
	movups	XMMWORD PTR [rax-16], xmm1
	cmp	r9, r10
	jne	SHORT $LL69@erase

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	r8, QWORD PTR _First_arg$[rsp]
$LN67@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1488 : 				this->_Mylast = _Ptr;

	mov	QWORD PTR [rcx+8], rax
$LN86@erase:

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rdx], r8

; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));

	mov	rax, rdx

; 1492 : 		}

	ret	0
?erase@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@0@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear, COMDAT

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1511 : 		}

	ret	0
?clear@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$ = 56
?_Buy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAA_N_K@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Buy, COMDAT

; 1546 : 		{	// allocate array with _Capacity elements

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1547 : 		this->_Myfirst = pointer();

	xor	eax, eax
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax

; 1548 : 		this->_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1549 : 		this->_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 1550 : 
; 1551 : 		if (_Capacity == 0)

	test	rdx, rdx
	je	SHORT $LN5@Buy

; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN2@Buy

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2@Buy:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, edx
	shl	rdx, 6
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

	shl	rbx, 6
	add	rbx, rax
	mov	QWORD PTR [rdi], rax
	mov	QWORD PTR [rdi+8], rax
	mov	QWORD PTR [rdi+16], rbx

; 1560 : 			}
; 1561 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1562 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy:
?_Buy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAA_N_K@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXPEAURESULT@CDB@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXPEAURESULT@CDB@@0@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Destroy, COMDAT

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

	ret	0
?_Destroy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXPEAURESULT@CDB@@0@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBA_NPEBURESULT@CDB@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBA_NPEBURESULT@CDB@@@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Inside, COMDAT

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1584 : 		}

	ret	0
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	xor	al, al

; 1584 : 		}

	ret	0
?_Inside@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBA_NPEBURESULT@CDB@@@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reserve, COMDAT

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

$LN47:
	sub	rsp, 40					; 00000028H

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, QWORD PTR [rcx+8]
	mov	rax, rdx
	sub	rax, r8
	sar	rax, 6

; 1613 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r10, QWORD PTR [rcx]

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	r9, 288230376151711743			; 03ffffffffffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r8, r10

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	rax, r9

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sar	r8, 6

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	sub	rax, r8
	cmp	rax, 1
	jae	SHORT $LN1@Reserve

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@Reserve:

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rdx, r10

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	r8

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sar	rdx, 6

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rdx
	shr	rax, 1
	sub	r9, rax
	cmp	r9, rdx
	jae	SHORT $LN29@Reserve
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reallocate
$LN29@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rax

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN46@Reserve:
?_Reserve@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Tidy, COMDAT

; 1622 : 		{	// free all storage

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN1@Tidy:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAXXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXPEAURESULT@CDB@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXPEAURESULT@CDB@@0@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXPEAURESULT@CDB@@0@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEAA@AEBV?$xalloc@URESULT@CDB@@@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEAA@AEBV?$xalloc@URESULT@CDB@@@@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEAA@AEBV?$xalloc@URESULT@CDB@@@@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Change_alloc, COMDAT

; 594  : 		}

	ret	0
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Getal, COMDAT

; 642  : 		return (_Alty());

	mov	rax, rdx

; 643  : 		}

	ret	0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::RESULT,xalloc<CDB::RESULT> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AU12@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AU12@XZ PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::select_on_container_copy_construction, COMDAT

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	rax, rdx

; 780  : 		}

	ret	0
?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AU12@XZ ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@_K@Z PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN5@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN5@deallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 859  : 		}

	ret	0
?deallocate@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAA@PEAURESULT@CDB@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAA@PEAURESULT@CDB@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAA@PEAURESULT@CDB@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$dead$ = 24
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator-, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	sub	rax, 64					; 00000040H

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 379  : 		}

	ret	0
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAAEBURESULT@CDB@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAAEBURESULT@CDB@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAAEBURESULT@CDB@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear_and_free@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAXXZ PROC ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::clear_and_free, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	ret	0
?clear_and_free@?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAXXZ ENDP ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 681  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::vector<CDB::TRI,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::capacity, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 1011 : 		}

	ret	0
?capacity@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1030 : 		return (const_iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1031 : 		}

	ret	0
?begin@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1040 : 		return (const_iterator(this->_Mylast, this));

	mov	rax, rdx

; 1041 : 		}

	ret	0
?end@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::size, COMDAT

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+8]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx]
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 1149 : 		}

	ret	0
?size@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?empty@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_NXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::empty, COMDAT

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 1159 : 		}

	ret	0
?empty@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_NXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::clear, COMDAT

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1511 : 		}

	ret	0
?clear@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAA_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Capacity$ = 56
?_Buy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAA_N_K@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Buy, COMDAT

; 1546 : 		{	// allocate array with _Capacity elements

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1547 : 		this->_Myfirst = pointer();

	xor	eax, eax
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 1548 : 		this->_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 1549 : 		this->_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 1550 : 
; 1551 : 		if (_Capacity == 0)

	test	rdx, rdx
	je	SHORT $LN5@Buy

; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	rdx, rax
	jbe	SHORT $LN2@Buy

; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN2@Buy:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;

	lea	rcx, QWORD PTR [rdi+rdi*2]
	mov	QWORD PTR [rbx], rax
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rax+rcx*8]
	mov	QWORD PTR [rbx+16], rax

; 1560 : 			}
; 1561 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1562 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN31@Buy:
?_Buy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAA_N_K@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Buy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXPEAVTRI@CDB@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXPEAVTRI@CDB@@0@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Destroy, COMDAT

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

	ret	0
?_Destroy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXPEAVTRI@CDB@@0@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Tidy, COMDAT

; 1622 : 		{	// free all storage

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN1@Tidy:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAXXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEAA@AEBV?$xalloc@VTRI@CDB@@@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEAA@AEBV?$xalloc@VTRI@CDB@@@@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEAA@AEBV?$xalloc@VTRI@CDB@@@@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Change_alloc, COMDAT

; 594  : 		}

	ret	0
?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Getal, COMDAT

; 642  : 		return (_Alty());

	mov	rax, rdx

; 643  : 		}

	ret	0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CDB::TRI,xalloc<CDB::TRI> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AU12@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AU12@XZ PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::select_on_container_copy_construction, COMDAT

; 779  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	rax, rdx

; 780  : 		}

	ret	0
?select_on_container_copy_construction@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEBA?AU12@XZ ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@_K@Z PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN5@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN5@deallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 859  : 		}

	ret	0
?deallocate@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@PEAU?$_vector3@M@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@PEAU?$_vector3@M@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@PEAU?$_vector3@M@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAAEBU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAAEBU?$_vector3@M@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAAEBU?$_vector3@M@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAA@PEAVTRI@CDB@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAA@PEAVTRI@CDB@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAA@PEAVTRI@CDB@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAAEBVTRI@CDB@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAAEBVTRI@CDB@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAAEBVTRI@CDB@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::max_size, COMDAT

; 1153 : 		return (this->_Getal().max_size());

	mov	rax, 1537228672809129301		; 1555555555555555H

; 1154 : 		}

	ret	0
?max_size@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXXZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Xlen, COMDAT

; 1753 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXXZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@U?$_vector3@M@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xalloc@U?$_vector3@M@@@@QEAA@XZ PROC		; xalloc<_vector3<float> >::xalloc<_vector3<float> >, COMDAT

; 76   : 													xalloc			()										{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@U?$_vector3@M@@@@QEAA@XZ ENDP		; xalloc<_vector3<float> >::xalloc<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@U?$_vector3@M@@@@QEBAXPEAU?$_vector3@M@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
n$dead$ = 24
?deallocate@?$xalloc@U?$_vector3@M@@@@QEBAXPEAU?$_vector3@M@@_K@Z PROC ; xalloc<_vector3<float> >::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN3@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN3@deallocate:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	0
?deallocate@?$xalloc@U?$_vector3@M@@@@QEBAXPEAU?$_vector3@M@@_K@Z ENDP ; xalloc<_vector3<float> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::_Wrap_alloc<xalloc<_vector3<float> > >, COMDAT

; 802  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::_Wrap_alloc<xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV?$xalloc@U?$_vector3@M@@@@@Z
_TEXT	SEGMENT
this$ = 8
_Right$dead$ = 16
??0?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV?$xalloc@U?$_vector3@M@@@@@Z PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::_Wrap_alloc<xalloc<_vector3<float> > >, COMDAT

; 807  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA@AEBV?$xalloc@U?$_vector3@M@@@@@Z ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::_Wrap_alloc<xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAPEAU?$_vector3@M@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAPEAU?$_vector3@M@@_K@Z PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 2
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAPEAU?$_vector3@M@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SA?AV?$xalloc@U?$_vector3@M@@@@AEBV3@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SA?AV?$xalloc@U?$_vector3@M@@@@AEBV3@@Z PROC ; std::allocator_traits<xalloc<_vector3<float> > >::select_on_container_copy_construction, COMDAT

; 487  : 		return (_Alloc_select::_Fn(0, _Al));

	mov	rax, rcx

; 488  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SA?AV?$xalloc@U?$_vector3@M@@@@AEBV3@@Z ENDP ; std::allocator_traits<xalloc<_vector3<float> > >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<_vector3<float> > >::_Vector_val<std::_Simple_types<_vector3<float> > >, COMDAT

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 485  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<_vector3<float> > >::_Vector_val<std::_Simple_types<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 6

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Make_iter, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rdx], r8

; 1045 : 		return (iterator(_Where._Ptr, this));

	mov	rax, rdx

; 1046 : 		}

	ret	0
?_Make_iter@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@2@@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::max_size, COMDAT

; 1153 : 		return (this->_Getal().max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1154 : 		}

	ret	0
?max_size@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBA_K_K@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r8, QWORD PTR [rcx]
	sar	r8, 6

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to
	xor	r8d, r8d

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reallocate, COMDAT

; 1587 : 		{	// move to array of exactly _Count elements

$LN58:
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	rsi, rdx
	mov	rdi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, edx
	shl	rdx, 6
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	r14, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, rax
	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rdi]
	mov	rbx, QWORD PTR [rdi+8]
	sub	rbx, rdx

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN52@Reallocate
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN52@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

	shl	rsi, 6
	add	rsi, r14
	mov	QWORD PTR [rdi+16], rsi

; 1607 : 		this->_Mylast = _Ptr + _Size;

	and	rbx, -64				; ffffffffffffffc0H
	add	rbx, r14
	mov	QWORD PTR [rdi+8], rbx

; 1608 : 		this->_Myfirst = _Ptr;

	mov	QWORD PTR [rdi], r14

; 1609 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN57@Reallocate:
?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reallocate'::`1'::catch$0

; 1592 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z$0:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR _Ptr$[rbp]
	test	rdx, rdx
	je	SHORT $LN41@catch$0
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN41@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1594 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXXZ PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Xlen, COMDAT

; 1753 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEBAXXZ ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@URESULT@CDB@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xalloc@URESULT@CDB@@@@QEAA@XZ PROC			; xalloc<CDB::RESULT>::xalloc<CDB::RESULT>, COMDAT

; 76   : 													xalloc			()										{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@URESULT@CDB@@@@QEAA@XZ ENDP			; xalloc<CDB::RESULT>::xalloc<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@URESULT@CDB@@@@QEBAXPEAURESULT@CDB@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
n$dead$ = 24
?deallocate@?$xalloc@URESULT@CDB@@@@QEBAXPEAURESULT@CDB@@_K@Z PROC ; xalloc<CDB::RESULT>::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN3@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN3@deallocate:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	0
?deallocate@?$xalloc@URESULT@CDB@@@@QEBAXPEAURESULT@CDB@@_K@Z ENDP ; xalloc<CDB::RESULT>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::_Wrap_alloc<xalloc<CDB::RESULT> >, COMDAT

; 802  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::_Wrap_alloc<xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV?$xalloc@URESULT@CDB@@@@@Z
_TEXT	SEGMENT
this$ = 8
_Right$dead$ = 16
??0?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV?$xalloc@URESULT@CDB@@@@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::_Wrap_alloc<xalloc<CDB::RESULT> >, COMDAT

; 807  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAA@AEBV?$xalloc@URESULT@CDB@@@@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::_Wrap_alloc<xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAPEAURESULT@CDB@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAPEAURESULT@CDB@@_K@Z PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, edx
	shl	rdx, 6
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAPEAURESULT@CDB@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SA?AV?$xalloc@URESULT@CDB@@@@AEBV3@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SA?AV?$xalloc@URESULT@CDB@@@@AEBV3@@Z PROC ; std::allocator_traits<xalloc<CDB::RESULT> >::select_on_container_copy_construction, COMDAT

; 487  : 		return (_Alloc_select::_Fn(0, _Al));

	mov	rax, rcx

; 488  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SA?AV?$xalloc@URESULT@CDB@@@@AEBV3@@Z ENDP ; std::allocator_traits<xalloc<CDB::RESULT> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<CDB::RESULT> >::_Vector_val<std::_Simple_types<CDB::RESULT> >, COMDAT

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 485  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<CDB::RESULT> >::_Vector_val<std::_Simple_types<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator-=, COMDAT

; 170  : 		_Ptr += _Off;

	add	QWORD PTR [rcx], -64			; ffffffffffffffc0H

; 372  : 		return (*this += -_Off);

	mov	rax, rcx

; 373  : 		}

	ret	0
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAA@PEAURESULT@CDB@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAA@PEAURESULT@CDB@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAA@PEAURESULT@CDB@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 206  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

	setne	al

; 211  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::max_size, COMDAT

; 1153 : 		return (this->_Getal().max_size());

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 1154 : 		}

	ret	0
?max_size@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Xlen, COMDAT

; 1753 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@VTRI@CDB@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xalloc@VTRI@CDB@@@@QEAA@XZ PROC			; xalloc<CDB::TRI>::xalloc<CDB::TRI>, COMDAT

; 76   : 													xalloc			()										{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@VTRI@CDB@@@@QEAA@XZ ENDP			; xalloc<CDB::TRI>::xalloc<CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@VTRI@CDB@@@@QEBAXPEAVTRI@CDB@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
n$dead$ = 24
?deallocate@?$xalloc@VTRI@CDB@@@@QEBAXPEAVTRI@CDB@@_K@Z PROC ; xalloc<CDB::TRI>::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN3@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN3@deallocate:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	0
?deallocate@?$xalloc@VTRI@CDB@@@@QEBAXPEAVTRI@CDB@@_K@Z ENDP ; xalloc<CDB::TRI>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::_Wrap_alloc<xalloc<CDB::TRI> >, COMDAT

; 802  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::_Wrap_alloc<xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV?$xalloc@VTRI@CDB@@@@@Z
_TEXT	SEGMENT
this$ = 8
_Right$dead$ = 16
??0?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV?$xalloc@VTRI@CDB@@@@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::_Wrap_alloc<xalloc<CDB::TRI> >, COMDAT

; 807  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAA@AEBV?$xalloc@VTRI@CDB@@@@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::_Wrap_alloc<xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAPEAVTRI@CDB@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAPEAVTRI@CDB@@_K@Z PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAPEAVTRI@CDB@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SA?AV?$xalloc@VTRI@CDB@@@@AEBV3@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SA?AV?$xalloc@VTRI@CDB@@@@AEBV3@@Z PROC ; std::allocator_traits<xalloc<CDB::TRI> >::select_on_container_copy_construction, COMDAT

; 487  : 		return (_Alloc_select::_Fn(0, _Al));

	mov	rax, rcx

; 488  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SA?AV?$xalloc@VTRI@CDB@@@@AEBV3@@Z ENDP ; std::allocator_traits<xalloc<CDB::TRI> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<CDB::TRI> >::_Vector_val<std::_Simple_types<CDB::TRI> >, COMDAT

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 485  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<CDB::TRI> >::_Vector_val<std::_Simple_types<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@PEAU?$_vector3@M@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@PEAU?$_vector3@M@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@PEAU?$_vector3@M@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAA@PEAVTRI@CDB@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAA@PEAVTRI@CDB@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAA@PEAVTRI@CDB@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@U?$_vector3@M@@@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$xalloc@U?$_vector3@M@@@@QEAA@AEBV0@@Z PROC		; xalloc<_vector3<float> >::xalloc<_vector3<float> >, COMDAT

; 77   : 													xalloc			(const xalloc<T>&)						{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@U?$_vector3@M@@@@QEAA@AEBV0@@Z ENDP		; xalloc<_vector3<float> >::xalloc<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@U?$_vector3@M@@@@QEBAPEAU?$_vector3@M@@_KPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
n$ = 16
p$dead$ = 24
?allocate@?$xalloc@U?$_vector3@M@@@@QEBAPEAU?$_vector3@M@@_KPEBX@Z PROC ; xalloc<_vector3<float> >::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 2
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$xalloc@U?$_vector3@M@@@@QEBAPEAU?$_vector3@M@@_KPEBX@Z ENDP ; xalloc<_vector3<float> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 1537228672809129301		; 1555555555555555H

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@URESULT@CDB@@@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$xalloc@URESULT@CDB@@@@QEAA@AEBV0@@Z PROC		; xalloc<CDB::RESULT>::xalloc<CDB::RESULT>, COMDAT

; 77   : 													xalloc			(const xalloc<T>&)						{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@URESULT@CDB@@@@QEAA@AEBV0@@Z ENDP		; xalloc<CDB::RESULT>::xalloc<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@URESULT@CDB@@@@QEBAPEAURESULT@CDB@@_KPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
n$ = 16
p$dead$ = 24
?allocate@?$xalloc@URESULT@CDB@@@@QEBAPEAURESULT@CDB@@_KPEBX@Z PROC ; xalloc<CDB::RESULT>::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, edx
	shl	rdx, 6
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$xalloc@URESULT@CDB@@@@QEBAPEAURESULT@CDB@@_KPEBX@Z ENDP ; xalloc<CDB::RESULT>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	add	QWORD PTR [rcx], -64			; ffffffffffffffc0H

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Compat, COMDAT

; 255  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@VTRI@CDB@@@@QEAA@AEBV0@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$xalloc@VTRI@CDB@@@@QEAA@AEBV0@@Z PROC		; xalloc<CDB::TRI>::xalloc<CDB::TRI>, COMDAT

; 77   : 													xalloc			(const xalloc<T>&)						{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@VTRI@CDB@@@@QEAA@AEBV0@@Z ENDP		; xalloc<CDB::TRI>::xalloc<CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@VTRI@CDB@@@@QEBAPEAVTRI@CDB@@_KPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
n$ = 16
p$dead$ = 24
?allocate@?$xalloc@VTRI@CDB@@@@QEBAPEAVTRI@CDB@@_KPEBX@Z PROC ; xalloc<CDB::TRI>::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$xalloc@VTRI@CDB@@@@QEBAPEAVTRI@CDB@@_KPEBX@Z ENDP ; xalloc<CDB::TRI>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SA_KAEBV?$xalloc@U?$_vector3@M@@@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SA_KAEBV?$xalloc@U?$_vector3@M@@@@@Z PROC ; std::allocator_traits<xalloc<_vector3<float> > >::max_size, COMDAT

; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));

	mov	rax, 1537228672809129301		; 1555555555555555H

; 482  : 		}

	ret	0
?max_size@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SA_KAEBV?$xalloc@U?$_vector3@M@@@@@Z ENDP ; std::allocator_traits<xalloc<_vector3<float> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SA_KAEBV?$xalloc@URESULT@CDB@@@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SA_KAEBV?$xalloc@URESULT@CDB@@@@@Z PROC ; std::allocator_traits<xalloc<CDB::RESULT> >::max_size, COMDAT

; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 482  : 		}

	ret	0
?max_size@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SA_KAEBV?$xalloc@URESULT@CDB@@@@@Z ENDP ; std::allocator_traits<xalloc<CDB::RESULT> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	add	QWORD PTR [rcx], -64			; ffffffffffffffc0H

; 171  : 		return (*this);

	mov	rax, rcx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SA_KAEBV?$xalloc@VTRI@CDB@@@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SA_KAEBV?$xalloc@VTRI@CDB@@@@@Z PROC ; std::allocator_traits<xalloc<CDB::TRI> >::max_size, COMDAT

; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 482  : 		}

	ret	0
?max_size@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SA_KAEBV?$xalloc@VTRI@CDB@@@@@Z ENDP ; std::allocator_traits<xalloc<CDB::TRI> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@VOPCODE_Model@Opcode@@@@YAXAEAPEAVOPCODE_Model@Opcode@@@Z
_TEXT	SEGMENT
ptr$ = 48
??$xr_delete@VOPCODE_Model@Opcode@@@@YAXAEAPEAVOPCODE_Model@Opcode@@@Z PROC ; xr_delete<Opcode::OPCODE_Model>, COMDAT

; 150  : {

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 151  : 	if (ptr) 

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN1@xr_delete
	call	??1OPCODE_Model@Opcode@@QEAA@XZ		; Opcode::OPCODE_Model::~OPCODE_Model

; 144  : 		Memory.mem_free	(ptr);

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = NULL;

	mov	QWORD PTR [rbx], 0
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_delete@VOPCODE_Model@Opcode@@@@YAXAEAPEAVOPCODE_Model@Opcode@@@Z ENDP ; xr_delete<Opcode::OPCODE_Model>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_free@VTRI@CDB@@@@YAXAEAPEAVTRI@CDB@@@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@VTRI@CDB@@@@YAXAEAPEAVTRI@CDB@@@Z PROC	; xr_free<CDB::TRI>, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@xr_free
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx], 0
$LN1@xr_free:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_free@VTRI@CDB@@@@YAXAEAPEAVTRI@CDB@@@Z ENDP	; xr_free<CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_free@U?$_vector3@M@@@@YAXAEAPEAU?$_vector3@M@@@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@U?$_vector3@M@@@@YAXAEAPEAU?$_vector3@M@@@Z PROC ; xr_free<_vector3<float> >, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@xr_free
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx], 0
$LN1@xr_free:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_free@U?$_vector3@M@@@@YAXAEAPEAU?$_vector3@M@@@Z ENDP ; xr_free<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_alloc@U?$_vector3@M@@@@YAPEAU?$_vector3@M@@I@Z
_TEXT	SEGMENT
count$ = 8
??$xr_alloc@U?$_vector3@M@@@@YAPEAU?$_vector3@M@@I@Z PROC ; xr_alloc<_vector3<float> >, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, ecx
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 2
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
??$xr_alloc@U?$_vector3@M@@@@YAPEAU?$_vector3@M@@I@Z ENDP ; xr_alloc<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_alloc@VTRI@CDB@@@@YAPEAVTRI@CDB@@I@Z
_TEXT	SEGMENT
count$ = 8
??$xr_alloc@VTRI@CDB@@@@YAPEAVTRI@CDB@@I@Z PROC		; xr_alloc<CDB::TRI>, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, ecx
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
??$xr_alloc@VTRI@CDB@@@@YAPEAVTRI@CDB@@I@Z ENDP		; xr_alloc<CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_alloc@I@@YAPEAII@Z
_TEXT	SEGMENT
count$ = 8
??$xr_alloc@I@@YAPEAII@Z PROC				; xr_alloc<unsigned int>, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ecx
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	rdx, 2
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
??$xr_alloc@I@@YAPEAII@Z ENDP				; xr_alloc<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VOPCODE_Model@Opcode@@@@YAPEAVOPCODE_Model@Opcode@@XZ
_TEXT	SEGMENT
??$xr_new@VOPCODE_Model@Opcode@@@@YAPEAVOPCODE_Model@Opcode@@XZ PROC ; xr_new<Opcode::OPCODE_Model>, COMDAT

; 67   : {

$LN10:
	sub	rsp, 40					; 00000028H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 24
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 156  : {

	mov	QWORD PTR [rax], 0
	mov	QWORD PTR [rax+8], 0
	mov	WORD PTR [rax+16], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@xr_new:
	add	rsp, 40					; 00000028H
	ret	0
??$xr_new@VOPCODE_Model@Opcode@@@@YAPEAVOPCODE_Model@Opcode@@XZ ENDP ; xr_new<Opcode::OPCODE_Model>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@0PEAU2@@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@0PEAU2@@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > > >, COMDAT

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	r10, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, r10
	call	??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1641 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@0PEAU2@@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?9V?$xalloc@U?$_vector3@M@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$?9V?$xalloc@U?$_vector3@M@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0@Z PROC ; std::operator!=<xalloc<_vector3<float> >,xalloc<_vector3<float> > >, COMDAT

; 901  : 	return (!(_Left == _Right));

	xor	al, al

; 902  : 	}

	ret	0
??$?9V?$xalloc@U?$_vector3@M@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0@Z ENDP ; std::operator!=<xalloc<_vector3<float> >,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@PEAU?$_vector3@M@@PEAU1@@std@@YAPEAU?$_vector3@M@@PEAU1@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Copy_impl@PEAU?$_vector3@M@@PEAU1@@std@@YAPEAU?$_vector3@M@@PEAU1@00@Z PROC ; std::_Copy_impl<_vector3<float> * __ptr64,_vector3<float> * __ptr64>, COMDAT

; 2064 : 	{	// copy [_First, _Last) to [_Dest, ...)

	mov	rax, r8

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN14@Copy_impl
	npad	8
$LL7@Copy_impl:

; 2045 : 		*_Dest = *_First;

	movsdx	xmm0, QWORD PTR [rcx]
	add	rcx, 12
	add	rax, 12
	movsdx	QWORD PTR [rax-12], xmm0
	mov	r8d, DWORD PTR [rcx-4]
	mov	DWORD PTR [rax-4], r8d
	cmp	rcx, rdx
	jne	SHORT $LL7@Copy_impl
$LN14@Copy_impl:

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2067 : 	}

	ret	0
??$_Copy_impl@PEAU?$_vector3@M@@PEAU1@@std@@YAPEAU?$_vector3@M@@PEAU1@00@Z ENDP ; std::_Copy_impl<_vector3<float> * __ptr64,_vector3<float> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Ucopy@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Ucopy@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Ucopy<_vector3<float> * __ptr64>, COMDAT

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

$LN18:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1641 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Ucopy@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Ucopy<_vector3<float> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@1@0PEAU23@@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@1@0PEAU23@@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > > >, COMDAT

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	r10, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, r10
	call	??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1641 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@1@0PEAU23@@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@URESULT@CDB@@@std@@YAPEAURESULT@CDB@@AEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@URESULT@CDB@@@std@@YAPEAURESULT@CDB@@AEAU12@@Z PROC ; std::addressof<CDB::RESULT>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@URESULT@CDB@@@std@@YAPEAURESULT@CDB@@AEAU12@@Z ENDP ; std::addressof<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@URESULT@CDB@@@std@@YA$$QEAURESULT@CDB@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@URESULT@CDB@@@std@@YA$$QEAURESULT@CDB@@AEAU12@@Z PROC ; std::forward<CDB::RESULT>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@URESULT@CDB@@@std@@YA$$QEAURESULT@CDB@@AEAU12@@Z ENDP ; std::forward<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@URESULT@CDB@@U12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@$$QEAU23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@URESULT@CDB@@U12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@$$QEAU23@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@URESULT@CDB@@U12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@$$QEAU23@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?9V?$xalloc@URESULT@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$?9V?$xalloc@URESULT@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0@Z PROC ; std::operator!=<xalloc<CDB::RESULT>,xalloc<CDB::RESULT> >, COMDAT

; 901  : 	return (!(_Left == _Right));

	xor	al, al

; 902  : 	}

	ret	0
??$?9V?$xalloc@URESULT@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0@Z ENDP ; std::operator!=<xalloc<CDB::RESULT>,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z PROC ; std::_Copy_impl<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>, COMDAT

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN14@Copy_impl
	npad	11
$LL7@Copy_impl:

; 2045 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [rcx]
	add	rcx, 64					; 00000040H
	add	r8, 64					; 00000040H
	movups	XMMWORD PTR [r8-64], xmm0
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [r8-48], xmm1
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [r8-32], xmm0
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [r8-16], xmm1
	cmp	rcx, rdx
	jne	SHORT $LL7@Copy_impl
$LN14@Copy_impl:

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, r8

; 2067 : 	}

	ret	0
??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z ENDP ; std::_Copy_impl<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Ucopy@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Ucopy@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Ucopy<CDB::RESULT * __ptr64>, COMDAT

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

$LN18:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1641 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Ucopy@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Ucopy<CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@1@0PEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@1@0PEAV23@@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > > >, COMDAT

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	r10, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, r10
	call	??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1641 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@1@0PEAV23@@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?9V?$xalloc@VTRI@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$?9V?$xalloc@VTRI@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0@Z PROC ; std::operator!=<xalloc<CDB::TRI>,xalloc<CDB::TRI> >, COMDAT

; 901  : 	return (!(_Left == _Right));

	xor	al, al

; 902  : 	}

	ret	0
??$?9V?$xalloc@VTRI@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0@Z ENDP ; std::operator!=<xalloc<CDB::TRI>,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@PEAVTRI@CDB@@PEAV12@@std@@YAPEAVTRI@CDB@@PEAV12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Copy_impl@PEAVTRI@CDB@@PEAV12@@std@@YAPEAVTRI@CDB@@PEAV12@00@Z PROC ; std::_Copy_impl<CDB::TRI * __ptr64,CDB::TRI * __ptr64>, COMDAT

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN14@Copy_impl
	npad	11
$LL7@Copy_impl:

; 2045 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [rcx]
	add	rcx, 24
	add	r8, 24
	movups	XMMWORD PTR [r8-24], xmm0
	movsdx	xmm1, QWORD PTR [rcx-8]
	movsdx	QWORD PTR [r8-8], xmm1
	cmp	rcx, rdx
	jne	SHORT $LL7@Copy_impl
$LN14@Copy_impl:

; 2065 : 	return (_Copy_impl(_First, _Last,
; 2066 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, r8

; 2067 : 	}

	ret	0
??$_Copy_impl@PEAVTRI@CDB@@PEAV12@@std@@YAPEAVTRI@CDB@@PEAV12@00@Z ENDP ; std::_Copy_impl<CDB::TRI * __ptr64,CDB::TRI * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Ucopy@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Ucopy@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Ucopy<CDB::TRI * __ptr64>, COMDAT

; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

$LN18:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 416  : 		_Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1641 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Ucopy@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Ucopy<CDB::TRI * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAXPEAU?$_vector3@M@@0AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAXPEAU?$_vector3@M@@0AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<_vector3<float> > > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAXPEAU?$_vector3@M@@0AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Move@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z PROC ; std::_Move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>, COMDAT

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN16@Move
	npad	11
$LL7@Move:

; 2420 : 		*_Dest = _STD move(*_First);

	movups	xmm0, XMMWORD PTR [rcx]
	add	rcx, 64					; 00000040H
	add	r8, 64					; 00000040H
	movups	XMMWORD PTR [r8-64], xmm0
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [r8-48], xmm1
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [r8-32], xmm0
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [r8-16], xmm1
	cmp	rcx, rdx
	jne	SHORT $LL7@Move
$LN16@Move:

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, r8

; 2442 : 	}

	ret	0
??$_Move@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00@Z ENDP ; std::_Move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAXPEAURESULT@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAXPEAURESULT@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::RESULT> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAXPEAURESULT@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAXPEAVTRI@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAXPEAVTRI@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::TRI> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAXPEAVTRI@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@U?$_vector3@M@@@@@_Alloc_select@std@@SA?AV?$xalloc@U?$_vector3@M@@@@U_Wrap_int@1@AEBV2@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$dead$ = 16
_Al$dead$ = 24
??$_Fn@V?$xalloc@U?$_vector3@M@@@@@_Alloc_select@std@@SA?AV?$xalloc@U?$_vector3@M@@@@U_Wrap_int@1@AEBV2@@Z PROC ; std::_Alloc_select::_Fn<xalloc<_vector3<float> > >, COMDAT

; 408  : 		return (_Al);

	mov	rax, rcx

; 409  : 		}

	ret	0
??$_Fn@V?$xalloc@U?$_vector3@M@@@@@_Alloc_select@std@@SA?AV?$xalloc@U?$_vector3@M@@@@U_Wrap_int@1@AEBV2@@Z ENDP ; std::_Alloc_select::_Fn<xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z PROC ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Umove<CDB::RESULT * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN20:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAURESULT@CDB@@@?$vector@URESULT@CDB@@V?$xalloc@URESULT@CDB@@@@@std@@IEAAPEAURESULT@CDB@@PEAU23@00@Z ENDP ; std::vector<CDB::RESULT,xalloc<CDB::RESULT> >::_Umove<CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_free@URESULT@CDB@@@@YAXAEAPEAURESULT@CDB@@@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@URESULT@CDB@@@@YAXAEAPEAURESULT@CDB@@@Z PROC	; xr_free<CDB::RESULT>, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@xr_free
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx], 0
$LN1@xr_free:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_free@URESULT@CDB@@@@YAXAEAPEAURESULT@CDB@@@Z ENDP	; xr_free<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@URESULT@CDB@@@@@_Alloc_select@std@@SA?AV?$xalloc@URESULT@CDB@@@@U_Wrap_int@1@AEBV2@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$dead$ = 16
_Al$dead$ = 24
??$_Fn@V?$xalloc@URESULT@CDB@@@@@_Alloc_select@std@@SA?AV?$xalloc@URESULT@CDB@@@@U_Wrap_int@1@AEBV2@@Z PROC ; std::_Alloc_select::_Fn<xalloc<CDB::RESULT> >, COMDAT

; 408  : 		return (_Al);

	mov	rax, rcx

; 409  : 		}

	ret	0
??$_Fn@V?$xalloc@URESULT@CDB@@@@@_Alloc_select@std@@SA?AV?$xalloc@URESULT@CDB@@@@U_Wrap_int@1@AEBV2@@Z ENDP ; std::_Alloc_select::_Fn<xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@VTRI@CDB@@@@@_Alloc_select@std@@SA?AV?$xalloc@VTRI@CDB@@@@U_Wrap_int@1@AEBV2@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$dead$ = 16
_Al$dead$ = 24
??$_Fn@V?$xalloc@VTRI@CDB@@@@@_Alloc_select@std@@SA?AV?$xalloc@VTRI@CDB@@@@U_Wrap_int@1@AEBV2@@Z PROC ; std::_Alloc_select::_Fn<xalloc<CDB::TRI> >, COMDAT

; 408  : 		return (_Al);

	mov	rax, rcx

; 409  : 		}

	ret	0
??$_Fn@V?$xalloc@VTRI@CDB@@@@@_Alloc_select@std@@SA?AV?$xalloc@VTRI@CDB@@@@U_Wrap_int@1@AEBV2@@Z ENDP ; std::_Alloc_select::_Fn<xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_alloc@URESULT@CDB@@@@YAPEAURESULT@CDB@@I@Z
_TEXT	SEGMENT
count$ = 8
??$xr_alloc@URESULT@CDB@@@@YAPEAURESULT@CDB@@I@Z PROC	; xr_alloc<CDB::RESULT>, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ecx
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	rdx, 6
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
??$xr_alloc@URESULT@CDB@@@@YAPEAURESULT@CDB@@I@Z ENDP	; xr_alloc<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@U?$_vector3@M@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@U?$_vector3@M@@@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
??$_Fn@V?$xalloc@U?$_vector3@M@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@U?$_vector3@M@@@@@Z PROC ; std::_Alloc_max_size::_Fn<xalloc<_vector3<float> > >, COMDAT

; 381  : 		return (_Al.max_size());

	mov	rax, 1537228672809129301		; 1555555555555555H

; 382  : 		}

	ret	0
??$_Fn@V?$xalloc@U?$_vector3@M@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@U?$_vector3@M@@@@@Z ENDP ; std::_Alloc_max_size::_Fn<xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@URESULT@CDB@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@URESULT@CDB@@@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
??$_Fn@V?$xalloc@URESULT@CDB@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@URESULT@CDB@@@@@Z PROC ; std::_Alloc_max_size::_Fn<xalloc<CDB::RESULT> >, COMDAT

; 381  : 		return (_Al.max_size());

	mov	rax, 288230376151711743			; 03ffffffffffffffH

; 382  : 		}

	ret	0
??$_Fn@V?$xalloc@URESULT@CDB@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@URESULT@CDB@@@@@Z ENDP ; std::_Alloc_max_size::_Fn<xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@VTRI@CDB@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@VTRI@CDB@@@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
??$_Fn@V?$xalloc@VTRI@CDB@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@VTRI@CDB@@@@@Z PROC ; std::_Alloc_max_size::_Fn<xalloc<CDB::TRI> >, COMDAT

; 381  : 		return (_Al.max_size());

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 382  : 		}

	ret	0
??$_Fn@V?$xalloc@VTRI@CDB@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@VTRI@CDB@@@@@Z ENDP ; std::_Alloc_max_size::_Fn<xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@U?$_vector3@M@@@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$xalloc@U?$_vector3@M@@@@QEBA_KXZ PROC	; xalloc<_vector3<float> >::max_size, COMDAT

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	rax, 1537228672809129301		; 1555555555555555H
	ret	0
?max_size@?$xalloc@U?$_vector3@M@@@@QEBA_KXZ ENDP	; xalloc<_vector3<float> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@URESULT@CDB@@@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$xalloc@URESULT@CDB@@@@QEBA_KXZ PROC		; xalloc<CDB::RESULT>::max_size, COMDAT

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	rax, 288230376151711743			; 03ffffffffffffffH
	ret	0
?max_size@?$xalloc@URESULT@CDB@@@@QEBA_KXZ ENDP		; xalloc<CDB::RESULT>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@VTRI@CDB@@@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$xalloc@VTRI@CDB@@@@QEBA_KXZ PROC		; xalloc<CDB::TRI>::max_size, COMDAT

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	ret	0
?max_size@?$xalloc@VTRI@CDB@@@@QEBA_KXZ ENDP		; xalloc<CDB::TRI>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VOPCODE_Model@Opcode@@@@QEAAXAEAPEAVOPCODE_Model@Opcode@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$ = 56
??R?$xr_special_free@$0A@VOPCODE_Model@Opcode@@@@QEAAXAEAPEAVOPCODE_Model@Opcode@@@Z PROC ; xr_special_free<0,Opcode::OPCODE_Model>::operator(), COMDAT

; 142  : 	{

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
	call	??1OPCODE_Model@Opcode@@QEAA@XZ		; Opcode::OPCODE_Model::~OPCODE_Model

; 143  : 		ptr->~T			();
; 144  : 		Memory.mem_free	(ptr);

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A

; 145  : 	}

	add	rsp, 32					; 00000020H
	pop	rbx

; 143  : 		ptr->~T			();
; 144  : 		Memory.mem_free	(ptr);

	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
??R?$xr_special_free@$0A@VOPCODE_Model@Opcode@@@@QEAAXAEAPEAVOPCODE_Model@Opcode@@@Z ENDP ; xr_special_free<0,Opcode::OPCODE_Model>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GOPCODE_Model@Opcode@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GOPCODE_Model@Opcode@@QEAAPEAXI@Z PROC		; Opcode::OPCODE_Model::`scalar deleting destructor', COMDAT
$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	call	??1OPCODE_Model@Opcode@@QEAA@XZ		; Opcode::OPCODE_Model::~OPCODE_Model
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GOPCODE_Model@Opcode@@QEAAPEAXI@Z ENDP		; Opcode::OPCODE_Model::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@PEAU?$_vector3@M@@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@std@@YAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@PEAU?$_vector3@M@@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@std@@YAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@PEAU?$_vector3@M@@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@2@@std@@YAPEAU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8V?$xalloc@U?$_vector3@M@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$?8V?$xalloc@U?$_vector3@M@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0@Z PROC ; std::operator==<xalloc<_vector3<float> >,xalloc<_vector3<float> > >, COMDAT

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	al, 1

; 894  : 	}

	ret	0
??$?8V?$xalloc@U?$_vector3@M@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0@Z ENDP ; std::operator==<xalloc<_vector3<float> >,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@U?$_vector3@M@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAU?$_vector3@M@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@U?$_vector3@M@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAU?$_vector3@M@@0@Z PROC ; std::_Ptr_cat<_vector3<float>,_vector3<float> >, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@U?$_vector3@M@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAU?$_vector3@M@@0@Z ENDP ; std::_Ptr_cat<_vector3<float>,_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@PEAU?$_vector3@M@@PEAU1@@std@@YAPEAU?$_vector3@M@@PEAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Copy_impl@PEAU?$_vector3@M@@PEAU1@@std@@YAPEAU?$_vector3@M@@PEAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<_vector3<float> * __ptr64,_vector3<float> * __ptr64>, COMDAT

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN10@Copy_impl
	npad	11
$LL3@Copy_impl:

; 2045 : 		*_Dest = *_First;

	movsdx	xmm0, QWORD PTR [rcx]
	add	rcx, 12
	add	r8, 12
	movsdx	QWORD PTR [r8-12], xmm0
	mov	eax, DWORD PTR [rcx-4]
	mov	DWORD PTR [r8-4], eax
	cmp	rcx, rdx
	jne	SHORT $LL3@Copy_impl
$LN10@Copy_impl:

; 2046 : 	return (_Dest);

	mov	rax, r8

; 2047 : 	}

	ret	0
??$_Copy_impl@PEAU?$_vector3@M@@PEAU1@@std@@YAPEAU?$_vector3@M@@PEAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<_vector3<float> * __ptr64,_vector3<float> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z PROC ; std::_Uninitialized_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN16:
	sub	rsp, 56					; 00000038H

; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ENDP ; std::_Uninitialized_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@PEAURESULT@CDB@@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@std@@YAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@PEAURESULT@CDB@@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@std@@YAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@PEAURESULT@CDB@@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@2@@std@@YAPEAURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@URESULT@CDB@@U12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@$$QEAU34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@URESULT@CDB@@U12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@$$QEAU34@@Z PROC ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@URESULT@CDB@@U12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@$$QEAU34@@Z ENDP ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8V?$xalloc@URESULT@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$?8V?$xalloc@URESULT@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0@Z PROC ; std::operator==<xalloc<CDB::RESULT>,xalloc<CDB::RESULT> >, COMDAT

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	al, 1

; 894  : 	}

	ret	0
??$?8V?$xalloc@URESULT@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0@Z ENDP ; std::operator==<xalloc<CDB::RESULT>,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@URESULT@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAURESULT@CDB@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@URESULT@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAURESULT@CDB@@0@Z PROC ; std::_Ptr_cat<CDB::RESULT,CDB::RESULT>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@URESULT@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAURESULT@CDB@@0@Z ENDP ; std::_Ptr_cat<CDB::RESULT,CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>, COMDAT

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN10@Copy_impl
	npad	11
$LL3@Copy_impl:

; 2045 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [rcx]
	add	rcx, 64					; 00000040H
	add	r8, 64					; 00000040H
	movups	XMMWORD PTR [r8-64], xmm0
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [r8-48], xmm1
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [r8-32], xmm0
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [r8-16], xmm1
	cmp	rcx, rdx
	jne	SHORT $LL3@Copy_impl
$LN10@Copy_impl:

; 2046 : 	return (_Dest);

	mov	rax, r8

; 2047 : 	}

	ret	0
??$_Copy_impl@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z PROC ; std::_Uninitialized_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN16:
	sub	rsp, 56					; 00000038H

; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ENDP ; std::_Uninitialized_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@PEAVTRI@CDB@@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@std@@YAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@PEAVTRI@CDB@@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@std@@YAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@PEAVTRI@CDB@@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@2@@std@@YAPEAVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$?8V?$xalloc@VTRI@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$?8V?$xalloc@VTRI@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0@Z PROC ; std::operator==<xalloc<CDB::TRI>,xalloc<CDB::TRI> >, COMDAT

; 893  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

	mov	al, 1

; 894  : 	}

	ret	0
??$?8V?$xalloc@VTRI@CDB@@@@V0@@std@@YA_NAEBU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0@Z ENDP ; std::operator==<xalloc<CDB::TRI>,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@VTRI@CDB@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAVTRI@CDB@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@VTRI@CDB@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAVTRI@CDB@@0@Z PROC ; std::_Ptr_cat<CDB::TRI,CDB::TRI>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@VTRI@CDB@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAVTRI@CDB@@0@Z ENDP ; std::_Ptr_cat<CDB::TRI,CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_impl@PEAVTRI@CDB@@PEAV12@@std@@YAPEAVTRI@CDB@@PEAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Copy_impl@PEAVTRI@CDB@@PEAV12@@std@@YAPEAVTRI@CDB@@PEAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_impl<CDB::TRI * __ptr64,CDB::TRI * __ptr64>, COMDAT

; 2044 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN10@Copy_impl
	npad	11
$LL3@Copy_impl:

; 2045 : 		*_Dest = *_First;

	movups	xmm0, XMMWORD PTR [rcx]
	add	rcx, 24
	add	r8, 24
	movups	XMMWORD PTR [r8-24], xmm0
	movsdx	xmm1, QWORD PTR [rcx-8]
	movsdx	QWORD PTR [r8-8], xmm1
	cmp	rcx, rdx
	jne	SHORT $LL3@Copy_impl
$LN10@Copy_impl:

; 2046 : 	return (_Dest);

	mov	rax, r8

; 2047 : 	}

	ret	0
??$_Copy_impl@PEAVTRI@CDB@@PEAV12@@std@@YAPEAVTRI@CDB@@PEAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_impl<CDB::TRI * __ptr64,CDB::TRI * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z PROC ; std::_Uninitialized_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >, COMDAT

; 424  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN16:
	sub	rsp, 56					; 00000038H

; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >

; 425  : 	return (_Rechecked(_Dest,
; 426  : 		_Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
; 427  : 			_Unchecked(_Dest), _Al)));
; 428  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ENDP ; std::_Uninitialized_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAXPEAU?$_vector3@M@@0AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAXPEAU?$_vector3@M@@0AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<_vector3<float> > > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAXPEAU?$_vector3@M@@0AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Move@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>, COMDAT

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN12@Move
	npad	11
$LL3@Move:

; 2420 : 		*_Dest = _STD move(*_First);

	movups	xmm0, XMMWORD PTR [rcx]
	add	rcx, 64					; 00000040H
	add	r8, 64					; 00000040H
	movups	XMMWORD PTR [r8-64], xmm0
	movups	xmm1, XMMWORD PTR [rcx-48]
	movups	XMMWORD PTR [r8-48], xmm1
	movups	xmm0, XMMWORD PTR [rcx-32]
	movups	XMMWORD PTR [r8-32], xmm0
	movups	xmm1, XMMWORD PTR [rcx-16]
	movups	XMMWORD PTR [r8-16], xmm1
	cmp	rcx, rdx
	jne	SHORT $LL3@Move
$LN12@Move:

; 2421 : 	return (_Dest);

	mov	rax, r8

; 2422 : 	}

	ret	0
??$_Move@PEAURESULT@CDB@@PEAU12@@std@@YAPEAURESULT@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAXPEAURESULT@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAXPEAURESULT@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::RESULT> > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAXPEAURESULT@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAXPEAVTRI@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAXPEAVTRI@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::TRI> > >, COMDAT

; 81   : 	for (; _First != _Last; ++_First)
; 82   : 		_Al.destroy(_First);
; 83   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAXPEAVTRI@CDB@@0AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z PROC ; std::_Uninitialized_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN18:
	sub	rsp, 56					; 00000038H

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	call	??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ENDP ; std::_Uninitialized_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@YAPEBU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Iter$ = 8
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@YAPEBU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<_vector3<float> > > >, COMDAT

; 265  : 	return (_Iter._Unchecked());

	mov	rax, rcx

; 266  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@YAPEBU?$_vector3@M@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z PROC ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN6:
	sub	rsp, 56					; 00000038H

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >

; 417  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ENDP ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAU?$_vector3@M@@PEAU1@@std@@YAAEAPEAU?$_vector3@M@@AEAPEAU1@PEAU1@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAU?$_vector3@M@@PEAU1@@std@@YAAEAPEAU?$_vector3@M@@AEAPEAU1@PEAU1@@Z PROC ; std::_Rechecked<_vector3<float> * __ptr64,_vector3<float> * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAU?$_vector3@M@@PEAU1@@std@@YAAEAPEAU?$_vector3@M@@AEAPEAU1@PEAU1@@Z ENDP ; std::_Rechecked<_vector3<float> * __ptr64,_vector3<float> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??$?8U?$_vector3@M@@U0@@@YA_NAEBV?$xalloc@U?$_vector3@M@@@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
??$?8U?$_vector3@M@@U0@@@YA_NAEBV?$xalloc@U?$_vector3@M@@@@0@Z PROC ; operator==<_vector3<float>,_vector3<float> >, COMDAT

; 100  : template<class _Ty,	class _Other>	inline	bool operator==(const xalloc<_Ty>&, const xalloc<_Other>&)		{	return (true);							}

	mov	al, 1
	ret	0
??$?8U?$_vector3@M@@U0@@@YA_NAEBV?$xalloc@U?$_vector3@M@@@@0@Z ENDP ; operator==<_vector3<float>,_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z PROC ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN6:
	sub	rsp, 56					; 00000038H

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >

; 417  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ENDP ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@YAPEBURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Iter$ = 8
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@YAPEBURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >, COMDAT

; 265  : 	return (_Iter._Unchecked());

	mov	rax, rcx

; 266  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@YAPEBURESULT@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAURESULT@CDB@@@std@@YAPEAURESULT@CDB@@PEAU12@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAURESULT@CDB@@@std@@YAPEAURESULT@CDB@@PEAU12@@Z PROC ; std::_Unchecked<CDB::RESULT * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAURESULT@CDB@@@std@@YAPEAURESULT@CDB@@PEAU12@@Z ENDP ; std::_Unchecked<CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z PROC ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN6:
	sub	rsp, 56					; 00000038H

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >

; 417  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ENDP ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAURESULT@CDB@@PEAU12@@std@@YAAEAPEAURESULT@CDB@@AEAPEAU12@PEAU12@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAURESULT@CDB@@PEAU12@@std@@YAAEAPEAURESULT@CDB@@AEAPEAU12@PEAU12@@Z PROC ; std::_Rechecked<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAURESULT@CDB@@PEAU12@@std@@YAAEAPEAURESULT@CDB@@AEAPEAU12@PEAU12@@Z ENDP ; std::_Rechecked<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@U23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@U23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@$$QEAU34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [r9+16]
	movups	XMMWORD PTR [r8+16], xmm1
	movups	xmm0, XMMWORD PTR [r9+32]
	movups	XMMWORD PTR [r8+32], xmm0
	movups	xmm1, XMMWORD PTR [r9+48]
	movups	XMMWORD PTR [r8+48], xmm1
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@U23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@$$QEAU34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??$?8URESULT@CDB@@U01@@@YA_NAEBV?$xalloc@URESULT@CDB@@@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
??$?8URESULT@CDB@@U01@@@YA_NAEBV?$xalloc@URESULT@CDB@@@@0@Z PROC ; operator==<CDB::RESULT,CDB::RESULT>, COMDAT

; 100  : template<class _Ty,	class _Other>	inline	bool operator==(const xalloc<_Ty>&, const xalloc<_Other>&)		{	return (true);							}

	mov	al, 1
	ret	0
??$?8URESULT@CDB@@U01@@@YA_NAEBV?$xalloc@URESULT@CDB@@@@0@Z ENDP ; operator==<CDB::RESULT,CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z PROC ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN6:
	sub	rsp, 56					; 00000038H

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >

; 417  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ENDP ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@YAPEBVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Iter$ = 8
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@YAPEBVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CDB::TRI> > >, COMDAT

; 265  : 	return (_Iter._Unchecked());

	mov	rax, rcx

; 266  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@YAPEBVTRI@CDB@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAVTRI@CDB@@@std@@YAPEAVTRI@CDB@@PEAV12@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAVTRI@CDB@@@std@@YAPEAVTRI@CDB@@PEAV12@@Z PROC ; std::_Unchecked<CDB::TRI * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAVTRI@CDB@@@std@@YAPEAVTRI@CDB@@PEAV12@@Z ENDP ; std::_Unchecked<CDB::TRI * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z PROC ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN6:
	sub	rsp, 56					; 00000038H

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >

; 417  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ENDP ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAVTRI@CDB@@PEAV12@@std@@YAAEAPEAVTRI@CDB@@AEAPEAV12@PEAV12@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAVTRI@CDB@@PEAV12@@std@@YAAEAPEAVTRI@CDB@@AEAPEAV12@PEAV12@@Z PROC ; std::_Rechecked<CDB::TRI * __ptr64,CDB::TRI * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAVTRI@CDB@@PEAV12@@std@@YAAEAPEAVTRI@CDB@@AEAPEAV12@PEAV12@@Z ENDP ; std::_Rechecked<CDB::TRI * __ptr64,CDB::TRI * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??$?8VTRI@CDB@@V01@@@YA_NAEBV?$xalloc@VTRI@CDB@@@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
??$?8VTRI@CDB@@V01@@@YA_NAEBV?$xalloc@VTRI@CDB@@@@0@Z PROC ; operator==<CDB::TRI,CDB::TRI>, COMDAT

; 100  : template<class _Ty,	class _Other>	inline	bool operator==(const xalloc<_Ty>&, const xalloc<_Other>&)		{	return (true);							}

	mov	al, 1
	ret	0
??$?8VTRI@CDB@@V01@@@YA_NAEBV?$xalloc@VTRI@CDB@@@@0@Z ENDP ; operator==<CDB::TRI,CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z PROC ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN6:
	sub	rsp, 56					; 00000038H

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));

	call	??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >

; 417  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ENDP ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$_vector3@M@@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@U?$_vector3@M@@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@@Z PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::destroy<_vector3<float> >, COMDAT

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	0
??$destroy@U?$_vector3@M@@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@@Z ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::destroy<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AEAURESULT@CDB@@@std@@YA$$QEAURESULT@CDB@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAURESULT@CDB@@@std@@YA$$QEAURESULT@CDB@@AEAU12@@Z PROC ; std::move<CDB::RESULT & __ptr64>, COMDAT

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, rcx

; 1521 : 	}

	ret	0
??$move@AEAURESULT@CDB@@@std@@YA$$QEAURESULT@CDB@@AEAU12@@Z ENDP ; std::move<CDB::RESULT & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@URESULT@CDB@@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@URESULT@CDB@@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::destroy<CDB::RESULT>, COMDAT

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	0
??$destroy@URESULT@CDB@@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::destroy<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VTRI@CDB@@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@VTRI@CDB@@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::destroy<CDB::TRI>, COMDAT

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	0
??$destroy@VTRI@CDB@@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::destroy<CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z PROC ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
	sub	rsp, 56					; 00000038H

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	call	??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>

; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAURESULT@CDB@@PEAU12@U?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@@Z ENDP ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,std::_Wrap_alloc<xalloc<CDB::RESULT> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@URESULT@CDB@@@@QEAAXPEAURESULT@CDB@@AEBU23@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
_Val$ = 24
?construct@?$xalloc@URESULT@CDB@@@@QEAAXPEAURESULT@CDB@@AEBU23@@Z PROC ; xalloc<CDB::RESULT>::construct, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN5@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
$LN5@construct:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	std::_Construct(p, _Val);	}

	ret	0
?construct@?$xalloc@URESULT@CDB@@@@QEAAXPEAURESULT@CDB@@AEBU23@@Z ENDP ; xalloc<CDB::RESULT>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAPEBURESULT@CDB@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAPEBURESULT@CDB@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Unchecked, COMDAT

; 61   : 		return (_Unchecked_type(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 62   : 		}

	ret	0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@URESULT@CDB@@@std@@@std@@@std@@QEBAPEBURESULT@CDB@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::RESULT> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAPEBU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAPEBU?$_vector3@M@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Unchecked, COMDAT

; 61   : 		return (_Unchecked_type(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 62   : 		}

	ret	0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAPEBU?$_vector3@M@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAPEBVTRI@CDB@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAPEBVTRI@CDB@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Unchecked, COMDAT

; 61   : 		return (_Unchecked_type(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 62   : 		}

	ret	0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAPEBVTRI@CDB@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@U?$_vector3@M@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBU?$_vector3@M@@PEAU2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@U?$_vector3@M@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBU?$_vector3@M@@PEAU2@@Z PROC ; std::_Ptr_cat<_vector3<float>,_vector3<float> >, COMDAT

; 453  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 454  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 455  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 456  : 	}

	ret	0
??$_Ptr_cat@U?$_vector3@M@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBU?$_vector3@M@@PEAU2@@Z ENDP ; std::_Ptr_cat<_vector3<float>,_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_cop:

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_cop
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_cop
	movsdx	xmm0, QWORD PTR [rcx]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r8+8], eax
$LN30@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 12
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 12
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_cop
$LN4@Uninit_cop:

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

	mov	rax, r8

; 385  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_cop:
??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >'::`1'::catch$0

; 379  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_copy@PEBU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEBU1@0PEAU1@AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_copy<_vector3<float> const * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_cop:

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_cop
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_cop
	movsdx	xmm0, QWORD PTR [rcx]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r8+8], eax
$LN30@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 12
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 12
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_cop
$LN4@Uninit_cop:

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

	mov	rax, r8

; 385  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_cop:
??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >'::`1'::catch$0

; 379  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_copy@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_copy<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> > >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@URESULT@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBURESULT@CDB@@PEAU23@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@URESULT@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBURESULT@CDB@@PEAU23@@Z PROC ; std::_Ptr_cat<CDB::RESULT,CDB::RESULT>, COMDAT

; 453  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 454  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 455  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 456  : 	}

	ret	0
??$_Ptr_cat@URESULT@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBURESULT@CDB@@PEAU23@@Z ENDP ; std::_Ptr_cat<CDB::RESULT,CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_cop:

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_cop
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_cop
	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [r8+16], xmm1
	movups	xmm0, XMMWORD PTR [rcx+32]
	movups	XMMWORD PTR [r8+32], xmm0
	movups	xmm1, XMMWORD PTR [rcx+48]
	movups	XMMWORD PTR [r8+48], xmm1
$LN30@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 64					; 00000040H
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 64					; 00000040H
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_cop
$LN4@Uninit_cop:

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

	mov	rax, r8

; 385  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_cop:
??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >'::`1'::catch$0

; 379  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_copy@PEBURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEBU12@0PEAU12@AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_copy<CDB::RESULT const * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_cop:

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_cop
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_cop
	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [r8+16], xmm1
	movups	xmm0, XMMWORD PTR [rcx+32]
	movups	XMMWORD PTR [r8+32], xmm0
	movups	xmm1, XMMWORD PTR [rcx+48]
	movups	XMMWORD PTR [r8+48], xmm1
$LN30@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 64					; 00000040H
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 64					; 00000040H
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_cop
$LN4@Uninit_cop:

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

	mov	rax, r8

; 385  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_cop:
??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >'::`1'::catch$0

; 379  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_copy@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_copy<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@VTRI@CDB@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBVTRI@CDB@@PEAV23@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@VTRI@CDB@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBVTRI@CDB@@PEAV23@@Z PROC ; std::_Ptr_cat<CDB::TRI,CDB::TRI>, COMDAT

; 453  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 454  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 455  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 456  : 	}

	ret	0
??$_Ptr_cat@VTRI@CDB@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEBVTRI@CDB@@PEAV23@@Z ENDP ; std::_Ptr_cat<CDB::TRI,CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_cop:

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_cop
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_cop
	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [r8], xmm0
	movsdx	xmm1, QWORD PTR [rcx+16]
	movsdx	QWORD PTR [r8+16], xmm1
$LN30@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 24
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 24
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_cop
$LN4@Uninit_cop:

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

	mov	rax, r8

; 385  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_cop:
??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >'::`1'::catch$0

; 379  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_copy@PEBVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEBV12@0PEAV12@AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_copy<CDB::TRI const * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >, COMDAT

; 371  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_cop:

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_cop
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_cop
	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [r8], xmm0
	movsdx	xmm1, QWORD PTR [rcx+16]
	movsdx	QWORD PTR [r8+16], xmm1
$LN30@Uninit_cop:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 377  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 24
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 24
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_cop
$LN4@Uninit_cop:

; 378  : 		_Al.construct(_Dest, *_First);
; 379  : 	_CATCH_ALL
; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;
; 383  : 	_CATCH_END
; 384  : 	return (_Dest);

	mov	rax, r8

; 385  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_cop:
??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >'::`1'::catch$0

; 379  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 380  : 	for (; _Next != _Dest; ++_Next)
; 381  : 		_Al.destroy(_Next);
; 382  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_copy@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_copy<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$_vector3@M@@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@U?$_vector3@M@@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@@Z PROC ; std::allocator_traits<xalloc<_vector3<float> > >::destroy<_vector3<float> >, COMDAT

; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}

	ret	0
??$destroy@U?$_vector3@M@@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@@Z ENDP ; std::allocator_traits<xalloc<_vector3<float> > >::destroy<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@URESULT@CDB@@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@URESULT@CDB@@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@@Z PROC ; std::allocator_traits<xalloc<CDB::RESULT> >::destroy<CDB::RESULT>, COMDAT

; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}

	ret	0
??$destroy@URESULT@CDB@@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@@Z ENDP ; std::allocator_traits<xalloc<CDB::RESULT> >::destroy<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@VTRI@CDB@@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@VTRI@CDB@@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@@Z PROC ; std::allocator_traits<xalloc<CDB::TRI> >::destroy<CDB::TRI>, COMDAT

; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}

	ret	0
??$destroy@VTRI@CDB@@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@@Z ENDP ; std::allocator_traits<xalloc<CDB::TRI> >::destroy<CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAURESULT@CDB@@@std@@YAPEAURESULT@CDB@@PEAU12@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAURESULT@CDB@@@std@@YAPEAURESULT@CDB@@PEAU12@@Z PROC ; std::_Val_type<CDB::RESULT * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAURESULT@CDB@@@std@@YAPEAURESULT@CDB@@PEAU12@@Z ENDP ; std::_Val_type<CDB::RESULT * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [rcx+16]
	movups	XMMWORD PTR [r8+16], xmm1
	movups	xmm0, XMMWORD PTR [rcx+32]
	movups	XMMWORD PTR [r8+32], xmm0
	movups	xmm1, XMMWORD PTR [rcx+48]
	movups	XMMWORD PTR [r8+48], xmm1
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 64					; 00000040H
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 64					; 00000040H
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAURESULT@CDB@@PEAU12@V?$xalloc@URESULT@CDB@@@@U12@@std@@YAPEAURESULT@CDB@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<CDB::RESULT * __ptr64,CDB::RESULT * __ptr64,xalloc<CDB::RESULT>,CDB::RESULT>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Construct@URESULT@CDB@@AEBU12@@std@@YAXPEAURESULT@CDB@@AEBU12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Val$ = 16
??$_Construct@URESULT@CDB@@AEBU12@@std@@YAXPEAURESULT@CDB@@AEBU12@@Z PROC ; std::_Construct<CDB::RESULT,CDB::RESULT const & __ptr64>, COMDAT

; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN3@Construct
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movups	xmm1, XMMWORD PTR [rdx+16]
	movups	XMMWORD PTR [rcx+16], xmm1
	movups	xmm0, XMMWORD PTR [rdx+32]
	movups	XMMWORD PTR [rcx+32], xmm0
	movups	xmm1, XMMWORD PTR [rdx+48]
	movups	XMMWORD PTR [rcx+48], xmm1
$LN3@Construct:

; 41   : 	}

	ret	0
??$_Construct@URESULT@CDB@@AEBU12@@std@@YAXPEAURESULT@CDB@@AEBU12@@Z ENDP ; std::_Construct<CDB::RESULT,CDB::RESULT const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$_vector3@M@@AEBU1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@AEBU2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$_vector3@M@@AEBU1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@AEBU2@@Z PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@U?$_vector3@M@@AEBU1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@AEBU2@@Z ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$_vector3@M@@AEAU1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@AEAU2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$_vector3@M@@AEAU1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@AEAU2@@Z PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@U?$_vector3@M@@AEAU1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@AEAU2@@Z ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@URESULT@CDB@@AEBU12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@AEBU23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@URESULT@CDB@@AEBU12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@AEBU23@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@URESULT@CDB@@AEBU12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@AEBU23@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@URESULT@CDB@@AEAU12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@AEAU23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@URESULT@CDB@@AEAU12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@AEAU23@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@URESULT@CDB@@AEAU12@@?$_Wrap_alloc@V?$xalloc@URESULT@CDB@@@@@std@@QEAAXPEAURESULT@CDB@@AEAU23@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VTRI@CDB@@AEBV12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@AEBV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VTRI@CDB@@AEBV12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@AEBV23@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@VTRI@CDB@@AEBV12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@AEBV23@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VTRI@CDB@@AEAV12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@AEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VTRI@CDB@@AEAV12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@AEAV23@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@VTRI@CDB@@AEAV12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@AEAV23@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$dead$ = 24
??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@@Z PROC ; std::_Alloc_destroy::_Fn<xalloc<_vector3<float> >,_vector3<float> >, COMDAT

; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}

	ret	0
??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@@Z ENDP ; std::_Alloc_destroy::_Fn<xalloc<_vector3<float> >,_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$dead$ = 24
??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@@Z PROC ; std::_Alloc_destroy::_Fn<xalloc<CDB::RESULT>,CDB::RESULT>, COMDAT

; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}

	ret	0
??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@@Z ENDP ; std::_Alloc_destroy::_Fn<xalloc<CDB::RESULT>,CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$dead$ = 24
??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@@Z PROC ; std::_Alloc_destroy::_Fn<xalloc<CDB::TRI>,CDB::TRI>, COMDAT

; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}

	ret	0
??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@@Z ENDP ; std::_Alloc_destroy::_Fn<xalloc<CDB::TRI>,CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEBURESULT@CDB@@@std@@YAAEBURESULT@CDB@@AEBU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBURESULT@CDB@@@std@@YAAEBURESULT@CDB@@AEBU12@@Z PROC ; std::forward<CDB::RESULT const & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEBURESULT@CDB@@@std@@YAAEBURESULT@CDB@@AEBU12@@Z ENDP ; std::forward<CDB::RESULT const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@U?$_vector3@M@@@@QEAAXPEAU?$_vector3@M@@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$dead$ = 16
?destroy@?$xalloc@U?$_vector3@M@@@@QEAAXPEAU?$_vector3@M@@@Z PROC ; xalloc<_vector3<float> >::destroy, COMDAT

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy(p);			}

	ret	0
?destroy@?$xalloc@U?$_vector3@M@@@@QEAAXPEAU?$_vector3@M@@@Z ENDP ; xalloc<_vector3<float> >::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@URESULT@CDB@@@@QEAAXPEAURESULT@CDB@@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$dead$ = 16
?destroy@?$xalloc@URESULT@CDB@@@@QEAAXPEAURESULT@CDB@@@Z PROC ; xalloc<CDB::RESULT>::destroy, COMDAT

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy(p);			}

	ret	0
?destroy@?$xalloc@URESULT@CDB@@@@QEAAXPEAURESULT@CDB@@@Z ENDP ; xalloc<CDB::RESULT>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@VTRI@CDB@@@@QEAAXPEAVTRI@CDB@@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$dead$ = 16
?destroy@?$xalloc@VTRI@CDB@@@@QEAAXPEAVTRI@CDB@@@Z PROC	; xalloc<CDB::TRI>::destroy, COMDAT

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy(p);			}

	ret	0
?destroy@?$xalloc@VTRI@CDB@@@@QEAAXPEAVTRI@CDB@@@Z ENDP	; xalloc<CDB::TRI>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEBU?$_vector3@M@@@std@@YAAEBU?$_vector3@M@@AEBU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBU?$_vector3@M@@@std@@YAAEBU?$_vector3@M@@AEBU1@@Z PROC ; std::forward<_vector3<float> const & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEBU?$_vector3@M@@@std@@YAAEBU?$_vector3@M@@AEBU1@@Z ENDP ; std::forward<_vector3<float> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$_vector3@M@@AEBU1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEBU3@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$_vector3@M@@AEBU1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEBU3@@Z PROC ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@U?$_vector3@M@@AEBU1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEBU3@@Z ENDP ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAU?$_vector3@M@@@std@@YAAEAU?$_vector3@M@@AEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAU?$_vector3@M@@@std@@YAAEAU?$_vector3@M@@AEAU1@@Z PROC ; std::forward<_vector3<float> & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAU?$_vector3@M@@@std@@YAAEAU?$_vector3@M@@AEAU1@@Z ENDP ; std::forward<_vector3<float> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$_vector3@M@@AEAU1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEAU3@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$_vector3@M@@AEAU1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEAU3@@Z PROC ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@U?$_vector3@M@@AEAU1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEAU3@@Z ENDP ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@URESULT@CDB@@AEBU12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEBU34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@URESULT@CDB@@AEBU12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEBU34@@Z PROC ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@URESULT@CDB@@AEBU12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEBU34@@Z ENDP ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAURESULT@CDB@@@std@@YAAEAURESULT@CDB@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAURESULT@CDB@@@std@@YAAEAURESULT@CDB@@AEAU12@@Z PROC ; std::forward<CDB::RESULT & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAURESULT@CDB@@@std@@YAAEAURESULT@CDB@@AEAU12@@Z ENDP ; std::forward<CDB::RESULT & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@URESULT@CDB@@AEAU12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEAU34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@URESULT@CDB@@AEAU12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEAU34@@Z PROC ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movups	xmm1, XMMWORD PTR [r8+16]
	movups	XMMWORD PTR [rdx+16], xmm1
	movups	xmm0, XMMWORD PTR [r8+32]
	movups	XMMWORD PTR [rdx+32], xmm0
	movups	xmm1, XMMWORD PTR [r8+48]
	movups	XMMWORD PTR [rdx+48], xmm1
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@URESULT@CDB@@AEAU12@@?$allocator_traits@V?$xalloc@URESULT@CDB@@@@@std@@SAXAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEAU34@@Z ENDP ; std::allocator_traits<xalloc<CDB::RESULT> >::construct<CDB::RESULT,CDB::RESULT & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEBVTRI@CDB@@@std@@YAAEBVTRI@CDB@@AEBV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBVTRI@CDB@@@std@@YAAEBVTRI@CDB@@AEBV12@@Z PROC ; std::forward<CDB::TRI const & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEBVTRI@CDB@@@std@@YAAEBVTRI@CDB@@AEBV12@@Z ENDP ; std::forward<CDB::TRI const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VTRI@CDB@@AEBV12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEBV34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VTRI@CDB@@AEBV12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEBV34@@Z PROC ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@VTRI@CDB@@AEBV12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEBV34@@Z ENDP ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAVTRI@CDB@@@std@@YAAEAVTRI@CDB@@AEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAVTRI@CDB@@@std@@YAAEAVTRI@CDB@@AEAV12@@Z PROC ; std::forward<CDB::TRI & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAVTRI@CDB@@@std@@YAAEAVTRI@CDB@@AEAV12@@Z ENDP ; std::forward<CDB::TRI & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VTRI@CDB@@AEAV12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEAV34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VTRI@CDB@@AEAV12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEAV34@@Z PROC ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@VTRI@CDB@@AEAV12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEAV34@@Z ENDP ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy@U?$_vector3@M@@@std@@YAXPEAU?$_vector3@M@@@Z
_TEXT	SEGMENT
_Ptr$dead$ = 8
??$_Destroy@U?$_vector3@M@@@std@@YAXPEAU?$_vector3@M@@@Z PROC ; std::_Destroy<_vector3<float> >, COMDAT

; 55   : 	_Ptr->~_Ty();
; 56   : 	}

	ret	0
??$_Destroy@U?$_vector3@M@@@std@@YAXPEAU?$_vector3@M@@@Z ENDP ; std::_Destroy<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy@URESULT@CDB@@@std@@YAXPEAURESULT@CDB@@@Z
_TEXT	SEGMENT
_Ptr$dead$ = 8
??$_Destroy@URESULT@CDB@@@std@@YAXPEAURESULT@CDB@@@Z PROC ; std::_Destroy<CDB::RESULT>, COMDAT

; 55   : 	_Ptr->~_Ty();
; 56   : 	}

	ret	0
??$_Destroy@URESULT@CDB@@@std@@YAXPEAURESULT@CDB@@@Z ENDP ; std::_Destroy<CDB::RESULT>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy@VTRI@CDB@@@std@@YAXPEAVTRI@CDB@@@Z
_TEXT	SEGMENT
_Ptr$dead$ = 8
??$_Destroy@VTRI@CDB@@@std@@YAXPEAVTRI@CDB@@@Z PROC	; std::_Destroy<CDB::TRI>, COMDAT

; 55   : 	_Ptr->~_Ty();
; 56   : 	}

	ret	0
??$_Destroy@VTRI@CDB@@@std@@YAXPEAVTRI@CDB@@@Z ENDP	; std::_Destroy<CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@AEBU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEBU3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@AEBU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEBU3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movsdx	xmm0, QWORD PTR [r9]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [r9+8]
	mov	DWORD PTR [r8+8], eax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@AEBU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEBU3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@AEAU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEAU3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@AEAU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEAU3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movsdx	xmm0, QWORD PTR [r9]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [r9+8]
	mov	DWORD PTR [r8+8], eax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@AEAU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@AEAU3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@AEBU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEBU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@AEBU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEBU34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [r9+16]
	movups	XMMWORD PTR [r8+16], xmm1
	movups	xmm0, XMMWORD PTR [r9+32]
	movups	XMMWORD PTR [r8+32], xmm0
	movups	xmm1, XMMWORD PTR [r9+48]
	movups	XMMWORD PTR [r8+48], xmm1
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@AEBU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEBU34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@AEAU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@AEAU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEAU34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [r8], xmm0
	movups	xmm1, XMMWORD PTR [r9+16]
	movups	XMMWORD PTR [r8+16], xmm1
	movups	xmm0, XMMWORD PTR [r9+32]
	movups	XMMWORD PTR [r8+32], xmm0
	movups	xmm1, XMMWORD PTR [r9+48]
	movups	XMMWORD PTR [r8+48], xmm1
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@URESULT@CDB@@@@URESULT@CDB@@AEAU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@URESULT@CDB@@@@PEAURESULT@CDB@@AEAU34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CDB::RESULT>,CDB::RESULT,CDB::RESULT & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@AEBV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEBV34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@AEBV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEBV34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [r8], xmm0
	movsdx	xmm1, QWORD PTR [r9+16]
	movsdx	QWORD PTR [r8+16], xmm1
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@AEBV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEBV34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@AEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEAV34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@AEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEAV34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [r8], xmm0
	movsdx	xmm1, QWORD PTR [r9+16]
	movsdx	QWORD PTR [r8+16], xmm1
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@AEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@AEAV34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@U?$_vector3@M@@@@QEAAXPEAU?$_vector3@M@@AEBU2@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
_Val$ = 24
?construct@?$xalloc@U?$_vector3@M@@@@QEAAXPEAU?$_vector3@M@@AEBU2@@Z PROC ; xalloc<_vector3<float> >::construct, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN5@construct
	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
$LN5@construct:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	std::_Construct(p, _Val);	}

	ret	0
?construct@?$xalloc@U?$_vector3@M@@@@QEAAXPEAU?$_vector3@M@@AEBU2@@Z ENDP ; xalloc<_vector3<float> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@VTRI@CDB@@@@QEAAXPEAVTRI@CDB@@AEBV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
_Val$ = 24
?construct@?$xalloc@VTRI@CDB@@@@QEAAXPEAVTRI@CDB@@AEBV23@@Z PROC ; xalloc<CDB::TRI>::construct, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN5@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
$LN5@construct:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	std::_Construct(p, _Val);	}

	ret	0
?construct@?$xalloc@VTRI@CDB@@@@QEAAXPEAVTRI@CDB@@AEBV23@@Z ENDP ; xalloc<CDB::TRI>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Construct@U?$_vector3@M@@AEBU1@@std@@YAXPEAU?$_vector3@M@@AEBU1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Val$ = 16
??$_Construct@U?$_vector3@M@@AEBU1@@std@@YAXPEAU?$_vector3@M@@AEBU1@@Z PROC ; std::_Construct<_vector3<float>,_vector3<float> const & __ptr64>, COMDAT

; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN3@Construct
	movsdx	xmm0, QWORD PTR [rdx]
	movsdx	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
$LN3@Construct:

; 41   : 	}

	ret	0
??$_Construct@U?$_vector3@M@@AEBU1@@std@@YAXPEAU?$_vector3@M@@AEBU1@@Z ENDP ; std::_Construct<_vector3<float>,_vector3<float> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Construct@VTRI@CDB@@AEBV12@@std@@YAXPEAVTRI@CDB@@AEBV12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Val$ = 16
??$_Construct@VTRI@CDB@@AEBV12@@std@@YAXPEAVTRI@CDB@@AEBV12@@Z PROC ; std::_Construct<CDB::TRI,CDB::TRI const & __ptr64>, COMDAT

; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN3@Construct
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rcx], xmm0
	movsdx	xmm1, QWORD PTR [rdx+16]
	movsdx	QWORD PTR [rcx+16], xmm1
$LN3@Construct:

; 41   : 	}

	ret	0
??$_Construct@VTRI@CDB@@AEBV12@@std@@YAXPEAVTRI@CDB@@AEBV12@@Z ENDP ; std::_Construct<CDB::TRI,CDB::TRI const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 55   : 		}

	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtr1common
;	COMDAT ??0_Wrap_int@std@@QEAA@H@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0_Wrap_int@std@@QEAA@H@Z PROC				; std::_Wrap_int::_Wrap_int, COMDAT

; 375  : 		{	// do nothing
; 376  : 		}

	mov	rax, rcx
	ret	0
??0_Wrap_int@std@@QEAA@H@Z ENDP				; std::_Wrap_int::_Wrap_int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.h
;	COMDAT ?GetUsedBytes@OPCODE_Model@Opcode@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?GetUsedBytes@OPCODE_Model@Opcode@@QEBAIXZ PROC		; Opcode::OPCODE_Model::GetUsedBytes, COMDAT

; 115  : 						udword				GetUsedBytes()	const	{ return mTree->GetUsedBytes();	}

	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx]
	rex_jmp	QWORD PTR [rax+8]
?GetUsedBytes@OPCODE_Model@Opcode@@QEBAIXZ ENDP		; Opcode::OPCODE_Model::GetUsedBytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ?strstr@@YAPEADPEADPEBD@Z
_TEXT	SEGMENT
_Str$ = 8
_SubStr$dead$ = 16
?strstr@@YAPEADPEADPEBD@Z PROC				; strstr, COMDAT

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_07JLJFPMN@?9mt_cdb?$AA@
	rex_jmp	QWORD PTR __imp_strstr
?strstr@@YAPEADPEADPEBD@Z ENDP				; strstr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI0AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI0AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<unsigned int> > >, COMDAT

; 90   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI0AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAI0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAI0@Z PROC ; std::_Ptr_cat<unsigned int,unsigned int>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@II@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAI0@Z ENDP ; std::_Ptr_cat<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI0AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI0AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<unsigned int> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI0AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@IV?$xalloc@I@@@std@@IEAAXPEAI0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@IV?$xalloc@I@@@std@@IEAAXPEAI0@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Destroy, COMDAT

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

	ret	0
?_Destroy@?$vector@IV?$xalloc@I@@@std@@IEAAXPEAI0@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_free@I@@YAXAEAPEAI@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@I@@YAXAEAPEAI@Z PROC				; xr_free<unsigned int>, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@xr_free
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx], 0
$LN1@xr_free:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_free@I@@YAXAEAPEAI@Z ENDP				; xr_free<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@I@@QEBAXPEAI_K@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
n$dead$ = 24
?deallocate@?$xalloc@I@@QEBAXPEAI_K@Z PROC		; xalloc<unsigned int>::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN3@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN3@deallocate:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	0
?deallocate@?$xalloc@I@@QEBAXPEAI_K@Z ENDP		; xalloc<unsigned int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI_K@Z PROC ; std::_Wrap_alloc<xalloc<unsigned int> >::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN5@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN5@deallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 859  : 		}

	ret	0
?deallocate@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI_K@Z ENDP ; std::_Wrap_alloc<xalloc<unsigned int> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@I@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xalloc@I@@QEAA@XZ PROC				; xalloc<unsigned int>::xalloc<unsigned int>, COMDAT

; 76   : 													xalloc			()										{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@I@@QEAA@XZ ENDP				; xalloc<unsigned int>::xalloc<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAA@XZ PROC	; std::_Wrap_alloc<xalloc<unsigned int> >::_Wrap_alloc<xalloc<unsigned int> >, COMDAT

; 802  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAA@XZ ENDP	; std::_Wrap_alloc<xalloc<unsigned int> >::_Wrap_alloc<xalloc<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$xalloc@I@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@I@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$xalloc@I@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@I@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >::_Getal, COMDAT

; 642  : 		return (_Alty());

	mov	rax, rdx

; 643  : 		}

	ret	0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$xalloc@I@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@I@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@IV?$xalloc@I@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@IV?$xalloc@I@@@std@@IEAAXXZ PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Tidy, COMDAT

; 1622 : 		{	// free all storage

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN1@Tidy:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$vector@IV?$xalloc@I@@@std@@IEAAXXZ ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@IV?$xalloc@I@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@IV?$xalloc@I@@@std@@QEAA@XZ PROC		; std::vector<unsigned int,xalloc<unsigned int> >::~vector<unsigned int,xalloc<unsigned int> >, COMDAT

; 944  : 		{	// destroy the object

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]

; 944  : 		{	// destroy the object

	mov	rbx, rcx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN3@vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN3@vector:

; 945  : 		_Tidy();
; 946  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$vector@IV?$xalloc@I@@@std@@QEAA@XZ ENDP		; std::vector<unsigned int,xalloc<unsigned int> >::~vector<unsigned int,xalloc<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ PROC		; xr_vector<unsigned int,xalloc<unsigned int> >::~xr_vector<unsigned int,xalloc<unsigned int> >, COMDAT
$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN5@xr_vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN5@xr_vector:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ ENDP		; xr_vector<unsigned int,xalloc<unsigned int> >::~xr_vector<unsigned int,xalloc<unsigned int> >
_TEXT	ENDS
END
