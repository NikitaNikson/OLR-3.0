; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

EPS_L	DD	03a83126fr			; 0.001
clpMZ	DD	018H
clpMY	DD	010H
clpMX	DD	018H
PUBLIC	??0?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ		; xr_vector<unsigned int,xalloc<unsigned int> >::xr_vector<unsigned int,xalloc<unsigned int> >
PUBLIC	??0?$vector@IV?$xalloc@I@@@std@@QEAA@XZ		; std::vector<unsigned int,xalloc<unsigned int> >::vector<unsigned int,xalloc<unsigned int> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$xalloc@I@@@std@@@std@@QEAA@AEBV?$xalloc@I@@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
PUBLIC	?iFloor@@YAHM@Z					; iFloor
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator!=
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Compat
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	?max_size@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEBA_KXZ ; std::_Wrap_alloc<xalloc<unsigned int> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$xalloc@I@@@std@@SA_KAEBV?$xalloc@I@@@Z ; std::allocator_traits<xalloc<unsigned int> >::max_size
PUBLIC	??$_Fn@V?$xalloc@I@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@I@@@Z ; std::_Alloc_max_size::_Fn<xalloc<unsigned int> >
PUBLIC	?max_size@?$xalloc@I@@QEBA_KXZ			; xalloc<unsigned int>::max_size
PUBLIC	??$_Fn@V?$xalloc@I@@II@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAI$$QEAI@Z ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int>
PUBLIC	??$_Destroy@I@std@@YAXPEAI@Z			; std::_Destroy<unsigned int>
PUBLIC	??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@V23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@$$QEAV34@@Z ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI>
PUBLIC	??$construct@II@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI$$QEAI@Z ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int>
PUBLIC	??$forward@I@std@@YA$$QEAIAEAI@Z		; std::forward<unsigned int>
PUBLIC	??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@U2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@$$QEAU3@@Z ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> >
PUBLIC	??$move@AEAUedge@CDB@@@std@@YA$$QEAUedge@CDB@@AEAU12@@Z ; std::move<CDB::edge & __ptr64>
PUBLIC	??$_Pop_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00$$QEAU12@Usort_predicate@2@PEA_J@Z ; std::_Pop_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
PUBLIC	?destroy@?$xalloc@I@@QEAAXPEAI@Z		; xalloc<unsigned int>::destroy
PUBLIC	??$_Fn@V?$xalloc@I@@I@_Alloc_destroy@std@@SAXHAEAV?$xalloc@I@@PEAI@Z ; std::_Alloc_destroy::_Fn<xalloc<unsigned int>,unsigned int>
PUBLIC	??$construct@VTRI@CDB@@V12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@$$QEAV34@@Z ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI>
PUBLIC	??$forward@VTRI@CDB@@@std@@YA$$QEAVTRI@CDB@@AEAV12@@Z ; std::forward<CDB::TRI>
PUBLIC	??$construct@II@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI$$QEAI@Z ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int>
PUBLIC	??$construct@U?$_vector3@M@@U1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@$$QEAU3@@Z ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> >
PUBLIC	??$forward@U?$_vector3@M@@@std@@YA$$QEAU?$_vector3@M@@AEAU1@@Z ; std::forward<_vector3<float> >
PUBLIC	??$_Move_backward@PEAUedge@CDB@@PEAU12@@std@@YAPEAUedge@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move_backward<CDB::edge * __ptr64,CDB::edge * __ptr64>
PUBLIC	??$_Ptr_cat@Uedge@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAUedge@CDB@@0@Z ; std::_Ptr_cat<CDB::edge,CDB::edge>
PUBLIC	??$_Pop_heap_0@PEAUedge@CDB@@U12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z ; std::_Pop_heap_0<CDB::edge * __ptr64,CDB::edge,CDB::sort_predicate>
PUBLIC	??$_Push_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z ; std::_Push_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
PUBLIC	??$destroy@I@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI@Z ; std::allocator_traits<xalloc<unsigned int> >::destroy<unsigned int>
PUBLIC	??$construct@VTRI@CDB@@V12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@$$QEAV23@@Z ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI>
PUBLIC	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
PUBLIC	??$construct@U?$_vector3@M@@U1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@$$QEAU2@@Z ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> >
PUBLIC	??$_Move_backward@PEAUedge@CDB@@PEAU12@@std@@YAPEAUedge@CDB@@PEAU12@00@Z ; std::_Move_backward<CDB::edge * __ptr64,CDB::edge * __ptr64>
PUBLIC	??$_Pop_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ; std::_Pop_heap<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z ; std::_Adjust_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
PUBLIC	??$_Move@AEAUedge@CDB@@@std@@YA$$QEAUedge@CDB@@AEAU12@@Z ; std::_Move<CDB::edge & __ptr64>
PUBLIC	??$forward@AEAPEAUedge@CDB@@@std@@YAAEAPEAUedge@CDB@@AEAPEAU12@@Z ; std::forward<CDB::edge * __ptr64 & __ptr64>
PUBLIC	??$swap@Uedge@CDB@@@std@@YAXAEAUedge@CDB@@0@Z	; std::swap<CDB::edge>
PUBLIC	??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ; std::_Med3<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	??$_Construct@IAEBI@std@@YAXPEAIAEBI@Z		; std::_Construct<unsigned int,unsigned int const & __ptr64>
PUBLIC	??$destroy@I@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI@Z ; std::_Wrap_alloc<xalloc<unsigned int> >::destroy<unsigned int>
PUBLIC	??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>
PUBLIC	??$_Val_type@PEAVTRI@CDB@@@std@@YAPEAVTRI@CDB@@PEAV12@@Z ; std::_Val_type<CDB::TRI * __ptr64>
PUBLIC	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
PUBLIC	??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >
PUBLIC	??$_Val_type@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z ; std::_Val_type<_vector3<float> * __ptr64>
PUBLIC	??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z ; std::_Insertion_sort1<CDB::edge * __ptr64,CDB::sort_predicate,CDB::edge>
PUBLIC	??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ; std::_Sort_heap<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z ; std::_Make_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
PUBLIC	??$_Val_type@PEAUedge@CDB@@@std@@YAPEAUedge@CDB@@PEAU12@@Z ; std::_Val_type<CDB::edge * __ptr64>
PUBLIC	??$_Dist_type@PEAUedge@CDB@@@std@@YAPEA_JPEAUedge@CDB@@@Z ; std::_Dist_type<CDB::edge * __ptr64>
PUBLIC	??$?0AEAPEAUedge@CDB@@AEAPEAU01@X@?$pair@PEAUedge@CDB@@PEAU12@@std@@QEAA@AEAPEAUedge@CDB@@0@Z ; std::pair<CDB::edge * __ptr64,CDB::edge * __ptr64>::pair<CDB::edge * __ptr64,CDB::edge * __ptr64><CDB::edge * __ptr64 & __ptr64,CDB::edge * __ptr64 & __ptr64,void>
PUBLIC	??$iter_swap@PEAUedge@CDB@@PEAU12@@std@@YAXPEAUedge@CDB@@0@Z ; std::iter_swap<CDB::edge * __ptr64,CDB::edge * __ptr64>
PUBLIC	??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ; std::_Median<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	?construct@?$xalloc@I@@QEAAXPEAIAEBI@Z		; xalloc<unsigned int>::construct
PUBLIC	??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>
PUBLIC	??$_Uninit_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
PUBLIC	??$_Rechecked@PEAIPEAI@std@@YAAEAPEAIAEAPEAIPEAI@Z ; std::_Rechecked<unsigned int * __ptr64,unsigned int * __ptr64>
PUBLIC	??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >
PUBLIC	??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
PUBLIC	??$_Fn@V?$xalloc@I@@IAEBI@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAIAEBI@Z ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int const & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@I@@IAEAI@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAIAEAI@Z ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int & __ptr64>
PUBLIC	??$_Insertion_sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ; std::_Insertion_sort<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	??$sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ; std::sort_heap<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	??$make_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ; std::make_heap<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	??$_Unguarded_partition@PEAUedge@CDB@@Usort_predicate@2@@std@@YA?AU?$pair@PEAUedge@CDB@@PEAU12@@0@PEAUedge@CDB@@0Usort_predicate@3@@Z ; std::_Unguarded_partition<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>
PUBLIC	??$_Val_type@PEAI@std@@YAPEAIPEAI@Z		; std::_Val_type<unsigned int * __ptr64>
PUBLIC	??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<unsigned int * __ptr64,unsigned int * __ptr64>
PUBLIC	??$_Fill@PEAII@std@@YAXPEAI0AEBI@Z		; std::_Fill<unsigned int * __ptr64,unsigned int>
PUBLIC	??$_Unchecked@PEAI@std@@YAPEAIPEAI@Z		; std::_Unchecked<unsigned int * __ptr64>
PUBLIC	??$_Uninitialized_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ; std::_Uninitialized_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
PUBLIC	??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ; std::_Uninitialized_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >
PUBLIC	??$_Uninitialized_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ; std::_Uninitialized_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
PUBLIC	??$construct@IAEBI@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAIAEBI@Z ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int const & __ptr64>
PUBLIC	??$forward@AEBI@std@@YAAEBIAEBI@Z		; std::forward<unsigned int const & __ptr64>
PUBLIC	??$construct@IAEAI@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAIAEAI@Z ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int & __ptr64>
PUBLIC	??$forward@AEAI@std@@YAAEAIAEAI@Z		; std::forward<unsigned int & __ptr64>
PUBLIC	??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z ; std::_Sort<CDB::edge * __ptr64,__int64,CDB::sort_predicate>
PUBLIC	??$_Unchecked@PEAUedge@CDB@@@std@@YAPEAUedge@CDB@@PEAU12@@Z ; std::_Unchecked<CDB::edge * __ptr64>
PUBLIC	??$_Move@AEAG@std@@YA$$QEAGAEAG@Z		; std::_Move<unsigned short & __ptr64>
PUBLIC	??$_Uninitialized_fill_n@PEAI_KIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ; std::_Uninitialized_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,std::_Wrap_alloc<xalloc<unsigned int> > >
PUBLIC	??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00@Z	; std::_Copy_backward<unsigned int * __ptr64,unsigned int * __ptr64>
PUBLIC	??$fill@PEAII@std@@YAXPEAI0AEBI@Z		; std::fill<unsigned int * __ptr64,unsigned int>
PUBLIC	??$addressof@I@std@@YAPEAIAEAI@Z		; std::addressof<unsigned int>
PUBLIC	??$_Umove@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Umove<CDB::TRI * __ptr64>
PUBLIC	??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Umove<unsigned int * __ptr64>
PUBLIC	??$addressof@U?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@AEAU1@@Z ; std::addressof<_vector3<float> >
PUBLIC	??$_Umove@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Umove<_vector3<float> * __ptr64>
PUBLIC	??$addressof@$$CBVTRI@CDB@@@std@@YAPEBVTRI@CDB@@AEBV12@@Z ; std::addressof<CDB::TRI const >
PUBLIC	??$construct@IAEBI@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAIAEBI@Z ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int const & __ptr64>
PUBLIC	??$construct@IAEAI@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAIAEAI@Z ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int & __ptr64>
PUBLIC	??$addressof@$$CBI@std@@YAPEBIAEBI@Z		; std::addressof<unsigned int const >
PUBLIC	??$addressof@$$CBU?$_vector3@M@@@std@@YAPEBU?$_vector3@M@@AEBU1@@Z ; std::addressof<_vector3<float> const >
PUBLIC	??$clamp@I@@YAXAEAIAEBI1@Z			; clamp<unsigned int>
PUBLIC	??$sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ; std::sort<CDB::edge * __ptr64,CDB::sort_predicate>
PUBLIC	??$swap@G@std@@YAXAEAG0@Z			; std::swap<unsigned short>
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+=
PUBLIC	?_Ufill@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI_KPEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Ufill
PUBLIC	?allocate@?$xalloc@I@@QEBAPEAI_KPEBX@Z		; xalloc<unsigned int>::allocate
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-=
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Compat
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+=
PUBLIC	?_Grow_to@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBA_K_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Grow_to
PUBLIC	?_Unused_capacity@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Unused_capacity
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++
PUBLIC	?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n
PUBLIC	?_Grow_to@?$vector@IV?$xalloc@I@@@std@@IEBA_K_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Grow_to
PUBLIC	?size@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ	; std::vector<unsigned int,xalloc<unsigned int> >::size
PUBLIC	?_Unused_capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ ; std::vector<unsigned int,xalloc<unsigned int> >::_Unused_capacity
PUBLIC	?_Grow_to@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBA_K_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Grow_to
PUBLIC	?_Unused_capacity@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Unused_capacity
PUBLIC	?allocate@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAPEAI_K@Z ; std::_Wrap_alloc<xalloc<unsigned int> >::allocate
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Compat
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator==
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator==
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_JAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator-
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++
PUBLIC	?_Orphan_range@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXPEAVTRI@CDB@@0@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
PUBLIC	?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate
PUBLIC	?_Inside@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBA_NPEBVTRI@CDB@@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Inside
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEBIXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++
PUBLIC	?_Orphan_range@?$vector@IV?$xalloc@I@@@std@@IEBAXPEAI0@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Orphan_range
PUBLIC	?_Xlen@?$vector@IV?$xalloc@I@@@std@@IEBAXXZ	; std::vector<unsigned int,xalloc<unsigned int> >::_Xlen
PUBLIC	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
PUBLIC	?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
PUBLIC	?_Inside@?$vector@IV?$xalloc@I@@@std@@IEBA_NPEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Inside
PUBLIC	?clear@?$vector@IV?$xalloc@I@@@std@@QEAAXXZ	; std::vector<unsigned int,xalloc<unsigned int> >::clear
PUBLIC	?insert@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::insert
PUBLIC	?max_size@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ	; std::vector<unsigned int,xalloc<unsigned int> >::max_size
PUBLIC	?capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ	; std::vector<unsigned int,xalloc<unsigned int> >::capacity
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$_vector3@M@@@std@@SAPEAU?$_vector3@M@@AEAU3@@Z ; std::pointer_traits<_vector3<float> * __ptr64>::pointer_to
PUBLIC	?_Orphan_range@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXPEAU?$_vector3@M@@0@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Orphan_range
PUBLIC	?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reserve
PUBLIC	?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate
PUBLIC	?_Inside@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBA_NPEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Inside
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator!=
PUBLIC	??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_JAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator++
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator!=
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_JAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator-
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAPEAU?$_vector3@M@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator->
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
PUBLIC	?pop_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXXZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::pop_back
PUBLIC	?push_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXAEBVTRI@CDB@@@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::push_back
PUBLIC	?back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAVTRI@CDB@@XZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::back
PUBLIC	?end@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::end
PUBLIC	?reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::reserve
PUBLIC	??A?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAVTRI@CDB@@_K@Z ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::operator[]
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEAIXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
PUBLIC	?assign@?$vector@IV?$xalloc@I@@@std@@QEAAX_KAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::assign
PUBLIC	?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::push_back
PUBLIC	?end@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,xalloc<unsigned int> >::end
PUBLIC	?begin@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,xalloc<unsigned int> >::begin
PUBLIC	?reserve@?$vector@IV?$xalloc@I@@@std@@QEAAX_K@Z	; std::vector<unsigned int,xalloc<unsigned int> >::reserve
PUBLIC	??A?$xr_vector@IV?$xalloc@I@@@@QEAAAEAI_K@Z	; xr_vector<unsigned int,xalloc<unsigned int> >::operator[]
PUBLIC	?clear_and_free@?$xr_vector@IV?$xalloc@I@@@@QEAAXXZ ; xr_vector<unsigned int,xalloc<unsigned int> >::clear_and_free
PUBLIC	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back
PUBLIC	?end@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::end
PUBLIC	?reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::reserve
PUBLIC	??A?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAU?$_vector3@M@@_K@Z ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::operator[]
PUBLIC	?clear@CollectorPacked@CDB@@QEAAXXZ		; CDB::CollectorPacked::clear
PUBLIC	?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z ; CDB::CollectorPacked::VPack
PUBLIC	?add_face_D@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z ; CDB::CollectorPacked::add_face_D
PUBLIC	?add_face@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z ; CDB::CollectorPacked::add_face
PUBLIC	??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z ; CDB::CollectorPacked::CollectorPacked
PUBLIC	?remove_duplicate_T@Collector@CDB@@QEAAXXZ	; CDB::Collector::remove_duplicate_T
PUBLIC	?similar@CDB@@YAHAEAVTRI@1@0@Z			; CDB::similar
PUBLIC	?calc_adjacency@Collector@CDB@@QEAAXAEAV?$xr_vector@IV?$xalloc@I@@@@@Z ; CDB::Collector::calc_adjacency
PUBLIC	??Rsort_predicate@CDB@@QEBA_NAEBUedge@1@0@Z	; CDB::sort_predicate::operator()
PUBLIC	?add_face_packed_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_KM@Z ; CDB::Collector::add_face_packed_D
PUBLIC	?add_face_packed@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GGM@Z ; CDB::Collector::add_face_packed
PUBLIC	?add_face@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z ; CDB::Collector::add_face
PUBLIC	?add_face_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z ; CDB::Collector::add_face_D
PUBLIC	?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z ; CDB::Collector::VPack
PUBLIC	??0non_copyable@CDB@@QEAA@XZ			; CDB::non_copyable::non_copyable
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00$$QEAU12@Usort_predicate@2@PEA_J@Z DD imagerel $LN8
	DD	imagerel $LN8+41
	DD	imagerel $unwind$??$_Pop_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00$$QEAU12@Usort_predicate@2@PEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap_0@PEAUedge@CDB@@U12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z DD imagerel $LN16
	DD	imagerel $LN16+61
	DD	imagerel $unwind$??$_Pop_heap_0@PEAUedge@CDB@@U12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Push_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z DD imagerel $LN25
	DD	imagerel $LN25+145
	DD	imagerel $unwind$??$_Push_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+59
	DD	imagerel $unwind$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Pop_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD imagerel $LN24
	DD	imagerel $LN24+56
	DD	imagerel $unwind$??$_Pop_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z DD imagerel $LN50
	DD	imagerel $LN50+294
	DD	imagerel $unwind$??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+72
	DD	imagerel $unwind$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+70
	DD	imagerel $unwind$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z DD imagerel $LN57
	DD	imagerel $LN57+34
	DD	imagerel $unwind$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z DD imagerel $LN57+34
	DD	imagerel $LN57+299
	DD	imagerel $chain$1$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z DD imagerel $LN57+299
	DD	imagerel $LN57+301
	DD	imagerel $chain$2$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD imagerel $LN33
	DD	imagerel $LN33+30
	DD	imagerel $unwind$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD imagerel $LN33+30
	DD	imagerel $LN33+138
	DD	imagerel $chain$2$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD imagerel $LN33+138
	DD	imagerel $LN33+145
	DD	imagerel $chain$3$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z DD imagerel $LN61
	DD	imagerel $LN61+47
	DD	imagerel $unwind$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z DD imagerel $LN61+47
	DD	imagerel $LN61+370
	DD	imagerel $chain$1$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z DD imagerel $LN61+370
	DD	imagerel $LN61+377
	DD	imagerel $chain$2$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z DD imagerel $LN6+43
	DD	imagerel $LN6+202
	DD	imagerel $chain$3$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z DD imagerel $LN6+202
	DD	imagerel $LN6+216
	DD	imagerel $chain$4$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+55
	DD	imagerel $unwind$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insertion_sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD imagerel $LN6
	DD	imagerel $LN6+14
	DD	imagerel $unwind$??$_Insertion_sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$make_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD imagerel $LN13
	DD	imagerel $LN13+30
	DD	imagerel $unwind$??$make_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Unguarded_partition@PEAUedge@CDB@@Usort_predicate@2@@std@@YA?AU?$pair@PEAUedge@CDB@@PEAU12@@0@PEAUedge@CDB@@0Usort_predicate@3@@Z DD imagerel $LN210
	DD	imagerel $LN210+890
	DD	imagerel $unwind$??$_Unguarded_partition@PEAUedge@CDB@@Usort_predicate@2@@std@@YA?AU?$pair@PEAUedge@CDB@@PEAU12@@0@PEAUedge@CDB@@0Usort_predicate@3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z DD imagerel $LN39
	DD	imagerel $LN39+305
	DD	imagerel $unwind$??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_fill_n@PEAI_KIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninitialized_fill_n@PEAI_KIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00@Z DD imagerel $LN8
	DD	imagerel $LN8+48
	DD	imagerel $unwind$??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z DD imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??$_Umove@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z DD imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??$_Umove@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD imagerel $LN8
	DD	imagerel $LN8+31
	DD	imagerel $unwind$??$sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ufill@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI_KPEBI@Z DD imagerel $LN12
	DD	imagerel $LN12+45
	DD	imagerel $unwind$?_Ufill@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI_KPEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD imagerel $LN254
	DD	imagerel $LN254+688
	DD	imagerel $unwind$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA DD imagerel ?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA+45
	DD	imagerel $unwind$?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA DD imagerel ?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA+23
	DD	imagerel $unwind$?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD imagerel $LN47
	DD	imagerel $LN47+208
	DD	imagerel $unwind$?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD imagerel $LN58
	DD	imagerel $LN58+193
	DD	imagerel $unwind$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA+45
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@IV?$xalloc@I@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@IV?$xalloc@I@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD imagerel $LN47
	DD	imagerel $LN47+140
	DD	imagerel $unwind$?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD imagerel $LN60
	DD	imagerel $LN60+152
	DD	imagerel $unwind$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA+45
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$?insert@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD imagerel $LN47
	DD	imagerel $LN47+205
	DD	imagerel $unwind$?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD imagerel $LN58
	DD	imagerel $LN58+192
	DD	imagerel $unwind$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA+45
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXAEBVTRI@CDB@@@Z DD imagerel $LN70
	DD	imagerel $LN70+168
	DD	imagerel $unwind$?push_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXAEBVTRI@CDB@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+92
	DD	imagerel $unwind$?reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$vector@IV?$xalloc@I@@@std@@QEAAX_KAEBI@Z DD imagerel $LN18
	DD	imagerel $LN18+37
	DD	imagerel $unwind$?assign@?$vector@IV?$xalloc@I@@@std@@QEAAX_KAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z DD imagerel $LN69
	DD	imagerel $LN69+130
	DD	imagerel $unwind$?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$vector@IV?$xalloc@I@@@std@@QEAAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+63
	DD	imagerel $unwind$?reserve@?$vector@IV?$xalloc@I@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z DD imagerel $LN70
	DD	imagerel $LN70+182
	DD	imagerel $unwind$?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAX_K@Z DD imagerel $LN24
	DD	imagerel $LN24+91
	DD	imagerel $unwind$?reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAX_K@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z DD imagerel $LN689
	DD	imagerel $LN689+610
	DD	imagerel $unwind$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z
$pdata$1$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z DD imagerel $LN689+610
	DD	imagerel $LN689+2195
	DD	imagerel $chain$1$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z
$pdata$2$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z DD imagerel $LN689+2195
	DD	imagerel $LN689+2213
	DD	imagerel $chain$2$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z
$pdata$?add_face_D@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z DD imagerel $LN72
	DD	imagerel $LN72+252
	DD	imagerel $unwind$?add_face_D@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z
$pdata$?add_face@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z DD imagerel $LN72
	DD	imagerel $LN72+291
	DD	imagerel $unwind$?add_face@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z
$pdata$??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z DD imagerel $LN149
	DD	imagerel $LN149+476
	DD	imagerel $unwind$??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z
$pdata$0$??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z DD imagerel $LN149+476
	DD	imagerel $LN149+692
	DD	imagerel $chain$0$??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z
$pdata$?remove_duplicate_T@Collector@CDB@@QEAAXXZ DD imagerel $LN123
	DD	imagerel $LN123+60
	DD	imagerel $unwind$?remove_duplicate_T@Collector@CDB@@QEAAXXZ
$pdata$2$?remove_duplicate_T@Collector@CDB@@QEAAXXZ DD imagerel $LN123+60
	DD	imagerel $LN123+277
	DD	imagerel $chain$2$?remove_duplicate_T@Collector@CDB@@QEAAXXZ
$pdata$3$?remove_duplicate_T@Collector@CDB@@QEAAXXZ DD imagerel $LN123+277
	DD	imagerel $LN123+286
	DD	imagerel $chain$3$?remove_duplicate_T@Collector@CDB@@QEAAXXZ
$pdata$?calc_adjacency@Collector@CDB@@QEAAXAEAV?$xr_vector@IV?$xalloc@I@@@@@Z DD imagerel $LN164
	DD	imagerel $LN164+555
	DD	imagerel $unwind$?calc_adjacency@Collector@CDB@@QEAAXAEAV?$xr_vector@IV?$xalloc@I@@@@@Z
$pdata$?add_face_packed_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_KM@Z DD imagerel $LN72
	DD	imagerel $LN72+268
	DD	imagerel $unwind$?add_face_packed_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_KM@Z
$pdata$?add_face_packed@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GGM@Z DD imagerel $LN72
	DD	imagerel $LN72+316
	DD	imagerel $unwind$?add_face_packed@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GGM@Z
$pdata$?add_face@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z DD imagerel $LN84
	DD	imagerel $LN84+345
	DD	imagerel $unwind$?add_face@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z
$pdata$?add_face_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z DD imagerel $LN84
	DD	imagerel $LN84+303
	DD	imagerel $unwind$?add_face_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z
$pdata$?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z DD imagerel $LN96
	DD	imagerel $LN96+196
	DD	imagerel $unwind$?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z
xdata	SEGMENT
$unwind$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z DD 093801H
	DD	056838H
	DD	0e00de214H
	DD	07009d00bH
	DD	030076008H
	DD	05006H
$chain$1$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z DD 040d21H
	DD	0df40dH
	DD	0ec405H
	DD	imagerel $LN689
	DD	imagerel $LN689+610
	DD	imagerel $unwind$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z
$chain$2$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z DD 021H
	DD	imagerel $LN689
	DD	imagerel $LN689+610
	DD	imagerel $unwind$?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z
$unwind$?add_face_D@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
$unwind$?add_face@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
$unwind$??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z DD 0a1601H
	DD	0c5416H
	DD	0b3416H
	DD	0f0123216H
	DD	0d00ee010H
	DD	0600b700cH
$chain$0$??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z DD 020521H
	DD	0ac405H
	DD	imagerel $LN149
	DD	imagerel $LN149+476
	DD	imagerel $unwind$??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z
$unwind$?remove_duplicate_T@Collector@CDB@@QEAAXXZ DD 040901H
	DD	0f0053209H
	DD	050027003H
$chain$2$?remove_duplicate_T@Collector@CDB@@QEAAXXZ DD 060f21H
	DD	0ae40fH
	DD	09640aH
	DD	083405H
	DD	imagerel $LN123
	DD	imagerel $LN123+60
	DD	imagerel $unwind$?remove_duplicate_T@Collector@CDB@@QEAAXXZ
$chain$3$?remove_duplicate_T@Collector@CDB@@QEAAXXZ DD 021H
	DD	imagerel $LN123
	DD	imagerel $LN123+60
	DD	imagerel $unwind$?remove_duplicate_T@Collector@CDB@@QEAAXXZ
$unwind$?calc_adjacency@Collector@CDB@@QEAAXAEAV?$xr_vector@IV?$xalloc@I@@@@@Z DD 035092d01H
	DD	0e342dH
	DD	0520c3311H
	DD	0e006f008H
	DD	060037004H
	DD	05002H
$unwind$?add_face_packed_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_KM@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
$unwind$?add_face_packed@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GGM@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
$unwind$?add_face@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
$unwind$?add_face_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
$unwind$?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$vector@IV?$xalloc@I@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$vector@IV?$xalloc@I@@@std@@QEAAX_KAEBI@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXAEBVTRI@CDB@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z+67
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z+83
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD 081e19H
	DD	0d741eH
	DD	0c6419H
	DD	0a3414H
	DD	0e0027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z+63
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z+79
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 081e19H
	DD	0d741eH
	DD	0c6419H
	DD	0a3414H
	DD	0e0027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@IV?$xalloc@I@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z+67
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z+83
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD 081e19H
	DD	0d741eH
	DD	0c6419H
	DD	0a3414H
	DD	0e0027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD imagerel ?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
	DD	0ffffffffH
	DD	imagerel ?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z+220
	DD	00H
	DD	imagerel ?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z+301
	DD	0ffffffffH
	DD	imagerel ?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z+419
	DD	02H
	DD	imagerel ?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z+455
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA+13
	DD	01H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA+13
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$1$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$1$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
	DD	02H
	DD	imagerel $tryMap$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
	DD	09H
	DD	imagerel $ip2state$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
	DD	038H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z DD 0a2419H
	DD	0116424H
	DD	0f3420H
	DD	0f0107214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ufill@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI_KPEBI@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_fill_n@PEAI_KIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z DD 081901H
	DD	0c6419H
	DD	0b5419H
	DD	0a3419H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00U_Scalar_ptr_iterator_tag@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Unguarded_partition@PEAUedge@CDB@@Usort_predicate@2@@std@@YA?AU?$pair@PEAUedge@CDB@@PEAU12@@0@PEAUedge@CDB@@0Usort_predicate@3@@Z DD 0a1a01H
	DD	09e41aH
	DD	08741aH
	DD	07641aH
	DD	06341aH
	DD	0f016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$make_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insertion_sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+50
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z DD 021H
	DD	imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z DD 081621H
	DD	0be416H
	DD	0a7411H
	DD	09640aH
	DD	085405H
	DD	imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z DD 040a01H
	DD	0f006320aH
	DD	03002c004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z DD 021H
	DD	imagerel $LN61
	DD	imagerel $LN61+47
	DD	imagerel $unwind$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z DD 040a21H
	DD	03540aH
	DD	023405H
	DD	imagerel $LN61
	DD	imagerel $LN61+47
	DD	imagerel $unwind$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z DD 030b01H
	DD	04640bH
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+30
	DD	imagerel $unwind$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD 060f21H
	DD	06f40fH
	DD	0ce40aH
	DD	0b7405H
	DD	imagerel $LN33
	DD	imagerel $LN33+30
	DD	imagerel $unwind$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD 030701H
	DD	060036207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z DD 021H
	DD	imagerel $LN57
	DD	imagerel $LN57+34
	DD	imagerel $unwind$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z DD 040a21H
	DD	03740aH
	DD	023405H
	DD	imagerel $LN57
	DD	imagerel $LN57+34
	DD	imagerel $unwind$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z DD 010f01H
	DD	0600fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+62
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+64
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+51
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Push_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap_0@PEAUedge@CDB@@U12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Pop_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00$$QEAU12@Usort_predicate@2@PEA_J@Z DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
;	COMDAT ??0non_copyable@CDB@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0non_copyable@CDB@@QEAA@XZ PROC			; CDB::non_copyable::non_copyable, COMDAT

; 219  : 						non_copyable	() {}

	mov	rax, rcx
	ret	0
??0non_copyable@CDB@@QEAA@XZ ENDP			; CDB::non_copyable::non_copyable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
this$ = 48
V$ = 56
eps$ = 64
?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z PROC	; CDB::Collector::VPack

; 9    : 	{

$LN96:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 10   : 		xr_vector<Fvector>::iterator I,E;
; 11   : 		I=verts.begin();	E=verts.end();

	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rbx+8]
	mov	r8, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rcx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 12   : 		for (;I!=E;I++)		if (I->similar(V,eps)) return u32(I-verts.begin());

	je	SHORT $LN2@VPack
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm3, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	npad	12
$LL35@VPack:
	movss	xmm0, DWORD PTR [r8]
	subss	xmm0, xmm3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm2
	jae	SHORT $LN55@VPack
	movss	xmm0, DWORD PTR [r8+4]
	subss	xmm0, DWORD PTR [rdx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm2
	jae	SHORT $LN55@VPack
	movss	xmm0, DWORD PTR [r8+8]
	subss	xmm0, DWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm2
	jb	SHORT $LN88@VPack
$LN55@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	r8, 12

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r8, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 12   : 		for (;I!=E;I++)		if (I->similar(V,eps)) return u32(I-verts.begin());

	jne	SHORT $LL35@VPack
$LN2@VPack:

; 13   : 		verts.push_back		(V);

	mov	rcx, rbx
	call	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rbx+8]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rcx, QWORD PTR [rbx]
	imul	rcx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 14   : 		return verts.size	()-1;

	dec	eax

; 15   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN88@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

	sub	r8, rcx
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	r8
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 15   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z ENDP	; CDB::Collector::VPack
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
T$ = 32
this$ = 80
v0$ = 88
v1$ = 96
v2$ = 104
dummy$ = 112
?add_face_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z PROC ; CDB::Collector::add_face_D

; 25   : 	{

$LN84:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r10, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 25   : 	{

	mov	r11, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rbp, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r10, QWORD PTR [rcx]
	mov	rax, rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 25   : 	{

	mov	rdi, r9
	mov	rbx, r8
	mov	rsi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	imul	r10
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 27   : 		T.verts		[0] = verts.size();

	mov	DWORD PTR T$[rsp], edx

; 28   : 		T.verts		[1] = verts.size()+1;

	lea	eax, DWORD PTR [rdx+1]
	mov	DWORD PTR T$[rsp+4], eax

; 29   : 		T.verts		[2] = verts.size()+2;  

	lea	eax, DWORD PTR [rdx+2]

; 30   : 		T.dummy			= dummy;
; 31   : 
; 32   : 		verts.push_back(v0);

	mov	rdx, r11
	mov	DWORD PTR T$[rsp+8], eax
	mov	rax, QWORD PTR dummy$[rsp]
	mov	QWORD PTR T$[rsp+16], rax
	call	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back

; 33   : 		verts.push_back(v1);

	mov	rdx, rbx
	mov	rcx, rsi
	call	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back

; 34   : 		verts.push_back(v2);

	mov	rdx, rdi
	mov	rcx, rsi
	call	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	r8, QWORD PTR [rsi+32]
	lea	rcx, QWORD PTR T$[rsp]
	cmp	rcx, r8
	jae	SHORT $LN18@add_face_D
	mov	rdx, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR T$[rsp]
	cmp	rdx, rcx
	ja	SHORT $LN18@add_face_D

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rcx, QWORD PTR T$[rsp]
	mov	rax, rbp
	sub	rcx, rdx
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 2
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN17@add_face_D

; 1248 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN17@add_face_D:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	rax, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [rbx+rbx*2]
	lea	rdx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN75@add_face_D
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
	movsdx	xmm1, QWORD PTR [rdx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN82@add_face_D
$LN18@add_face_D:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN15@add_face_D

; 1257 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN15@add_face_D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN75@add_face_D
	movups	xmm0, XMMWORD PTR T$[rsp]
	movsdx	xmm1, QWORD PTR T$[rsp+16]
	movups	XMMWORD PTR [rax], xmm0
$LN82@add_face_D:
	movsdx	QWORD PTR [rax+16], xmm1
$LN75@add_face_D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rsi+32], 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 36   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?add_face_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z ENDP ; CDB::Collector::add_face_D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
T$ = 32
this$ = 80
v0$ = 88
v1$ = 96
v2$ = 104
material$ = 112
sector$ = 120
?add_face@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z PROC ; CDB::Collector::add_face

; 39   : 	{

$LN84:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r10, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 39   : 	{

	mov	r11, rdx
	mov	rsi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r10, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 45   : 		T.sector		= sector;

	movzx	ecx, WORD PTR material$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rbp, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	and	ecx, 16383				; 00003fffH
	mov	rax, rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 39   : 	{

	mov	rdi, r9
	mov	rbx, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	imul	r10
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 41   : 		T.verts	[0]		= verts.size();

	mov	DWORD PTR T$[rsp], edx

; 42   : 		T.verts	[1]		= verts.size()+1;

	lea	eax, DWORD PTR [rdx+1]
	mov	DWORD PTR T$[rsp+4], eax

; 43   : 		T.verts	[2]		= verts.size()+2;

	lea	eax, DWORD PTR [rdx+2]
	mov	rdx, -4294918144			; ffffffff0000c000H
	mov	DWORD PTR T$[rsp+8], eax

; 45   : 		T.sector		= sector;

	movzx	eax, WORD PTR sector$[rsp]
	shl	rax, 16
	or	rcx, rax
	mov	rax, QWORD PTR T$[rsp+16]
	and	rax, rdx

; 46   : 
; 47   : 		verts.push_back(v0);

	mov	rdx, r11
	or	rcx, rax
	mov	QWORD PTR T$[rsp+16], rcx
	mov	rcx, rsi
	call	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back

; 48   : 		verts.push_back(v1);

	mov	rdx, rbx
	mov	rcx, rsi
	call	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back

; 49   : 		verts.push_back(v2);

	mov	rdx, rdi
	mov	rcx, rsi
	call	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	r8, QWORD PTR [rsi+32]
	lea	rcx, QWORD PTR T$[rsp]
	cmp	rcx, r8
	jae	SHORT $LN18@add_face
	mov	rdx, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR T$[rsp]
	cmp	rdx, rcx
	ja	SHORT $LN18@add_face

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rcx, QWORD PTR T$[rsp]
	mov	rax, rbp
	sub	rcx, rdx
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 2
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN17@add_face

; 1248 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN17@add_face:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	rax, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [rbx+rbx*2]
	lea	rdx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN75@add_face
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
	movsdx	xmm1, QWORD PTR [rdx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN82@add_face
$LN18@add_face:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN15@add_face

; 1257 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN15@add_face:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN75@add_face
	movups	xmm0, XMMWORD PTR T$[rsp]
	movsdx	xmm1, QWORD PTR T$[rsp+16]
	movups	XMMWORD PTR [rax], xmm0
$LN82@add_face:
	movsdx	QWORD PTR [rax+16], xmm1
$LN75@add_face:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rsi+32], 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 51   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?add_face@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z ENDP ; CDB::Collector::add_face
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
T$ = 32
this$ = 80
v0$ = 88
v1$ = 96
v2$ = 104
material$ = 112
sector$ = 120
eps$ = 128
?add_face_packed@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GGM@Z PROC ; CDB::Collector::add_face_packed

; 58   : 	{

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 59   : 		TRI T;
; 60   : 		T.verts	[0]		= VPack(v0,eps);

	movss	xmm2, DWORD PTR eps$[rsp]
	mov	rdi, r9
	mov	rbx, r8
	mov	rsi, rcx
	call	?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z ; CDB::Collector::VPack

; 61   : 		T.verts	[1]		= VPack(v1,eps);

	movss	xmm2, DWORD PTR eps$[rsp]
	mov	rdx, rbx
	mov	rcx, rsi
	mov	DWORD PTR T$[rsp], eax
	call	?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z ; CDB::Collector::VPack

; 62   : 		T.verts	[2]		= VPack(v2,eps);

	mov	rdx, rdi
	mov	rcx, rsi
	movss	xmm2, DWORD PTR eps$[rsp]
	mov	DWORD PTR T$[rsp+4], eax
	call	?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z ; CDB::Collector::VPack

; 64   : 		T.sector		= sector;

	movzx	ecx, WORD PTR material$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	r8, QWORD PTR [rsi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 62   : 		T.verts	[2]		= VPack(v2,eps);

	mov	DWORD PTR T$[rsp+8], eax

; 64   : 		T.sector		= sector;

	movzx	eax, WORD PTR sector$[rsp]
	and	ecx, 16383				; 00003fffH
	mov	rdx, -4294918144			; ffffffff0000c000H
	shl	rax, 16
	or	rcx, rax
	mov	rax, QWORD PTR T$[rsp+16]
	and	rax, rdx
	or	rcx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rax, QWORD PTR T$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 64   : 		T.sector		= sector;

	mov	QWORD PTR T$[rsp+16], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rax, r8
	jae	SHORT $LN6@add_face_p
	mov	rax, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR T$[rsp]
	cmp	rax, rcx
	ja	SHORT $LN6@add_face_p

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rcx, QWORD PTR T$[rsp]
	sub	rcx, rax
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 2
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN5@add_face_p

; 1248 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN5@add_face_p:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1251 : 				this->_Myfirst[_Idx]);

	mov	rdx, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [rbx+rbx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rax, rax
	je	SHORT $LN63@add_face_p
	movups	xmm0, XMMWORD PTR [rdx+rcx*8]
	movups	XMMWORD PTR [rax], xmm0
	movsdx	xmm1, QWORD PTR [rdx+rcx*8+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN70@add_face_p
$LN6@add_face_p:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN3@add_face_p

; 1257 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN3@add_face_p:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN63@add_face_p
	movups	xmm0, XMMWORD PTR T$[rsp]
	movsdx	xmm1, QWORD PTR T$[rsp+16]
	movups	XMMWORD PTR [rax], xmm0
$LN70@add_face_p:
	movsdx	QWORD PTR [rax+16], xmm1
$LN63@add_face_p:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rsi+32], 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 66   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?add_face_packed@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00GGM@Z ENDP ; CDB::Collector::add_face_packed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
T$ = 32
this$ = 80
v0$ = 88
v1$ = 96
v2$ = 104
dummy$ = 112
eps$ = 120
?add_face_packed_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_KM@Z PROC ; CDB::Collector::add_face_packed_D

; 76   : 	{

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 77   : 		TRI T;
; 78   : 		T.verts	[0] = VPack(v0,eps);

	movss	xmm2, DWORD PTR eps$[rsp]
	mov	rdi, r9
	mov	rbx, r8
	mov	rsi, rcx
	call	?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z ; CDB::Collector::VPack

; 79   : 		T.verts	[1] = VPack(v1,eps);

	movss	xmm2, DWORD PTR eps$[rsp]
	mov	rdx, rbx
	mov	rcx, rsi
	mov	DWORD PTR T$[rsp], eax
	call	?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z ; CDB::Collector::VPack

; 80   : 		T.verts	[2] = VPack(v2,eps);

	mov	rdx, rdi
	mov	rcx, rsi
	movss	xmm2, DWORD PTR eps$[rsp]
	mov	DWORD PTR T$[rsp+4], eax
	call	?VPack@Collector@CDB@@AEAAIAEBU?$_vector3@M@@M@Z ; CDB::Collector::VPack
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	r8, QWORD PTR [rsi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 80   : 		T.verts	[2] = VPack(v2,eps);

	mov	DWORD PTR T$[rsp+8], eax

; 81   : 		T.dummy			= dummy;

	mov	rax, QWORD PTR dummy$[rsp]
	mov	QWORD PTR T$[rsp+16], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rax, QWORD PTR T$[rsp]
	cmp	rax, r8
	jae	SHORT $LN6@add_face_p
	mov	rax, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR T$[rsp]
	cmp	rax, rcx
	ja	SHORT $LN6@add_face_p

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rcx, QWORD PTR T$[rsp]
	sub	rcx, rax
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 2
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN5@add_face_p

; 1248 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN5@add_face_p:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1251 : 				this->_Myfirst[_Idx]);

	mov	rdx, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [rbx+rbx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rax, rax
	je	SHORT $LN63@add_face_p
	movups	xmm0, XMMWORD PTR [rdx+rcx*8]
	movups	XMMWORD PTR [rax], xmm0
	movsdx	xmm1, QWORD PTR [rdx+rcx*8+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN70@add_face_p
$LN6@add_face_p:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN3@add_face_p

; 1257 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN3@add_face_p:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN63@add_face_p
	movups	xmm0, XMMWORD PTR T$[rsp]
	movsdx	xmm1, QWORD PTR T$[rsp+16]
	movups	XMMWORD PTR [rax], xmm0
$LN70@add_face_p:
	movsdx	QWORD PTR [rax+16], xmm1
$LN63@add_face_p:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rsi+32], 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 83   : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?add_face_packed_D@Collector@CDB@@QEAAXAEBU?$_vector3@M@@00_KM@Z ENDP ; CDB::Collector::add_face_packed_D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
;	COMDAT ??Rsort_predicate@CDB@@QEBA_NAEBUedge@1@0@Z
_TEXT	SEGMENT
edge0$ = 8
edge1$ = 16
??Rsort_predicate@CDB@@QEBA_NAEBUedge@1@0@Z PROC	; CDB::sort_predicate::operator(), COMDAT

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)
; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	movzx	eax, WORD PTR [rcx+4]
	mov	r8, rdx
	cmp	WORD PTR [rdx+4], ax
	jae	SHORT $LN3@operator
$LN12@operator:

; 106  : 				return				(false);

	xor	al, al

; 115  : 		}

	ret	0
$LN3@operator:

; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rcx+6]
	movzx	edx, WORD PTR [rdx+6]
	cmp	dx, ax
	jbe	SHORT $LN11@operator

; 109  : 				return				(true);

	mov	al, 1

; 115  : 		}

	ret	0
$LN11@operator:

; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	jb	SHORT $LN12@operator

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	edx, DWORD PTR [rcx]
	mov	ecx, DWORD PTR [r8]
	xor	eax, eax
	and	ecx, 1073741823				; 3fffffffH
	and	edx, 1073741823				; 3fffffffH
	cmp	edx, ecx
	setb	al

; 115  : 		}

	ret	0
??Rsort_predicate@CDB@@QEBA_NAEBUedge@1@0@Z ENDP	; CDB::sort_predicate::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
$T1 = 48
this$ = 48
$T2 = 56
dest$ = 56
?calc_adjacency@Collector@CDB@@QEAAXAEAV?$xr_vector@IV?$xalloc@I@@@@@Z PROC ; CDB::Collector::calc_adjacency

; 119  : 	{

$LN164:
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	lea	rbp, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 119  : 	{

	mov	rdi, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r15, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx+24]
	mov	rax, r15
	mov	QWORD PTR [rbp+64], rbx
	imul	r8
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 122  : 		const u32						edge_count = faces.size()*3;

	lea	eax, DWORD PTR [rdx+rdx*2]

; 123  : #ifdef _EDITOR
; 124  : 		xr_vector<edge> _edges			(edge_count);
; 125  : 		edge 							*edges = &*_edges.begin();
; 126  : #else
; 127  : 		edge							*edges = (edge*)_alloca(edge_count*sizeof(edge));

	mov	r14d, eax
	lea	rbx, QWORD PTR [rax*8]
	lea	rax, QWORD PTR [rbx+15]
	cmp	rax, rbx
	ja	SHORT $LN162@calc_adjac
	mov	rax, 1152921504606846960		; 0ffffffffffffff0H
$LN162@calc_adjac:
	and	rax, -16
	call	__chkstk
	sub	rsp, rax

; 128  : #endif
; 129  : 		edge							*i = edges;
; 130  : 		xr_vector<TRI>::const_iterator	B = faces.begin(), I = B;

	mov	rax, QWORD PTR [rcx+24]

; 131  : 		xr_vector<TRI>::const_iterator	E = faces.end();

	mov	rcx, QWORD PTR [rcx+32]
	lea	rsi, QWORD PTR [rsp+48]
	mov	r8, rsi

; 132  : 		for ( ; I != E; ++I) {

	cmp	rax, rcx
	je	$LN10@calc_adjac

; 122  : 		const u32						edge_count = faces.size()*3;

	mov	r11, -4
	lea	r9, QWORD PTR [rax+4]
	sub	r11, rax
$LL38@calc_adjac:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 194  : 		return (this->_Ptr - _Right._Ptr);

	lea	rdx, QWORD PTR [r11+r9]
	mov	rax, r15
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 135  : 			(*i).face_id				= face_id;

	and	edx, 1073741823				; 3fffffffH

; 136  : 			(*i).edge_id				= 0;

	mov	eax, edx
	and	eax, 1073741823				; 3fffffffH
	mov	DWORD PTR [r8], eax

; 137  : 			(*i).vertex_id0				= (u16)(*I).verts[0];

	movzx	r10d, WORD PTR [r9-4]
	mov	WORD PTR [r8+4], r10w

; 138  : 			(*i).vertex_id1				= (u16)(*I).verts[1];

	movzx	eax, WORD PTR [r9]
	mov	WORD PTR [r8+6], ax

; 139  : 			if ((*i).vertex_id0 > (*i).vertex_id1)

	cmp	r10w, ax
	jbe	SHORT $LN54@calc_adjac
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	WORD PTR [r8+4], ax

; 54   : 	_Right = _Move(_Tmp);

	mov	WORD PTR [r8+6], r10w
$LN54@calc_adjac:
	mov	eax, edx
	and	eax, 1073741823				; 3fffffffH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 144  : 			(*i).edge_id				= 1;

	bts	eax, 30
	mov	DWORD PTR [r8+8], eax

; 145  : 			(*i).vertex_id0				= (u16)(*I).verts[1];

	movzx	r10d, WORD PTR [r9]
	mov	WORD PTR [r8+12], r10w

; 146  : 			(*i).vertex_id1				= (u16)(*I).verts[2];

	movzx	eax, WORD PTR [r9+4]
	mov	WORD PTR [r8+14], ax

; 147  : 			if ((*i).vertex_id0 > (*i).vertex_id1)

	cmp	r10w, ax
	jbe	SHORT $LN66@calc_adjac
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	WORD PTR [r8+12], ax

; 54   : 	_Right = _Move(_Tmp);

	mov	WORD PTR [r8+14], r10w
$LN66@calc_adjac:
	and	edx, 1073741823				; 3fffffffH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 152  : 			(*i).edge_id				= 2;

	bts	edx, 31
	mov	DWORD PTR [r8+16], edx

; 153  : 			(*i).vertex_id0				= (u16)(*I).verts[2];

	movzx	edx, WORD PTR [r9+4]
	mov	WORD PTR [r8+20], dx

; 154  : 			(*i).vertex_id1				= (u16)(*I).verts[0];

	movzx	eax, WORD PTR [r9-4]
	mov	WORD PTR [r8+22], ax

; 155  : 			if ((*i).vertex_id0 > (*i).vertex_id1)

	cmp	dx, ax
	jbe	SHORT $LN78@calc_adjac
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	WORD PTR [r8+20], ax

; 54   : 	_Right = _Move(_Tmp);

	mov	WORD PTR [r8+22], dx
$LN78@calc_adjac:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	r9, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 157  : 			++i;

	add	r8, 24
	lea	rax, QWORD PTR [r9-4]
	cmp	rax, rcx
	jne	$LL38@calc_adjac
$LN10@calc_adjac:

; 158  : 		}
; 159  : 
; 160  : 		std::sort						(edges,edges + edge_count,sort_predicate());

	add	rbx, rsi
	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

	mov	rcx, rsi
	mov	r8, rbx
	movzx	r9d, al
	mov	rdx, rbx
	sub	r8, rsi
	sar	r8, 3
	call	??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z ; std::_Sort<CDB::edge * __ptr64,__int64,CDB::sort_predicate>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	r8, QWORD PTR [rdi]

; 1334 : 		return (_Insert_n(_Where, _Count, _Val));

	lea	rax, QWORD PTR $T1[rbp]
	lea	rdx, QWORD PTR $T2[rbp]
	mov	r9, r14
	mov	rcx, rdi

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rdi+8], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 162  : 		dest.assign						(edge_count,u32(-1));

	mov	DWORD PTR $T1[rbp], -1			; ffffffffH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1334 : 		return (_Insert_n(_Where, _Count, _Val));

	mov	QWORD PTR [rsp+32], rax
	call	?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 167  : 			for ( ; I != E; ++I) {

	cmp	rsi, rbx
	je	$LN4@calc_adjac

; 158  : 		}
; 159  : 
; 160  : 		std::sort						(edges,edges + edge_count,sort_predicate());

	lea	rax, QWORD PTR [rsi+8]
$LL6@calc_adjac:

; 168  : 				if (I + 1 == E)

	cmp	rax, rbx
	je	SHORT $LN5@calc_adjac

; 169  : 					continue;
; 170  : 
; 171  : 				J							= I + 1;
; 172  : 
; 173  : 				if ((*I).vertex_id0 != (*J).vertex_id0)

	movzx	ecx, WORD PTR [rax+4]
	cmp	WORD PTR [rax-4], cx
	jne	SHORT $LN5@calc_adjac

; 174  : 					continue;
; 175  : 
; 176  : 				if ((*I).vertex_id1 != (*J).vertex_id1)

	movzx	ecx, WORD PTR [rax+6]
	cmp	WORD PTR [rax-2], cx
	jne	SHORT $LN5@calc_adjac

; 177  : 					continue;
; 178  : 
; 179  : 				dest[(*I).face_id*3 + (*I).edge_id]	= (*J).face_id;

	mov	r8d, DWORD PTR [rax-8]
	mov	r9d, DWORD PTR [rax]
	mov	ecx, r8d
	shr	r8d, 30
	and	r9d, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	lea	edx, DWORD PTR [rcx+rcx*2]
	mov	rcx, QWORD PTR [rdi]
	add	edx, r8d
	mov	DWORD PTR [rcx+rdx*4], r9d

; 180  : 				dest[(*J).face_id*3 + (*J).edge_id]	= (*I).face_id;

	mov	r8d, DWORD PTR [rax]
	mov	r9d, DWORD PTR [rax-8]
	mov	ecx, r8d
	and	r9d, 1073741823				; 3fffffffH
	shr	r8d, 30
	and	ecx, 1073741823				; 3fffffffH
	lea	edx, DWORD PTR [rcx+rcx*2]
	mov	rcx, QWORD PTR [rdi]
	add	edx, r8d
	mov	DWORD PTR [rcx+rdx*4], r9d
$LN5@calc_adjac:

; 167  : 			for ( ; I != E; ++I) {

	add	rax, 8
	lea	rcx, QWORD PTR [rax-8]
	cmp	rcx, rbx
	jne	SHORT $LL6@calc_adjac
$LN4@calc_adjac:

; 181  : 			}
; 182  : 		}
; 183  : #	if 0
; 184  : 		xr_vector<u32>	test = dest;
; 185  : 
; 186  : 		dest.assign		(faces.size()*3,0xffffffff);
; 187  : 		// Dumb algorithm O(N^2) :)
; 188  : 		for (u32 f=0; f<faces.size(); f++)
; 189  : 		{
; 190  : 			for (u32 t=0; t<faces.size(); t++)
; 191  : 			{
; 192  : 				if (t==f)	continue;
; 193  : 
; 194  : 				for (u32 f_e=0; f_e<3; f_e++)
; 195  : 				{
; 196  : 					u32 f1	= faces[f].verts[(f_e+0)%3];
; 197  : 					u32 f2	= faces[f].verts[(f_e+1)%3];
; 198  : 					if (f1>f2)	std::swap(f1,f2);
; 199  : 
; 200  : 					for (u32 t_e=0; t_e<3; t_e++)
; 201  : 					{
; 202  : 						u32 t1	= faces[t].verts[(t_e+0)%3];
; 203  : 						u32 t2	= faces[t].verts[(t_e+1)%3];
; 204  : 						if (t1>t2)	std::swap(t1,t2);
; 205  : 
; 206  : 						if (f1==t1 && f2==t2)
; 207  : 						{
; 208  : 							// f.edge[f_e] linked to t.edge[t_e]
; 209  : 							dest[f*3+f_e]	= t;
; 210  : 							break;
; 211  : 						}
; 212  : 					}
; 213  : 				}
; 214  : 			}
; 215  : 		}
; 216  : 
; 217  : 		{
; 218  : 			xr_vector<u32>::const_iterator	I = test.begin();
; 219  : 			xr_vector<u32>::const_iterator	E = test.end();
; 220  : 			xr_vector<u32>::const_iterator	J = dest.begin();
; 221  : 			for ( ; I != E; ++I, ++J) {
; 222  : 				VERIFY	(*I == *J);
; 223  : 			}
; 224  : 		}
; 225  : #	endif
; 226  : #else
; 227  : 		dest.assign		(faces.size()*3,0xffffffff);
; 228  : 		// Dumb algorithm O(N^2) :)
; 229  : 		for (u32 f=0; f<faces.size(); f++)
; 230  : 		{
; 231  : 			for (u32 t=0; t<faces.size(); t++)
; 232  : 			{
; 233  : 				if (t==f)	continue;
; 234  : 
; 235  : 				for (u32 f_e=0; f_e<3; f_e++)
; 236  : 				{
; 237  : 					u32 f1	= faces[f].verts[(f_e+0)%3];
; 238  : 					u32 f2	= faces[f].verts[(f_e+1)%3];
; 239  : 					if (f1>f2)	std::swap(f1,f2);
; 240  : 
; 241  : 					for (u32 t_e=0; t_e<3; t_e++)
; 242  : 					{
; 243  : 						u32 t1	= faces[t].verts[(t_e+0)%3];
; 244  : 						u32 t2	= faces[t].verts[(t_e+1)%3];
; 245  : 						if (t1>t2)	std::swap(t1,t2);
; 246  : 
; 247  : 						if (f1==t1 && f2==t2)
; 248  : 						{
; 249  : 							// f.edge[f_e] linked to t.edge[t_e]
; 250  : 							dest[f*3+f_e]	= t;
; 251  : 							break;
; 252  : 						}
; 253  : 					}
; 254  : 				}
; 255  : 			}
; 256  : 		}
; 257  : #endif
; 258  : 	}

	mov	rbx, QWORD PTR [rbp+64]
	mov	rsp, rbp
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?calc_adjacency@Collector@CDB@@QEAAXAEAV?$xr_vector@IV?$xalloc@I@@@@@Z ENDP ; CDB::Collector::calc_adjacency
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
;	COMDAT ?similar@CDB@@YAHAEAVTRI@1@0@Z
_TEXT	SEGMENT
T1$ = 8
T2$ = 16
?similar@CDB@@YAHAEAVTRI@1@0@Z PROC			; CDB::similar, COMDAT

; 261  :         if ((T1.verts[0]==T2.verts[0]) && (T1.verts[1]==T2.verts[1]) && (T1.verts[2]==T2.verts[2]) && (T1.dummy==T2.dummy)) return TRUE;

	mov	r8d, DWORD PTR [rcx]
	mov	r9d, DWORD PTR [rdx]
	cmp	r8d, r9d
	jne	SHORT $LN5@similar
	mov	eax, DWORD PTR [rdx+4]
	cmp	DWORD PTR [rcx+4], eax
	jne	SHORT $LN6@similar
	mov	eax, DWORD PTR [rdx+8]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN6@similar
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	jne	SHORT $LN6@similar
$LN12@similar:
	mov	eax, 1

; 268  :     }

	ret	0
$LN6@similar:

; 262  :         if ((T1.verts[0]==T2.verts[0]) && (T1.verts[2]==T2.verts[1]) && (T1.verts[1]==T2.verts[2]) && (T1.dummy==T2.dummy)) return TRUE;

	cmp	r8d, r9d
	jne	SHORT $LN5@similar
	mov	eax, DWORD PTR [rdx+4]
	cmp	DWORD PTR [rcx+8], eax
	jne	SHORT $LN5@similar
	mov	eax, DWORD PTR [rdx+8]
	cmp	DWORD PTR [rcx+4], eax
	jne	SHORT $LN5@similar
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	je	SHORT $LN12@similar
$LN5@similar:

; 263  :         if ((T1.verts[2]==T2.verts[0]) && (T1.verts[0]==T2.verts[1]) && (T1.verts[1]==T2.verts[2]) && (T1.dummy==T2.dummy)) return TRUE;

	mov	r10d, DWORD PTR [rcx+8]
	cmp	r10d, r9d
	jne	SHORT $LN3@similar
	cmp	r8d, DWORD PTR [rdx+4]
	jne	SHORT $LN4@similar
	mov	eax, DWORD PTR [rdx+8]
	cmp	DWORD PTR [rcx+4], eax
	jne	SHORT $LN4@similar
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	je	SHORT $LN12@similar
$LN4@similar:

; 264  :         if ((T1.verts[2]==T2.verts[0]) && (T1.verts[1]==T2.verts[1]) && (T1.verts[0]==T2.verts[2]) && (T1.dummy==T2.dummy)) return TRUE;

	cmp	r10d, r9d
	jne	SHORT $LN3@similar
	mov	eax, DWORD PTR [rdx+4]
	cmp	DWORD PTR [rcx+4], eax
	jne	SHORT $LN3@similar
	cmp	r8d, DWORD PTR [rdx+8]
	jne	SHORT $LN3@similar
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	je	SHORT $LN12@similar
$LN3@similar:

; 265  :         if ((T1.verts[1]==T2.verts[0]) && (T1.verts[0]==T2.verts[1]) && (T1.verts[2]==T2.verts[2]) && (T1.dummy==T2.dummy)) return TRUE;

	mov	r11d, DWORD PTR [rcx+4]
	cmp	r11d, r9d
	jne	SHORT $LN1@similar
	cmp	r8d, DWORD PTR [rdx+4]
	jne	SHORT $LN2@similar
	cmp	r10d, DWORD PTR [rdx+8]
	jne	SHORT $LN2@similar
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	je	$LN12@similar
$LN2@similar:

; 266  :         if ((T1.verts[1]==T2.verts[0]) && (T1.verts[2]==T2.verts[1]) && (T1.verts[0]==T2.verts[2]) && (T1.dummy==T2.dummy)) return TRUE;

	cmp	r11d, r9d
	jne	SHORT $LN1@similar
	cmp	r10d, DWORD PTR [rdx+4]
	jne	SHORT $LN1@similar
	cmp	r8d, DWORD PTR [rdx+8]
	jne	SHORT $LN1@similar
	mov	rax, QWORD PTR [rdx+16]
	cmp	QWORD PTR [rcx+16], rax
	je	$LN12@similar
$LN1@similar:

; 267  :         return FALSE;

	xor	eax, eax

; 268  :     }

	ret	0
?similar@CDB@@YAHAEAVTRI@1@0@Z ENDP			; CDB::similar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
this$ = 64
?remove_duplicate_T@Collector@CDB@@QEAAXXZ PROC		; CDB::Collector::remove_duplicate_T

; 270  :     {

$LN123:
	push	rbp
	push	rdi
	push	r15
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rcx+32]
	mov	r15, 3074457345618258603		; 2aaaaaaaaaaaaaabH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 271  : 		for (u32 f=0; f<faces.size(); f++)

	xor	ebp, ebp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	rdx, QWORD PTR [rcx+24]
	mov	rax, r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 270  :     {

	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 271  : 		for (u32 f=0; f<faces.size(); f++)

	test	edx, edx
	je	$LN6@remove_dup
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+80], r14
	npad	5
$LL8@remove_dup:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 273  : 			for (u32 t=f+1; t<faces.size();)

	lea	r14d, DWORD PTR [rbp+1]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, r15
	sub	rcx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 273  : 			for (u32 t=f+1; t<faces.size();)

	mov	ebx, r14d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 273  : 			for (u32 t=f+1; t<faces.size();)

	cmp	r14d, edx
	jae	SHORT $LN7@remove_dup
$LL5@remove_dup:

; 274  : 			{
; 275  : 				if (t==f)	continue;

	cmp	ebx, ebp
	je	SHORT $LN1@remove_dup
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rdx, QWORD PTR [rdi+24]
	mov	eax, ebx
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	eax, ebp
	lea	rsi, QWORD PTR [rdx+rcx*8]
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rdx+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 278  :                 if (similar(T1,T2)){

	mov	rdx, rsi
	call	?similar@CDB@@YAHAEAVTRI@1@0@Z		; CDB::similar
	test	eax, eax
	je	SHORT $LN2@remove_dup
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 279  :                 	faces[t] = faces.back();

	movups	xmm0, XMMWORD PTR [rax-24]
	movups	XMMWORD PTR [rsi], xmm0
	movsdx	xmm1, QWORD PTR [rax-8]
	movsdx	QWORD PTR [rsi+16], xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

	add	QWORD PTR [rdi+32], -24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 281  :                 }else{

	jmp	SHORT $LN1@remove_dup
$LN2@remove_dup:

; 282  :                 	t++;

	inc	ebx
$LN1@remove_dup:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rdi+32]
	mov	rax, r15
	sub	rcx, QWORD PTR [rdi+24]
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 273  : 			for (u32 t=f+1; t<faces.size();)

	cmp	ebx, edx
	jb	SHORT $LL5@remove_dup
$LN7@remove_dup:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rdi+32]
	mov	rax, r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 271  : 		for (u32 f=0; f<faces.size(); f++)

	mov	ebp, r14d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	rcx, QWORD PTR [rdi+24]
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 271  : 		for (u32 f=0; f<faces.size(); f++)

	cmp	r14d, edx
	jb	$LL8@remove_dup
	mov	r14, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
$LN6@remove_dup:

; 283  :                 }
; 284  :             }
; 285  :         }
; 286  :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbp
	ret	0
?remove_duplicate_T@Collector@CDB@@QEAAXXZ ENDP		; CDB::Collector::remove_duplicate_T
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
this$ = 80
bb$ = 88
apx_vertices$ = 96
apx_faces$ = 104
??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z PROC	; CDB::CollectorPacked::CollectorPacked

; 289  : 	{

$LN149:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	ebp, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 289  : 	{

	lea	r13, QWORD PTR [rcx+72]
	mov	r10, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx], rbp

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rbp

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 289  : 	{

	mov	rax, r13
	movsxd	rsi, r9d
	movsxd	rdi, r8d
	mov	r15, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx+24], rbp

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+32], rbp

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+40], rbp
	mov	edx, 10624				; 00002980H
	npad	9
$LL41@CollectorP:
	dec	edx

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rax], rbp

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rax+8], rbp

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rax+16], rbp
	lea	rax, QWORD PTR [rax+24]
	jns	SHORT $LL41@CollectorP
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 291  : 		VMscale.set		(bb.max.x-bb.min.x, bb.max.y-bb.min.y, bb.max.z-bb.min.z);

	movss	xmm2, DWORD PTR [r10+20]
	movss	xmm1, DWORD PTR [r10+16]
	movss	xmm0, DWORD PTR [r10+12]
	subss	xmm0, DWORD PTR [r10]
	subss	xmm1, DWORD PTR [r10+4]
	subss	xmm2, DWORD PTR [r10+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [rcx+60], xmm0
	movss	DWORD PTR [rcx+64], xmm1
	movss	DWORD PTR [rcx+68], xmm2

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [r10]
	mov	DWORD PTR [rcx+48], eax
	mov	eax, DWORD PTR [r10+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 293  : 		VMeps.set		(VMscale.x/clpMX/2,VMscale.y/clpMY/2,VMscale.z/clpMZ/2);

	movss	xmm2, DWORD PTR __real@3f000000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+52], eax
	mov	eax, DWORD PTR [r10+8]
	mov	DWORD PTR [rcx+56], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 293  : 		VMeps.set		(VMscale.x/clpMX/2,VMscale.y/clpMY/2,VMscale.z/clpMZ/2);

	movss	xmm0, DWORD PTR [rcx+60]
	movss	xmm4, DWORD PTR [rcx+68]
	movss	xmm1, DWORD PTR [rcx+64]
	mulss	xmm0, DWORD PTR __real@3d2aaaab
	mulss	xmm4, DWORD PTR __real@3d2aaaab
	mulss	xmm1, DWORD PTR __real@3d800000
	mulss	xmm0, xmm2
	mulss	xmm4, xmm2
	mulss	xmm1, xmm2

; 294  : 		VMeps.x			= (VMeps.x<EPS_L)?VMeps.x:EPS_L;

	movss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [rcx+255072], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 294  : 		VMeps.x			= (VMeps.x<EPS_L)?VMeps.x:EPS_L;

	movss	xmm0, DWORD PTR __real@3a83126f
	comiss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	DWORD PTR [rcx+255076], xmm1
	movss	DWORD PTR [rcx+255080], xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 294  : 		VMeps.x			= (VMeps.x<EPS_L)?VMeps.x:EPS_L;

	jb	SHORT $LN13@CollectorP
	movaps	xmm2, xmm0
$LN13@CollectorP:

; 295  : 		VMeps.y			= (VMeps.y<EPS_L)?VMeps.y:EPS_L;

	comiss	xmm1, xmm0
	movss	DWORD PTR [rcx+255072], xmm2
	jb	SHORT $LN15@CollectorP
	movaps	xmm1, xmm0
$LN15@CollectorP:

; 296  : 		VMeps.z			= (VMeps.z<EPS_L)?VMeps.z:EPS_L;

	comiss	xmm4, xmm0
	movss	DWORD PTR [rcx+255076], xmm1
	movss	xmm2, xmm4
	jb	SHORT $LN17@CollectorP
	movaps	xmm2, xmm0
$LN17@CollectorP:
	movss	DWORD PTR [rcx+255080], xmm2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rcx, QWORD PTR [rcx+16]
	mov	r14, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rcx, QWORD PTR [r15]
	mov	rax, r14
	imul	rcx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)

	cmp	rdx, rdi
	jae	SHORT $LN61@CollectorP

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	rax, 1537228672809129301		; 1555555555555555H
	cmp	rdi, rax
	jbe	SHORT $LN60@CollectorP

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN60@CollectorP:

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	mov	rdx, rdi
	mov	rcx, r15
	call	?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate
$LN61@CollectorP:

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rcx, QWORD PTR [r15+40]
	mov	rax, r14
	sub	rcx, QWORD PTR [r15+24]
	imul	rcx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)

	cmp	rdx, rsi
	jae	SHORT $LN83@CollectorP

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	rsi, rax
	jbe	SHORT $LN82@CollectorP

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN82@CollectorP:

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	lea	rcx, QWORD PTR [r15+24]
	mov	rdx, rsi
	call	?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate
$LN83@CollectorP:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 303  : 		int		_average= (apx_vertices/_size)/2;

	mov	eax, -983496981				; ffffffffc56106ebH
	mov	QWORD PTR [rsp+80], r12
	mov	rcx, 4611686018427387903		; 3fffffffffffffffH

; 304  : 		for (int ix=0; ix<clpMX+1; ix++)

	mov	r12d, ebp
	imul	edi
	add	edx, edi
	sar	edx, 13
	mov	eax, edx
	shr	eax, 31
	add	eax, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	movsxd	rsi, eax
	npad	12
$LL9@CollectorP:

; 305  : 			for (int iy=0; iy<clpMY+1; iy++)

	mov	r14, r13
	npad	13
$LL6@CollectorP:

; 306  : 				for (int iz=0; iz<clpMZ+1; iz++)

	xor	edi, edi
	mov	rbx, r14
	npad	11
$LL3@CollectorP:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rbx+16]
	sub	rax, QWORD PTR [rbx]
	sar	rax, 2

; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)

	cmp	rax, rsi
	jae	SHORT $LN2@CollectorP

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	cmp	rsi, rcx
	ja	SHORT $LN128@CollectorP

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	mov	rdx, rsi
	mov	rcx, rbx
	call	?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
$LN2@CollectorP:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 306  : 				for (int iz=0; iz<clpMZ+1; iz++)

	inc	edi
	add	rbx, 24
	cmp	edi, 25
	jb	SHORT $LL3@CollectorP

; 305  : 			for (int iy=0; iy<clpMY+1; iy++)

	inc	ebp
	add	r14, 600				; 00000258H
	cmp	ebp, 17
	jb	SHORT $LL6@CollectorP

; 304  : 		for (int ix=0; ix<clpMX+1; ix++)

	inc	r12d
	add	r13, 10200				; 000027d8H
	cmp	r12d, 25
	jae	SHORT $LN143@CollectorP
	xor	ebp, ebp
	jmp	SHORT $LL9@CollectorP
$LN128@CollectorP:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN143@CollectorP:
	mov	r12, QWORD PTR [rsp+80]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 308  : 	}

	mov	rbx, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+96]
	mov	rax, r15
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	ret	0
$LN148@CollectorP:
??0CollectorPacked@CDB@@QEAA@AEBV?$_box3@M@@HH@Z ENDP	; CDB::CollectorPacked::CollectorPacked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
T$ = 32
this$ = 80
v0$ = 88
v1$ = 96
v2$ = 104
material$ = 112
sector$ = 120
?add_face@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z PROC ; CDB::CollectorPacked::add_face

; 314  : 	{

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, r9
	mov	rbx, r8
	mov	rsi, rcx

; 315  : 		TRI T;
; 316  : 		T.verts	[0] = VPack(v0);

	call	?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z ; CDB::CollectorPacked::VPack

; 317  : 		T.verts	[1] = VPack(v1);

	mov	rdx, rbx
	mov	rcx, rsi
	mov	DWORD PTR T$[rsp], eax
	call	?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z ; CDB::CollectorPacked::VPack

; 318  : 		T.verts	[2] = VPack(v2);

	mov	rdx, rdi
	mov	rcx, rsi
	mov	DWORD PTR T$[rsp+4], eax
	call	?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z ; CDB::CollectorPacked::VPack

; 320  : 		T.sector		= sector;

	movzx	edx, WORD PTR material$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	r8, QWORD PTR [rsi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 318  : 		T.verts	[2] = VPack(v2);

	mov	DWORD PTR T$[rsp+8], eax

; 320  : 		T.sector		= sector;

	movzx	eax, WORD PTR sector$[rsp]
	and	edx, 16383				; 00003fffH
	shl	rax, 16
	mov	rcx, -4294918144			; ffffffff0000c000H
	or	rdx, rax
	mov	rax, QWORD PTR T$[rsp+16]
	and	rax, rcx
	or	rdx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rax, QWORD PTR T$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 320  : 		T.sector		= sector;

	mov	QWORD PTR T$[rsp+16], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rax, r8
	jae	SHORT $LN6@add_face
	mov	rax, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR T$[rsp]
	cmp	rax, rcx
	ja	SHORT $LN6@add_face

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rcx, QWORD PTR T$[rsp]
	sub	rcx, rax
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 2
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN5@add_face

; 1248 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN5@add_face:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	rax, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [rbx+rbx*2]
	lea	rdx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN63@add_face
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
	movsdx	xmm1, QWORD PTR [rdx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN70@add_face
$LN6@add_face:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN3@add_face

; 1257 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN3@add_face:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN63@add_face
	movups	xmm0, XMMWORD PTR T$[rsp]
	movsdx	xmm1, QWORD PTR T$[rsp+16]
	movups	XMMWORD PTR [rax], xmm0
$LN70@add_face:
	movsdx	QWORD PTR [rax+16], xmm1
$LN63@add_face:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rsi+32], 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 322  : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?add_face@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00GG@Z ENDP ; CDB::CollectorPacked::add_face
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
T$ = 32
this$ = 80
v0$ = 88
v1$ = 96
v2$ = 104
dummy$ = 112
?add_face_D@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z PROC ; CDB::CollectorPacked::add_face_D

; 332  : 	{

$LN72:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rdi, r9
	mov	rbx, r8
	mov	rsi, rcx

; 333  : 		TRI T;
; 334  : 		T.verts	[0] = VPack(v0);

	call	?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z ; CDB::CollectorPacked::VPack

; 335  : 		T.verts	[1] = VPack(v1);

	mov	rdx, rbx
	mov	rcx, rsi
	mov	DWORD PTR T$[rsp], eax
	call	?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z ; CDB::CollectorPacked::VPack

; 336  : 		T.verts	[2] = VPack(v2);

	mov	rdx, rdi
	mov	rcx, rsi
	mov	DWORD PTR T$[rsp+4], eax
	call	?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z ; CDB::CollectorPacked::VPack
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	r8, QWORD PTR [rsi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 336  : 		T.verts	[2] = VPack(v2);

	mov	DWORD PTR T$[rsp+8], eax

; 337  : 		T.dummy			= dummy;

	mov	rax, QWORD PTR dummy$[rsp]
	mov	QWORD PTR T$[rsp+16], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rax, QWORD PTR T$[rsp]
	cmp	rax, r8
	jae	SHORT $LN6@add_face_D
	mov	rax, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR T$[rsp]
	cmp	rax, rcx
	ja	SHORT $LN6@add_face_D

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rcx, QWORD PTR T$[rsp]
	sub	rcx, rax
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	mov	rbx, rdx
	sar	rbx, 2
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN5@add_face_D

; 1248 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN5@add_face_D:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	rax, QWORD PTR [rsi+24]
	lea	rcx, QWORD PTR [rbx+rbx*2]
	lea	rdx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN63@add_face_D
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
	movsdx	xmm1, QWORD PTR [rdx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN70@add_face_D
$LN6@add_face_D:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	r8, QWORD PTR [rsi+40]
	jne	SHORT $LN3@add_face_D

; 1257 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+24]
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN3@add_face_D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+32]
	test	rax, rax
	je	SHORT $LN63@add_face_D
	movups	xmm0, XMMWORD PTR T$[rsp]
	movsdx	xmm1, QWORD PTR T$[rsp+16]
	movups	XMMWORD PTR [rax], xmm0
$LN70@add_face_D:
	movsdx	QWORD PTR [rax+16], xmm1
$LN63@add_face_D:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rsi+32], 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 339  : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?add_face_D@CollectorPacked@CDB@@QEAAXAEBU?$_vector3@M@@00_K@Z ENDP ; CDB::CollectorPacked::add_face_D
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
ix$2$ = 32
tv2370 = 40
tv2372 = 48
tv2373 = 56
tv2371 = 64
a$1 = 176
a$2 = 176
a$3 = 176
P$ = 176
this$ = 176
a$4 = 184
a$5 = 184
a$6 = 184
V$ = 184
iz$2$ = 192
iy$2$ = 200
?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z PROC ; CDB::CollectorPacked::VPack

; 342  : 	{

$LN689:
	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	push	rbx
	push	rsi
	push	rdi
	push	r13
	push	r14
	mov	rbp, rsp
	sub	rsp, 120				; 00000078H

; 346  : 		ix = iFloor(float(V.x-VMmin.x)/VMscale.x*clpMX);

	movss	xmm5, DWORD PTR [rdx]
	mov	rsi, rcx
	mov	r14, rdx

; 347  : 		iy = iFloor(float(V.y-VMmin.y)/VMscale.y*clpMY);

	movss	xmm3, DWORD PTR [r14+4]

; 348  : 		iz = iFloor(float(V.z-VMmin.z)/VMscale.z*clpMZ);

	movss	xmm4, DWORD PTR [r14+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r9d, 158				; 0000009eH
	mov	edx, r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 342  : 	{

	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	ebx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 346  : 		ix = iFloor(float(V.x-VMmin.x)/VMscale.x*clpMX);

	movaps	xmm0, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	edi, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 346  : 		ix = iFloor(float(V.x-VMmin.x)/VMscale.x*clpMX);

	subss	xmm0, DWORD PTR [rcx+48]
	movss	xmm6, DWORD PTR __real@41c00000
	divss	xmm0, DWORD PTR [rcx+60]
	mulss	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR a$3[rbp-120], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r8d, DWORD PTR a$3[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 347  : 		iy = iFloor(float(V.y-VMmin.y)/VMscale.y*clpMY);

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rsi+52]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, r8d

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r11d, r8d
	sar	eax, 23
	or	r11d, -8388608				; ff800000H
	movzx	ecx, al
	shl	r11d, 8

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 347  : 		iy = iFloor(float(V.y-VMmin.y)/VMscale.y*clpMY);

	divss	xmm0, DWORD PTR [rsi+64]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	sub	edx, ecx

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ecx, edx
	shr	r11d, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	lea	ecx, DWORD PTR [rdx-96]
	shl	eax, cl
	dec	eax
	sar	eax, 8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 347  : 		iy = iFloor(float(V.y-VMmin.y)/VMscale.y*clpMY);

	mulss	xmm0, DWORD PTR __real@41800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	test	eax, r8d
	mov	eax, edi
	sete	al

; 91   :         a			>>=	31;

	sar	r8d, 31

; 92   :         r			-=	(imask&a);

	and	eax, r8d
	sub	r11d, eax

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR a$2[rbp-120], xmm0

; 89   :         exponent	-=	(31-127)+32;

	lea	eax, DWORD PTR [rdx-32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 348  : 		iz = iFloor(float(V.z-VMmin.z)/VMscale.z*clpMZ);

	movaps	xmm0, xmm4
	subss	xmm0, DWORD PTR [rsi+56]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 90   :         exponent	>>=	31;

	sar	eax, 31

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edx, r9d

; 93   :         r			&=	exponent;

	and	r11d, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 348  : 		iz = iFloor(float(V.z-VMmin.z)/VMscale.z*clpMZ);

	divss	xmm0, DWORD PTR [rsi+68]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 94   :         r			^=	a;

	xor	r11d, r8d

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r8d, DWORD PTR a$2[rbp-120]
	mov	eax, r8d

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r10d, r8d
	sar	eax, 23
	or	r10d, -8388608				; ff800000H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 348  : 		iz = iFloor(float(V.z-VMmin.z)/VMscale.z*clpMZ);

	mulss	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	movzx	ecx, al

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	shl	r10d, 8

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, ebx
	sub	edx, ecx
	mov	ecx, edx

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR a$1[rbp-120], xmm0

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	shr	r10d, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	lea	ecx, DWORD PTR [rdx-96]
	shl	eax, cl
	dec	eax
	sar	eax, 8
	test	eax, r8d
	mov	eax, edi
	sete	al

; 91   :         a			>>=	31;

	sar	r8d, 31

; 92   :         r			-=	(imask&a);

	and	eax, r8d
	sub	r10d, eax
	lea	eax, DWORD PTR [rdx-32]
	sar	eax, 31

; 93   :         r			&=	exponent;

	and	r10d, eax

; 94   :         r			^=	a;

	xor	r10d, r8d

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r8d, DWORD PTR a$1[rbp-120]
	mov	eax, r8d
	sar	eax, 23
	movzx	ecx, al
	mov	edx, r9d

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r9d, r8d

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, ebx
	or	r9d, -8388608				; ff800000H
	sub	edx, ecx
	shl	r9d, 8
	mov	ecx, edx
	shr	r9d, cl
	lea	ecx, DWORD PTR [rdx-96]
	shl	eax, cl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	ecx, 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	dec	eax
	sar	eax, 8
	test	eax, r8d
	mov	eax, edi
	sete	al

; 91   :         a			>>=	31;

	sar	r8d, 31

; 92   :         r			-=	(imask&a);

	and	eax, r8d
	sub	r9d, eax
	lea	eax, DWORD PTR [rdx-32]
	sar	eax, 31

; 93   :         r			&=	exponent;

	and	r9d, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	eax, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 94   :         r			^=	a;

	xor	r9d, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	r11d, eax
	cmova	r11d, eax
	cmp	r10d, ecx
	cmova	r10d, ecx
	cmp	r9d, eax
	mov	DWORD PTR ix$2$[rbp-120], r11d
	cmova	r9d, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 355  : 			vl = &(VM[ix][iy][iz]);

	mov	eax, r11d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	DWORD PTR iy$2$[rbp-120], r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 355  : 			vl = &(VM[ix][iy][iz]);

	mov	r13d, r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	DWORD PTR iz$2$[rbp-120], r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 355  : 			vl = &(VM[ix][iy][iz]);

	imul	rcx, rax, 17
	mov	eax, r10d
	mov	QWORD PTR tv2373[rbp-120], rcx
	mov	QWORD PTR tv2370[rbp-120], r13
	mov	QWORD PTR tv2372[rbp-120], rax
	add	rax, rcx
	imul	rax, rax, 25
	mov	QWORD PTR tv2371[rbp-120], rax
	add	rax, 3
	add	rax, r13
	lea	rcx, QWORD PTR [rax+rax*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rsi+rcx*8]
	mov	r9, QWORD PTR [rsi+rcx*8+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 355  : 			vl = &(VM[ix][iy][iz]);

	lea	rdi, QWORD PTR [rsi+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rax, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 356  : 			for(DWORDIt it=vl->begin();it!=vl->end(); it++)

	je	SHORT $LN669@VPack
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	r8, QWORD PTR [rsi]
	movss	xmm1, DWORD PTR __real@3a83126f
	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	npad	7
$LL48@VPack:
	mov	ecx, DWORD PTR [rax]

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	lea	rdx, QWORD PTR [rcx+rcx*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	movss	xmm0, DWORD PTR [r8+rdx*4]
	subss	xmm0, xmm5
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm1
	jae	SHORT $LN93@VPack
	movss	xmm0, DWORD PTR [r8+rdx*4+4]
	subss	xmm0, xmm3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm1
	jae	SHORT $LN93@VPack
	movss	xmm0, DWORD PTR [r8+rdx*4+8]
	subss	xmm0, xmm4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 58   : 	ICF BOOL	similar(const Self &v, T E=EPS_L) const	{ return _abs(x-v.x)<E && _abs(y-v.y)<E && _abs(z-v.z)<E;};

	comiss	xmm0, xmm1
	jb	SHORT $LN665@VPack
$LN93@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rax, 4

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rax, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 356  : 			for(DWORDIt it=vl->begin();it!=vl->end(); it++)

	jne	SHORT $LL48@VPack
	jmp	SHORT $LN669@VPack
$LN665@VPack:

; 357  : 				if( verts[*it].similar(V) )	{
; 358  : 					P = *it;

	mov	eax, DWORD PTR [rax]

; 359  : 					break;
; 360  : 				}
; 361  : 		}
; 362  : 		if (0xffffffff==P)

	cmp	eax, -1					; ffffffffH
	jne	$LN599@VPack
$LN669@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rsi+8]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	QWORD PTR [rsp+112], r12
	sub	rcx, QWORD PTR [rsi]
	mov	QWORD PTR [rsp+104], r15
	imul	rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 365  : 			verts.push_back(V);

	mov	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 365  : 			verts.push_back(V);

	mov	rdx, r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sar	rbx, 1
	mov	rax, rbx
	shr	rax, 63					; 0000003fH
	add	rbx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 364  : 			P = verts.size();

	mov	DWORD PTR P$[rbp-120], ebx

; 365  : 			verts.push_back(V);

	call	?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rdi+8]
	lea	rcx, QWORD PTR P$[rbp-120]
	cmp	rcx, rax
	jae	SHORT $LN118@VPack
	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR P$[rbp-120]
	cmp	rcx, rdx
	ja	SHORT $LN118@VPack

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	r14, QWORD PTR P$[rbp-120]
	sub	r14, rcx
	sar	r14, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN117@VPack

; 1248 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN117@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN149@VPack
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+r14*4]
	mov	DWORD PTR [rdx], ecx
$LN149@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	mov	r14, QWORD PTR V$[rbp-120]
	jmp	SHORT $LN175@VPack
$LN118@VPack:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN115@VPack

; 1257 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN115@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN175@VPack
	mov	DWORD PTR [rax], ebx
$LN175@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rdi+8], 4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 370  : 			ixE = iFloor(float(V.x+VMeps.x-VMmin.x)/VMscale.x*clpMX);

	movss	xmm0, DWORD PTR [rsi+255072]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r9d, 158				; 0000009eH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 370  : 			ixE = iFloor(float(V.x+VMeps.x-VMmin.x)/VMscale.x*clpMX);

	addss	xmm0, DWORD PTR [r14]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edx, r9d

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	r10d, 1
	mov	r11d, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 370  : 			ixE = iFloor(float(V.x+VMeps.x-VMmin.x)/VMscale.x*clpMX);

	subss	xmm0, DWORD PTR [rsi+48]
	divss	xmm0, DWORD PTR [rsi+60]
	mulss	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR a$6[rbp-120], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r8d, DWORD PTR a$6[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 371  : 			iyE = iFloor(float(V.y+VMeps.y-VMmin.y)/VMscale.y*clpMY);

	movss	xmm0, DWORD PTR [rsi+255076]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, r8d

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r12d, r8d
	sar	eax, 23
	or	r12d, -8388608				; ff800000H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 371  : 			iyE = iFloor(float(V.y+VMeps.y-VMmin.y)/VMscale.y*clpMY);

	addss	xmm0, DWORD PTR [r14+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	movzx	ecx, al

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	shl	r12d, 8

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 371  : 			iyE = iFloor(float(V.y+VMeps.y-VMmin.y)/VMscale.y*clpMY);

	subss	xmm0, DWORD PTR [rsi+52]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	sub	edx, ecx

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ecx, edx
	shr	r12d, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	lea	ecx, DWORD PTR [rdx-96]
	shl	eax, cl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 371  : 			iyE = iFloor(float(V.y+VMeps.y-VMmin.y)/VMscale.y*clpMY);

	divss	xmm0, DWORD PTR [rsi+64]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	dec	eax
	sar	eax, 8
	test	eax, r8d
	mov	eax, r11d
	sete	al

; 91   :         a			>>=	31;

	sar	r8d, 31

; 92   :         r			-=	(imask&a);

	and	eax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 371  : 			iyE = iFloor(float(V.y+VMeps.y-VMmin.y)/VMscale.y*clpMY);

	mulss	xmm0, DWORD PTR __real@41800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 92   :         r			-=	(imask&a);

	sub	r12d, eax
	lea	eax, DWORD PTR [rdx-32]
	sar	eax, 31

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edx, r9d

; 93   :         r			&=	exponent;

	and	r12d, eax

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR a$5[rbp-120], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 372  : 			izE = iFloor(float(V.z+VMeps.z-VMmin.z)/VMscale.z*clpMZ);

	movss	xmm0, DWORD PTR [rsi+255080]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 94   :         r			^=	a;

	xor	r12d, r8d

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r8d, DWORD PTR a$5[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 372  : 			izE = iFloor(float(V.z+VMeps.z-VMmin.z)/VMscale.z*clpMZ);

	addss	xmm0, DWORD PTR [r14+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, r8d

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r15d, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 372  : 			izE = iFloor(float(V.z+VMeps.z-VMmin.z)/VMscale.z*clpMZ);

	subss	xmm0, DWORD PTR [rsi+56]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	sar	eax, 23

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	or	r15d, -8388608				; ff800000H
	movzx	ecx, al
	shl	r15d, 8

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 372  : 			izE = iFloor(float(V.z+VMeps.z-VMmin.z)/VMscale.z*clpMZ);

	divss	xmm0, DWORD PTR [rsi+68]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	sub	edx, ecx

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	ecx, edx
	shr	r15d, cl

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	lea	ecx, DWORD PTR [rdx-96]
	shl	eax, cl
	dec	eax
	sar	eax, 8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 372  : 			izE = iFloor(float(V.z+VMeps.z-VMmin.z)/VMscale.z*clpMZ);

	mulss	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	test	eax, r8d
	mov	eax, r11d
	sete	al

; 91   :         a			>>=	31;

	sar	r8d, 31

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR a$4[rbp-120], xmm0

; 92   :         r			-=	(imask&a);

	and	eax, r8d
	sub	r15d, eax
	lea	eax, DWORD PTR [rdx-32]

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edx, DWORD PTR a$4[rbp-120]

; 90   :         exponent	>>=	31;

	sar	eax, 31

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r14d, edx

; 93   :         r			&=	exponent;

	and	r15d, eax

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, edx
	sar	eax, 23

; 94   :         r			^=	a;

	xor	r15d, r8d

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	movzx	ecx, al
	sub	r9d, ecx

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	or	r14d, -8388608				; ff800000H
	shl	r14d, 8
	mov	ecx, r9d

; 89   :         exponent	-=	(31-127)+32;

	lea	eax, DWORD PTR [r9-32]
	shr	r14d, cl
	lea	ecx, DWORD PTR [r9-96]
	shl	r10d, cl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	ecx, 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	dec	r10d
	sar	r10d, 8
	test	r10d, edx
	sete	r11b

; 91   :         a			>>=	31;

	sar	edx, 31
	sar	eax, 31

; 92   :         r			-=	(imask&a);

	and	r11d, edx
	sub	r14d, r11d

; 93   :         r			&=	exponent;

	and	r14d, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	eax, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 94   :         r			^=	a;

	xor	r14d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	cmp	r12d, 24
	cmova	r12d, eax
	cmp	r15d, 16
	cmova	r15d, ecx
	cmp	r14d, eax
	cmova	r14d, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 377  : 			if (ixE!=ix)							VM[ixE][iy][iz].push_back	(P);

	cmp	r12d, DWORD PTR ix$2$[rbp-120]
	je	$LN203@VPack
	mov	eax, r12d
	imul	rcx, rax, 17
	add	rcx, QWORD PTR tv2372[rbp-120]
	imul	rcx, rcx, 25
	add	rcx, 3
	add	rcx, r13
	lea	rax, QWORD PTR [rcx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rcx, QWORD PTR P$[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 377  : 			if (ixE!=ix)							VM[ixE][iy][iz].push_back	(P);

	lea	rdi, QWORD PTR [rsi+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rsi+rax*8+8]
	cmp	rcx, rax
	jae	SHORT $LN205@VPack
	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR P$[rbp-120]
	cmp	rcx, rdx
	ja	SHORT $LN205@VPack

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	r13, QWORD PTR P$[rbp-120]
	sub	r13, rcx
	sar	r13, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN204@VPack

; 1248 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN204@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN236@VPack
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+r13*4]
	mov	DWORD PTR [rdx], ecx
$LN236@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	mov	r13, QWORD PTR tv2370[rbp-120]
	jmp	SHORT $LN262@VPack
$LN205@VPack:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN202@VPack

; 1257 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN202@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN262@VPack
	mov	DWORD PTR [rax], ebx
$LN262@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rdi+8], 4
$LN203@VPack:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 378  : 			if (iyE!=iy)							VM[ix][iyE][iz].push_back	(P);

	cmp	r15d, DWORD PTR iy$2$[rbp-120]
	je	SHORT $LN269@VPack
	mov	eax, r15d
	add	rax, QWORD PTR tv2373[rbp-120]
	imul	rcx, rax, 25
	add	rcx, 3
	add	rcx, r13
	lea	rax, QWORD PTR [rcx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rcx, QWORD PTR P$[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 378  : 			if (iyE!=iy)							VM[ix][iyE][iz].push_back	(P);

	lea	rdi, QWORD PTR [rsi+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rsi+rax*8+8]
	cmp	rcx, rax
	jae	SHORT $LN271@VPack
	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR P$[rbp-120]
	cmp	rcx, rdx
	ja	SHORT $LN271@VPack

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	r13, QWORD PTR P$[rbp-120]
	sub	r13, rcx
	sar	r13, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN270@VPack

; 1248 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN270@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN328@VPack
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+r13*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN328@VPack
$LN271@VPack:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN268@VPack

; 1257 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN268@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN328@VPack
	mov	DWORD PTR [rax], ebx
$LN328@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rdi+8], 4
$LN269@VPack:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 379  : 			if (izE!=iz)							VM[ix][iy][izE].push_back	(P);

	cmp	r14d, DWORD PTR iz$2$[rbp-120]
	je	SHORT $LN335@VPack
	mov	rcx, QWORD PTR tv2371[rbp-120]
	mov	eax, r14d
	add	rcx, 3
	add	rcx, rax
	lea	rax, QWORD PTR [rcx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rcx, QWORD PTR P$[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 379  : 			if (izE!=iz)							VM[ix][iy][izE].push_back	(P);

	lea	rdi, QWORD PTR [rsi+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rsi+rax*8+8]
	cmp	rcx, rax
	jae	SHORT $LN337@VPack
	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR P$[rbp-120]
	cmp	rcx, rdx
	ja	SHORT $LN337@VPack

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	r13, QWORD PTR P$[rbp-120]
	sub	r13, rcx
	sar	r13, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN336@VPack

; 1248 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN336@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN394@VPack
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+r13*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN394@VPack
$LN337@VPack:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN334@VPack

; 1257 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN334@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN394@VPack
	mov	DWORD PTR [rax], ebx
$LN394@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rdi+8], 4
$LN335@VPack:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 380  : 			if ((ixE!=ix)&&(iyE!=iy))				VM[ixE][iyE][iz].push_back	(P);

	cmp	r12d, DWORD PTR ix$2$[rbp-120]
	je	$LN685@VPack
	cmp	r15d, DWORD PTR iy$2$[rbp-120]
	je	$LN401@VPack
	mov	eax, r12d
	imul	rcx, rax, 17
	mov	eax, r15d
	add	rcx, rax
	imul	rax, rcx, 25
	mov	rcx, QWORD PTR tv2370[rbp-120]
	add	rcx, 3
	add	rcx, rax
	lea	rax, QWORD PTR [rcx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rcx, QWORD PTR P$[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 380  : 			if ((ixE!=ix)&&(iyE!=iy))				VM[ixE][iyE][iz].push_back	(P);

	lea	rdi, QWORD PTR [rsi+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rsi+rax*8+8]
	cmp	rcx, rax
	jae	SHORT $LN403@VPack
	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR P$[rbp-120]
	cmp	rcx, rdx
	ja	SHORT $LN403@VPack

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	r13, QWORD PTR P$[rbp-120]
	sub	r13, rcx
	sar	r13, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN402@VPack

; 1248 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN402@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN460@VPack
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+r13*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN460@VPack
$LN403@VPack:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN400@VPack

; 1257 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN400@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN460@VPack
	mov	DWORD PTR [rax], ebx
$LN460@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rdi+8], 4
$LN401@VPack:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 381  : 			if ((ixE!=ix)&&(izE!=iz))				VM[ixE][iy][izE].push_back	(P);

	mov	eax, DWORD PTR iz$2$[rbp-120]
	cmp	r14d, eax
	je	$LN467@VPack
	mov	eax, r12d
	imul	rcx, rax, 17
	add	rcx, QWORD PTR tv2372[rbp-120]
	imul	rdx, rcx, 25
	mov	ecx, r14d
	add	rcx, 3
	add	rcx, rdx
	lea	rax, QWORD PTR [rcx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rcx, QWORD PTR P$[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 381  : 			if ((ixE!=ix)&&(izE!=iz))				VM[ixE][iy][izE].push_back	(P);

	lea	rdi, QWORD PTR [rsi+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rsi+rax*8+8]
	cmp	rcx, rax
	jae	SHORT $LN469@VPack
	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR P$[rbp-120]
	cmp	rcx, rdx
	ja	SHORT $LN469@VPack

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	r13, QWORD PTR P$[rbp-120]
	sub	r13, rcx
	sar	r13, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN468@VPack

; 1248 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN468@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN526@VPack
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+r13*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN526@VPack
$LN469@VPack:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN466@VPack

; 1257 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN466@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN526@VPack
	mov	DWORD PTR [rax], ebx
$LN526@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rdi+8], 4
$LN685@VPack:
	mov	eax, DWORD PTR iz$2$[rbp-120]
$LN467@VPack:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 382  : 			if ((iyE!=iy)&&(izE!=iz))				VM[ix][iyE][izE].push_back	(P);

	mov	ecx, DWORD PTR iy$2$[rbp-120]
	cmp	r15d, ecx
	je	$LN533@VPack
	cmp	r14d, eax
	je	$LN533@VPack
	mov	eax, r15d
	add	rax, QWORD PTR tv2373[rbp-120]
	imul	rcx, rax, 25
	mov	eax, r14d
	add	rax, 3
	add	rcx, rax
	lea	rax, QWORD PTR [rcx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rcx, QWORD PTR P$[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 382  : 			if ((iyE!=iy)&&(izE!=iz))				VM[ix][iyE][izE].push_back	(P);

	lea	rdi, QWORD PTR [rsi+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rsi+rax*8+8]
	cmp	rcx, rax
	jae	SHORT $LN535@VPack
	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR P$[rbp-120]
	cmp	rcx, rdx
	ja	SHORT $LN535@VPack

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	r13, QWORD PTR P$[rbp-120]
	sub	r13, rcx
	sar	r13, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN534@VPack

; 1248 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN534@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN592@VPack
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+r13*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN592@VPack
$LN535@VPack:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN532@VPack

; 1257 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN532@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN592@VPack
	mov	DWORD PTR [rax], ebx
$LN592@VPack:
	mov	ecx, DWORD PTR iy$2$[rbp-120]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rdi+8], 4
$LN533@VPack:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 383  : 			if ((ixE!=ix)&&(iyE!=iy)&&(izE!=iz))	VM[ixE][iyE][izE].push_back	(P);

	cmp	r12d, DWORD PTR ix$2$[rbp-120]
	je	$LN681@VPack
	cmp	r15d, ecx
	je	$LN681@VPack
	cmp	r14d, DWORD PTR iz$2$[rbp-120]
	je	$LN681@VPack
	mov	eax, r12d
	imul	rcx, rax, 17
	mov	eax, r15d
	add	rcx, rax
	mov	eax, r14d
	add	rax, 3
	imul	rcx, rcx, 25
	add	rcx, rax
	lea	rax, QWORD PTR [rcx+rcx*2]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rcx, QWORD PTR P$[rbp-120]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 383  : 			if ((ixE!=ix)&&(iyE!=iy)&&(izE!=iz))	VM[ixE][iyE][izE].push_back	(P);

	lea	rdi, QWORD PTR [rsi+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rsi+rax*8+8]
	cmp	rcx, rax
	jae	SHORT $LN601@VPack
	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR P$[rbp-120]
	cmp	rcx, rdx
	ja	SHORT $LN601@VPack

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rsi, QWORD PTR P$[rbp-120]
	sub	rsi, rcx
	sar	rsi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN600@VPack

; 1248 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN600@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rdi+8]
	test	rdx, rdx
	je	SHORT $LN658@VPack
	mov	rax, QWORD PTR [rdi]
	mov	ecx, DWORD PTR [rax+rsi*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN658@VPack
$LN601@VPack:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rdi+16]
	jne	SHORT $LN598@VPack

; 1257 : 				_Reserve(1);

	mov	rcx, rdi
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN598@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN658@VPack
	mov	DWORD PTR [rax], ebx
$LN658@VPack:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rdi+8], 4
$LN681@VPack:
	mov	r12, QWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+104]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 385  : 		return P;

	mov	eax, ebx
$LN599@VPack:

; 386  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	add	rsp, 120				; 00000078H
	pop	r14
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?VPack@CollectorPacked@CDB@@AEAAIAEBU?$_vector3@M@@@Z ENDP ; CDB::CollectorPacked::VPack
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
_TEXT	SEGMENT
this$ = 8
?clear@CollectorPacked@CDB@@QEAAXXZ PROC		; CDB::CollectorPacked::clear
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	r9d, 25
	mov	QWORD PTR [rcx+8], rax
	mov	rax, QWORD PTR [rcx+24]
	mov	QWORD PTR [rcx+32], rax
	lea	rax, QWORD PTR [rcx+72]
	npad	7
$LL9@clear:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 393  : 			for (u32 _y=0; _y<=clpMY; _y++)

	mov	r8d, 17
	npad	10
$LL6@clear:

; 394  : 				for (u32 _z=0; _z<=clpMZ; _z++)

	mov	edx, 25
	npad	11
$LL3@clear:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rcx, QWORD PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 394  : 				for (u32 _z=0; _z<=clpMZ; _z++)

	add	rax, 24
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rax-16], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 394  : 				for (u32 _z=0; _z<=clpMZ; _z++)

	dec	rdx
	jne	SHORT $LL3@clear

; 393  : 			for (u32 _y=0; _y<=clpMY; _y++)

	dec	r8
	jne	SHORT $LL6@clear

; 390  : 		verts.clear_and_free	();
; 391  : 		faces.clear_and_free	();
; 392  : 		for (u32 _x=0; _x<=clpMX; _x++)

	dec	r9
	jne	SHORT $LL9@clear

; 395  : 					VM[_x][_y][_z].clear_and_free	();
; 396  : 	}

	ret	0
?clear@CollectorPacked@CDB@@QEAAXXZ ENDP		; CDB::CollectorPacked::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAU?$_vector3@M@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAU?$_vector3@M@@_K@Z PROC ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::operator[], COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax+rdx*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	0
??A?$xr_vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@@QEAAAEAU?$_vector3@M@@_K@Z ENDP ; xr_vector<_vector3<float>,xalloc<_vector3<float> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAX_K@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::reserve, COMDAT

; 999  : 		{	// determine new minimum length of allocated storage

$LN24:
	sub	rsp, 40					; 00000028H

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 999  : 		{	// determine new minimum length of allocated storage

	mov	r9, rdx

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	imul	r8
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1000 : 		if (capacity() < _Count)

	cmp	rdx, r9
	jae	SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	rax, 1537228672809129301		; 1555555555555555H
	cmp	r9, rax
	jbe	SHORT $LN1@reserve

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@reserve:

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	mov	rdx, r9

; 1005 : 			}
; 1006 : 		}

	add	rsp, 40					; 00000028H

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	jmp	?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate
$LN2@reserve:

; 1005 : 			}
; 1006 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN23@reserve:
?reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAX_K@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@2@XZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back, COMDAT

; 1243 : 		{	// insert element at end

$LN70:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rcx, QWORD PTR [rcx+8]

; 1243 : 		{	// insert element at end

	mov	rdi, rdx

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, rcx
	jae	SHORT $LN4@push_back
	mov	rax, QWORD PTR [rbx]
	cmp	rax, rdx
	ja	SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	sub	rdi, rax
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rdi
	mov	rdi, rdx
	sar	rdi, 1
	mov	rax, rdi
	shr	rax, 63					; 0000003fH
	add	rdi, rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rcx, QWORD PTR [rbx+16]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdi+rdi*2]
	lea	rdx, QWORD PTR [rax+rcx*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN61@push_back
	movsdx	xmm0, QWORD PTR [rdx]
	movsdx	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+8], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 12

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@push_back:

; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rcx, QWORD PTR [rbx+16]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN61@push_back
	movsdx	xmm0, QWORD PTR [rdi]
	movsdx	QWORD PTR [rcx], xmm0
	mov	eax, DWORD PTR [rdi+8]
	mov	DWORD PTR [rcx+8], eax
$LN61@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 12

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXAEBU?$_vector3@M@@@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@IV?$xalloc@I@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear_and_free@?$xr_vector@IV?$xalloc@I@@@@QEAAXXZ PROC ; xr_vector<unsigned int,xalloc<unsigned int> >::clear_and_free, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	ret	0
?clear_and_free@?$xr_vector@IV?$xalloc@I@@@@QEAAXXZ ENDP ; xr_vector<unsigned int,xalloc<unsigned int> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@IV?$xalloc@I@@@@QEAAAEAI_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$xr_vector@IV?$xalloc@I@@@@QEAAAEAI_K@Z PROC	; xr_vector<unsigned int,xalloc<unsigned int> >::operator[], COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	0
??A?$xr_vector@IV?$xalloc@I@@@@QEAAAEAI_K@Z ENDP	; xr_vector<unsigned int,xalloc<unsigned int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?reserve@?$vector@IV?$xalloc@I@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?reserve@?$vector@IV?$xalloc@I@@@std@@QEAAX_K@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::reserve, COMDAT

; 999  : 		{	// determine new minimum length of allocated storage

$LN24:
	sub	rsp, 40					; 00000028H

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1000 : 		if (capacity() < _Count)

	cmp	rax, rdx
	jae	SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN1@reserve

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@reserve:

; 1005 : 			}
; 1006 : 		}

	add	rsp, 40					; 00000028H

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	jmp	?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
$LN2@reserve:

; 1005 : 			}
; 1006 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN23@reserve:
?reserve@?$vector@IV?$xalloc@I@@@std@@QEAAX_K@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,xalloc<unsigned int> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,xalloc<unsigned int> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::push_back, COMDAT

; 1243 : 		{	// insert element at end

$LN69:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]

; 1243 : 		{	// insert element at end

	mov	rdi, rdx
	mov	rbx, rcx

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN4@push_back
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	sub	rdi, rcx
	sar	rdi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN61@push_back
	mov	rax, QWORD PTR [rbx]
	mov	ecx, DWORD PTR [rax+rdi*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 4

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN61@push_back
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx], eax
$LN61@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 4

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?assign@?$vector@IV?$xalloc@I@@@std@@QEAAX_KAEBI@Z
_TEXT	SEGMENT
$T1 = 64
this$ = 64
_Count$ = 72
_Val$ = 80
?assign@?$vector@IV?$xalloc@I@@@std@@QEAAX_KAEBI@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::assign, COMDAT

; 1321 : 		{	// assign _Count * _Val

$LN18:
	sub	rsp, 56					; 00000038H
	mov	rax, r8

; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	r8, QWORD PTR [rcx]

; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));

	mov	r9, rdx
	lea	rdx, QWORD PTR $T1[rsp]

; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rcx+8], r8

; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));

	mov	QWORD PTR [rsp+32], rax
	call	?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n

; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}

	add	rsp, 56					; 00000038H
	ret	0
?assign@?$vector@IV?$xalloc@I@@@std@@QEAAX_KAEBI@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEAIXZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEAIXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEAIXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++, COMDAT

; 340  : 		_Myiter _Tmp = *this;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 112  : 		++this->_Ptr;

	add	rax, 4
	mov	QWORD PTR [rcx], rax

; 341  : 		++*this;
; 342  : 		return (_Tmp);

	mov	rax, rdx

; 343  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAVTRI@CDB@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAVTRI@CDB@@_K@Z PROC ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::operator[], COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+rdx*2]
	lea	rax, QWORD PTR [rax+rdx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	0
??A?$xr_vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@@QEAAAEAVTRI@CDB@@_K@Z ENDP ; xr_vector<CDB::TRI,xalloc<CDB::TRI> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAX_K@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::reserve, COMDAT

; 999  : 		{	// determine new minimum length of allocated storage

$LN24:
	sub	rsp, 40					; 00000028H

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 999  : 		{	// determine new minimum length of allocated storage

	mov	r9, rdx

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	imul	r8
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1000 : 		if (capacity() < _Count)

	cmp	rdx, r9
	jae	SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	cmp	r9, rax
	jbe	SHORT $LN1@reserve

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@reserve:

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	mov	rdx, r9

; 1005 : 			}
; 1006 : 		}

	add	rsp, 40					; 00000028H

; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	jmp	?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate
$LN2@reserve:

; 1005 : 			}
; 1006 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN23@reserve:
?reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAX_K@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@2@XZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAVTRI@CDB@@XZ
_TEXT	SEGMENT
this$ = 8
?back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAVTRI@CDB@@XZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::back, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, 24

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

	ret	0
?back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAAEAVTRI@CDB@@XZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXAEBVTRI@CDB@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXAEBVTRI@CDB@@@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::push_back, COMDAT

; 1243 : 		{	// insert element at end

$LN70:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rcx, QWORD PTR [rcx+8]

; 1243 : 		{	// insert element at end

	mov	rdi, rdx

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, rcx
	jae	SHORT $LN4@push_back
	mov	rax, QWORD PTR [rbx]
	cmp	rax, rdx
	ja	SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	sub	rdi, rax
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rdi
	mov	rdi, rdx
	sar	rdi, 2
	mov	rax, rdi
	shr	rax, 63					; 0000003fH
	add	rdi, rax

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rcx, QWORD PTR [rbx+16]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN3@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);

	mov	rax, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdi+rdi*2]
	lea	rdx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	je	SHORT $LN61@push_back
	movups	xmm0, XMMWORD PTR [rdx]
	movups	XMMWORD PTR [rax], xmm0
	movsdx	xmm1, QWORD PTR [rdx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN68@push_back
$LN4@push_back:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rcx, QWORD PTR [rbx+16]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	je	SHORT $LN61@push_back
	movups	xmm0, XMMWORD PTR [rdi]
	movups	XMMWORD PTR [rax], xmm0
	movsdx	xmm1, QWORD PTR [rdi+16]
$LN68@push_back:
	movsdx	QWORD PTR [rax+16], xmm1
$LN61@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 24

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXAEBVTRI@CDB@@@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::pop_back, COMDAT

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

	add	QWORD PTR [rcx+8], -24

; 1283 : 		}

	ret	0
?pop_back@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >, COMDAT

; 42   : 		{	// construct with null pointer

	mov	QWORD PTR [rcx], 0

; 301  : 		{	// construct with null vector pointer
; 302  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAPEAU?$_vector3@M@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAPEAU?$_vector3@M@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator->, COMDAT

; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

	mov	rax, QWORD PTR [rcx]

; 330  : 		}

	ret	0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAPEAU?$_vector3@M@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++, COMDAT

; 340  : 		_Myiter _Tmp = *this;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 112  : 		++this->_Ptr;

	add	rax, 12
	mov	QWORD PTR [rcx], rax

; 341  : 		++*this;
; 342  : 		return (_Tmp);

	mov	rax, rdx

; 343  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_JAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_JAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator-, COMDAT

; 194  : 		return (this->_Ptr - _Right._Ptr);

	mov	r8, QWORD PTR [rcx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rdx]
	imul	r8
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}

	ret	0
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_JAEBV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

	setne	al

; 211  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator++, COMDAT

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 24

; 113  : 		return (*this);

	mov	rax, rcx

; 114  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_JAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_JAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-, COMDAT

; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);

	mov	r8, QWORD PTR [rcx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rdx]
	imul	r8
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_JAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

	setne	al

; 211  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBA_NPEBU?$_vector3@M@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBA_NPEBU?$_vector3@M@@@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Inside, COMDAT

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1584 : 		}

	ret	0
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	xor	al, al

; 1584 : 		}

	ret	0
?_Inside@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBA_NPEBU?$_vector3@M@@@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate, COMDAT

; 1587 : 		{	// move to array of exactly _Count elements

$LN58:
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	r14, rdx
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 2
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	rdi, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, rax
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r8, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	sub	rcx, r8
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	mov	rsi, rdx
	sar	rsi, 1
	mov	rax, rsi
	shr	rax, 63					; 0000003fH
	add	rsi, rax

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

	test	r8, r8
	je	SHORT $LN52@Reallocate
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, r8
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN52@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR [rbx+16], rcx

; 1607 : 		this->_Mylast = _Ptr + _Size;

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	rcx, QWORD PTR [rdi+rax*4]
	mov	QWORD PTR [rbx+8], rcx

; 1608 : 		this->_Myfirst = _Ptr;

	mov	QWORD PTR [rbx], rdi

; 1609 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN57@Reallocate:
?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate'::`1'::catch$0

; 1592 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z$0:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR _Ptr$[rbp]
	test	rdx, rdx
	je	SHORT $LN41@catch$0
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN41@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1594 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reserve, COMDAT

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

$LN47:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	r9, QWORD PTR [rcx+16]
	mov	r8, QWORD PTR [rcx+8]
	mov	rbx, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdx, r9
	mov	rax, rbx
	sub	rdx, r8
	imul	rdx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1613 : 		if (_Unused_capacity() < _Count)

	cmp	rdx, 1
	jae	$LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r11, QWORD PTR [rcx]
	mov	rax, rbx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	r10, 1537228672809129301		; 1555555555555555H

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r8, r11
	imul	r8
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	rax, r10
	sub	rax, rdx
	cmp	rax, 1
	jae	SHORT $LN1@Reserve

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@Reserve:

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	lea	r8, QWORD PTR [rdx+1]

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r9, r11
	mov	rax, rbx
	imul	r9
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rdx
	shr	rax, 1
	sub	r10, rax
	cmp	r10, rdx
	jae	SHORT $LN29@Reserve
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate
$LN29@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rax

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN46@Reserve:
?_Reserve@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAX_K@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXPEAU?$_vector3@M@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXPEAU?$_vector3@M@@0@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBAXPEAU?$_vector3@M@@0@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$_vector3@M@@@std@@SAPEAU?$_vector3@M@@AEAU3@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAU?$_vector3@M@@@std@@SAPEAU?$_vector3@M@@AEAU3@@Z PROC ; std::pointer_traits<_vector3<float> * __ptr64>::pointer_to, COMDAT

; 234  : 		return (_STD addressof(_Val));

	mov	rax, rcx

; 235  : 		}

	ret	0
?pointer_to@?$pointer_traits@PEAU?$_vector3@M@@@std@@SAPEAU?$_vector3@M@@AEAU3@@Z ENDP ; std::pointer_traits<_vector3<float> * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ PROC	; std::vector<unsigned int,xalloc<unsigned int> >::capacity, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1011 : 		}

	ret	0
?capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ PROC	; std::vector<unsigned int,xalloc<unsigned int> >::max_size, COMDAT

; 1153 : 		return (this->_Getal().max_size());

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1154 : 		}

	ret	0
?max_size@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?insert@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Where$ = 80
_Count$ = 88
_Val$ = 96
?insert@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::insert, COMDAT

; 1333 : 		{	// insert _Count * _Val at _Where

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H

; 1334 : 		return (_Insert_n(_Where, _Count, _Val));

	mov	rax, QWORD PTR _Val$[rsp]
	mov	rbx, rdx
	mov	QWORD PTR [rsp+32], rax
	call	?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n
	mov	rax, rbx

; 1335 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?insert@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?clear@?$vector@IV?$xalloc@I@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@IV?$xalloc@I@@@std@@QEAAXXZ PROC	; std::vector<unsigned int,xalloc<unsigned int> >::clear, COMDAT

; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax

; 1511 : 		}

	ret	0
?clear@?$vector@IV?$xalloc@I@@@std@@QEAAXXZ ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@IV?$xalloc@I@@@std@@IEBA_NPEBI@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@IV?$xalloc@I@@@std@@IEBA_NPEBI@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Inside, COMDAT

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1584 : 		}

	ret	0
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	xor	al, al

; 1584 : 		}

	ret	0
?_Inside@?$vector@IV?$xalloc@I@@@std@@IEBA_NPEBI@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate, COMDAT

; 1587 : 		{	// move to array of exactly _Count elements

$LN60:
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	r14, rdx
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, edx
	shl	rdx, 2
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	rsi, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, rax
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]
	sub	rdi, rdx
	sar	rdi, 2

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN54@Reallocate
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN54@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

	lea	rax, QWORD PTR [rsi+r14*4]
	mov	QWORD PTR [rbx+16], rax

; 1607 : 		this->_Mylast = _Ptr + _Size;

	lea	rax, QWORD PTR [rsi+rdi*4]
	mov	QWORD PTR [rbx+8], rax

; 1608 : 		this->_Myfirst = _Ptr;

	mov	QWORD PTR [rbx], rsi

; 1609 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN59@Reallocate:
?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate'::`1'::catch$0

; 1592 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z$0:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR _Ptr$[rbp]
	test	rdx, rdx
	je	SHORT $LN43@catch$0
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN43@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1594 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve, COMDAT

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

$LN47:
	sub	rsp, 40					; 00000028H

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, QWORD PTR [rcx+8]
	mov	rax, rdx
	sub	rax, r8
	sar	rax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r10, QWORD PTR [rcx]

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	r9, 4611686018427387903			; 3fffffffffffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r8, r10

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	rax, r9

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sar	r8, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	sub	rax, r8
	cmp	rax, 1
	jae	SHORT $LN1@Reserve

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@Reserve:

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rdx, r10

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	r8

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sar	rdx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rdx
	shr	rax, 1
	sub	r9, rax
	cmp	r9, rdx
	jae	SHORT $LN29@Reserve
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
$LN29@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rax

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN46@Reserve:
?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@IV?$xalloc@I@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@IV?$xalloc@I@@@std@@IEBAXXZ PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Xlen, COMDAT

; 1753 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@IV?$xalloc@I@@@std@@IEBAXXZ ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@IV?$xalloc@I@@@std@@IEBAXPEAI0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@IV?$xalloc@I@@@std@@IEBAXPEAI0@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@IV?$xalloc@I@@@std@@IEBAXPEAI0@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++, COMDAT

; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 4

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

	mov	rax, rcx

; 336  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEBIXZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEBIXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEBIXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBA_NPEBVTRI@CDB@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBA_NPEBVTRI@CDB@@@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Inside, COMDAT

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1584 : 		}

	ret	0
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	xor	al, al

; 1584 : 		}

	ret	0
?_Inside@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBA_NPEBVTRI@CDB@@@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate, COMDAT

; 1587 : 		{	// move to array of exactly _Count elements

$LN58:
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	r14, rdx
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	eax, edx
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rdx, 3
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	rdi, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, rax
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r8, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rbx+8]
	sub	rcx, r8
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	imul	rcx
	mov	rsi, rdx
	sar	rsi, 2
	mov	rax, rsi
	shr	rax, 63					; 0000003fH
	add	rsi, rax

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

	test	r8, r8
	je	SHORT $LN52@Reallocate
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, r8
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN52@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

	lea	rax, QWORD PTR [r14+r14*2]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR [rbx+16], rcx

; 1607 : 		this->_Mylast = _Ptr + _Size;

	lea	rax, QWORD PTR [rsi+rsi*2]
	lea	rcx, QWORD PTR [rdi+rax*8]
	mov	QWORD PTR [rbx+8], rcx

; 1608 : 		this->_Myfirst = _Ptr;

	mov	QWORD PTR [rbx], rdi

; 1609 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN57@Reallocate:
?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate'::`1'::catch$0

; 1592 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z$0:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR _Ptr$[rbp]
	test	rdx, rdx
	je	SHORT $LN41@catch$0
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN41@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1594 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve, COMDAT

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

$LN47:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	r9, QWORD PTR [rcx+16]
	mov	r8, QWORD PTR [rcx+8]
	mov	rbx, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	mov	rdx, r9
	mov	rax, rbx
	sub	rdx, r8
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1613 : 		if (_Unused_capacity() < _Count)

	cmp	rdx, 1
	jae	$LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r11, QWORD PTR [rcx]
	mov	rax, rbx

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	r10, 768614336404564650			; 0aaaaaaaaaaaaaaaH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r8, r11
	imul	r8
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	rax, r10
	sub	rax, rdx
	cmp	rax, 1
	jae	SHORT $LN1@Reserve

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@Reserve:

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	lea	r8, QWORD PTR [rdx+1]

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r9, r11
	mov	rax, rbx
	imul	r9
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rdx
	shr	rax, 1
	sub	r10, rax
	cmp	r10, rdx
	jae	SHORT $LN29@Reserve
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate
$LN29@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rax

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN46@Reserve:
?_Reserve@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAX_K@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXPEAVTRI@CDB@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXPEAVTRI@CDB@@0@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBAXPEAVTRI@CDB@@0@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++, COMDAT

; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 12

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

	mov	rax, rcx

; 336  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	r8, QWORD PTR [r8+r8*2]
	lea	rcx, QWORD PTR [rax+r8*4]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx

; 368  : 		}

	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >, COMDAT

; 42   : 		{	// construct with null pointer

	mov	QWORD PTR [rcx], 0

; 43   : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_JAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_JAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator-, COMDAT

; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);

	mov	r8, QWORD PTR [rcx]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rdx]
	imul	r8
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_JAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 206  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	r8, QWORD PTR [r8+r8*2]
	lea	rcx, QWORD PTR [rax+r8*8]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx

; 368  : 		}

	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$dead$ = 24
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	sub	rax, 24

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 379  : 		}

	ret	0
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 206  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Compat, COMDAT

; 255  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAPEAI_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAPEAI_K@Z PROC ; std::_Wrap_alloc<xalloc<unsigned int> >::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, edx
	shl	rdx, 2
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAPEAI_K@Z ENDP ; std::_Wrap_alloc<xalloc<unsigned int> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx+8]
	imul	rdx
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@QEBA_KXZ ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBA_K_K@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1571 : 		{	// grow by 50% or at least to _Count

	mov	r9, rdx

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	imul	r8
	sar	rdx, 1
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 1537228672809129301		; 1555555555555555H
	mov	rcx, rdx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, rdx
	jae	SHORT $LN4@Grow_to
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r9
	cmovb	rdx, r9

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, rdx

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r9
	cmovb	rdx, r9

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, rdx

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 2

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ PROC	; std::vector<unsigned int,xalloc<unsigned int> >::size, COMDAT

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 2

; 1149 : 		}

	ret	0
?size@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@IV?$xalloc@I@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@IV?$xalloc@I@@@std@@IEBA_K_K@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r8, QWORD PTR [rcx]
	sar	r8, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to
	xor	r8d, r8d

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@IV?$xalloc@I@@@std@@IEBA_K_K@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z
_TEXT	SEGMENT
_Ncopied$1 = 48
_Tmp$2 = 112
_Newvec$3 = 112
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$ = 136
_Val$ = 144
?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n, COMDAT

; 1653 : 		{	// insert _Count * _Val at _Where

$LN254:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], r8
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rax-48], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+32], rsi
	mov	rsi, r9
	mov	rax, r8
	mov	r13, rdx
	mov	rdi, rcx

; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;

	mov	r8, QWORD PTR [rcx]
	mov	r12, rax
	sub	r12, r8
	sar	r12, 2

; 1662 : 		if (_Count == 0)

	test	r9, r9
	je	$LN224@Insert_n

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rbx, QWORD PTR [rcx+16]
	mov	r14, QWORD PTR [rcx+8]
	mov	rcx, rbx
	sub	rcx, r14
	sar	rcx, 2

; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)

	cmp	rcx, r9
	jae	$LN10@Insert_n

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r14, r8
	sar	r14, 2

; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)

	mov	rcx, 4611686018427387903		; 3fffffffffffffffH
	mov	rax, rcx
	sub	rax, r14
	cmp	rax, r9
	jae	SHORT $LN9@Insert_n

; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN9@Insert_n:

; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);

	lea	rdx, QWORD PTR [r14+r9]

; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rbx, r8
	sar	rbx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rbx
	shr	rax, 1
	sub	rcx, rax
	cmp	rcx, rbx
	jae	SHORT $LN47@Insert_n
	xor	ebx, ebx
	jmp	SHORT $LN48@Insert_n
$LN47@Insert_n:
	add	rbx, rax
$LN48@Insert_n:

; 1576 : 		if (_Capacity < _Count)

	cmp	rbx, rdx
	cmovb	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ebx
	shl	rdx, 2
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	r14, rax
	mov	QWORD PTR _Newvec$3[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

	mov	r15, QWORD PTR _Where$[rsp]
	sub	r15, QWORD PTR [rdi]
	sar	r15, 2

; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff

	lea	rcx, QWORD PTR [rax+r15*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	mov	r8, QWORD PTR _Val$[rsp]
	mov	rdx, rsi
	call	??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1677 : 			++_Ncopied;

	mov	DWORD PTR _Ncopied$1[rsp], 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r14
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1680 : 			++_Ncopied;

	mov	DWORD PTR _Ncopied$1[rsp], 2

; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix

	lea	rax, QWORD PTR [r15+rsi]
	lea	r8, QWORD PTR [r14+rax*4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR _Where$[rsp]
	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rdi]
	mov	rax, QWORD PTR [rdi+8]
	sub	rax, rdx
	sar	rax, 2

; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();

	add	rsi, rax

; 1693 : 			if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN140@Insert_n
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN140@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1701 : 			this->_Myend = _Newvec + _Capacity;

	lea	rax, QWORD PTR [r14+rbx*4]
	mov	QWORD PTR [rdi+16], rax

; 1702 : 			this->_Mylast = _Newvec + _Count;

	lea	rax, QWORD PTR [r14+rsi*4]
	mov	QWORD PTR [rdi+8], rax

; 1703 : 			this->_Myfirst = _Newvec;

	mov	QWORD PTR [rdi], r14

; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))

	jmp	$LN224@Insert_n
$LN10@Insert_n:

; 1706 : 			< _Count)

	mov	rcx, r14
	sub	rcx, rax
	sar	rcx, 2
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rdx, r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1706 : 			< _Count)

	cmp	rcx, r9
	jae	$LN3@Insert_n

; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence

	mov	rcx, QWORD PTR _Val$[rsp]
	mov	r15d, DWORD PTR [rcx]
	mov	DWORD PTR _Tmp$2[rsp], r15d

; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix

	lea	rbx, QWORD PTR [r9*4]
	lea	r8, QWORD PTR [rbx+rax]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rcx, rax
	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end

	mov	rcx, QWORD PTR [rdi+8]
	mov	rax, rcx
	sub	rax, QWORD PTR _Where$[rsp]
	sar	rax, 2
	sub	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	lea	r8, QWORD PTR _Tmp$2[rsp]
	mov	rdx, rsi
	call	??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>
	npad	1
	add	QWORD PTR [rdi+8], rbx
	mov	rax, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1726 : 				_Tmp);	// insert up to old end

	sub	rax, rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

	mov	rcx, QWORD PTR _Where$[rsp]
	xor	ebx, ebx
	mov	rdx, rax
	sub	rdx, rcx
	add	rdx, 3
	shr	rdx, 2
	cmp	rcx, rax
	cmova	rdx, rbx

; 2599 : 	for (; _First != _Last; ++_First)

	test	rdx, rdx
	je	$LN224@Insert_n
	npad	6
$LL247@Insert_n:

; 2600 : 		*_First = _Val;

	mov	DWORD PTR [rcx], r15d
	lea	rcx, QWORD PTR [rcx+4]

; 2599 : 	for (; _First != _Last; ++_First)

	inc	rbx
	cmp	rbx, rdx
	jne	SHORT $LL247@Insert_n
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1728 : 		else

	jmp	SHORT $LN224@Insert_n
$LN3@Insert_n:

; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence

	mov	rax, QWORD PTR _Val$[rsp]
	mov	r15d, DWORD PTR [rax]

; 1734 : 				this->_Mylast);	// copy suffix

	lea	rsi, QWORD PTR [r9*4]
	mov	rbx, r14
	sub	rbx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r14
	mov	rcx, rbx
	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1734 : 				this->_Mylast);	// copy suffix

	mov	QWORD PTR [rdi+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	mov	rdx, QWORD PTR _Where$[rsp]
	sub	rbx, rdx
	sar	rbx, 2

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rbx*4]
	sub	r14, r8
	mov	rcx, r14
	call	QWORD PTR __imp_memmove

; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

	mov	rdx, QWORD PTR _Where$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

	lea	rax, QWORD PTR [rsi+rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rdx, rax
	je	SHORT $LN224@Insert_n
	npad	3
$LL226@Insert_n:

; 2600 : 		*_First = _Val;

	mov	DWORD PTR [rdx], r15d

; 2599 : 	for (; _First != _Last; ++_First)

	add	rdx, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

	mov	rcx, QWORD PTR _Where$[rsp]
	add	rcx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rdx, rcx
	jne	SHORT $LL226@Insert_n
$LN224@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rdi]
	lea	rcx, QWORD PTR [rax+r12*4]

; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	QWORD PTR [r13], rcx

; 1741 : 			}
; 1742 : 		return (begin() + _Off);

	mov	rax, r13

; 1743 : 		}

	mov	rbx, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+136]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN253@Insert_n:
?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
_Ncopied$1 = 48
_Tmp$2 = 112
_Newvec$3 = 112
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$ = 136
_Val$ = 144
?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA PROC ; `std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n'::`1'::catch$0

; 1683 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z$0:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR _Newvec$3[rbp]
	test	rdx, rdx
	je	SHORT $LN129@catch$0
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN129@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1689 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA ENDP ; `std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ncopied$1 = 48
_Tmp$2 = 112
_Newvec$3 = 112
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$ = 136
_Val$ = 144
?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA PROC ; `std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n'::`1'::catch$1

; 1717 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z$2:

; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$1@?0??_Insert_n@?$vector@IV?$xalloc@I@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@_KAEBI@Z@4HA ENDP ; `std::vector<unsigned int,xalloc<unsigned int> >::_Insert_n'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++, COMDAT

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 4

; 113  : 		return (*this);

	mov	rax, rcx

; 114  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rdx, QWORD PTR [rcx+16]
	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	rdx, QWORD PTR [rcx+8]
	imul	rdx
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rax, rdx

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@QEBA_KXZ ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBA_K_K@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1571 : 		{	// grow by 50% or at least to _Count

	mov	r9, rdx

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, 3074457345618258603		; 2aaaaaaaaaaaaaabH
	sub	r8, QWORD PTR [rcx]
	imul	r8
	sar	rdx, 2
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 768614336404564650			; 0aaaaaaaaaaaaaaaH
	mov	rcx, rdx
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, rdx
	jae	SHORT $LN4@Grow_to
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r9
	cmovb	rdx, r9

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, rdx

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r9
	cmovb	rdx, r9

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, rdx

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 2
	add	QWORD PTR [rcx], rax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++, COMDAT

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 12

; 113  : 		return (*this);

	mov	rax, rcx

; 114  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Compat, COMDAT

; 255  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 3
	add	QWORD PTR [rcx], rax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-=, COMDAT

; 170  : 		_Ptr += _Off;

	add	QWORD PTR [rcx], -24

; 372  : 		return (*this += -_Off);

	mov	rax, rcx

; 373  : 		}

	ret	0
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@I@@QEBAPEAI_KPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
n$ = 16
p$dead$ = 24
?allocate@?$xalloc@I@@QEBAPEAI_KPEBX@Z PROC		; xalloc<unsigned int>::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, edx
	shl	rdx, 2
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$xalloc@I@@QEBAPEAI_KPEBX@Z ENDP		; xalloc<unsigned int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI_KPEBI@Z
_TEXT	SEGMENT
this$dead$ = 64
_Ptr$ = 72
_Count$ = 80
_Pval$ = 88
?_Ufill@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI_KPEBI@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Ufill, COMDAT

; 1746 : 		{	// copy initializing _Count * _Val, using allocator

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, r8
	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	mov	r8, r9
	mov	rdx, rdi
	mov	rcx, rbx
	call	??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1749 : 		return (_Ptr + _Count);

	lea	rax, QWORD PTR [rbx+rdi*4]

; 1750 : 		}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_Ufill@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI_KPEBI@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 2
	add	QWORD PTR [rcx], rax

; 171  : 		return (*this);

	mov	rax, rcx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$_vector3@M@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_vector3<float> > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx+rdx*2]
	shl	rax, 3
	add	QWORD PTR [rcx], rax

; 171  : 		return (*this);

	mov	rax, rcx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@VTRI@CDB@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CDB::TRI> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@G@std@@YAXAEAG0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@G@std@@YAXAEAG0@Z PROC				; std::swap<unsigned short>, COMDAT

; 52   : 	_Ty _Tmp = _Move(_Left);
; 53   : 	_Left = _Move(_Right);

	movzx	eax, WORD PTR [rdx]
	movzx	r8d, WORD PTR [rcx]
	mov	WORD PTR [rcx], ax

; 54   : 	_Right = _Move(_Tmp);

	mov	WORD PTR [rdx], r8w

; 55   : 	}

	ret	0
??$swap@G@std@@YAXAEAG0@Z ENDP				; std::swap<unsigned short>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Pred$ = 64
??$sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z PROC ; std::sort<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT

; 3154 : 	{	// order [_First, _Last), using _Pred

$LN8:
	sub	rsp, 40					; 00000028H

; 3155 : 	_DEBUG_RANGE(_First, _Last);
; 3156 : 	_DEBUG_POINTER(_Pred);
; 3157 : 	_Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);

	mov	rax, rdx
	movzx	r9d, r8b
	sub	rax, rcx
	sar	rax, 3
	mov	r8, rax
	call	??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z ; std::_Sort<CDB::edge * __ptr64,__int64,CDB::sort_predicate>

; 3158 : 	}

	add	rsp, 40					; 00000028H
	ret	0
??$sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ENDP ; std::sort<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\vector.h
;	COMDAT ??$clamp@I@@YAXAEAIAEBI1@Z
_TEXT	SEGMENT
val$ = 8
_high$ = 16
??$clamp@I@@YAXAEAIAEBI1@Z PROC				; clamp<unsigned int>, COMDAT

; 92   : 	if( val<_low ) val = _low; else if( val>_high ) val = _high;

	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	jbe	SHORT $LN1@clamp
	mov	DWORD PTR [rcx], eax
$LN1@clamp:

; 93   : };

	ret	0
??$clamp@I@@YAXAEAIAEBI1@Z ENDP				; clamp<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBU?$_vector3@M@@@std@@YAPEBU?$_vector3@M@@AEBU1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBU?$_vector3@M@@@std@@YAPEBU?$_vector3@M@@AEBU1@@Z PROC ; std::addressof<_vector3<float> const >, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@$$CBU?$_vector3@M@@@std@@YAPEBU?$_vector3@M@@AEBU1@@Z ENDP ; std::addressof<_vector3<float> const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBI@std@@YAPEBIAEBI@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBI@std@@YAPEBIAEBI@Z PROC		; std::addressof<unsigned int const >, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@$$CBI@std@@YAPEBIAEBI@Z ENDP		; std::addressof<unsigned int const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@IAEAI@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAIAEAI@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@IAEAI@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAIAEAI@Z PROC ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@IAEAI@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAIAEAI@Z ENDP ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@IAEBI@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAIAEBI@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@IAEBI@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAIAEBI@Z PROC ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@IAEBI@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAIAEBI@Z ENDP ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBVTRI@CDB@@@std@@YAPEBVTRI@CDB@@AEBV12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBVTRI@CDB@@@std@@YAPEBVTRI@CDB@@AEBV12@@Z PROC ; std::addressof<CDB::TRI const >, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@$$CBVTRI@CDB@@@std@@YAPEBVTRI@CDB@@AEBV12@@Z ENDP ; std::addressof<CDB::TRI const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z PROC ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Umove<_vector3<float> * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN20:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAU?$_vector3@M@@@?$vector@U?$_vector3@M@@V?$xalloc@U?$_vector3@M@@@@@std@@IEAAPEAU?$_vector3@M@@PEAU2@00@Z ENDP ; std::vector<_vector3<float>,xalloc<_vector3<float> > >::_Umove<_vector3<float> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@AEAU1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@AEAU1@@Z PROC ; std::addressof<_vector3<float> >, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@U?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@AEAU1@@Z ENDP ; std::addressof<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Umove<unsigned int * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Umove<unsigned int * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z PROC ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Umove<CDB::TRI * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN20:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAVTRI@CDB@@@?$vector@VTRI@CDB@@V?$xalloc@VTRI@CDB@@@@@std@@IEAAPEAVTRI@CDB@@PEAV23@00@Z ENDP ; std::vector<CDB::TRI,xalloc<CDB::TRI> >::_Umove<CDB::TRI * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@I@std@@YAPEAIAEAI@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@I@std@@YAPEAIAEAI@Z PROC			; std::addressof<unsigned int>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@I@std@@YAPEAIAEAI@Z ENDP			; std::addressof<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$fill@PEAII@std@@YAXPEAI0AEBI@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$fill@PEAII@std@@YAXPEAI0AEBI@Z PROC			; std::fill<unsigned int * __ptr64,unsigned int>, COMDAT

; 2621 : 	{	// copy _Val through [_First, _Last)

	xor	r9d, r9d
	mov	r10, rdx
	sub	r10, rcx
	add	r10, 3
	shr	r10, 2
	cmp	rcx, rdx
	cmova	r10, r9

; 2599 : 	for (; _First != _Last; ++_First)

	test	r10, r10
	je	SHORT $LN7@fill
	npad	3
$LL9@fill:

; 2600 : 		*_First = _Val;

	mov	eax, DWORD PTR [r8]
	inc	r9
	lea	rcx, QWORD PTR [rcx+4]
	mov	DWORD PTR [rcx-4], eax
	cmp	r9, r10
	jne	SHORT $LL9@fill
$LN7@fill:

; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}

	ret	0
??$fill@PEAII@std@@YAXPEAI0AEBI@Z ENDP			; std::fill<unsigned int * __ptr64,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00@Z PROC	; std::_Copy_backward<unsigned int * __ptr64,unsigned int * __ptr64>, COMDAT

; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx

; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

	mov	rbx, r8

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sar	rdx, 2

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rdx*4]
	mov	rdx, rcx
	sub	rbx, r8
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove

; 2366 : 	return (_Copy_backward(_First, _Last,
; 2367 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, rbx

; 2368 : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00@Z ENDP	; std::_Copy_backward<unsigned int * __ptr64,unsigned int * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PEAI_KIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
??$_Uninitialized_fill_n@PEAI_KIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z PROC ; std::_Uninitialized_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,std::_Wrap_alloc<xalloc<unsigned int> > >, COMDAT

; 633  : 	{	// copy _Count * *_Pval to raw _First, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	call	??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>

; 634  : 	_Uninit_fill_n(_First, _Count, _Pval, _Al,
; 635  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 636  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_fill_n@PEAI_KIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ENDP ; std::_Uninitialized_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,std::_Wrap_alloc<xalloc<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAG@std@@YA$$QEAGAEAG@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAG@std@@YA$$QEAGAEAG@Z PROC			; std::_Move<unsigned short & __ptr64>, COMDAT

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, rcx

; 1529 : 	}

	ret	0
??$_Move@AEAG@std@@YA$$QEAGAEAG@Z ENDP			; std::_Move<unsigned short & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAUedge@CDB@@@std@@YAPEAUedge@CDB@@PEAU12@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAUedge@CDB@@@std@@YAPEAUedge@CDB@@PEAU12@@Z PROC ; std::_Unchecked<CDB::edge * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAUedge@CDB@@@std@@YAPEAUedge@CDB@@PEAU12@@Z ENDP ; std::_Unchecked<CDB::edge * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z
_TEXT	SEGMENT
_Mid$1 = 48
_First$ = 80
_Last$ = 88
_Ideal$ = 96
_Pred$ = 104
??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z PROC ; std::_Sort<CDB::edge * __ptr64,__int64,CDB::sort_predicate>, COMDAT

; 3122 : 	{	// order [_First, _Last), using _Pred

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	BYTE PTR [rsp+32], r9b
	push	rdi
	sub	rsp, 64					; 00000040H

; 3123 : 	_Diff _Count;
; 3124 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	rax, rdx
	mov	rsi, r8
	mov	rbx, rdx
	sub	rax, rcx
	mov	rdi, rcx
	sar	rax, 3
	cmp	rax, 32					; 00000020H
	jle	$LN3@Sort
$LL7@Sort:
	test	rsi, rsi
	jle	$LN6@Sort

; 3125 : 		{	// divide and conquer by quicksort
; 3126 : 		pair<_RanIt, _RanIt> _Mid =
; 3127 : 			_Unguarded_partition(_First, _Last, _Pred);

	lea	rcx, QWORD PTR _Mid$1[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	call	??$_Unguarded_partition@PEAUedge@CDB@@Usort_predicate@2@@std@@YA?AU?$pair@PEAUedge@CDB@@PEAU12@@0@PEAUedge@CDB@@0Usort_predicate@3@@Z ; std::_Unguarded_partition<CDB::edge * __ptr64,CDB::sort_predicate>

; 3128 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3129 : 
; 3130 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	rbp, QWORD PTR _Mid$1[rsp+8]

; 3131 : 			{	// loop on second half
; 3132 : 			_Sort(_First, _Mid.first, _Ideal, _Pred);

	movzx	r9d, BYTE PTR _Pred$[rsp]
	mov	rax, rsi
	mov	rcx, rbx
	cdq
	sub	rcx, rbp
	sub	rax, rdx
	and	rcx, -8
	sar	rax, 1
	mov	rsi, rax
	cdq
	sub	rax, rdx
	mov	rdx, QWORD PTR _Mid$1[rsp]
	sar	rax, 1
	add	rsi, rax
	mov	rax, rdx
	sub	rax, rdi
	mov	r8, rsi
	and	rax, -8
	cmp	rax, rcx
	jge	SHORT $LN5@Sort
	mov	rcx, rdi
	call	??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z ; std::_Sort<CDB::edge * __ptr64,__int64,CDB::sort_predicate>

; 3133 : 			_First = _Mid.second;

	mov	rdi, rbp

; 3134 : 			}
; 3135 : 		else

	jmp	SHORT $LN4@Sort
$LN5@Sort:

; 3136 : 			{	// loop on first half
; 3137 : 			_Sort(_Mid.second, _Last, _Ideal, _Pred);

	mov	rdx, rbx
	mov	rcx, rbp
	call	??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z ; std::_Sort<CDB::edge * __ptr64,__int64,CDB::sort_predicate>

; 3138 : 			_Last = _Mid.first;

	mov	rbx, QWORD PTR _Mid$1[rsp]
$LN4@Sort:

; 3123 : 	_Diff _Count;
; 3124 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	movzx	r9d, BYTE PTR _Pred$[rsp]
	mov	rax, rbx
	sub	rax, rdi
	sar	rax, 3
	cmp	rax, 32					; 00000020H
	jg	$LL7@Sort
$LN3@Sort:

; 3143 : 		{	// heap sort if too many divisions
; 3144 : 		_STD make_heap(_First, _Last, _Pred);
; 3145 : 		_STD sort_heap(_First, _Last, _Pred);
; 3146 : 		}
; 3147 : 	else if (1 < _Count)

	cmp	rax, 1
	jle	SHORT $LN27@Sort

; 2489 : 
; 2490 : 		// TEMPLATE FUNCTION sort_heap
; 2491 : template<class _RanIt> inline
; 2492 : 	void sort_heap(_RanIt _First, _RanIt _Last)
; 2493 : 	{	// order heap by repeatedly popping, using operator<
; 2494 : 	_STD sort_heap(_First, _Last, less<>());
; 2495 : 	}
; 2496 : 
; 2497 : 		// TEMPLATE FUNCTION lower_bound WITH PRED
; 2498 : template<class _FwdIt,
; 2499 : 	class _Ty,
; 2500 : 	class _Diff,
; 2501 : 	class _Pr> inline
; 2502 : 	_FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
; 2503 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2504 : 	{	// find first element not before _Val, using _Pred
; 2505 : 	_Diff _Count = 0;
; 2506 : 	_Distance(_First, _Last, _Count);
; 2507 : 
; 2508 : 	while (0 < _Count)
; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;
; 2511 : 		_FwdIt _Mid = _First;
; 2512 : 		_STD advance(_Mid, _Count2);
; 2513 : 
; 2514 : 		if (_Pred(*_Mid, _Val))
; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;
; 2519 : 			}
; 2520 : 		else
; 2521 : 			_Count = _Count2;
; 2522 : 		}
; 2523 : 	return (_First);
; 2524 : 	}
; 2525 : 
; 2526 : template<class _FwdIt,
; 2527 : 	class _Ty,
; 2528 : 	class _Pr> inline
; 2529 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
; 2530 : 		const _Ty& _Val, _Pr _Pred)
; 2531 : 	{	// find first element not before _Val, using _Pred
; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));
; 2536 : 	}
; 2537 : 
; 2538 : 		// TEMPLATE FUNCTION lower_bound
; 2539 : template<class _FwdIt,
; 2540 : 	class _Ty> inline
; 2541 : 	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2542 : 	{	// find first element not before _Val, using operator<
; 2543 : 	return (_STD lower_bound(_First, _Last, _Val, less<>()));
; 2544 : 	}
; 2545 : 
; 2546 : 		// TEMPLATE FUNCTION upper_bound WITH PRED
; 2547 : template<class _FwdIt,
; 2548 : 	class _Ty,
; 2549 : 	class _Diff,
; 2550 : 	class _Pr> inline
; 2551 : 	_FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
; 2552 : 		const _Ty& _Val, _Pr _Pred, _Diff *)
; 2553 : 	{	// find first element that _Val is before, using _Pred
; 2554 : 	_Diff _Count = 0;
; 2555 : 	_Distance(_First, _Last, _Count);
; 2556 : 
; 2557 : 	while (0 < _Count)
; 2558 : 		{	// divide and conquer, find half that contains answer
; 2559 : 		_Diff _Count2 = _Count / 2;
; 2560 : 		_FwdIt _Mid = _First;
; 2561 : 		_STD advance(_Mid, _Count2);
; 2562 : 
; 2563 : 		if (!_Pred(_Val, *_Mid))
; 2564 : //		if (!_DEBUG_LT_PRED(_Pred, _Val, *_Mid))
; 2565 : 			{	// try top half
; 2566 : 			_First = ++_Mid;
; 2567 : 			_Count -= _Count2 + 1;
; 2568 : 			}
; 2569 : 		else
; 2570 : 			_Count = _Count2;
; 2571 : 		}
; 2572 : 	return (_First);
; 2573 : 	}
; 2574 : 
; 2575 : template<class _FwdIt,
; 2576 : 	class _Ty,
; 2577 : 	class _Pr> inline
; 2578 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
; 2579 : 		const _Ty& _Val, _Pr _Pred)
; 2580 : 	{	// find first element that _Val is before, using _Pred
; 2581 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2582 : 	return (_Rechecked(_First,
; 2583 : 		_Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2584 : 			_Dist_type(_First))));
; 2585 : 	}
; 2586 : 
; 2587 : 		// TEMPLATE FUNCTION upper_bound
; 2588 : template<class _FwdIt,
; 2589 : 	class _Ty> inline
; 2590 : 	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2591 : 	{	// find first element that _Val is before, using operator<
; 2592 : 	return (_STD upper_bound(_First, _Last, _Val, less<>()));
; 2593 : 	}
; 2594 : 
; 2595 : 		// TEMPLATE FUNCTION equal_range WITH PRED
; 2596 : template<class _FwdIt,
; 2597 : 	class _Ty,
; 2598 : 	class _Diff,
; 2599 : 	class _Pr> inline
; 2600 : 	pair<_FwdIt, _FwdIt>
; 2601 : 		_Equal_range(_FwdIt _First, _FwdIt _Last,
; 2602 : 			const _Ty& _Val, _Pr _Pred, _Diff *)
; 2603 : 	{	// find range equivalent to _Val, using _Pred
; 2604 : 	_Diff _Count = 0;
; 2605 : 	_Distance(_First, _Last, _Count);
; 2606 : 
; 2607 : 	while (0 < _Count)
; 2608 : 		{	// divide and conquer, check midpoint
; 2609 : 		_Diff _Count2 = _Count / 2;
; 2610 : 		_FwdIt _Mid = _First;
; 2611 : 		_STD advance(_Mid, _Count2);
; 2612 : 
; 2613 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2614 : 			{	// range begins above _Mid, loop
; 2615 : 			_First = ++_Mid;
; 2616 : 			_Count -= _Count2 + 1;
; 2617 : 			}
; 2618 : 		else if (_Pred(_Val, *_Mid))
; 2619 : 			_Count = _Count2;	// range in first half, loop
; 2620 : 		else
; 2621 : 			{	// range straddles _Mid, find each end and return
; 2622 : 			_FwdIt _First2 = _STD lower_bound(_First, _Mid, _Val, _Pred);
; 2623 : 			_STD advance(_First, _Count);
; 2624 : 			_FwdIt _Last2 = _STD upper_bound(++_Mid, _First, _Val, _Pred);
; 2625 : 			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
; 2626 : 			}
; 2627 : 		}
; 2628 : 
; 2629 : 	return (pair<_FwdIt, _FwdIt>(_First, _First));	// empty range
; 2630 : 	}
; 2631 : 
; 2632 : template<class _FwdIt,
; 2633 : 	class _Ty,
; 2634 : 	class _Pr> inline
; 2635 : 	pair<_FwdIt, _FwdIt>
; 2636 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2637 : 			const _Ty& _Val, _Pr _Pred)
; 2638 : 	{	// find range equivalent to _Val, using _Pred
; 2639 : 	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2640 : 	pair<_UNCHECKED_TYPE(_FwdIt), _UNCHECKED_TYPE(_FwdIt)> _Ans(
; 2641 : 		_Equal_range(_Unchecked(_First), _Unchecked(_Last),
; 2642 : 			_Val, _Pred, _Dist_type(_First)));
; 2643 : 	return (pair<_FwdIt, _FwdIt>(
; 2644 : 		_Rechecked(_First, _Ans.first),
; 2645 : 		_Rechecked(_Last, _Ans.second)));
; 2646 : 	}
; 2647 : 
; 2648 : 		// TEMPLATE FUNCTION equal_range
; 2649 : template<class _FwdIt,
; 2650 : 	class _Ty> inline
; 2651 : 	pair<_FwdIt, _FwdIt>
; 2652 : 		equal_range(_FwdIt _First, _FwdIt _Last,
; 2653 : 			const _Ty& _Val)
; 2654 : 	{	// find range equivalent to _Val, using operator<
; 2655 : 	return (_STD equal_range(_First, _Last, _Val, less<>()));
; 2656 : 	}
; 2657 : 
; 2658 : 		// TEMPLATE FUNCTION binary_search WITH PRED
; 2659 : template<class _FwdIt,
; 2660 : 	class _Ty,
; 2661 : 	class _Pr> inline
; 2662 : 	bool binary_search(_FwdIt _First, _FwdIt _Last,
; 2663 : 		const _Ty& _Val, _Pr _Pred)
; 2664 : 	{	// test if _Val equivalent to some element, using _Pred
; 2665 : 	_First = _STD lower_bound(_First, _Last, _Val, _Pred);
; 2666 : 	return (_First != _Last && !_Pred(_Val, *_First));
; 2667 : 	}
; 2668 : 
; 2669 : 		// TEMPLATE FUNCTION binary_search
; 2670 : template<class _FwdIt,
; 2671 : 	class _Ty> inline
; 2672 : 	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2673 : 	{	// test if _Val equivalent to some element, using operator<
; 2674 : 	return (_STD binary_search(_First, _Last, _Val, less<>()));
; 2675 : 	}
; 2676 : 
; 2677 : 		// TEMPLATE FUNCTION merge WITH PRED
; 2678 : template<class _InIt1,
; 2679 : 	class _InIt2,
; 2680 : 	class _OutIt,
; 2681 : 	class _Pr> inline
; 2682 : 	_OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
; 2683 : 		_InIt2 _First2, _InIt2 _Last2,
; 2684 : 		_OutIt _Dest, _Pr _Pred)
; 2685 : 	{	// copy merging ranges, both using _Pred
; 2686 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2687 : 		for (; ; )
; 2688 : 			{	// merge either first or second
; 2689 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2690 : 				{	// merge first
; 2691 : 				*_Dest++ = *_First2++;
; 2692 : 				if (_First2 == _Last2)
; 2693 : 					break;
; 2694 : 				}
; 2695 : 			else
; 2696 : 				{	// merge second
; 2697 : 				*_Dest++ = *_First1++;
; 2698 : 				if (_First1 == _Last1)
; 2699 : 					break;
; 2700 : 				}
; 2701 : 			}
; 2702 : 
; 2703 : 	_Dest = _Copy_impl(_First1, _Last1, _Dest);	// copy any tail
; 2704 : 	return (_Copy_impl(_First2, _Last2, _Dest));
; 2705 : 	}
; 2706 : 
; 2707 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2708 : template<class _InIt1,
; 2709 : 	class _InIt2,
; 2710 : 	class _OutIt,
; 2711 : 	class _Pr> inline
; 2712 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2713 : 		_InIt2 _First2, _InIt2 _Last2,
; 2714 : 		_OutIt _Dest, _Pr _Pred)
; 2715 : 	{	// copy merging ranges, both using _Pred
; 2716 : 	return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
; 2717 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2718 : 		_Dest, _Pred));
; 2719 : 	}
; 2720 : 
; 2721 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2722 : template<class _InIt1,
; 2723 : 	class _InIt2,
; 2724 : 	class _OutIt,
; 2725 : 	class _Pr> inline
; 2726 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2727 : 		_InIt2 _First2, _InIt2 _Last2,
; 2728 : 		_OutIt _Dest, _Pr _Pred, input_iterator_tag,
; 2729 : 		input_iterator_tag, _Mutable_iterator_tag)
; 2730 : 	{	// copy merging ranges, both using _Pred, arbitrary iterators
; 2731 : 	return (_Merge0(_First1, _Last1,
; 2732 : 		_First2, _Last2,
; 2733 : 		_Dest, _Pred));
; 2734 : 	}
; 2735 : 
; 2736 : template<class _InIt1,
; 2737 : 	class _InIt2,
; 2738 : 	class _OutIt,
; 2739 : 	class _Pr> inline
; 2740 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2741 : 		_InIt2 _First2, _InIt2 _Last2,
; 2742 : 		_OutIt _Dest, _Pr _Pred, random_access_iterator_tag,
; 2743 : 		random_access_iterator_tag, random_access_iterator_tag)
; 2744 : 	{	// copy merging ranges, both using _Pred, random-access iterators
; 2745 : 	_OutIt _Ans = _Dest + (_Last1 - _First1)
; 2746 : 		+ (_Last2 - _First2);	// also checks range
; 2747 : 	_Merge0(_First1, _Last1,
; 2748 : 		_First2, _Last2,
; 2749 : 		_Dest, _Pred);
; 2750 : 	return (_Ans);
; 2751 : 	}
; 2752 : 
; 2753 : template<class _InIt1,
; 2754 : 	class _InIt2,
; 2755 : 	class _OutIt,
; 2756 : 	class _Pr> inline
; 2757 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2758 : 		_InIt2 _First2, _InIt2 _Last2,
; 2759 : 		_OutIt _Dest, _Pr _Pred, true_type)
; 2760 : 	{	// copy merging ranges, both using _Pred, checked dest
; 2761 : 	return (_Merge2(_First1, _Last1,
; 2762 : 		_First2, _Last2,
; 2763 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2764 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2765 : 	}
; 2766 : 
; 2767 : template<class _InIt1,
; 2768 : 	class _InIt2,
; 2769 : 	class _OutIt,
; 2770 : 	class _Pr> inline
; 2771 : _SCL_INSECURE_DEPRECATE
; 2772 : 	_OutIt _Merge2(_InIt1 _First1, _InIt1 _Last1,
; 2773 : 		_InIt2 _First2, _InIt2 _Last2,
; 2774 : 		_OutIt _Dest, _Pr _Pred, false_type)
; 2775 : 	{	// copy merging ranges, both using _Pred, unchecked dest
; 2776 : 	return (_Merge2(_First1, _Last1,
; 2777 : 		_First2, _Last2,
; 2778 : 		_Dest, _Pred, _Iter_cat(_First1),
; 2779 : 		_Iter_cat(_First2), _Iter_cat(_Dest)));
; 2780 : 	}
; 2781 : 
; 2782 : template<class _InIt1,
; 2783 : 	class _InIt2,
; 2784 : 	class _OutIt,
; 2785 : 	class _Pr> inline
; 2786 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2787 : 		_InIt2 _First2, _InIt2 _Last2,
; 2788 : 		_OutIt _Dest, _Pr _Pred)
; 2789 : 	{	// copy merging ranges, both using _Pred
; 2790 : 	_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 2791 : 	_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 2792 : 	_DEBUG_POINTER(_Dest);
; 2793 : 	_DEBUG_POINTER(_Pred);
; 2794 : 	return (_Merge2(_Unchecked(_First1), _Unchecked(_Last1),
; 2795 : 		_Unchecked(_First2), _Unchecked(_Last2),
; 2796 : 		_Dest, _Pred, _Is_checked(_Dest)));
; 2797 : 	}
; 2798 : 
; 2799 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2800 : template<class _InIt1,
; 2801 : 	class _InIt2,
; 2802 : 	class _OutTy,
; 2803 : 	size_t _OutSize,
; 2804 : 	class _Pr> inline
; 2805 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InIt2 _First2, _InIt2 _Last2,
; 2807 : 		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
; 2808 : 	{	// copy merging ranges, both using _Pred, array dest
; 2809 : 	return (_Unchecked(
; 2810 : 		_STD merge(_First1, _Last1,
; 2811 : 			_First2, _Last2,
; 2812 : 			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
; 2813 : 	}
; 2814 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2815 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2816 : 
; 2817 : 		// TEMPLATE FUNCTION merge
; 2818 : template<class _InIt1,
; 2819 : 	class _InIt2,
; 2820 : 	class _OutIt> inline
; 2821 : 	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
; 2822 : 		_InIt2 _First2, _InIt2 _Last2,
; 2823 : 		_OutIt _Dest)
; 2824 : 	{	// copy merging ranges, both using operator<
; 2825 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2826 : 		less<>()));
; 2827 : 	}
; 2828 : 
; 2829 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2830 : template<class _InIt1,
; 2831 : 	class _InIt2,
; 2832 : 	class _OutTy,
; 2833 : 	size_t _OutSize> inline
; 2834 : 	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
; 2835 : 		_InIt2 _First2, _InIt2 _Last2,
; 2836 : 		_OutTy (&_Dest)[_OutSize])
; 2837 : 	{	// copy merging ranges, both using operator<, array dest
; 2838 : 	return (_STD merge(_First1, _Last1, _First2, _Last2, _Dest,
; 2839 : 		less<>()));
; 2840 : 	}
; 2841 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2842 : 
; 2843 : 		// TEMPLATE FUNCTION inplace_merge WITH PRED
; 2844 : template<class _BidIt1,
; 2845 : 	class _BidIt2,
; 2846 : 	class _BidIt3,
; 2847 : 	class _Pr> inline
; 2848 : 	_BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
; 2849 : 		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
; 2850 : 	{	// merge backwards to _Dest, using _Pred
; 2851 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2852 : 		for (; ; )
; 2853 : 			{	// merge either first or second
; 2854 : 			if (_DEBUG_LT_PRED(_Pred, *--_Last2, *--_Last1))
; 2855 : 				{	// merge first
; 2856 : 				*--_Dest = _Move(*_Last1);
; 2857 : 				++_Last2;
; 2858 : 				if (_First1 == _Last1)
; 2859 : 					break;
; 2860 : 				}
; 2861 : 			else
; 2862 : 				{	// merge second
; 2863 : 				*--_Dest = _Move(*_Last2);
; 2864 : 				++_Last1;
; 2865 : 				if (_First2 == _Last2)
; 2866 : 					break;
; 2867 : 				}
; 2868 : 			}
; 2869 : 
; 2870 : 	_Dest = _Move_backward(_First2, _Last2, _Dest);	// move any tail
; 2871 : 	return (_Move_backward(_First1, _Last1, _Dest));
; 2872 : 	}
; 2873 : 
; 2874 : template<class _InIt1,
; 2875 : 	class _InIt2,
; 2876 : 	class _OutIt,
; 2877 : 	class _Pr> inline
; 2878 : 	_OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
; 2879 : 		_InIt2 _First2, _InIt2 _Last2,
; 2880 : 		_OutIt _Dest, _Pr _Pred)
; 2881 : 	{	// move merging ranges, both using _Pred
; 2882 : 	if (_First1 != _Last1 && _First2 != _Last2)
; 2883 : 		for (; ; )
; 2884 : 			{	// merge either first or second
; 2885 : 			if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 2886 : 				{	// merge first
; 2887 : 				*_Dest++ = _Move(*_First2++);
; 2888 : 				if (_First2 == _Last2)
; 2889 : 					break;
; 2890 : 				}
; 2891 : 			else
; 2892 : 				{	// merge second
; 2893 : 				*_Dest++ = _Move(*_First1++);
; 2894 : 				if (_First1 == _Last1)
; 2895 : 					break;
; 2896 : 				}
; 2897 : 			}
; 2898 : 
; 2899 : 	_Dest = _Move(_First1, _Last1, _Dest);	// move any tail
; 2900 : 	return (_Move(_First2, _Last2, _Dest));
; 2901 : 	}
; 2902 : 
; 2903 : template<class _BidIt,
; 2904 : 	class _Diff,
; 2905 : 	class _Ty,
; 2906 : 	class _Pr> inline
; 2907 : 	void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
; 2908 : 		_Diff _Count1, _Diff _Count2,
; 2909 : 			_Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
; 2910 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2911 : 	if (_Count1 == 0 || _Count2 == 0)
; 2912 : 		;	// do nothing
; 2913 : 	else if (_Count1 + _Count2 == 2)
; 2914 : 		{	// order two one-element partitions
; 2915 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))
; 2916 : 			_STD iter_swap(_First, _Mid);
; 2917 : 		}
; 2918 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
; 2919 : 		{	// buffer left partition, then merge
; 2920 : 		_Move(_First, _Mid, _Tempbuf._Init());
; 2921 : 		_Merge(_Tempbuf._First(), _Tempbuf._Last(),
; 2922 : 			_Mid, _Last, _First, _Pred);
; 2923 : 		}
; 2924 : 	else if (_Count2 <= _Tempbuf._Maxlen())
; 2925 : 		{	// buffer right partition, then merge
; 2926 : 		_Move(_Mid, _Last, _Tempbuf._Init());
; 2927 : 		_Merge_backward(_First, _Mid,
; 2928 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
; 2929 : 		}
; 2930 : 	else
; 2931 : 		{	// buffer too small, divide and conquer
; 2932 : 		_BidIt _Firstn, _Lastn;
; 2933 : 		_Diff _Count1n, _Count2n;
; 2934 : 		if (_Count2 < _Count1)
; 2935 : 			{	// left larger, cut it in half and partition right to match
; 2936 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2937 : 			_Firstn = _First;
; 2938 : 			_STD advance(_Firstn, _Count1n);
; 2939 : 			_Lastn = _STD lower_bound(_Mid, _Last, *_Firstn, _Pred);
; 2940 : 			_Distance(_Mid, _Lastn, _Count2n);
; 2941 : 			}
; 2942 : 		else
; 2943 : 			{	// right larger, cut it in half and partition left to match
; 2944 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2945 : 			_Lastn = _Mid;
; 2946 : 			_STD advance(_Lastn, _Count2n);
; 2947 : 			_Firstn = _STD upper_bound(_First, _Mid, *_Lastn, _Pred);
; 2948 : 			_Distance(_First, _Firstn, _Count1n);
; 2949 : 			}
; 2950 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2951 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle
; 2952 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2953 : 			_Count1n, _Count2n, _Tempbuf, _Pred);	// merge each new part
; 2954 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2955 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
; 2956 : 		}
; 2957 : 	}
; 2958 : 
; 2959 : template<class _BidIt,
; 2960 : 	class _Diff,
; 2961 : 	class _Ty,
; 2962 : 	class _Pr> inline
; 2963 : 	void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
; 2964 : 		_Diff *, _Ty *)
; 2965 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2966 : 	_Diff _Count1 = 0;
; 2967 : 	_Distance(_First, _Mid, _Count1);
; 2968 : 	_Diff _Count2 = 0;
; 2969 : 	_Distance(_Mid, _Last, _Count2);
; 2970 : 	_Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
; 2971 : 	_Buffered_merge(_First, _Mid, _Last,
; 2972 : 		_Count1, _Count2, _Tempbuf, _Pred);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _BidIt,
; 2976 : 	class _Pr> inline
; 2977 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
; 2978 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using _Pred
; 2979 : 	_DEBUG_ORDER_PRED(_First, _Mid, _Pred);
; 2980 : 	_DEBUG_ORDER_PRED(_Mid, _Last, _Pred);
; 2981 : 	if (_First != _Mid && _Mid != _Last)
; 2982 : 		_Inplace_merge(
; 2983 : 			_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
; 2984 : 			_Dist_type(_First), _Val_type(_First));
; 2985 : 	}
; 2986 : 
; 2987 : 		// TEMPLATE FUNCTION inplace_merge
; 2988 : template<class _BidIt> inline
; 2989 : 	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
; 2990 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<
; 2991 : 	_STD inplace_merge(_First, _Mid, _Last, less<>());
; 2992 : 	}
; 2993 : 
; 2994 : 		// TEMPLATE FUNCTION sort WITH PRED
; 2995 : template<class _BidIt,
; 2996 : 	class _Pr,
; 2997 : 	class _Ty> inline
; 2998 : 	void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
; 2999 : 	{	// insertion sort [_First, _Last), using _Pred
; 3000 : 	if (_First != _Last)
; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )
; 3002 : 			{	// order next element
; 3003 : 			_BidIt _Next1 = _Next;
; 3004 : 			_Ty _Val = _Move(*_Next);
; 3005 : 
; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))
; 3007 : 				{	// found new earliest element, move to front
; 3008 : 				_Move_backward(_First, _Next, ++_Next1);
; 3009 : 				*_First = _Move(_Val);
; 3010 : 				}
; 3011 : 			else
; 3012 : 				{	// look for insertion point after first
; 3013 : 				for (_BidIt _First1 = _Next1;
; 3014 : 					_DEBUG_LT_PRED(_Pred, _Val, *--_First1);
; 3015 : 					_Next1 = _First1)
; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down
; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole
; 3018 : 				}
; 3019 : 			}
; 3020 : 	}
; 3021 : 
; 3022 : template<class _BidIt,
; 3023 : 	class _Pr> inline
; 3024 : 	void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
; 3025 : 	{	// insertion sort [_First, _Last), using _Pred
; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	movzx	r8d, r9b
	mov	rdx, rbx
	mov	rcx, rdi
	call	??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z ; std::_Insertion_sort1<CDB::edge * __ptr64,CDB::sort_predicate,CDB::edge>
$LN27@Sort:

; 3148 : 		_Insertion_sort(_First, _Last, _Pred);	// small
; 3149 : 	}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN6@Sort:

; 3139 : 			}
; 3140 : 		}
; 3141 : 
; 3142 : 	if (_ISORT_MAX < _Count)

	cmp	rax, 32					; 00000020H
	jle	SHORT $LN3@Sort

; 2459 : 	if (1 < _Last - _First)

	mov	rax, rbx
	sub	rax, rdi
	and	rax, -8
	cmp	rax, 8
	jle	SHORT $LN10@Sort

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

	movzx	r8d, r9b
	mov	rdx, rbx
	mov	rcx, rdi
	call	??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z ; std::_Make_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
	movzx	r9d, BYTE PTR _Pred$[rsp]
$LN10@Sort:

; 2462 : 	}
; 2463 : 
; 2464 : 		// TEMPLATE FUNCTION make_heap
; 2465 : template<class _RanIt> inline
; 2466 : 	void make_heap(_RanIt _First, _RanIt _Last)
; 2467 : 	{	// make [_First, _Last) into a heap, using operator<
; 2468 : 	_STD make_heap(_First, _Last, less<>());
; 2469 : 	}
; 2470 : 
; 2471 : 		// TEMPLATE FUNCTION sort_heap WITH PRED
; 2472 : template<class _RanIt,
; 2473 : 	class _Pr> inline
; 2474 : 	void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2475 : 	{	// order heap by repeatedly popping, using _Pred
; 2476 : 	for (; 1 < _Last - _First; --_Last)
; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}
; 2479 : 
; 2480 : template<class _RanIt,
; 2481 : 	class _Pr> inline
; 2482 : 	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2483 : 	{	// order heap by repeatedly popping, using _Pred
; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

	movzx	r8d, r9b
	mov	rdx, rbx
	mov	rcx, rdi
	call	??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ; std::_Sort_heap<CDB::edge * __ptr64,CDB::sort_predicate>

; 2488 : 	}

	jmp	SHORT $LN27@Sort
??$_Sort@PEAUedge@CDB@@_JUsort_predicate@2@@std@@YAXPEAUedge@CDB@@0_JUsort_predicate@2@@Z ENDP ; std::_Sort<CDB::edge * __ptr64,__int64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAI@std@@YAAEAIAEAI@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAI@std@@YAAEAIAEAI@Z PROC			; std::forward<unsigned int & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAI@std@@YAAEAIAEAI@Z ENDP			; std::forward<unsigned int & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@IAEAI@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAIAEAI@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@IAEAI@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAIAEAI@Z PROC ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@IAEAI@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAIAEAI@Z ENDP ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEBI@std@@YAAEBIAEBI@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBI@std@@YAAEBIAEBI@Z PROC			; std::forward<unsigned int const & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEBI@std@@YAAEBIAEBI@Z ENDP			; std::forward<unsigned int const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@IAEBI@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAIAEBI@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@IAEBI@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAIAEBI@Z PROC ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@IAEBI@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAIAEBI@Z ENDP ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z PROC ; std::_Uninitialized_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN18:
	sub	rsp, 56					; 00000038H

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	call	??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ENDP ; std::_Uninitialized_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z PROC ; std::_Uninitialized_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z PROC ; std::_Uninitialized_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN18:
	sub	rsp, 56					; 00000038H

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	call	??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ENDP ; std::_Uninitialized_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAI@std@@YAPEAIPEAI@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAI@std@@YAPEAIPEAI@Z PROC		; std::_Unchecked<unsigned int * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAI@std@@YAPEAIPEAI@Z ENDP		; std::_Unchecked<unsigned int * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill@PEAII@std@@YAXPEAI0AEBI@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Fill@PEAII@std@@YAXPEAI0AEBI@Z PROC			; std::_Fill<unsigned int * __ptr64,unsigned int>, COMDAT

; 2598 : 	{	// copy _Val through [_First, _Last)

	xor	r9d, r9d
	mov	r10, rdx
	sub	r10, rcx
	add	r10, 3
	shr	r10, 2
	cmp	rcx, rdx
	cmova	r10, r9

; 2599 : 	for (; _First != _Last; ++_First)

	test	r10, r10
	je	SHORT $LN1@Fill
	npad	3
$LL3@Fill:

; 2600 : 		*_First = _Val;

	mov	eax, DWORD PTR [r8]
	inc	r9
	lea	rcx, QWORD PTR [rcx+4]
	mov	DWORD PTR [rcx-4], eax
	cmp	r9, r10
	jne	SHORT $LL3@Fill
$LN1@Fill:

; 2601 : 	}

	ret	0
??$_Fill@PEAII@std@@YAXPEAI0AEBI@Z ENDP			; std::_Fill<unsigned int * __ptr64,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<unsigned int * __ptr64,unsigned int * __ptr64>, COMDAT

; 2354 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx
	mov	rbx, r8
	sar	rdx, 2

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rdx*4]
	mov	rdx, rcx
	sub	rbx, r8
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove

; 2358 : 	return (_Dest - _Count);

	mov	rax, rbx

; 2359 : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Copy_backward@PEAIPEAI@std@@YAPEAIPEAI00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<unsigned int * __ptr64,unsigned int * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAI@std@@YAPEAIPEAI@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAI@std@@YAPEAIPEAI@Z PROC		; std::_Val_type<unsigned int * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAI@std@@YAPEAIPEAI@Z ENDP		; std::_Val_type<unsigned int * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>, COMDAT

; 611  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

$LN4:
	sub	rsp, 56					; 00000038H

; 612  : 	_Uninit_fill_n(_First, _Count,
; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	call	??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>

; 614  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PEAUedge@CDB@@Usort_predicate@2@@std@@YA?AU?$pair@PEAUedge@CDB@@PEAU12@@0@PEAUedge@CDB@@0Usort_predicate@3@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_First$ = 56
_Last$ = 64
_Pred$ = 72
??$_Unguarded_partition@PEAUedge@CDB@@Usort_predicate@2@@std@@YA?AU?$pair@PEAUedge@CDB@@PEAU12@@0@PEAUedge@CDB@@0Usort_predicate@3@@Z PROC ; std::_Unguarded_partition<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT

; 3063 : 	{	// partition [_First, _Last), using _Pred

$LN210:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	r15
	sub	rsp, 32					; 00000020H
	mov	r14, rdx

; 3064 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

	mov	rax, r8
	mov	rsi, r8
	sub	rax, rdx
	mov	r15, rcx

; 3065 : 	_Median(_First, _Mid, _Last - 1, _Pred);

	add	r8, -8
	sar	rax, 3
	mov	rcx, r14
	cdq
	sub	rax, rdx
	sar	rax, 1
	lea	rbx, QWORD PTR [r14+rax*8]
	mov	rdx, rbx
	call	??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ; std::_Median<CDB::edge * __ptr64,CDB::sort_predicate>

; 3066 : 	_RanIt _Pfirst = _Mid;
; 3067 : 	_RanIt _Plast = _Pfirst + 1;

	lea	r10, QWORD PTR [rbx+8]

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	cmp	r14, rbx
	jae	$LN200@Unguarded_

; 3064 : 	_RanIt _Mid = _First + (_Last - _First) / 2;

	lea	rdx, QWORD PTR [rbx-2]
	npad	7
$LL29@Unguarded_:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	r8d, WORD PTR [rdx-2]
	movzx	r9d, WORD PTR [rdx+6]
	cmp	r8w, r9w
	jb	SHORT $LN200@Unguarded_

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	r9w, r8w
	jb	SHORT $LN200@Unguarded_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rdx]
	movzx	ecx, WORD PTR [rdx+8]
	cmp	ax, cx
	jb	SHORT $LN200@Unguarded_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN179@Unguarded_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [rdx-6]
	mov	eax, DWORD PTR [rbx]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	ecx, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	test	al, al
	jne	SHORT $LN200@Unguarded_
$LN179@Unguarded_:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	cmp	r9w, r8w
	jb	SHORT $LN200@Unguarded_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rdx+8]
	movzx	ecx, WORD PTR [rdx]
	cmp	ax, cx
	jb	SHORT $LN200@Unguarded_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN180@Unguarded_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [rdx-6]
	mov	eax, DWORD PTR [rbx]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	eax, ecx
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3071 : 		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))

	test	al, al
	jne	SHORT $LN200@Unguarded_
$LN180@Unguarded_:

; 3072 : 		--_Pfirst;

	sub	rbx, 8
	sub	rdx, 8
	cmp	r14, rbx
	jb	SHORT $LL29@Unguarded_
$LN200@Unguarded_:

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

	cmp	r10, rsi
	jae	$LN201@Unguarded_
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	r8d, WORD PTR [rbx+4]
	npad	5
$LL27@Unguarded_:
	movzx	edx, WORD PTR [r10+4]
	cmp	dx, r8w
	jb	SHORT $LN201@Unguarded_

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	r8w, dx
	jb	SHORT $LN201@Unguarded_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [r10+6]
	movzx	ecx, WORD PTR [rbx+6]
	cmp	ax, cx
	jb	SHORT $LN201@Unguarded_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN181@Unguarded_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r10]
	mov	eax, DWORD PTR [rbx]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	ecx, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

	test	al, al
	jne	SHORT $LN201@Unguarded_
$LN181@Unguarded_:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	cmp	r8w, dx
	jb	SHORT $LN201@Unguarded_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rbx+6]
	movzx	ecx, WORD PTR [r10+6]
	cmp	ax, cx
	jb	SHORT $LN201@Unguarded_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN182@Unguarded_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r10]
	mov	eax, DWORD PTR [rbx]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	eax, ecx
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3075 : 		&& !_Pred(*_Pfirst, *_Plast))

	test	al, al
	jne	SHORT $LN201@Unguarded_
$LN182@Unguarded_:

; 3076 : 		++_Plast;

	add	r10, 8
	cmp	r10, rsi
	jb	SHORT $LL27@Unguarded_
$LN201@Unguarded_:

; 3077 : 
; 3078 : 	_RanIt _Gfirst = _Plast;

	mov	r9, r10

; 3079 : 	_RanIt _Glast = _Pfirst;

	mov	r11, rbx
	npad	2
$LL25@Unguarded_:

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	r9, rsi
	jae	$LN202@Unguarded_
	npad	7
$LL23@Unguarded_:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	edx, WORD PTR [rbx+4]
	movzx	r8d, WORD PTR [r9+4]
	cmp	dx, r8w
	jb	$LN22@Unguarded_

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	r8w, dx
	jb	$LN202@Unguarded_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rbx+6]
	movzx	ecx, WORD PTR [r9+6]
	cmp	ax, cx
	jb	SHORT $LN22@Unguarded_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN183@Unguarded_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r9]
	mov	eax, DWORD PTR [rbx]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	eax, ecx
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3084 : 			if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst))

	test	al, al
	jne	SHORT $LN22@Unguarded_
$LN183@Unguarded_:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	cmp	r8w, dx
	jb	SHORT $LN202@Unguarded_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [r9+6]
	movzx	ecx, WORD PTR [rbx+6]
	cmp	ax, cx
	jb	SHORT $LN202@Unguarded_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN184@Unguarded_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r9]
	mov	eax, DWORD PTR [rbx]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	ecx, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3086 : 			else if (_Pred(*_Gfirst, *_Pfirst))

	test	al, al
	jne	SHORT $LN202@Unguarded_
$LN184@Unguarded_:

; 3087 : 				break;
; 3088 : 			else if (_Plast++ != _Gfirst)

	mov	rax, r10
	add	r10, 8
	cmp	rax, r9
	je	SHORT $LN22@Unguarded_
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [r9]
	mov	rax, QWORD PTR [r10-8]
	mov	QWORD PTR [r10-8], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [r9], rax
$LN22@Unguarded_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3083 : 		for (; _Gfirst < _Last; ++_Gfirst)

	add	r9, 8
	cmp	r9, rsi
	jb	$LL23@Unguarded_
$LN202@Unguarded_:

; 3090 : 		for (; _First < _Glast; --_Glast)

	cmp	r11, r14
	jbe	$LN207@Unguarded_
	lea	rdx, QWORD PTR [r11-2]
	npad	1
$LL15@Unguarded_:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	r8d, WORD PTR [rdx-2]
	movzx	edi, WORD PTR [rbx+4]
	cmp	r8w, di
	jb	SHORT $LN14@Unguarded_

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	di, r8w
	jb	$LN203@Unguarded_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rdx]
	movzx	ecx, WORD PTR [rbx+6]
	cmp	ax, cx
	jb	SHORT $LN14@Unguarded_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN185@Unguarded_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [rdx-6]
	mov	eax, DWORD PTR [rbx]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	ecx, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3091 : 			if (_DEBUG_LT_PRED(_Pred, *(_Glast - 1), *_Pfirst))

	test	al, al
	jne	SHORT $LN14@Unguarded_
$LN185@Unguarded_:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	cmp	di, r8w
	jb	SHORT $LN203@Unguarded_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rbx+6]
	movzx	ecx, WORD PTR [rdx]
	cmp	ax, cx
	jb	SHORT $LN203@Unguarded_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN186@Unguarded_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [rdx-6]
	mov	eax, DWORD PTR [rbx]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	eax, ecx
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3093 : 			else if (_Pred(*_Pfirst, *(_Glast - 1)))

	test	al, al
	jne	SHORT $LN203@Unguarded_
$LN186@Unguarded_:

; 3094 : 				break;
; 3095 : 			else if (--_Pfirst != _Glast - 1)

	lea	r8, QWORD PTR [rdx-6]
	sub	rbx, 8
	cmp	rbx, r8
	je	SHORT $LN14@Unguarded_
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [r8]
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rbx], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [r8], rax
$LN14@Unguarded_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3090 : 		for (; _First < _Glast; --_Glast)

	sub	r11, 8
	sub	rdx, 8
	cmp	r14, r11
	jb	$LL15@Unguarded_
$LN203@Unguarded_:

; 3096 : 				_STD iter_swap(_Pfirst, _Glast - 1);
; 3097 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	r11, r14
$LN207@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	r9, rsi
	je	SHORT $LN164@Unguarded_

; 3099 : 
; 3100 : 		if (_Glast == _First)
; 3101 : 			{	// no room at bottom, rotate pivot upward
; 3102 : 			if (_Plast != _Gfirst)

	cmp	r10, r9
	je	SHORT $LN108@Unguarded_
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [r10]
	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rbx], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [r10], rax
$LN108@Unguarded_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3105 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

	mov	r8, r9
	mov	rdx, rbx
	add	r10, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [r8]
	mov	rax, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3105 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

	add	rbx, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [rdx], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [r8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3105 : 			_STD iter_swap(_Pfirst++, _Gfirst++);

	add	r9, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 29   : 	}

	jmp	$LL25@Unguarded_
$LN6@Unguarded_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3109 : 			if (--_Glast != --_Pfirst)

	sub	r11, 8
	cmp	r9, rsi
	jne	SHORT $LN3@Unguarded_
	sub	rbx, 8
	cmp	r11, rbx
	je	SHORT $LN128@Unguarded_
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [r11]
	mov	QWORD PTR [r11], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [rbx], rax
$LN128@Unguarded_:

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [r10-8]
	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3111 : 			_STD iter_swap(_Pfirst, --_Plast);

	sub	r10, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [rbx], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [r10], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3113 : 		else

	jmp	$LL25@Unguarded_
$LN3@Unguarded_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 52   : 	_Ty _Tmp = _Move(_Left);

	mov	rax, QWORD PTR [r9]

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [r11]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3114 : 			_STD iter_swap(_Gfirst++, --_Glast);

	add	r9, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	QWORD PTR [r9-8], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [r11], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3115 : 		}

	jmp	$LL25@Unguarded_
$LN164@Unguarded_:

; 3116 : 	}

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+72]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

	mov	QWORD PTR [r15], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3116 : 	}

	mov	rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 144  : 		{	// construct from moved values

	mov	QWORD PTR [r15+8], r10
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3098 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	rax, r15

; 3116 : 	}

	add	rsp, 32					; 00000020H
	pop	r15
	ret	0
??$_Unguarded_partition@PEAUedge@CDB@@Usort_predicate@2@@std@@YA?AU?$pair@PEAUedge@CDB@@PEAU12@@0@PEAUedge@CDB@@0Usort_predicate@3@@Z ENDP ; std::_Unguarded_partition<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$make_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Pred$ = 80
??$make_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z PROC ; std::make_heap<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT

; 2456 : 	{	// make [_First, _Last) into a heap, using _Pred

$LN13:
	sub	rsp, 56					; 00000038H

; 2457 : 	_DEBUG_RANGE(_First, _Last);
; 2458 : 	_DEBUG_POINTER(_Pred);
; 2459 : 	if (1 < _Last - _First)

	mov	rax, rdx
	sub	rax, rcx
	and	rax, -8
	cmp	rax, 8
	jle	SHORT $LN1@make_heap

; 2460 : 		_Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2461 : 			_Dist_type(_First), _Val_type(_First));

	call	??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z ; std::_Make_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
$LN1@make_heap:

; 2462 : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$make_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ENDP ; std::make_heap<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Pred$ = 64
??$sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z PROC ; std::sort_heap<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT

; 2483 : 	{	// order heap by repeatedly popping, using _Pred

$LN8:
	sub	rsp, 40					; 00000028H

; 2484 : 	_DEBUG_RANGE(_First, _Last);
; 2485 : 	_DEBUG_POINTER(_Pred);
; 2486 : 	_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2487 : 	_Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);

	call	??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ; std::_Sort_heap<CDB::edge * __ptr64,CDB::sort_predicate>

; 2488 : 	}

	add	rsp, 40					; 00000028H
	ret	0
??$sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ENDP ; std::sort_heap<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Pred$ = 64
??$_Insertion_sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z PROC ; std::_Insertion_sort<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT

; 3025 : 	{	// insertion sort [_First, _Last), using _Pred

$LN6:
	sub	rsp, 40					; 00000028H

; 3026 : 	_Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));

	call	??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z ; std::_Insertion_sort1<CDB::edge * __ptr64,CDB::sort_predicate,CDB::edge>

; 3027 : 	}

	add	rsp, 40					; 00000028H
	ret	0
??$_Insertion_sort@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ENDP ; std::_Insertion_sort<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@I@@IAEAI@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAIAEAI@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@I@@IAEAI@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAIAEAI@Z PROC ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [r8], eax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@I@@IAEAI@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAIAEAI@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@I@@IAEBI@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAIAEBI@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@I@@IAEBI@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAIAEBI@Z PROC ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [r8], eax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@I@@IAEBI@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAIAEBI@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z PROC ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
	sub	rsp, 56					; 00000038H

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	call	??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >

; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@U?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@@Z ENDP ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,std::_Wrap_alloc<xalloc<_vector3<float> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z PROC ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ENDP ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAIPEAI@std@@YAAEAPEAIAEAPEAIPEAI@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAIPEAI@std@@YAAEAPEAIAEAPEAIPEAI@Z PROC	; std::_Rechecked<unsigned int * __ptr64,unsigned int * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAIPEAI@std@@YAAEAPEAIAEAPEAIPEAI@Z ENDP	; std::_Rechecked<unsigned int * __ptr64,unsigned int * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z PROC ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
	sub	rsp, 56					; 00000038H

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	call	??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>

; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAVTRI@CDB@@PEAV12@U?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@@Z ENDP ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,std::_Wrap_alloc<xalloc<CDB::TRI> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>, COMDAT

; 585  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_fil:

; 594  : 	for (; 0 < _Count; --_Count, ++_First)

	test	rdx, rdx
	je	SHORT $LN4@Uninit_fil
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN30@Uninit_fil
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rcx], eax
$LN30@Uninit_fil:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 594  : 	for (; 0 < _Count; --_Count, ++_First)

	dec	rdx
	mov	QWORD PTR _Count$[rsp], rdx
	add	rcx, 4
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_fil
$LN4@Uninit_fil:

; 595  : 		_Al.construct(_First, *_Pval);
; 596  : 	_CATCH_ALL
; 597  : 	for (; _Next != _First; ++_Next)
; 598  : 		_Al.destroy(_Next);
; 599  : 	_RERAISE;
; 600  : 	_CATCH_END
; 601  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_fil:
??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>'::`1'::catch$0

; 596  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 597  : 	for (; _Next != _First; ++_Next)
; 598  : 		_Al.destroy(_Next);
; 599  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_fill_n@PEAI_KIV?$xalloc@I@@I@std@@YAXPEAI_KPEBIAEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_fill_n<unsigned int * __ptr64,unsigned __int64,unsigned int,xalloc<unsigned int>,unsigned int>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@I@@QEAAXPEAIAEBI@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
_Val$ = 24
?construct@?$xalloc@I@@QEAAXPEAIAEBI@Z PROC		; xalloc<unsigned int>::construct, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN5@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN5@construct:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	std::_Construct(p, _Val);	}

	ret	0
?construct@?$xalloc@I@@QEAAXPEAIAEBI@Z ENDP		; xalloc<unsigned int>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z
_TEXT	SEGMENT
_First$ = 64
_Mid$ = 72
_Last$ = 80
_Pred$ = 88
??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z PROC ; std::_Median<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT

; 3046 : 	{	// sort median element to middle

$LN6:
	push	rbx
	push	r12
	push	r15
	sub	rsp, 32					; 00000020H

; 3047 : 	if (40 < _Last - _First)

	mov	rax, r8
	movzx	ebx, r9b
	mov	r15, r8
	sub	rax, rcx
	mov	r12, rdx
	sar	rax, 3
	cmp	rax, 40					; 00000028H
	jle	$LN2@Median

; 3048 : 		{	// median of nine
; 3049 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	rax
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+72], rsi
	cdq
	mov	QWORD PTR [rsp+80], rdi
	mov	QWORD PTR [rsp+88], r14
	and	edx, 7
	add	rax, rdx
	sar	rax, 3

; 3050 : 		_Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);

	mov	r14, rax
	lea	rsi, QWORD PTR [rax*8]
	shl	r14, 4
	lea	rbp, QWORD PTR [rsi+rcx]
	lea	r8, QWORD PTR [r14+rcx]
	mov	rdx, rbp
	call	??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ; std::_Med3<CDB::edge * __ptr64,CDB::sort_predicate>

; 3051 : 		_Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

	mov	rcx, r12
	lea	r8, QWORD PTR [rsi+r12]
	sub	rcx, rsi
	movzx	r9d, bl
	mov	rdx, r12
	call	??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ; std::_Med3<CDB::edge * __ptr64,CDB::sort_predicate>

; 3052 : 		_Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);

	mov	rdi, r15
	mov	rcx, r15
	sub	rdi, rsi
	movzx	r9d, bl
	mov	r8, r15
	mov	rdx, rdi
	sub	rcx, r14
	call	??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ; std::_Med3<CDB::edge * __ptr64,CDB::sort_predicate>

; 3053 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

	movzx	r9d, bl
	mov	r8, rdi
	mov	rdx, r12
	mov	rcx, rbp
	mov	r14, QWORD PTR [rsp+88]
	mov	rdi, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]

; 3057 : 	}

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rbx

; 3053 : 		_Med3(_First + _Step, _Mid, _Last - _Step, _Pred);

	jmp	??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ; std::_Med3<CDB::edge * __ptr64,CDB::sort_predicate>
$LN2@Median:

; 3057 : 	}

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rbx

; 3054 : 		}
; 3055 : 	else
; 3056 : 		_Med3(_First, _Mid, _Last, _Pred);

	jmp	??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ; std::_Med3<CDB::edge * __ptr64,CDB::sort_predicate>
??$_Median@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ENDP ; std::_Median<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$iter_swap@PEAUedge@CDB@@PEAU12@@std@@YAXPEAUedge@CDB@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$iter_swap@PEAUedge@CDB@@PEAU12@@std@@YAXPEAUedge@CDB@@0@Z PROC ; std::iter_swap<CDB::edge * __ptr64,CDB::edge * __ptr64>, COMDAT

; 30   : 
; 31   : 		// TEMPLATE FUNCTION swap
; 32   : template<class _Ty,
; 33   : 	size_t _Size> inline
; 34   : 	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
; 35   : 		_NOEXCEPT_OP(_NOEXCEPT_OP(swap(*_Left, *_Right)))
; 36   : 	{	// exchange arrays stored at _Left and _Right
; 37   : 	if (&_Left != &_Right)
; 38   : 		{	// worth swapping, swap ranges
; 39   : 		_Ty *_First1 = _Left;
; 40   : 		_Ty *_Last1 = _First1 + _Size;
; 41   : 		_Ty *_First2 = _Right;
; 42   : 		for (; _First1 != _Last1; ++_First1, ++_First2)
; 43   : 			_STD iter_swap(_First1, _First2);
; 44   : 		}
; 45   : 	}
; 46   : 
; 47   : template<class _Ty> inline
; 48   : 	void swap(_Ty& _Left, _Ty& _Right)
; 49   : 		_NOEXCEPT_OP(is_nothrow_move_constructible<_Ty>::value
; 50   : 			&& is_nothrow_move_assignable<_Ty>::value)
; 51   : 	{	// exchange values stored at _Left and _Right
; 52   : 	_Ty _Tmp = _Move(_Left);
; 53   : 	_Left = _Move(_Right);

	mov	r8, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], r8

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [rdx], rax

; 28   : 	swap(*_Left, *_Right);
; 29   : 	}

	ret	0
??$iter_swap@PEAUedge@CDB@@PEAU12@@std@@YAXPEAUedge@CDB@@0@Z ENDP ; std::iter_swap<CDB::edge * __ptr64,CDB::edge * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$?0AEAPEAUedge@CDB@@AEAPEAU01@X@?$pair@PEAUedge@CDB@@PEAU12@@std@@QEAA@AEAPEAUedge@CDB@@0@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
??$?0AEAPEAUedge@CDB@@AEAPEAU01@X@?$pair@PEAUedge@CDB@@PEAU12@@std@@QEAA@AEAPEAUedge@CDB@@0@Z PROC ; std::pair<CDB::edge * __ptr64,CDB::edge * __ptr64>::pair<CDB::edge * __ptr64,CDB::edge * __ptr64><CDB::edge * __ptr64 & __ptr64,CDB::edge * __ptr64 & __ptr64,void>, COMDAT

; 144  : 		{	// construct from moved values

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx+8], rax

; 145  : 		}

	mov	rax, rcx
	ret	0
??$?0AEAPEAUedge@CDB@@AEAPEAU01@X@?$pair@PEAUedge@CDB@@PEAU12@@std@@QEAA@AEAPEAUedge@CDB@@0@Z ENDP ; std::pair<CDB::edge * __ptr64,CDB::edge * __ptr64>::pair<CDB::edge * __ptr64,CDB::edge * __ptr64><CDB::edge * __ptr64 & __ptr64,CDB::edge * __ptr64 & __ptr64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PEAUedge@CDB@@@std@@YAPEA_JPEAUedge@CDB@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Dist_type@PEAUedge@CDB@@@std@@YAPEA_JPEAUedge@CDB@@@Z PROC ; std::_Dist_type<CDB::edge * __ptr64>, COMDAT

; 706  : 	return (0);

	xor	eax, eax

; 707  : 	}

	ret	0
??$_Dist_type@PEAUedge@CDB@@@std@@YAPEA_JPEAUedge@CDB@@@Z ENDP ; std::_Dist_type<CDB::edge * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAUedge@CDB@@@std@@YAPEAUedge@CDB@@PEAU12@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAUedge@CDB@@@std@@YAPEAUedge@CDB@@PEAU12@@Z PROC ; std::_Val_type<CDB::edge * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAUedge@CDB@@@std@@YAPEAUedge@CDB@@PEAU12@@Z ENDP ; std::_Val_type<CDB::edge * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Pred$ = 32
__formal$dead$ = 40
_Val$1 = 40
__formal$dead$ = 48
??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z PROC ; std::_Make_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>, COMDAT

; 2442 : 	{	// make nontrivial [_First, _Last) into a heap, using _Pred

$LN61:
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], r9
	push	rdi
	mov	rsi, rdx
	mov	r9, rcx

; 2443 : 	_Diff _Bottom = _Last - _First;

	sub	rsi, rcx
	sar	rsi, 3

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	rax, rsi
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	rdi, rax
	test	rax, rax
	jle	$LN1@Make_heap

; 2443 : 	_Diff _Bottom = _Last - _First;

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	lea	rbp, QWORD PTR [rax*2+2]
$LL2@Make_heap:

; 2445 : 		{	// reheap top half, bottom to top
; 2446 : 		--_Hole;
; 2447 : 		_Ty _Val = _Move(*(_First + _Hole));

	mov	rcx, QWORD PTR [r9+rdi*8-8]
	dec	rdi
	sub	rbp, 2
	mov	QWORD PTR _Val$1[rsp], rcx

; 2448 : 		_Adjust_heap(_First, _Hole, _Bottom,
; 2449 : 			_Move(_Val), _Pred);

	mov	r10, rdi

; 2323 : 	}
; 2324 : 
; 2325 : template<class _RanIt,
; 2326 : 	class _Diff,
; 2327 : 	class _Ty,
; 2328 : 	class _Pr> inline
; 2329 : 	void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
; 2330 : 	{	// push *_Last onto heap at [_First, _Last), using _Pred
; 2331 : 	_Diff _Count = _Last - _First;
; 2332 : 	if (0 < _Count)
; 2333 : 		{	// worth doing, percolate *_Last
; 2334 : 		_Ty _Val = _Move(*_Last);
; 2335 : 		_Push_heap(_First, _Count, _Diff(0), _Move(_Val), _Pred);
; 2336 : 		}
; 2337 : 	}
; 2338 : 
; 2339 : template<class _RanIt,
; 2340 : 	class _Pr> inline
; 2341 : 	void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
; 2342 : 	{	// push *(_Last - 1) onto heap at [_First, _Last - 1), using _Pred
; 2343 : 	_DEBUG_RANGE(_First, _Last);
; 2344 : 	_DEBUG_POINTER(_Pred);
; 2345 : 	if (_First != _Last)
; 2346 : 		{	// check and push to nontrivial heap
; 2347 : 		--_Last;
; 2348 : 		_DEBUG_HEAP_PRED(_First, _Last, _Pred);
; 2349 : 		_Push_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2350 : 			_Dist_type(_First), _Val_type(_First));
; 2351 : 		}
; 2352 : 	}
; 2353 : 
; 2354 : 		// TEMPLATE FUNCTION push_heap
; 2355 : template<class _RanIt> inline
; 2356 : 	void push_heap(_RanIt _First, _RanIt _Last)
; 2357 : 	{	// push *(_Last - 1) onto heap at [_First, _Last - 1), using operator<
; 2358 : 	_STD push_heap(_First, _Last, less<>());
; 2359 : 	}
; 2360 : 
; 2361 : 		// TEMPLATE FUNCTION pop_heap WITH PRED
; 2362 : template<class _RanIt,
; 2363 : 	class _Diff,
; 2364 : 	class _Ty,
; 2365 : 	class _Pr> inline
; 2366 : 	void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
; 2367 : 		_Ty&& _Val, _Pr _Pred)
; 2368 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred
; 2369 : 	_Diff _Top = _Hole;
; 2370 : 	_Diff _Idx = 2 * _Hole + 2;

	mov	rdx, rbp

; 2371 : 
; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	cmp	rbp, rsi
	jge	SHORT $LN11@Make_heap
	npad	3
$LL13@Make_heap:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	eax, WORD PTR [r9+rdx*8+4]
	movzx	r8d, WORD PTR [r9+rdx*8-4]
	cmp	ax, r8w
	jb	SHORT $LN55@Make_heap

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	r8w, ax
	jb	SHORT $LN10@Make_heap

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [r9+rdx*8+6]
	movzx	r8d, WORD PTR [r9+rdx*8-2]
	cmp	ax, r8w
	jb	SHORT $LN55@Make_heap

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	r8w, ax
	jb	SHORT $LN10@Make_heap

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	r8d, DWORD PTR [r9+rdx*8]
	mov	eax, DWORD PTR [r9+rdx*8-8]
	and	eax, 1073741823				; 3fffffffH
	and	r8d, 1073741823				; 3fffffffH
	cmp	r8d, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

	test	al, al
	je	SHORT $LN10@Make_heap
$LN55@Make_heap:

; 2375 : 			--_Idx;

	dec	rdx
$LN10@Make_heap:

; 2376 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

	mov	rax, QWORD PTR [r9+rdx*8]
	mov	QWORD PTR [r9+r10*8], rax

; 2377 : 		_Hole = _Idx;

	mov	r10, rdx
	lea	rdx, QWORD PTR [rdx*2+2]
	cmp	rdx, rsi
	jl	SHORT $LL13@Make_heap
$LN11@Make_heap:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

	cmp	rdx, rsi
	jne	SHORT $LN9@Make_heap

; 2381 : 		{	// only child at bottom, move _Hole down to it
; 2382 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

	mov	rax, QWORD PTR [r9+rsi*8-8]
	mov	QWORD PTR [r9+r10*8], rax

; 2383 : 		_Hole = _Bottom - 1;

	lea	r10, QWORD PTR [rsi-1]
$LN9@Make_heap:

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	lea	rax, QWORD PTR [r10-1]
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax

; 2316 : 		_Idx = (_Hole - 1) / 2)

	cmp	rdi, r10
	jge	SHORT $LN59@Make_heap
	movzx	r11d, WORD PTR _Val$1[rsp+6]
	movzx	ebx, WORD PTR _Val$1[rsp+4]
	npad	5
$LL30@Make_heap:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	edx, WORD PTR [r9+r8*8+4]
	cmp	dx, bx
	jb	SHORT $LN56@Make_heap

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	bx, dx
	jb	SHORT $LN59@Make_heap

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [r9+r8*8+6]
	cmp	ax, r11w
	jb	SHORT $LN56@Make_heap

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	r11w, ax
	jb	SHORT $LN59@Make_heap

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	edx, DWORD PTR [r9+r8*8]
	mov	eax, ecx
	and	eax, 1073741823				; 3fffffffH
	and	edx, 1073741823				; 3fffffffH
	cmp	edx, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

	test	al, al
	je	SHORT $LN59@Make_heap
$LN56@Make_heap:

; 2317 : 		{	// move _Hole up to parent
; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

	mov	rax, QWORD PTR [r9+r8*8]
	mov	QWORD PTR [r9+r10*8], rax
	lea	rax, QWORD PTR [r8-1]

; 2319 : 		_Hole = _Idx;

	mov	r10, r8
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	cmp	rdi, r10
	jl	SHORT $LL30@Make_heap
$LN59@Make_heap:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

	mov	QWORD PTR [r9+r10*8], rcx

; 2444 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	test	rdi, rdi
	jg	$LL2@Make_heap
	mov	rbp, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]
$LN1@Make_heap:

; 2450 : 		}
; 2451 : 	}

	mov	rsi, QWORD PTR [rsp+32]
	pop	rdi
	ret	0
??$_Make_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@PEA_J0@Z ENDP ; std::_Make_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
_TEXT	SEGMENT
_Val$1 = 80
_First$ = 80
_Last$ = 88
_Pred$ = 96
??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z PROC ; std::_Sort_heap<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT

; 2475 : 	{	// order heap by repeatedly popping, using _Pred

$LN33:
	push	rbx
	push	rsi
	sub	rsp, 56					; 00000038H

; 2476 : 	for (; 1 < _Last - _First; --_Last)

	mov	rax, rdx
	movzx	ebx, r8b
	mov	rsi, rcx
	sub	rax, rcx
	and	rax, -8
	cmp	rax, 8
	jle	SHORT $LN1@Sort_heap
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+96], r14
	mov	QWORD PTR [rsp+48], r15
	mov	r14, rcx
	mov	r15d, 8
	lea	rdi, QWORD PTR [rdx-8]
	neg	r14
	sub	r15, rcx
$LL3@Sort_heap:

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

	mov	rax, QWORD PTR [rdi]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

	lea	r8, QWORD PTR [r14+rdi]
	lea	r9, QWORD PTR _Val$1[rsp]

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

	mov	QWORD PTR _Val$1[rsp], rax

; 2395 : 	*_Dest = _Move(*_First);

	mov	rax, QWORD PTR [rsi]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

	sar	r8, 3
	xor	edx, edx
	mov	rcx, rsi
	mov	BYTE PTR [rsp+32], bl
	mov	QWORD PTR [rdi], rax
	call	??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z ; std::_Adjust_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>

; 2476 : 	for (; 1 < _Last - _First; --_Last)

	lea	rdi, QWORD PTR [rdi-8]
	lea	rax, QWORD PTR [r15+rdi]
	and	rax, -8
	cmp	rax, 8
	jg	SHORT $LL3@Sort_heap
	mov	r15, QWORD PTR [rsp+48]
	mov	r14, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+88]
$LN1@Sort_heap:

; 2477 : 		_Pop_heap(_First, _Last, _Pred);
; 2478 : 	}

	add	rsp, 56					; 00000038H
	pop	rsi
	pop	rbx
	ret	0
??$_Sort_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ENDP ; std::_Sort_heap<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Pred$ = 32
__formal$dead$ = 40
_Val$1 = 40
??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z PROC ; std::_Insertion_sort1<CDB::edge * __ptr64,CDB::sort_predicate,CDB::edge>, COMDAT

; 2999 : 	{	// insertion sort [_First, _Last), using _Pred

$LN57:

; 3000 : 	if (_First != _Last)

	cmp	rcx, rdx
	je	$LN55@Insertion_

; 2999 : 	{	// insertion sort [_First, _Last), using _Pred

	mov	QWORD PTR [rsp+32], r9
	push	rsi

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	r10, QWORD PTR [rcx+8]
	mov	rsi, rdx
	mov	r9, rcx
	cmp	r10, rdx
	je	$LN6@Insertion_
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rdi
	npad	4
$LL7@Insertion_:

; 3004 : 			_Ty _Val = _Move(*_Next);

	mov	rax, QWORD PTR [r10]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	edx, WORD PTR [r9+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3003 : 			_BidIt _Next1 = _Next;

	mov	rdi, r10
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	mov	rcx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3004 : 			_Ty _Val = _Move(*_Next);

	mov	QWORD PTR _Val$1[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	shr	rcx, 32					; 00000020H
	cmp	cx, dx
	jb	$LN51@Insertion_

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	dx, cx
	jb	SHORT $LN5@Insertion_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	edx, WORD PTR [r9+6]
	mov	rcx, rax
	shr	rcx, 48					; 00000030H
	cmp	cx, dx
	jb	$LN51@Insertion_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	dx, cx
	jb	SHORT $LN5@Insertion_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r9]
	mov	edx, eax
	and	ecx, 1073741823				; 3fffffffH
	and	edx, 1073741823				; 3fffffffH
	cmp	edx, ecx
	setb	cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3006 : 			if (_DEBUG_LT_PRED(_Pred, _Val, *_First))

	test	cl, cl
	jne	SHORT $LN51@Insertion_
$LN5@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	movzx	r11d, WORD PTR _Val$1[rsp+6]
	movzx	ebx, WORD PTR _Val$1[rsp+4]
	lea	r8, QWORD PTR [r10+6]
	npad	8
$LL3@Insertion_:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	ecx, WORD PTR [r8-10]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

	lea	r8, QWORD PTR [r8-8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	cmp	bx, cx
	jb	SHORT $LN52@Insertion_

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	cx, bx
	jb	SHORT $LN54@Insertion_

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	ecx, WORD PTR [r8]
	cmp	r11w, cx
	jb	SHORT $LN52@Insertion_

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, r11w
	jb	SHORT $LN54@Insertion_

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	edx, DWORD PTR [r8-6]
	mov	ecx, eax
	and	ecx, 1073741823				; 3fffffffH
	and	edx, 1073741823				; 3fffffffH
	cmp	ecx, edx
	setb	cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3015 : 					_Next1 = _First1)

	test	cl, cl
	je	SHORT $LN54@Insertion_
$LN52@Insertion_:

; 3016 : 					*_Next1 = _Move(*_First1);	// move hole down

	mov	rcx, QWORD PTR [r8-6]
	lea	rdx, QWORD PTR [r8-6]
	mov	QWORD PTR [rdi], rcx
	mov	rdi, rdx
	jmp	SHORT $LL3@Insertion_
$LN54@Insertion_:

; 3017 : 				*_Next1 = _Move(_Val);	// insert element in hole

	mov	QWORD PTR [rdi], rax
	jmp	SHORT $LN4@Insertion_
$LN51@Insertion_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rcx, r10

; 2526 : 	while (_First != _Last)

	cmp	r9, r10
	je	SHORT $LN23@Insertion_
	npad	5
$LL24@Insertion_:

; 2527 : 		*--_Dest = _STD move(*--_Last);

	mov	rdx, QWORD PTR [rcx-8]
	sub	rcx, 8
	mov	QWORD PTR [rcx+8], rdx
	cmp	rcx, r9
	jne	SHORT $LL24@Insertion_
$LN23@Insertion_:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3009 : 				*_First = _Move(_Val);

	mov	QWORD PTR [r9], rax
$LN4@Insertion_:

; 3001 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	r10, 8
	cmp	r10, rsi
	jne	$LL7@Insertion_
	mov	rdi, QWORD PTR [rsp+24]
	mov	rbx, QWORD PTR [rsp+16]
$LN6@Insertion_:

; 3018 : 				}
; 3019 : 			}
; 3020 : 	}

	pop	rsi
$LN55@Insertion_:
	ret	0
??$_Insertion_sort1@PEAUedge@CDB@@Usort_predicate@2@U12@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z ENDP ; std::_Insertion_sort1<CDB::edge * __ptr64,CDB::sort_predicate,CDB::edge>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z PROC ; std::_Val_type<_vector3<float> * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAU?$_vector3@M@@@std@@YAPEAU?$_vector3@M@@PEAU1@@Z ENDP ; std::_Val_type<_vector3<float> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	movsdx	xmm0, QWORD PTR [rcx]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r8+8], eax
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 12
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 12
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAU?$_vector3@M@@PEAU1@V?$xalloc@U?$_vector3@M@@@@U1@@std@@YAPEAU?$_vector3@M@@PEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<_vector3<float> * __ptr64,_vector3<float> * __ptr64,xalloc<_vector3<float> >,_vector3<float> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>, COMDAT

; 459  : 	{	// move [_First, _Last) to raw _Dest, using _Al, scalar type

$LN4:
	sub	rsp, 56					; 00000038H

; 460  : 	return (_Uninit_move(_First, _Last, _Dest,
; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>

; 462  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAVTRI@CDB@@@std@@YAPEAVTRI@CDB@@PEAV12@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAVTRI@CDB@@@std@@YAPEAVTRI@CDB@@PEAV12@@Z PROC ; std::_Val_type<CDB::TRI * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAVTRI@CDB@@@std@@YAPEAVTRI@CDB@@PEAV12@@Z ENDP ; std::_Val_type<CDB::TRI * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	movups	xmm0, XMMWORD PTR [rcx]
	movups	XMMWORD PTR [r8], xmm0
	movsdx	xmm1, QWORD PTR [rcx+16]
	movsdx	QWORD PTR [r8+16], xmm1
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 24
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 24
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAVTRI@CDB@@PEAV12@V?$xalloc@VTRI@CDB@@@@V12@@std@@YAPEAVTRI@CDB@@PEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<CDB::TRI * __ptr64,CDB::TRI * __ptr64,xalloc<CDB::TRI>,CDB::TRI>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@I@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@I@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI@Z PROC ; std::_Wrap_alloc<xalloc<unsigned int> >::destroy<unsigned int>, COMDAT

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	0
??$destroy@I@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI@Z ENDP ; std::_Wrap_alloc<xalloc<unsigned int> >::destroy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Construct@IAEBI@std@@YAXPEAIAEBI@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Val$ = 16
??$_Construct@IAEBI@std@@YAXPEAIAEBI@Z PROC		; std::_Construct<unsigned int,unsigned int const & __ptr64>, COMDAT

; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN3@Construct
	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx], eax
$LN3@Construct:

; 41   : 	}

	ret	0
??$_Construct@IAEBI@std@@YAXPEAIAEBI@Z ENDP		; std::_Construct<unsigned int,unsigned int const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z
_TEXT	SEGMENT
_First$ = 8
_Mid$ = 16
_Last$ = 24
_Pred$ = 32
??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z PROC ; std::_Med3<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	eax, WORD PTR [rdx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3032 : 	{	// sort median of three elements to middle

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	ecx, WORD PTR [rcx+4]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3032 : 	{	// sort median of three elements to middle

	mov	r9, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	cmp	ax, cx
	jb	SHORT $LN54@Med3

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	cx, ax
	jb	SHORT $LN14@Med3

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rdx+6]
	movzx	ecx, WORD PTR [r10+6]
	cmp	ax, cx
	jb	SHORT $LN54@Med3

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN14@Med3

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [rdx]
	mov	eax, DWORD PTR [r10]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	ecx, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3033 : 	if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	test	al, al
	je	SHORT $LN14@Med3
$LN54@Med3:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [r10]
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rdx], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [r10], rax
$LN14@Med3:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	eax, WORD PTR [r8+4]
	movzx	ecx, WORD PTR [rdx+4]
	cmp	ax, cx
	jb	SHORT $LN55@Med3

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	cx, ax
	jb	$LN46@Med3

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [r8+6]
	movzx	ecx, WORD PTR [rdx+6]
	cmp	ax, cx
	jb	SHORT $LN55@Med3

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN46@Med3

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [rdx]
	mov	eax, DWORD PTR [r8]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	eax, ecx
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3035 : 	if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid))

	test	al, al
	je	SHORT $LN46@Med3
$LN55@Med3:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [rdx]
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [r8], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [rdx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	ecx, WORD PTR [rdx+4]
	movzx	edx, WORD PTR [r10+4]
	cmp	cx, dx
	jb	SHORT $LN56@Med3

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	dx, cx
	jb	SHORT $LN46@Med3

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	ecx, WORD PTR [r9+6]
	movzx	edx, WORD PTR [r10+6]
	cmp	cx, dx
	jb	SHORT $LN56@Med3

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	dx, cx
	jb	SHORT $LN46@Med3

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r10]
	mov	edx, eax
	and	ecx, 1073741823				; 3fffffffH
	and	edx, 1073741823				; 3fffffffH
	cmp	edx, ecx
	setb	cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3038 : 		if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First))

	test	cl, cl
	je	SHORT $LN46@Med3
$LN56@Med3:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility

; 53   : 	_Left = _Move(_Right);

	mov	rcx, QWORD PTR [r10]
	mov	QWORD PTR [r9], rcx

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [r10], rax
$LN46@Med3:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 3041 : 	}

	ret	0
??$_Med3@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00Usort_predicate@2@@Z ENDP ; std::_Med3<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\utility
;	COMDAT ??$swap@Uedge@CDB@@@std@@YAXAEAUedge@CDB@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@Uedge@CDB@@@std@@YAXAEAUedge@CDB@@0@Z PROC	; std::swap<CDB::edge>, COMDAT

; 52   : 	_Ty _Tmp = _Move(_Left);
; 53   : 	_Left = _Move(_Right);

	mov	r8, QWORD PTR [rdx]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx], r8

; 54   : 	_Right = _Move(_Tmp);

	mov	QWORD PTR [rdx], rax

; 55   : 	}

	ret	0
??$swap@Uedge@CDB@@@std@@YAXAEAUedge@CDB@@0@Z ENDP	; std::swap<CDB::edge>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEAUedge@CDB@@@std@@YAAEAPEAUedge@CDB@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAUedge@CDB@@@std@@YAAEAPEAUedge@CDB@@AEAPEAU12@@Z PROC ; std::forward<CDB::edge * __ptr64 & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAPEAUedge@CDB@@@std@@YAAEAPEAUedge@CDB@@AEAPEAU12@@Z ENDP ; std::forward<CDB::edge * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAUedge@CDB@@@std@@YA$$QEAUedge@CDB@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAUedge@CDB@@@std@@YA$$QEAUedge@CDB@@AEAU12@@Z PROC ; std::_Move<CDB::edge & __ptr64>, COMDAT

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, rcx

; 1529 : 	}

	ret	0
??$_Move@AEAUedge@CDB@@@std@@YA$$QEAUedge@CDB@@AEAU12@@Z ENDP ; std::_Move<CDB::edge & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z
_TEXT	SEGMENT
_First$ = 8
_Hole$ = 16
_Bottom$ = 24
_Val$ = 32
_Pred$ = 40
??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z PROC ; std::_Adjust_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>, COMDAT

; 2368 : 	{	// percolate _Hole to _Bottom, then push _Val, using _Pred

$LN50:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 2369 : 	_Diff _Top = _Hole;
; 2370 : 	_Diff _Idx = 2 * _Hole + 2;

	lea	r10, QWORD PTR [rdx*2+2]
	mov	rbx, rdx
	mov	r11, rcx
	mov	rdi, rdx

; 2371 : 
; 2372 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	cmp	r10, r8
	jge	SHORT $LN48@Adjust_hea
$LL5@Adjust_hea:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	eax, WORD PTR [r11+r10*8+4]
	movzx	ecx, WORD PTR [r11+r10*8-4]
	cmp	ax, cx
	jb	SHORT $LN43@Adjust_hea

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	cx, ax
	jb	SHORT $LN2@Adjust_hea

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [r11+r10*8+6]
	movzx	ecx, WORD PTR [r11+r10*8-2]
	cmp	ax, cx
	jb	SHORT $LN43@Adjust_hea

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN2@Adjust_hea

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r11+r10*8]
	mov	eax, DWORD PTR [r11+r10*8-8]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	ecx, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2374 : 		if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1))))

	test	al, al
	je	SHORT $LN2@Adjust_hea
$LN43@Adjust_hea:

; 2375 : 			--_Idx;

	dec	r10
$LN2@Adjust_hea:

; 2376 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

	mov	rax, QWORD PTR [r11+r10*8]
	mov	QWORD PTR [r11+rbx*8], rax

; 2377 : 		_Hole = _Idx;

	mov	rbx, r10
	lea	r10, QWORD PTR [r10*2+2]
	cmp	r10, r8
	jl	SHORT $LL5@Adjust_hea
$LN48@Adjust_hea:

; 2378 : 		}
; 2379 : 
; 2380 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2381 : 		{	// only child at bottom, move _Hole down to it
; 2382 : 		*(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));

	mov	rax, QWORD PTR [r11+r8*8-8]
	mov	QWORD PTR [r11+rbx*8], rax

; 2383 : 		_Hole = _Bottom - 1;

	lea	rbx, QWORD PTR [r8-1]
$LN1@Adjust_hea:

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	lea	rax, QWORD PTR [rbx-1]
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax

; 2316 : 		_Idx = (_Hole - 1) / 2)

	cmp	rdi, rbx
	jge	SHORT $LN47@Adjust_hea
	npad	9
$LL22@Adjust_hea:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	ecx, WORD PTR [r11+r8*8+4]
	movzx	edx, WORD PTR [r9+4]
	cmp	cx, dx
	jb	SHORT $LN44@Adjust_hea

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	dx, cx
	jb	SHORT $LN47@Adjust_hea

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [r11+r8*8+6]
	movzx	ecx, WORD PTR [r9+6]
	cmp	ax, cx
	jb	SHORT $LN44@Adjust_hea

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN47@Adjust_hea

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r11+r8*8]
	mov	eax, DWORD PTR [r9]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	ecx, eax
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

	test	al, al
	je	SHORT $LN47@Adjust_hea
$LN44@Adjust_hea:

; 2317 : 		{	// move _Hole up to parent
; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

	mov	rax, QWORD PTR [r11+r8*8]
	mov	QWORD PTR [r11+rbx*8], rax
	lea	rax, QWORD PTR [r8-1]

; 2319 : 		_Hole = _Idx;

	mov	rbx, r8
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r8, rax
	cmp	rdi, rbx
	jl	SHORT $LL22@Adjust_hea
$LN47@Adjust_hea:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

	mov	rax, QWORD PTR [r9]

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);
; 2386 : 	}

	mov	rdi, QWORD PTR [rsp+16]

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

	mov	QWORD PTR [r11+rbx*8], rax

; 2384 : 		}
; 2385 : 	_Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);
; 2386 : 	}

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z ENDP ; std::_Adjust_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z
_TEXT	SEGMENT
_Val$1 = 64
_First$ = 64
_Last$ = 72
_Pred$ = 80
??$_Pop_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z PROC ; std::_Pop_heap<CDB::edge * __ptr64,CDB::sort_predicate>, COMDAT

; 2413 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

$LN24:
	sub	rsp, 56					; 00000038H

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

	mov	rax, QWORD PTR [rdx-8]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

	mov	BYTE PTR [rsp+32], r8b
	lea	r9, QWORD PTR _Val$1[rsp]

; 2398 : 	}
; 2399 : 
; 2400 : template<class _RanIt,
; 2401 : 	class _Ty,
; 2402 : 	class _Pr> inline
; 2403 : 	void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred
; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

	mov	QWORD PTR _Val$1[rsp], rax

; 2395 : 	*_Dest = _Move(*_First);

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx-8], rax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

	sub	rdx, rcx
	sub	rdx, 8
	sar	rdx, 3
	mov	r8, rdx
	xor	edx, edx
	call	??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z ; std::_Adjust_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>

; 2414 : 	_Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
; 2415 : 		_Val_type(_First));
; 2416 : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Pop_heap@PEAUedge@CDB@@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@@Z ENDP ; std::_Pop_heap<CDB::edge * __ptr64,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move_backward@PEAUedge@CDB@@PEAU12@@std@@YAPEAUedge@CDB@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Move_backward@PEAUedge@CDB@@PEAU12@@std@@YAPEAUedge@CDB@@PEAU12@00@Z PROC ; std::_Move_backward<CDB::edge * __ptr64,CDB::edge * __ptr64>, COMDAT

; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked

	mov	rax, r8

; 2526 : 	while (_First != _Last)

	cmp	rcx, rdx
	je	SHORT $LN15@Move_backw
	npad	8
$LL6@Move_backw:

; 2527 : 		*--_Dest = _STD move(*--_Last);

	mov	r8, QWORD PTR [rdx-8]
	sub	rdx, 8
	sub	rax, 8
	mov	QWORD PTR [rax], r8
	cmp	rdx, rcx
	jne	SHORT $LL6@Move_backw
$LN15@Move_backw:

; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2549 : 	}

	ret	0
??$_Move_backward@PEAUedge@CDB@@PEAU12@@std@@YAPEAUedge@CDB@@PEAU12@00@Z ENDP ; std::_Move_backward<CDB::edge * __ptr64,CDB::edge * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$_vector3@M@@U1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@$$QEAU2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$_vector3@M@@U1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@$$QEAU2@@Z PROC ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> >, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@U?$_vector3@M@@U1@@?$_Wrap_alloc@V?$xalloc@U?$_vector3@M@@@@@std@@QEAAXPEAU?$_vector3@M@@$$QEAU2@@Z ENDP ; std::_Wrap_alloc<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r8], eax
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 4
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 4
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VTRI@CDB@@V12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@$$QEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VTRI@CDB@@V12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@$$QEAV23@@Z PROC ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@VTRI@CDB@@V12@@?$_Wrap_alloc@V?$xalloc@VTRI@CDB@@@@@std@@QEAAXPEAVTRI@CDB@@$$QEAV23@@Z ENDP ; std::_Wrap_alloc<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@I@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@I@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI@Z PROC ; std::allocator_traits<xalloc<unsigned int> >::destroy<unsigned int>, COMDAT

; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}

	ret	0
??$destroy@I@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI@Z ENDP ; std::allocator_traits<xalloc<unsigned int> >::destroy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z
_TEXT	SEGMENT
_First$ = 8
_Hole$ = 16
_Top$ = 24
_Val$ = 32
_Pred$ = 40
??$_Push_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z PROC ; std::_Push_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>, COMDAT

; 2313 : 	{	// percolate _Hole to _Top or where _Val belongs, using operator<

$LN25:
	mov	QWORD PTR [rsp+8], rbx
	mov	r11, rdx

; 2314 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	lea	rax, QWORD PTR [rdx-1]
	mov	rbx, rcx
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax

; 2316 : 		_Idx = (_Hole - 1) / 2)

	cmp	r8, r11
	jge	SHORT $LN23@Push_heap
	npad	1
$LL3@Push_heap:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_collector.cpp

; 102  : 			if (edge0.vertex_id0 < edge1.vertex_id0)

	movzx	ecx, WORD PTR [rbx+r10*8+4]
	movzx	edx, WORD PTR [r9+4]
	cmp	cx, dx
	jb	SHORT $LN20@Push_heap

; 103  : 				return				(true);
; 104  : 
; 105  : 			if (edge1.vertex_id0 < edge0.vertex_id0)

	cmp	dx, cx
	jb	SHORT $LN23@Push_heap

; 106  : 				return				(false);
; 107  : 
; 108  : 			if (edge0.vertex_id1 < edge1.vertex_id1)

	movzx	eax, WORD PTR [rbx+r10*8+6]
	movzx	ecx, WORD PTR [r9+6]
	cmp	ax, cx
	jb	SHORT $LN20@Push_heap

; 109  : 				return				(true);
; 110  : 
; 111  : 			if (edge1.vertex_id1 < edge0.vertex_id1)

	cmp	cx, ax
	jb	SHORT $LN23@Push_heap

; 112  : 				return				(false);
; 113  : 
; 114  : 			return					(edge0.face_id < edge1.face_id);

	mov	ecx, DWORD PTR [r9]
	mov	eax, DWORD PTR [rbx+r10*8]
	and	eax, 1073741823				; 3fffffffH
	and	ecx, 1073741823				; 3fffffffH
	cmp	eax, ecx
	setb	al
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2316 : 		_Idx = (_Hole - 1) / 2)

	test	al, al
	je	SHORT $LN23@Push_heap
$LN20@Push_heap:

; 2317 : 		{	// move _Hole up to parent
; 2318 : 		*(_First + _Hole) = _Move(*(_First + _Idx));

	mov	rax, QWORD PTR [rbx+r10*8]
	mov	QWORD PTR [rbx+r11*8], rax
	lea	rax, QWORD PTR [r10-1]

; 2319 : 		_Hole = _Idx;

	mov	r11, r10
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
	cmp	r8, r11
	jl	SHORT $LL3@Push_heap
$LN23@Push_heap:

; 2320 : 		}
; 2321 : 
; 2322 : 	*(_First + _Hole) = _Move(_Val);	// drop _Val into final hole

	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [rbx+r11*8], rax

; 2323 : 	}

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
??$_Push_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z ENDP ; std::_Push_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap_0@PEAUedge@CDB@@U12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Pred$ = 80
__formal$dead$ = 88
_Val$ = 88
??$_Pop_heap_0@PEAUedge@CDB@@U12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z PROC ; std::_Pop_heap_0<CDB::edge * __ptr64,CDB::edge,CDB::sort_predicate>, COMDAT

; 2404 : 	{	// pop *_First to *(_Last - 1) and reheap, using _Pred

$LN16:
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

	mov	rax, QWORD PTR [rdx-8]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

	mov	BYTE PTR [rsp+32], r8b
	lea	r9, QWORD PTR _Val$[rsp]

; 2405 : 	_Ty _Val = _Move(*(_Last - 1));

	mov	QWORD PTR _Val$[rsp], rax

; 2395 : 	*_Dest = _Move(*_First);

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx-8], rax

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

	sub	rdx, rcx
	sub	rdx, 8
	sar	rdx, 3
	mov	r8, rdx
	xor	edx, edx
	call	??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z ; std::_Adjust_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>

; 2406 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2407 : 		_Move(_Val), _Pred, _Dist_type(_First));
; 2408 : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Pop_heap_0@PEAUedge@CDB@@U12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@0Usort_predicate@2@0@Z ENDP ; std::_Pop_heap_0<CDB::edge * __ptr64,CDB::edge,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@Uedge@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAUedge@CDB@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@Uedge@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAUedge@CDB@@0@Z PROC ; std::_Ptr_cat<CDB::edge,CDB::edge>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@Uedge@CDB@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAUedge@CDB@@0@Z ENDP ; std::_Ptr_cat<CDB::edge,CDB::edge>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move_backward@PEAUedge@CDB@@PEAU12@@std@@YAPEAUedge@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Move_backward@PEAUedge@CDB@@PEAU12@@std@@YAPEAUedge@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward<CDB::edge * __ptr64,CDB::edge * __ptr64>, COMDAT

; 2526 : 	while (_First != _Last)

	cmp	rcx, rdx
	je	SHORT $LN11@Move_backw
	npad	11
$LL2@Move_backw:

; 2527 : 		*--_Dest = _STD move(*--_Last);

	mov	rax, QWORD PTR [rdx-8]
	sub	rdx, 8
	sub	r8, 8
	mov	QWORD PTR [r8], rax
	cmp	rdx, rcx
	jne	SHORT $LL2@Move_backw
$LN11@Move_backw:

; 2528 : 	return (_Dest);

	mov	rax, r8

; 2529 : 	}

	ret	0
??$_Move_backward@PEAUedge@CDB@@PEAU12@@std@@YAPEAUedge@CDB@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward<CDB::edge * __ptr64,CDB::edge * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_vector3@M@@@std@@YA$$QEAU?$_vector3@M@@AEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$_vector3@M@@@std@@YA$$QEAU?$_vector3@M@@AEAU1@@Z PROC ; std::forward<_vector3<float> >, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@U?$_vector3@M@@@std@@YA$$QEAU?$_vector3@M@@AEAU1@@Z ENDP ; std::forward<_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$_vector3@M@@U1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@$$QEAU3@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U?$_vector3@M@@U1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@$$QEAU3@@Z PROC ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> >, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [rdx], xmm0
	mov	eax, DWORD PTR [r8+8]
	mov	DWORD PTR [rdx+8], eax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@U?$_vector3@M@@U1@@?$allocator_traits@V?$xalloc@U?$_vector3@M@@@@@std@@SAXAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@$$QEAU3@@Z ENDP ; std::allocator_traits<xalloc<_vector3<float> > >::construct<_vector3<float>,_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@II@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI$$QEAI@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@II@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI$$QEAI@Z PROC ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@II@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI$$QEAI@Z ENDP ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@VTRI@CDB@@@std@@YA$$QEAVTRI@CDB@@AEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VTRI@CDB@@@std@@YA$$QEAVTRI@CDB@@AEAV12@@Z PROC ; std::forward<CDB::TRI>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@VTRI@CDB@@@std@@YA$$QEAVTRI@CDB@@AEAV12@@Z ENDP ; std::forward<CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@VTRI@CDB@@V12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@$$QEAV34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@VTRI@CDB@@V12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@$$QEAV34@@Z PROC ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	movups	xmm0, XMMWORD PTR [r8]
	movups	XMMWORD PTR [rdx], xmm0
	movsdx	xmm1, QWORD PTR [r8+16]
	movsdx	QWORD PTR [rdx+16], xmm1
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@VTRI@CDB@@V12@@?$allocator_traits@V?$xalloc@VTRI@CDB@@@@@std@@SAXAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@$$QEAV34@@Z ENDP ; std::allocator_traits<xalloc<CDB::TRI> >::construct<CDB::TRI,CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@I@@I@_Alloc_destroy@std@@SAXHAEAV?$xalloc@I@@PEAI@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$dead$ = 24
??$_Fn@V?$xalloc@I@@I@_Alloc_destroy@std@@SAXHAEAV?$xalloc@I@@PEAI@Z PROC ; std::_Alloc_destroy::_Fn<xalloc<unsigned int>,unsigned int>, COMDAT

; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}

	ret	0
??$_Fn@V?$xalloc@I@@I@_Alloc_destroy@std@@SAXHAEAV?$xalloc@I@@PEAI@Z ENDP ; std::_Alloc_destroy::_Fn<xalloc<unsigned int>,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@I@@QEAAXPEAI@Z
_TEXT	SEGMENT
this$dead$ = 8
p$dead$ = 16
?destroy@?$xalloc@I@@QEAAXPEAI@Z PROC			; xalloc<unsigned int>::destroy, COMDAT

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy(p);			}

	ret	0
?destroy@?$xalloc@I@@QEAAXPEAI@Z ENDP			; xalloc<unsigned int>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00$$QEAU12@Usort_predicate@2@PEA_J@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Val$ = 88
_Pred$ = 96
__formal$dead$ = 104
??$_Pop_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00$$QEAU12@Usort_predicate@2@PEA_J@Z PROC ; std::_Pop_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>, COMDAT

; 2394 : 	{	// pop *_First to *_Dest and reheap, using _Pred

$LN8:
	sub	rsp, 56					; 00000038H

; 2395 : 	*_Dest = _Move(*_First);

	mov	rax, QWORD PTR [rcx]

; 2396 : 	_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
; 2397 : 		_Move(_Val), _Pred);

	sub	rdx, rcx
	mov	QWORD PTR [r8], rax
	movzx	eax, BYTE PTR _Pred$[rsp]
	sar	rdx, 3
	mov	r8, rdx
	xor	edx, edx
	mov	BYTE PTR [rsp+32], al
	call	??$_Adjust_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@_J1$$QEAU12@Usort_predicate@2@@Z ; std::_Adjust_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>

; 2398 : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Pop_heap@PEAUedge@CDB@@_JU12@Usort_predicate@2@@std@@YAXPEAUedge@CDB@@00$$QEAU12@Usort_predicate@2@PEA_J@Z ENDP ; std::_Pop_heap<CDB::edge * __ptr64,__int64,CDB::edge,CDB::sort_predicate>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AEAUedge@CDB@@@std@@YA$$QEAUedge@CDB@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUedge@CDB@@@std@@YA$$QEAUedge@CDB@@AEAU12@@Z PROC ; std::move<CDB::edge & __ptr64>, COMDAT

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, rcx

; 1521 : 	}

	ret	0
??$move@AEAUedge@CDB@@@std@@YA$$QEAUedge@CDB@@AEAU12@@Z ENDP ; std::move<CDB::edge & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@U2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@$$QEAU3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@U2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@$$QEAU3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> >, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movsdx	xmm0, QWORD PTR [r9]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [r9+8]
	mov	DWORD PTR [r8+8], eax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@U?$_vector3@M@@@@U?$_vector3@M@@U2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@U?$_vector3@M@@@@PEAU?$_vector3@M@@$$QEAU3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<_vector3<float> >,_vector3<float>,_vector3<float> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@I@std@@YA$$QEAIAEAI@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@I@std@@YA$$QEAIAEAI@Z PROC			; std::forward<unsigned int>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@I@std@@YA$$QEAIAEAI@Z ENDP			; std::forward<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@II@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI$$QEAI@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@II@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI$$QEAI@Z PROC ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@II@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI$$QEAI@Z ENDP ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@V23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@$$QEAV34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@V23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@$$QEAV34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	movups	xmm0, XMMWORD PTR [r9]
	movups	XMMWORD PTR [r8], xmm0
	movsdx	xmm1, QWORD PTR [r9+16]
	movsdx	QWORD PTR [r8+16], xmm1
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@VTRI@CDB@@@@VTRI@CDB@@V23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@VTRI@CDB@@@@PEAVTRI@CDB@@$$QEAV34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CDB::TRI>,CDB::TRI,CDB::TRI>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy@I@std@@YAXPEAI@Z
_TEXT	SEGMENT
_Ptr$dead$ = 8
??$_Destroy@I@std@@YAXPEAI@Z PROC			; std::_Destroy<unsigned int>, COMDAT

; 55   : 	_Ptr->~_Ty();
; 56   : 	}

	ret	0
??$_Destroy@I@std@@YAXPEAI@Z ENDP			; std::_Destroy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@I@@II@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAI$$QEAI@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@I@@II@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAI$$QEAI@Z PROC ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [r8], eax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@I@@II@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAI$$QEAI@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@I@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$xalloc@I@@QEBA_KXZ PROC			; xalloc<unsigned int>::max_size, COMDAT

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	rax, 4611686018427387903		; 3fffffffffffffffH
	ret	0
?max_size@?$xalloc@I@@QEBA_KXZ ENDP			; xalloc<unsigned int>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@I@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@I@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
??$_Fn@V?$xalloc@I@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@I@@@Z PROC ; std::_Alloc_max_size::_Fn<xalloc<unsigned int> >, COMDAT

; 381  : 		return (_Al.max_size());

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 382  : 		}

	ret	0
??$_Fn@V?$xalloc@I@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@I@@@Z ENDP ; std::_Alloc_max_size::_Fn<xalloc<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$xalloc@I@@@std@@SA_KAEBV?$xalloc@I@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$xalloc@I@@@std@@SA_KAEBV?$xalloc@I@@@Z PROC ; std::allocator_traits<xalloc<unsigned int> >::max_size, COMDAT

; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 482  : 		}

	ret	0
?max_size@?$allocator_traits@V?$xalloc@I@@@std@@SA_KAEBV?$xalloc@I@@@Z ENDP ; std::allocator_traits<xalloc<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<xalloc<unsigned int> >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<xalloc<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx*4]
	add	QWORD PTR [rcx], rax

; 171  : 		return (*this);

	mov	rax, rcx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx*4]
	add	QWORD PTR [rcx], rax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax+r8*4]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx

; 368  : 		}

	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Compat, COMDAT

; 255  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 206  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

	setne	al

; 211  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?iFloor@@YAHM@Z
_TEXT	SEGMENT
x$ = 8
?iFloor@@YAHM@Z PROC					; iFloor, COMDAT

; 83   :     int a			= *(const int*)(&x);
; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edx, 158				; 0000009eH
	movss	DWORD PTR [rsp+8], xmm0
	mov	r9d, DWORD PTR x$[rsp]
	mov	eax, r9d

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r8d, r9d
	sar	eax, 23
	or	r8d, -8388608				; ff800000H
	movzx	ecx, al
	shl	r8d, 8

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, 1
	sub	edx, ecx
	mov	ecx, edx
	shr	r8d, cl
	lea	ecx, DWORD PTR [rdx-96]
	shl	eax, cl
	mov	ecx, 0
	dec	eax
	sar	eax, 8
	test	eax, r9d

; 89   :         exponent	-=	(31-127)+32;

	lea	eax, DWORD PTR [rdx-32]
	sete	cl

; 90   :         exponent	>>=	31;
; 91   :         a			>>=	31;

	sar	r9d, 31
	sar	eax, 31

; 92   :         r			-=	(imask&a);

	and	ecx, r9d
	sub	r8d, ecx

; 93   :         r			&=	exponent;

	and	eax, r8d

; 94   :         r			^=	a;

	xor	eax, r9d

; 95   :     }
; 96   :     return r;
; 97   : }

	ret	0
?iFloor@@YAHM@Z ENDP					; iFloor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >, COMDAT

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 485  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$xalloc@I@@@std@@@std@@QEAA@AEBV?$xalloc@I@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$xalloc@I@@@std@@@std@@QEAA@AEBV?$xalloc@I@@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@IV?$xalloc@I@@@std@@@std@@QEAA@AEBV?$xalloc@I@@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >::_Vector_alloc<0,std::_Vec_base_types<unsigned int,xalloc<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@IV?$xalloc@I@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@IV?$xalloc@I@@@std@@QEAA@XZ PROC		; std::vector<unsigned int,xalloc<unsigned int> >::vector<unsigned int,xalloc<unsigned int> >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 681  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@IV?$xalloc@I@@@std@@QEAA@XZ ENDP		; std::vector<unsigned int,xalloc<unsigned int> >::vector<unsigned int,xalloc<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ PROC		; xr_vector<unsigned int,xalloc<unsigned int> >::xr_vector<unsigned int,xalloc<unsigned int> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	rax, rcx
	ret	0
??0?$xr_vector@IV?$xalloc@I@@@@QEAA@XZ ENDP		; xr_vector<unsigned int,xalloc<unsigned int> >::xr_vector<unsigned int,xalloc<unsigned int> >
_TEXT	ENDS
END
