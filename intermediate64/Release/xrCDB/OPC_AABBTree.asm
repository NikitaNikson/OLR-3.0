; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??0AABB@Meshmerizer@@QEAA@XZ			; Meshmerizer::AABB::AABB
PUBLIC	??1AABB@Meshmerizer@@QEAA@XZ			; Meshmerizer::AABB::~AABB
PUBLIC	??_GAABBTreeNode@Opcode@@QEAAPEAXI@Z		; Opcode::AABBTreeNode::`scalar deleting destructor'
PUBLIC	?destroy@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::destroy
PUBLIC	?node_destroy@AABBTreeBuilder@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z ; Opcode::AABBTreeBuilder::node_destroy
PUBLIC	?LargestAxis@icePoint@IceMaths@@QEBA?AW4PointComponent@2@XZ ; IceMaths::icePoint::LargestAxis
PUBLIC	??_0icePoint@IceMaths@@QEAAAEAV01@M@Z		; IceMaths::icePoint::operator/=
PUBLIC	?IncreaseCount@AABBTreeBuilder@Opcode@@QEAAXI@Z	; Opcode::AABBTreeBuilder::IncreaseCount
PUBLIC	?IncreaseNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXXZ ; Opcode::AABBTreeBuilder::IncreaseNbInvalidSplits
PUBLIC	?_Inside@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_NPEBQEAVAABBTreeNode@Opcode@@@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Inside
PUBLIC	??$xr_alloc@PEAVAABBTreeNode@Opcode@@@@YAPEAPEAVAABBTreeNode@Opcode@@I@Z ; xr_alloc<Opcode::AABBTreeNode * __ptr64>
PUBLIC	?allocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAPEAPEAVAABBTreeNode@Opcode@@_KPEBX@Z ; xalloc<Opcode::AABBTreeNode * __ptr64>::allocate
PUBLIC	??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z ; xr_free<Opcode::AABBTreeNode * __ptr64>
PUBLIC	?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z ; xalloc<Opcode::AABBTreeNode * __ptr64>::deallocate
PUBLIC	??$_Destroy_range@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	??$_Destroy_range@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ; std::_Destroy_range<xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	?_Destroy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXPEAPEAVAABBTreeNode@Opcode@@0@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Destroy
PUBLIC	??$_Ptr_cat@PEAVAABBTreeNode@Opcode@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVAABBTreeNode@Opcode@@0@Z ; std::_Ptr_cat<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Val_type@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z ; std::_Val_type<Opcode::AABBTreeNode * __ptr64 * __ptr64>
PUBLIC	??$forward@PEAVAABBTreeNode@Opcode@@@std@@YA$$QEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z ; std::forward<Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@PEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV23@@Z ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Destroy@PEAVAABBTreeNode@Opcode@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@@Z ; std::_Destroy<Opcode::AABBTreeNode * __ptr64>
PUBLIC	?destroy@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z ; xalloc<Opcode::AABBTreeNode * __ptr64>::destroy
PUBLIC	??$_Dest_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z ; std::_Dest_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ; std::_Uninitialized_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Umove<Opcode::AABBTreeNode * __ptr64 * __ptr64>
PUBLIC	?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::reserve
PUBLIC	?size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size
PUBLIC	?capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::capacity
PUBLIC	?max_size@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBA_KXZ ; xalloc<Opcode::AABBTreeNode * __ptr64>::max_size
PUBLIC	?max_size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size
PUBLIC	?_Grow_to@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_K_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Grow_to
PUBLIC	?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Xlen
PUBLIC	?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve
PUBLIC	?_Orphan_range@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXPEAPEAVAABBTreeNode@Opcode@@0@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Orphan_range
PUBLIC	??$addressof@QEAVAABBTreeNode@Opcode@@@std@@YAPEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ; std::addressof<Opcode::AABBTreeNode * __ptr64 const>
PUBLIC	??$forward@AEAPEAVAABBTreeNode@Opcode@@@std@@YAAEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z ; std::forward<Opcode::AABBTreeNode * __ptr64 & __ptr64>
PUBLIC	??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEAPEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV23@@Z ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>
PUBLIC	??$_Construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ; std::_Construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
PUBLIC	?construct@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z ; xalloc<Opcode::AABBTreeNode * __ptr64>::construct
PUBLIC	??$forward@AEBQEAVAABBTreeNode@Opcode@@@std@@YAAEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ; std::forward<Opcode::AABBTreeNode * __ptr64 const & __ptr64>
PUBLIC	??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEBQEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
PUBLIC	?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::push_back
PUBLIC	?access@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAPEAPEAVAABBTreeNode@2@PEAV32@@Z ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::access
PUBLIC	??$xr_alloc@VAABBTreeNode@Opcode@@@@YAPEAVAABBTreeNode@Opcode@@I@Z ; xr_alloc<Opcode::AABBTreeNode>
PUBLIC	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
PUBLIC	?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::create
PUBLIC	?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ ; Opcode::AABBTreeBuilder::node_alloc
PUBLIC	?SetCount@AABBTreeBuilder@Opcode@@QEAAXI@Z	; Opcode::AABBTreeBuilder::SetCount
PUBLIC	?GetCount@AABBTreeBuilder@Opcode@@QEBAIXZ	; Opcode::AABBTreeBuilder::GetCount
PUBLIC	?SetNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXI@Z ; Opcode::AABBTreeBuilder::SetNbInvalidSplits
PUBLIC	?GetNodeSize@AABBTreeNode@Opcode@@QEBAIXZ	; Opcode::AABBTreeNode::GetNodeSize
PUBLIC	?GetNbNodes@AABBTree@Opcode@@QEBAIXZ		; Opcode::AABBTree::GetNbNodes
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
;	COMDAT ?access@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAPEAPEAVAABBTreeNode@2@PEAV32@@Z
_TEXT	SEGMENT
P$ = 8
?access@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAPEAPEAVAABBTreeNode@2@PEAV32@@Z PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::access, COMDAT

; 12   : 	T**					access			(T* P)	{ return (T**) LPVOID(P);	}

	mov	rax, rcx
	ret	0
?access@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAPEAPEAVAABBTreeNode@2@PEAV32@@Z ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::access
_TEXT	ENDS
EXTRN	_fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
;	COMDAT ?LargestAxis@icePoint@IceMaths@@QEBA?AW4PointComponent@2@XZ
_TEXT	SEGMENT
this$ = 8
?LargestAxis@icePoint@IceMaths@@QEBA?AW4PointComponent@2@XZ PROC ; IceMaths::icePoint::LargestAxis, COMDAT

; 320  : 									const float* Vals = &x;
; 321  : 									PointComponent m = _X;
; 322  : 									if(Vals[_Y] > Vals[m]) m = _Y;

	movss	xmm0, DWORD PTR [rcx]
	xor	edx, edx
	comiss	xmm0, DWORD PTR [rcx+4]
	jae	SHORT $LN2@LargestAxi
	mov	edx, 1
$LN2@LargestAxi:

; 323  : 									if(Vals[_Z] > Vals[m]) m = _Z;

	movsxd	rax, edx
	movss	xmm0, DWORD PTR [rcx+rax*4]

; 324  : 									return m;

	mov	eax, 2
	comiss	xmm0, DWORD PTR [rcx+8]
	jb	SHORT $LN1@LargestAxi
	mov	eax, edx
$LN1@LargestAxi:

; 325  : 								}

	fatret	0
?LargestAxis@icePoint@IceMaths@@QEBA?AW4PointComponent@2@XZ ENDP ; IceMaths::icePoint::LargestAxis
_TEXT	ENDS
PUBLIC	__real@3f800000
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??_0icePoint@IceMaths@@QEAAAEAV01@M@Z
_TEXT	SEGMENT
this$ = 8
s$ = 16
??_0icePoint@IceMaths@@QEAAAEAV01@M@Z PROC		; IceMaths::icePoint::operator/=, COMDAT

; 420  : 		inline_	Point&			operator/=(float s)								{ s = 1.0f/s; x *= s; y *= s; z *= s; return *this; }

	movss	xmm2, DWORD PTR __real@3f800000
	mov	rax, rcx
	divss	xmm2, xmm1
	movaps	xmm0, xmm2
	movaps	xmm1, xmm2
	mulss	xmm2, DWORD PTR [rcx+8]
	mulss	xmm0, DWORD PTR [rcx]
	mulss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx+8], xmm2
	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
	ret	0
??_0icePoint@IceMaths@@QEAAAEAV01@M@Z ENDP		; IceMaths::icePoint::operator/=
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
_TEXT	ENDS
;	COMDAT ?IncreaseNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?IncreaseNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXXZ PROC ; Opcode::AABBTreeBuilder::IncreaseNbInvalidSplits, COMDAT

; 102  : 		inline_						void		IncreaseNbInvalidSplits()		{ mNbInvalidSplits++;		}

	inc	DWORD PTR [rcx+24]
	ret	0
?IncreaseNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXXZ ENDP ; Opcode::AABBTreeBuilder::IncreaseNbInvalidSplits
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AEBQEAVAABBTreeNode@Opcode@@@std@@YAAEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAVAABBTreeNode@Opcode@@@std@@YAAEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z PROC ; std::forward<Opcode::AABBTreeNode * __ptr64 const & __ptr64>, COMDAT

; 79   : 	return ((_Ty&&)_Arg);

	mov	rax, rcx

; 80   : 	}

	ret	0
??$forward@AEBQEAVAABBTreeNode@Opcode@@@std@@YAAEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ENDP ; std::forward<Opcode::AABBTreeNode * __ptr64 const & __ptr64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Orphan_range@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXPEAPEAVAABBTreeNode@Opcode@@0@Z
_TEXT	SEGMENT
?_Orphan_range@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXPEAPEAVAABBTreeNode@Opcode@@0@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Orphan_range, COMDAT

; 1454 : 		}

	ret	0
?_Orphan_range@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXPEAPEAVAABBTreeNode@Opcode@@0@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Orphan_range
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?max_size@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBA_KXZ
_TEXT	SEGMENT
?max_size@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBA_KXZ PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::max_size, COMDAT

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	ret	0
?max_size@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBA_KXZ ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::capacity, COMDAT

; 777  : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 778  : 		}

	ret	0
?capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::capacity
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
pdata	SEGMENT
$pdata$??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z DD imagerel $LN4
	DD	imagerel $LN4+43
	DD	imagerel $unwind$??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z PROC ; xr_free<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@xr_free@7
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx], 0
$LN1@xr_free@7:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; xr_free<Opcode::AABBTreeNode * __ptr64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PEAVAABBTreeNode@Opcode@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVAABBTreeNode@Opcode@@0@Z
_TEXT	SEGMENT
_Cat$ = 8
??$_Ptr_cat@PEAVAABBTreeNode@Opcode@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVAABBTreeNode@Opcode@@0@Z PROC ; std::_Ptr_cat<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 519  : 	}

	ret	0
??$_Ptr_cat@PEAVAABBTreeNode@Opcode@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVAABBTreeNode@Opcode@@0@Z ENDP ; std::_Ptr_cat<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT

; 105  : 	}

	ret	0
??$_Destroy_range@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<xalloc<Opcode::AABBTreeNode * __ptr64> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size, COMDAT

; 879  : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 880  : 		}

	ret	0
?size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z
_TEXT	SEGMENT
??$_Val_type@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z PROC ; std::_Val_type<Opcode::AABBTreeNode * __ptr64 * __ptr64>, COMDAT

; 790  : 	return (0);

	xor	eax, eax

; 791  : 	}

	ret	0
??$_Val_type@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z ENDP ; std::_Val_type<Opcode::AABBTreeNode * __ptr64 * __ptr64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@PEAVAABBTreeNode@Opcode@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
??$_Destroy@PEAVAABBTreeNode@Opcode@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@@Z PROC ; std::_Destroy<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

	ret	0
??$_Destroy@PEAVAABBTreeNode@Opcode@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; std::_Destroy<Opcode::AABBTreeNode * __ptr64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@PEAVAABBTreeNode@Opcode@@@std@@YA$$QEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVAABBTreeNode@Opcode@@@std@@YA$$QEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z PROC ; std::forward<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 79   : 	return ((_Ty&&)_Arg);

	mov	rax, rcx

; 80   : 	}

	ret	0
??$forward@PEAVAABBTreeNode@Opcode@@@std@@YA$$QEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z ENDP ; std::forward<Opcode::AABBTreeNode * __ptr64>
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_alloc@PEAVAABBTreeNode@Opcode@@@@YAPEAPEAVAABBTreeNode@Opcode@@I@Z
_TEXT	SEGMENT
count$ = 8
??$xr_alloc@PEAVAABBTreeNode@Opcode@@@@YAPEAPEAVAABBTreeNode@Opcode@@I@Z PROC ; xr_alloc<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ecx
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	rdx, 3
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
??$xr_alloc@PEAVAABBTreeNode@Opcode@@@@YAPEAPEAVAABBTreeNode@Opcode@@I@Z ENDP ; xr_alloc<Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
pdata	SEGMENT
$pdata$?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Xlen, COMDAT

; 1426 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1427 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Xlen
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$forward@AEAPEAVAABBTreeNode@Opcode@@@std@@YAAEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVAABBTreeNode@Opcode@@@std@@YAAEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z PROC ; std::forward<Opcode::AABBTreeNode * __ptr64 & __ptr64>, COMDAT

; 79   : 	return ((_Ty&&)_Arg);

	mov	rax, rcx

; 80   : 	}

	ret	0
??$forward@AEAPEAVAABBTreeNode@Opcode@@@std@@YAAEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z ENDP ; std::forward<Opcode::AABBTreeNode * __ptr64 & __ptr64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$addressof@QEAVAABBTreeNode@Opcode@@@std@@YAPEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@QEAVAABBTreeNode@Opcode@@@std@@YAPEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z PROC ; std::addressof<Opcode::AABBTreeNode * __ptr64 const>, COMDAT

; 111  : 	return ((_Ty *) &(char&)_Val);

	mov	rax, rcx

; 112  : 	}

	ret	0
??$addressof@QEAVAABBTreeNode@Opcode@@@std@@YAPEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ENDP ; std::addressof<Opcode::AABBTreeNode * __ptr64 const>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Inside@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_NPEBQEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_NPEBQEAVAABBTreeNode@Opcode@@@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Inside, COMDAT

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1287 : 		}

	ret	0
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	xor	al, al

; 1287 : 		}

	ret	0
?_Inside@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_NPEBQEAVAABBTreeNode@Opcode@@@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Inside
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
_TEXT	ENDS
;	COMDAT ??$xr_alloc@VAABBTreeNode@Opcode@@@@YAPEAVAABBTreeNode@Opcode@@I@Z
_TEXT	SEGMENT
??$xr_alloc@VAABBTreeNode@Opcode@@@@YAPEAVAABBTreeNode@Opcode@@I@Z PROC ; xr_alloc<Opcode::AABBTreeNode>, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 917504				; 000e0000H
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
??$xr_alloc@VAABBTreeNode@Opcode@@@@YAPEAVAABBTreeNode@Opcode@@I@Z ENDP ; xr_alloc<Opcode::AABBTreeNode>
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
_TEXT	ENDS
;	COMDAT ?IncreaseCount@AABBTreeBuilder@Opcode@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
?IncreaseCount@AABBTreeBuilder@Opcode@@QEAAXI@Z PROC	; Opcode::AABBTreeBuilder::IncreaseCount, COMDAT

; 99   : 		inline_						void		IncreaseCount(udword nb)		{ mCount+=nb;				}

	add	DWORD PTR [rcx+20], 2
	ret	0
?IncreaseCount@AABBTreeBuilder@Opcode@@QEAAXI@Z ENDP	; Opcode::AABBTreeBuilder::IncreaseCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SetCount@AABBTreeBuilder@Opcode@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
?SetCount@AABBTreeBuilder@Opcode@@QEAAXI@Z PROC		; Opcode::AABBTreeBuilder::SetCount, COMDAT

; 98   : 		inline_						void		SetCount(udword nb)				{ mCount=nb;				}

	mov	DWORD PTR [rcx+20], 1
	ret	0
?SetCount@AABBTreeBuilder@Opcode@@QEAAXI@Z ENDP		; Opcode::AABBTreeBuilder::SetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SetNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
?SetNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXI@Z PROC ; Opcode::AABBTreeBuilder::SetNbInvalidSplits, COMDAT

; 101  : 		inline_						void		SetNbInvalidSplits(udword nb)	{ mNbInvalidSplits=nb;		}

	mov	DWORD PTR [rcx+24], 0
	ret	0
?SetNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXI@Z ENDP ; Opcode::AABBTreeBuilder::SetNbInvalidSplits
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@AABBTreeBuilder@Opcode@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?GetCount@AABBTreeBuilder@Opcode@@QEBAIXZ PROC		; Opcode::AABBTreeBuilder::GetCount, COMDAT

; 100  : 		inline_						udword		GetCount()				const	{ return mCount;			}

	mov	eax, DWORD PTR [rcx+20]
	ret	0
?GetCount@AABBTreeBuilder@Opcode@@QEBAIXZ ENDP		; Opcode::AABBTreeBuilder::GetCount
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.h
_TEXT	ENDS
;	COMDAT ?GetNbNodes@AABBTree@Opcode@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?GetNbNodes@AABBTree@Opcode@@QEBAIXZ PROC		; Opcode::AABBTree::GetNbNodes, COMDAT

; 77   : 		inline_	udword				GetNbNodes()		const	{ return mTotalNbNodes;	}	//!< Catch the number of nodes

	mov	eax, DWORD PTR [rcx+64]
	ret	0
?GetNbNodes@AABBTree@Opcode@@QEBAIXZ ENDP		; Opcode::AABBTree::GetNbNodes
_TEXT	ENDS
PUBLIC	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
pdata	SEGMENT
$pdata$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD imagerel $LN10
	DD	imagerel $LN10+69
	DD	imagerel $unwind$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
$pdata$1$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD imagerel $LN10+69
	DD	imagerel $LN10+174
	DD	imagerel $chain$1$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
$pdata$2$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD imagerel $LN10+174
	DD	imagerel $LN10+201
	DD	imagerel $chain$2$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD 0a2201H
	DD	036822H
	DD	0f6413H
	DD	0e5413H
	DD	0e00f7213H
	DD	0700bd00dH
$chain$1$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD 040a21H
	DD	0dc40aH
	DD	0c3405H
	DD	imagerel $LN10
	DD	imagerel $LN10+69
	DD	imagerel $unwind$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
$chain$2$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+69
	DD	imagerel $unwind$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
xdata	ENDS
_TEXT	SEGMENT
this$ = 96
axis$ = 104
builder$ = 112
?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTreeNode::Split

; 89   : {

$LN10:
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r13
	push	r14
	sub	rsp, 64					; 00000040H

; 90   : 	// Get node split value
; 91   : 	float SplitValue = builder->GetSplittingValueEx(mNodePrimitives, mNbPrimitives, mBV, axis);

	mov	rax, QWORD PTR [r8]
	mov	r13, r8
	mov	r8d, DWORD PTR [rcx+48]
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	r14d, edx
	mov	DWORD PTR [rsp+32], edx
	mov	rdx, QWORD PTR [rcx+40]
	mov	rsi, rcx
	mov	r9, rcx
	mov	rcx, r13
	call	QWORD PTR [rax+24]

; 92   : 
; 93   : 	udword NbPos = 0;

	xor	ebp, ebp

; 94   : 	// Loop through all node-related primitives. Their indices range from mNodePrimitives[0] to mNodePrimitives[mNbPrimitives-1].
; 95   : 	// Those indices map the global list in the tree builder.
; 96   : 	for(udword i=0;i<mNbPrimitives;i++)

	mov	edi, ebp
	movaps	xmm6, xmm0
	cmp	DWORD PTR [rsi+48], ebp
	jbe	SHORT $LN9@Split

; 90   : 	// Get node split value
; 91   : 	float SplitValue = builder->GetSplittingValueEx(mNodePrimitives, mNbPrimitives, mBV, axis);

	mov	QWORD PTR [rsp+96], rbx
	mov	QWORD PTR [rsp+104], r12
	mov	r12d, ebp
	mov	ebx, ebp
	npad	12
$LL4@Split:

; 97   : 	{
; 98   : 		// Get index in global list
; 99   : 		udword Index = mNodePrimitives[i];

	mov	rax, QWORD PTR [rsi+40]

; 100  : 
; 101  : 		// Test against the splitting value. The primitive value is tested against the enclosing-box center.
; 102  : 		// [We only need an approximate partition of the enclosing box here.]
; 103  : 		float PrimitiveValue = builder->GetSplittingValue(Index, axis);

	mov	r9, QWORD PTR [r13]
	mov	r8d, r14d
	mov	edx, DWORD PTR [rbx+rax]
	mov	rcx, r13
	call	QWORD PTR [r9+16]

; 104  : 
; 105  : 		// Reorganize the list of indices in this order: positive - negative.
; 106  : 		if(PrimitiveValue > SplitValue)

	comiss	xmm0, xmm6
	jbe	SHORT $LN3@Split

; 107  : 		{
; 108  : 			// Swap entries
; 109  : 			udword Tmp = mNodePrimitives[i];

	mov	rdx, QWORD PTR [rsi+40]

; 110  : 			mNodePrimitives[i] = mNodePrimitives[NbPos];
; 111  : 			mNodePrimitives[NbPos] = Tmp;
; 112  : 			// Count primitives assigned to positive space
; 113  : 			NbPos++;

	inc	ebp
	add	r12, 4
	mov	ecx, DWORD PTR [r12+rdx-4]
	mov	r8d, DWORD PTR [rbx+rdx]
	mov	DWORD PTR [rbx+rdx], ecx
	mov	rcx, QWORD PTR [rsi+40]
	mov	DWORD PTR [r12+rcx-4], r8d
$LN3@Split:

; 94   : 	// Loop through all node-related primitives. Their indices range from mNodePrimitives[0] to mNodePrimitives[mNbPrimitives-1].
; 95   : 	// Those indices map the global list in the tree builder.
; 96   : 	for(udword i=0;i<mNbPrimitives;i++)

	inc	edi
	add	rbx, 4
	cmp	edi, DWORD PTR [rsi+48]
	jb	SHORT $LL4@Split
	mov	r12, QWORD PTR [rsp+104]
	mov	rbx, QWORD PTR [rsp+96]
$LN9@Split:

; 114  : 		}
; 115  : 	}
; 116  : 	return NbPos;
; 117  : }

	mov	rsi, QWORD PTR [rsp+120]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	mov	eax, ebp
	mov	rbp, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r14
	pop	r13
	pop	rdi
	ret	0
?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTreeNode::Split
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
;	COMDAT ??0AABB@Meshmerizer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AABB@Meshmerizer@@QEAA@XZ PROC			; Meshmerizer::AABB::AABB, COMDAT

; 36   : 		inline_						AABB()	{}

	mov	rax, rcx
	ret	0
??0AABB@Meshmerizer@@QEAA@XZ ENDP			; Meshmerizer::AABB::AABB
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1AABB@Meshmerizer@@QEAA@XZ
_TEXT	SEGMENT
??1AABB@Meshmerizer@@QEAA@XZ PROC			; Meshmerizer::AABB::~AABB, COMDAT

; 38   : 		inline_						~AABB()	{}

	ret	0
??1AABB@Meshmerizer@@QEAA@XZ ENDP			; Meshmerizer::AABB::~AABB
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Val$ = 16
??$_Construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z PROC ; std::_Construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>, COMDAT

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN3@Construct@2
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN3@Construct@2:

; 49   : 	}

	fatret	0
??$_Construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ENDP ; std::_Construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
?max_size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size, COMDAT

; 884  : 		return (this->_Alval.max_size());

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 885  : 		}

	ret	0
?max_size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
pdata	SEGMENT
$pdata$?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+30
	DD	imagerel $unwind$?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
xdata	ENDS
;	COMDAT ?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z
_TEXT	SEGMENT
p$ = 48
?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::deallocate, COMDAT

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

$LN6:
	sub	rsp, 40					; 00000028H
	test	rcx, rcx
	je	SHORT $LN3@deallocate@4
	mov	rdx, rcx
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN3@deallocate@4:
	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z PROC ; std::_Destroy_range<xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

	ret	0
??$_Destroy_range@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ENDP ; std::_Destroy_range<xalloc<Opcode::AABBTreeNode * __ptr64> >
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?destroy@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
?destroy@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::destroy, COMDAT

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy(p);			}

	ret	0
?destroy@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAPEAPEAVAABBTreeNode@Opcode@@_KPEBX@Z
_TEXT	SEGMENT
n$ = 8
?allocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAPEAPEAVAABBTreeNode@Opcode@@_KPEBX@Z PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::allocate, COMDAT

; 80   : 							pointer					allocate		(size_type n, const void* p=0) const	{	return xr_alloc<T>((u32)n);	}

	mov	edx, ecx
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	rdx, 3
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAPEAPEAVAABBTreeNode@Opcode@@_KPEBX@Z ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::allocate
_TEXT	ENDS
PUBLIC	??1AABBTreeNode@Opcode@@QEAA@XZ			; Opcode::AABBTreeNode::~AABBTreeNode
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
??1AABBTreeNode@Opcode@@QEAA@XZ PROC			; Opcode::AABBTreeNode::~AABBTreeNode

; 68   : }

	ret	0
??1AABBTreeNode@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTreeNode::~AABBTreeNode
_TEXT	ENDS
PUBLIC	??0AABBTreeNode@Opcode@@QEAA@XZ			; Opcode::AABBTreeNode::AABBTreeNode
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
this$ = 8
??0AABBTreeNode@Opcode@@QEAA@XZ PROC			; Opcode::AABBTreeNode::AABBTreeNode

; 58   : {

	xor	eax, eax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	DWORD PTR [rcx+48], eax

; 59   : }

	mov	rax, rcx
	ret	0
??0AABBTreeNode@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTreeNode::AABBTreeNode
; Function compile flags: /Ogtpy
;	COMDAT ??_GAABBTreeNode@Opcode@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 8
??_GAABBTreeNode@Opcode@@QEAAPEAXI@Z PROC		; Opcode::AABBTreeNode::`scalar deleting destructor', COMDAT
	mov	rax, rcx
	ret	0
??_GAABBTreeNode@Opcode@@QEAAPEAXI@Z ENDP		; Opcode::AABBTreeNode::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
_TEXT	ENDS
;	COMDAT ?construct@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z
_TEXT	SEGMENT
p$ = 8
_Val$ = 16
?construct@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::construct, COMDAT

; 84   : 							void					construct		(pointer p, const T& _Val)				{	std::_Construct(p, _Val);	}

	test	rcx, rcx
	je	SHORT $LN5@construct@5
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN5@construct@5:
	fatret	0
?construct@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Grow_to@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_K_K@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Grow_to, COMDAT

; 1275 : 		size_type _Capacity = capacity();

	mov	r8, QWORD PTR [rcx+16]

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	sub	r8, QWORD PTR [rcx]
	sar	r8, 3
	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to@5
	xor	r8d, r8d

; 1279 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

	mov	rax, r8

; 1282 : 		}

	ret	0
$LN4@Grow_to@5:

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1279 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

	mov	rax, r8

; 1282 : 		}

	ret	0
?_Grow_to@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Grow_to
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXPEAPEAVAABBTreeNode@Opcode@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXPEAPEAVAABBTreeNode@Opcode@@0@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Destroy, COMDAT

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

	ret	0
?_Destroy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXPEAPEAVAABBTreeNode@Opcode@@0@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Dest_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
??$_Dest_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z PROC ; std::_Dest_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

	ret	0
??$_Dest_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; std::_Dest_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@PEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV23@@Z
_TEXT	SEGMENT
_Pdest$ = 8
_Src$ = 16
??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@PEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV23@@Z PROC ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	rcx, rcx
	je	SHORT $LN9@Cons_val@10
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN9@Cons_val@10:

; 281  : 	}

	fatret	0
??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@PEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV23@@Z ENDP ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEAPEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV23@@Z
_TEXT	SEGMENT
_Pdest$ = 8
_Src$ = 16
??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEAPEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV23@@Z PROC ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>, COMDAT

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	rcx, rcx
	je	SHORT $LN9@Cons_val@11
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN9@Cons_val@11:

; 281  : 	}

	fatret	0
??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEAPEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV23@@Z ENDP ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>
_TEXT	ENDS
PUBLIC	??1AABBTree@Opcode@@QEAA@XZ			; Opcode::AABBTree::~AABBTree
pdata	SEGMENT
$pdata$??1AABBTree@Opcode@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+45
	DD	imagerel $unwind$??1AABBTree@Opcode@@QEAA@XZ
pdata	ENDS
xdata	SEGMENT
$unwind$??1AABBTree@Opcode@@QEAA@XZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
??1AABBTree@Opcode@@QEAA@XZ PROC			; Opcode::AABBTree::~AABBTree

; 325  : {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 326  : 	xr_free(mIndices);

	mov	rdx, QWORD PTR [rcx+56]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN3@AABBTree
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+56], 0
$LN3@AABBTree:

; 327  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1AABBTree@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTree::~AABBTree
_TEXT	ENDS
PUBLIC	??0AABBTree@Opcode@@QEAA@XZ			; Opcode::AABBTree::AABBTree
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
this$ = 8
??0AABBTree@Opcode@@QEAA@XZ PROC			; Opcode::AABBTree::AABBTree

; 316  : {

	xor	eax, eax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	DWORD PTR [rcx+48], eax
	mov	QWORD PTR [rcx+56], rax
	mov	DWORD PTR [rcx+64], eax

; 317  : }

	mov	rax, rcx
	ret	0
??0AABBTree@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTree::AABBTree
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
;	COMDAT ?destroy@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z
_TEXT	SEGMENT
this$ = 8
P$ = 16
?destroy@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::destroy, COMDAT

; 48   : 		P->~T			();
; 49   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax

; 50   : 		list			= P;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 51   : 		P				= NULL;

	mov	QWORD PTR [rdx], 0

; 52   : 	}

	ret	0
?destroy@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEBQEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z
_TEXT	SEGMENT
_Pdest$ = 8
_Src$ = 16
??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEBQEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z PROC ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>, COMDAT

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

	test	rcx, rcx
	je	SHORT $LN9@Cons_val@15
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN9@Cons_val@15:

; 281  : 	}

	fatret	0
??$_Cons_val@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEBQEAV23@@std@@YAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z ENDP ; std::_Cons_val<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN32
	DD	imagerel $LN32+60
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z+52
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
xdata	ENDS
;	COMDAT ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T141288 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN32:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T141288[rsp], -2
	npad	3
$LL6@Uninit_mov@5:

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov@5

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

	mov	rax, QWORD PTR [rcx]
	test	r8, r8
	je	SHORT $LN22@Uninit_mov@5
	mov	QWORD PTR [r8], rax
$LN22@Uninit_mov@5:

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 8
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 8
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov@5
$LN4@Uninit_mov@5:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

	mov	rax, r8

; 438  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN31@Uninit_mov@5:
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T141288 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>'::`1'::catch$0

; 432  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>'::`1'::catch$0
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?node_destroy@AABBTreeBuilder@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?node_destroy@AABBTreeBuilder@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z PROC ; Opcode::AABBTreeBuilder::node_destroy, COMDAT

; 111  : 		inline_						void		node_destroy(AABBTreeNode* &n)	{return mPOOL.destroy(n);	}

	mov	rax, QWORD PTR [rcx+32]
	mov	r8, QWORD PTR [rdx]
	mov	QWORD PTR [r8], rax
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rdx], 0
	ret	0
?node_destroy@AABBTreeBuilder@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z ENDP ; Opcode::AABBTreeBuilder::node_destroy
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 446  : 	{	// move [_First, _Last) to raw _Dest, using _Al, scalar type

$LN3:
	sub	rsp, 40					; 00000028H

; 447  : 	return (_Uninit_move(_First, _Last, _Dest,
; 448  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>

; 449  : 	}

	add	rsp, 40					; 00000028H
	ret	0
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
PUBLIC	?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::destroy
pdata	SEGMENT
$pdata$?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z DD imagerel $LN34
	DD	imagerel $LN34+123
	DD	imagerel $unwind$?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
_tree$ = 56
?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTreeNode::destroy

; 71   : {

$LN34:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 72   : 	if (mP)	{ mP->destroy		(_tree); _tree->node_destroy	(mP); }

	mov	rcx, QWORD PTR [rcx+24]
	xor	esi, esi
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN7@destroy
	call	?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::destroy
	mov	rax, QWORD PTR [rdi+32]
	mov	r8, QWORD PTR [rbx+24]
	mov	QWORD PTR [r8], rax
	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rdi+32], rax
	mov	QWORD PTR [rbx+24], rsi
$LN7@destroy:

; 73   : 	if (mN)	{ mN->destroy		(_tree); _tree->node_destroy	(mN); }

	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN33@destroy
	mov	rdx, rdi
	call	?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::destroy
	mov	rax, QWORD PTR [rdi+32]
	mov	rcx, QWORD PTR [rbx+32]
	mov	QWORD PTR [rcx], rax
	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi+32], rax
	mov	QWORD PTR [rbx+32], rsi
$LN33@destroy:

; 74   : 	mNodePrimitives				= null;	// This was just a shortcut to the global list => no release
; 75   : 	mNbPrimitives				= 0;

	mov	DWORD PTR [rbx+48], esi
	mov	QWORD PTR [rbx+40], rsi

; 76   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTreeNode::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z PROC ; std::_Uninitialized_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 472  : 	}

	jmp	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ENDP ; std::_Uninitialized_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Ptr$ = 24
??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Umove<Opcode::AABBTreeNode * __ptr64 * __ptr64>, COMDAT

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));
; 1326 : 		}

	jmp	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Umove<Opcode::AABBTreeNode * __ptr64 * __ptr64>
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
pdata	SEGMENT
$pdata$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z DD imagerel $LN50
	DD	imagerel $LN50+197
	DD	imagerel $unwind$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA DD imagerel ?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA+45
	DD	imagerel $unwind$?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z DD imagerel ?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z+108
	DD	00H
	DD	imagerel ?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z+124
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z DD 081e19H
	DD	0b741eH
	DD	0a6419H
	DD	083414H
	DD	0c0025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata	ENDS
;	COMDAT ?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
$T176989 = 32
this$ = 64
_Ptr$92339 = 72
_Count$ = 72
?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::reserve, COMDAT

; 746  : 		{	// determine new minimum length of allocated storage

$LN50:
	push	r12
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T176989[rsp], -2
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	rdi, rdx
	mov	rbx, rcx

; 747  : 		if (max_size() < _Count)

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	cmp	rdx, rax
	jbe	SHORT $LN5@reserve@5

; 748  : 			_Xlen();	// result too long

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN5@reserve@5:

; 749  : 		else if (capacity() < _Count)

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3
	cmp	rax, rdx
	jae	SHORT $LN3@reserve@5

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	mov	edx, edx
	shl	rdx, 3
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	r12, rax
	mov	QWORD PTR _Ptr$92339[rsp], rax

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

	mov	r8, rax
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
	npad	1

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);
; 757  : 			_RERAISE;
; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

	mov	rdx, QWORD PTR [rbx]
	mov	rsi, QWORD PTR [rbx+8]
	sub	rsi, rdx
	sar	rsi, 3

; 761  : 			if (this->_Myfirst != 0)

	test	rdx, rdx
	je	SHORT $LN44@reserve@5

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN44@reserve@5:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

	lea	rax, QWORD PTR [r12+rdi*8]
	mov	QWORD PTR [rbx+16], rax

; 770  : 			this->_Mylast = _Ptr + _Size;

	lea	rax, QWORD PTR [r12+rsi*8]
	mov	QWORD PTR [rbx+8], rax

; 771  : 			this->_Myfirst = _Ptr;

	mov	QWORD PTR [rbx], r12
$LN3@reserve@5:

; 772  : 			}
; 773  : 		}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r12
	ret	0
$LN49@reserve@5:
?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::reserve
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T176989 = 32
this$ = 64
_Ptr$92339 = 72
_Count$ = 72
?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA PROC ; `std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::reserve'::`1'::catch$0

; 755  : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z$0:

; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	rdx, QWORD PTR _Ptr$92339[rbp]
	test	rdx, rdx
	je	SHORT $LN37@catch$0@9
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN37@catch$0@9:

; 757  : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z@4HA ENDP ; `std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::reserve'::`1'::catch$0
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
pdata	SEGMENT
$pdata$?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD imagerel $LN30
	DD	imagerel $LN30+137
	DD	imagerel $unwind$?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata	ENDS
;	COMDAT ?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve, COMDAT

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

$LN30:
	sub	rsp, 40					; 00000028H

; 1291 : 		size_type _Size = size();

	mov	rax, QWORD PTR [rcx]
	mov	r8, QWORD PTR [rcx+8]
	mov	r9, rcx
	sub	r8, rax

; 1292 : 		if (max_size() - _Count < _Size)

	mov	rcx, 2305843009213693950		; 1ffffffffffffffeH
	sar	r8, 3
	cmp	r8, rcx
	jbe	SHORT $LN4@Reserve@5

; 1293 : 			_Xlen();

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN4@Reserve@5:

; 1294 : 		else if ((_Size += _Count) <= capacity())

	mov	rdx, QWORD PTR [r9+16]
	inc	r8
	sub	rdx, rax
	sar	rdx, 3
	cmp	r8, rdx
	jbe	SHORT $LN1@Reserve@5

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

	mov	rcx, rdx
	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, rdx
	jae	SHORT $LN21@Reserve@5
	xor	edx, edx
	mov	rcx, r9
	cmp	rdx, r8
	cmovb	rdx, r8

; 1298 : 		}

	add	rsp, 40					; 00000028H
	jmp	?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

$LN21@Reserve@5:
	add	rdx, rcx
	mov	rcx, r9
	cmp	rdx, r8
	cmovb	rdx, r8
	call	?reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::reserve
$LN1@Reserve@5:

; 1298 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN29@Reserve@5:
?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
pdata	SEGMENT
$pdata$?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z DD imagerel $LN48
	DD	imagerel $LN48+134
	DD	imagerel $unwind$?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata	ENDS
;	COMDAT ?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::push_back, COMDAT

; 976  : 		{	// insert element at end

$LN48:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 977  : 		if (_Inside(_STD addressof(_Val)))

	mov	rax, QWORD PTR [rcx+8]
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	rdx, rax
	jae	SHORT $LN4@push_back@5
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN4@push_back@5

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	sub	rdi, rcx
	sar	rdi, 3

; 980  : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN3@push_back@5

; 981  : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve
$LN3@push_back@5:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN41@push_back@5
	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax+rdi*8]
	mov	QWORD PTR [rdx], rcx

; 996  : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 8

; 997  : 			}
; 998  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@push_back@5:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN1@push_back@5

; 991  : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve
$LN1@push_back@5:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN41@push_back@5
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx], rax
$LN41@push_back@5:

; 996  : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 8

; 997  : 			}
; 998  : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::push_back
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
pdata	SEGMENT
$pdata$?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ DD imagerel $LN18
	DD	imagerel $LN18+125
	DD	imagerel $unwind$?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create, COMDAT

; 14   : 	{

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 15   : 		// Allocate
; 16   : 		VERIFY				(0==list);
; 17   : 		list				= xr_alloc<T>	(granularity);

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 917504				; 000e0000H
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 18   : 		blocks.push_back	(list);

	lea	rcx, QWORD PTR [rbx+8]
	mov	rdx, rbx
	mov	QWORD PTR [rbx], rax
	call	?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::push_back
	xor	edx, edx
	npad	4
$LL3@block_crea:

; 19   : 
; 20   : 		// Partition
; 21   : 		for (int it=0; it<(granularity-1); it++)
; 22   : 		{
; 23   : 			T*		E			= list+it;

	mov	rcx, QWORD PTR [rbx]

; 24   : 			*access(E)			= E+1;

	lea	rax, QWORD PTR [rdx+rcx+56]
	mov	QWORD PTR [rdx+rcx], rax
	mov	rcx, QWORD PTR [rbx]
	lea	rax, QWORD PTR [rdx+rcx+112]
	mov	QWORD PTR [rdx+rcx+56], rax
	mov	rcx, QWORD PTR [rbx]
	lea	rax, QWORD PTR [rdx+rcx+168]
	add	rdx, 168				; 000000a8H
	mov	QWORD PTR [rdx+rcx-56], rax
	cmp	rdx, 917448				; 000dffc8H
	jl	SHORT $LL3@block_crea

; 25   : 		}
; 26   : 		*access(list+granularity-1)	= NULL;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+917448], 0

; 27   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
pdata	SEGMENT
$pdata$?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ DD imagerel $LN12
	DD	imagerel $LN12+61
	DD	imagerel $unwind$?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
xdata	ENDS
;	COMDAT ?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ
_TEXT	SEGMENT
this$ = 48
?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::create, COMDAT

; 39   : 	{

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 40   : 		if (0==list)	block_create();

	cmp	QWORD PTR [rcx], 0
	mov	rbx, rcx
	jne	SHORT $LN1@create
	call	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
$LN1@create:

; 41   : 
; 42   : 		T* E			= list;

	mov	r8, QWORD PTR [rbx]

; 43   : 		list			= *access(list);
; 44   : 		return			new (E) T();

	xor	eax, eax
	mov	rdx, QWORD PTR [r8]
	mov	QWORD PTR [rbx], rdx
	test	r8, r8
	je	SHORT $LN5@create
	mov	QWORD PTR [r8+24], rax
	mov	QWORD PTR [r8+32], rax
	mov	QWORD PTR [r8+40], rax
	mov	DWORD PTR [r8+48], eax
	mov	rax, r8
$LN5@create:

; 45   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::create
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
pdata	SEGMENT
$pdata$?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ DD imagerel $LN14
	DD	imagerel $LN14+65
	DD	imagerel $unwind$?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
xdata	ENDS
;	COMDAT ?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ
_TEXT	SEGMENT
this$ = 48
?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ PROC ; Opcode::AABBTreeBuilder::node_alloc, COMDAT

; 110  : 		inline_					AABBTreeNode*	node_alloc	()					{return mPOOL.create();		}

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	cmp	QWORD PTR [rcx+32], 0
	lea	rbx, QWORD PTR [rcx+32]
	jne	SHORT $LN3@node_alloc
	mov	rcx, rbx
	call	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
$LN3@node_alloc:
	mov	rdx, QWORD PTR [rbx]
	xor	eax, eax
	mov	rcx, QWORD PTR [rdx]
	mov	QWORD PTR [rbx], rcx
	test	rdx, rdx
	je	SHORT $LN7@node_alloc
	mov	QWORD PTR [rdx+24], rax
	mov	QWORD PTR [rdx+32], rax
	mov	QWORD PTR [rdx+40], rax
	mov	DWORD PTR [rdx+48], eax
	mov	rax, rdx
$LN7@node_alloc:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ ENDP ; Opcode::AABBTreeBuilder::node_alloc
_TEXT	ENDS
PUBLIC	__real@bf000000
PUBLIC	?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Subdivide
pdata	SEGMENT
$pdata$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN177
	DD	imagerel $LN177+73
	DD	imagerel $unwind$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN177+73
	DD	imagerel $LN177+292
	DD	imagerel $chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$13$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN177+292
	DD	imagerel $LN177+759
	DD	imagerel $chain$13$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$14$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN177+759
	DD	imagerel $LN177+778
	DD	imagerel $chain$14$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$15$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN177+778
	DD	imagerel $LN177+1582
	DD	imagerel $chain$15$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$16$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN177+1582
	DD	imagerel $LN177+1602
	DD	imagerel $chain$16$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 073201H
	DD	0203432H
	DD	01c0111H
	DD	07003c005H
	DD	05002H
$chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 0a2b21H
	DD	0b782bH
	DD	0c6823H
	DD	01be418H
	DD	022d410H
	DD	0216408H
	DD	imagerel $LN177
	DD	imagerel $LN177+73
	DD	imagerel $unwind$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$13$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 0104f21H
	DD	04e84fH
	DD	05d845H
	DD	06c83fH
	DD	07b82dH
	DD	08a827H
	DD	09981eH
	DD	0a8811H
	DD	01af408H
	DD	imagerel $LN177+73
	DD	imagerel $LN177+292
	DD	imagerel $chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$14$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 020021H
	DD	05d800H
	DD	imagerel $LN177+73
	DD	imagerel $LN177+292
	DD	imagerel $chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$15$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 021H
	DD	imagerel $LN177+73
	DD	imagerel $LN177+292
	DD	imagerel $chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$16$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 021H
	DD	imagerel $LN177
	DD	imagerel $LN177+73
	DD	imagerel $unwind$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
xdata	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
CONST	ENDS
_TEXT	SEGMENT
$T177547 = 32
SortedAxis$93994 = 32
Extents$93960 = 32
$T177462 = 48
Extents$93993 = 48
Results$93985 = 48
Vars$93972 = 48
this$ = 256
builder$ = 264
?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTreeNode::Subdivide

; 140  : {

$LN177:
	push	rbp
	push	rdi
	push	r12
	lea	rbp, QWORD PTR [rsp-71]
	sub	rsp, 224				; 000000e0H
	mov	r12, rdx
	mov	rdi, rcx

; 141  : 	// Checkings
; 142  : 	if(!builder)	return false;

	test	rdx, rdx
	jne	SHORT $LN44@Subdivide
	xor	al, al

; 287  : }

	add	rsp, 224				; 000000e0H
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN44@Subdivide:
	mov	QWORD PTR [rsp+256], rbx

; 143  : 
; 144  : 	// Stop subdividing if we reach a leaf node
; 145  : 	if(mNbPrimitives==1)	return true;

	mov	ebx, DWORD PTR [rcx+48]
	cmp	ebx, 1
	je	SHORT $LN176@Subdivide

; 146  : 
; 147  : 	// Check the user-defined limit
; 148  : 	if(mNbPrimitives<=builder->mLimit)	return true;

	cmp	ebx, DWORD PTR [rdx+8]
	ja	SHORT $LN42@Subdivide
$LN176@Subdivide:
	mov	al, 1
	jmp	$LN168@Subdivide
$LN42@Subdivide:

; 149  : 
; 150  : 	bool ValidSplit = true;	// Optimism...
; 151  : 	udword NbPos	= 0;
; 152  : 	if(builder->mRules&SPLIT_LARGESTAXIS)

	mov	eax, DWORD PTR [rdx+12]
	mov	QWORD PTR [rsp+264], rsi
	mov	QWORD PTR [rsp+272], r13
	mov	QWORD PTR [rsp+216], r14
	xor	r14d, r14d
	movaps	XMMWORD PTR [rsp+192], xmm6
	movaps	XMMWORD PTR [rsp+176], xmm7
	test	al, 2
	je	$LN41@Subdivide

; 153  : 	{
; 154  : 		// Find the largest axis to split along
; 155  : 		Point Extents;	mBV.GetExtents(Extents);	// Box extents

	movss	xmm0, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm1, DWORD PTR [rcx+16]

; 156  : 		udword Axis	= Extents.LargestAxis();		// Index of largest axis

	mov	esi, r14d
	subss	xmm2, DWORD PTR [rcx]
	subss	xmm1, DWORD PTR [rcx+4]
	movss	xmm3, DWORD PTR [rcx+20]
	mulss	xmm2, xmm0
	mulss	xmm1, xmm0
	comiss	xmm1, xmm2
	subss	xmm3, DWORD PTR [rcx+8]
	movss	DWORD PTR $T177462[rbp-153], xmm2
	mov	eax, DWORD PTR $T177462[rbp-153]
	mov	DWORD PTR Extents$93960[rbp-153], eax
	mulss	xmm3, xmm0
	movss	DWORD PTR $T177462[rbp-149], xmm1
	movss	DWORD PTR $T177462[rbp-145], xmm3
	mov	eax, DWORD PTR $T177462[rbp-149]
	mov	DWORD PTR Extents$93960[rbp-149], eax
	mov	eax, DWORD PTR $T177462[rbp-145]
	mov	DWORD PTR Extents$93960[rbp-145], eax
	jbe	SHORT $LN62@Subdivide
	mov	esi, 1
$LN62@Subdivide:
	movsxd	rax, esi
	comiss	xmm3, DWORD PTR Extents$93960[rbp+rax*4-153]
	jbe	SHORT $LN61@Subdivide
	mov	esi, 2
$LN61@Subdivide:

; 157  : 
; 158  : 		// Split along the axis
; 159  : 		NbPos = Split(Axis, builder);

	mov	r8, rdx
	mov	edx, esi
$LN174@Subdivide:
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
	mov	ebx, eax

; 160  : 
; 161  : 		// Check split validity
; 162  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;

	test	eax, eax
	je	SHORT $LN165@Subdivide
	cmp	eax, DWORD PTR [rdi+48]
	jne	$LN3@Subdivide
$LN165@Subdivide:

; 258  : 
; 259  : 	// Check the subdivision has been successful
; 260  : 	if(!ValidSplit)
; 261  : 	{
; 262  : 		// Here, all boxes lie in the same sub-space. Two strategies:
; 263  : 		// - if the tree *must* be complete, make an arbitrary 50-50 split
; 264  : 		// - else stop subdividing
; 265  : 		if(builder->mRules&SPLIT_COMPLETE)

	test	BYTE PTR [r12+12], 1
	je	$LN4@Subdivide

; 266  : 		{
; 267  : 			builder->IncreaseNbInvalidSplits();

	inc	DWORD PTR [r12+24]

; 268  : 			NbPos = mNbPrimitives>>1;

	mov	ebx, DWORD PTR [rdi+48]
	jmp	$LN175@Subdivide
$LN41@Subdivide:

; 163  : 	}
; 164  : 	else if(builder->mRules&SPLIT_SPLATTERPOINTS)

	test	al, 4
	je	$LN37@Subdivide

; 165  : 	{
; 166  : 		// Compute the means
; 167  : 		Point Means(0.0f, 0.0f, 0.0f);

	mov	QWORD PTR [rsp+208], r15
	movaps	XMMWORD PTR [rsp+160], xmm8
	xorps	xmm8, xmm8
	movaps	XMMWORD PTR [rsp+144], xmm9
	movaps	XMMWORD PTR [rsp+128], xmm10
	movaps	XMMWORD PTR [rsp+112], xmm11

; 168  : 		for(udword i=0;i<mNbPrimitives;i++)

	mov	esi, 1
	mov	r15d, r14d
	lea	r13d, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rsp+96], xmm12
	movaps	XMMWORD PTR [rsp+80], xmm13
	movaps	xmm9, xmm8
	movaps	XMMWORD PTR [rsp+64], xmm14
	movaps	xmm10, xmm8
	movaps	xmm11, xmm8
	test	ebx, ebx
	je	SHORT $LN34@Subdivide
	npad	1
$LL36@Subdivide:

; 169  : 		{
; 170  : 			udword Index = mNodePrimitives[i];

	mov	rax, QWORD PTR [rdi+40]

; 171  : 			Means.x+=builder->GetSplittingValue(Index, 0);

	xor	r8d, r8d
	mov	rcx, r12
	mov	ebx, DWORD PTR [r14+rax]
	mov	rax, QWORD PTR [r12]
	mov	edx, ebx
	call	QWORD PTR [rax+16]

; 172  : 			Means.y+=builder->GetSplittingValue(Index, 1);

	mov	rax, QWORD PTR [r12]
	mov	r8d, esi
	mov	edx, ebx
	mov	rcx, r12
	addss	xmm9, xmm0
	call	QWORD PTR [rax+16]

; 173  : 			Means.z+=builder->GetSplittingValue(Index, 2);

	mov	rax, QWORD PTR [r12]
	mov	r8d, r13d
	mov	edx, ebx
	mov	rcx, r12
	addss	xmm10, xmm0
	call	QWORD PTR [rax+16]
	inc	r15d
	add	r14, 4
	addss	xmm11, xmm0
	cmp	r15d, DWORD PTR [rdi+48]
	jb	SHORT $LL36@Subdivide
	xor	r14d, r14d
$LN34@Subdivide:

; 174  : 		}
; 175  : 		Means/=float(mNbPrimitives);

	mov	eax, DWORD PTR [rdi+48]
	movss	xmm12, DWORD PTR __real@3f800000
	pxor	xmm0, xmm0

; 176  : 
; 177  : 		// Compute variances
; 178  : 		Point Vars(0.0f, 0.0f, 0.0f);

	movaps	xmm14, xmm8
	movaps	xmm13, xmm8

; 179  : 		for(i=0;i<mNbPrimitives;i++)

	mov	r15d, r14d
	cvtsi2ss xmm0, rax
	movaps	xmm1, xmm12
	divss	xmm1, xmm0
	mulss	xmm9, xmm1
	mulss	xmm10, xmm1
	mulss	xmm11, xmm1
	test	eax, eax
	je	SHORT $LN31@Subdivide
	npad	1
$LL33@Subdivide:

; 180  : 		{
; 181  : 			udword Index = mNodePrimitives[i];

	mov	rax, QWORD PTR [rdi+40]

; 182  : 			float Cx = builder->GetSplittingValue(Index, 0);

	xor	r8d, r8d
	mov	rcx, r12
	mov	ebx, DWORD PTR [r14+rax]
	mov	rax, QWORD PTR [r12]
	mov	edx, ebx
	call	QWORD PTR [rax+16]

; 183  : 			float Cy = builder->GetSplittingValue(Index, 1);

	mov	rax, QWORD PTR [r12]
	mov	r8d, esi
	mov	edx, ebx
	mov	rcx, r12
	movaps	xmm6, xmm0
	call	QWORD PTR [rax+16]

; 184  : 			float Cz = builder->GetSplittingValue(Index, 2);

	mov	rax, QWORD PTR [r12]
	mov	r8d, r13d
	mov	edx, ebx
	mov	rcx, r12
	movaps	xmm7, xmm0
	call	QWORD PTR [rax+16]
	inc	r15d
	add	r14, 4

; 185  : 			Vars.x += (Cx - Means.x)*(Cx - Means.x);

	subss	xmm6, xmm9

; 186  : 			Vars.y += (Cy - Means.y)*(Cy - Means.y);

	subss	xmm7, xmm10
	mulss	xmm6, xmm6
	mulss	xmm7, xmm7

; 187  : 			Vars.z += (Cz - Means.z)*(Cz - Means.z);

	subss	xmm0, xmm11
	addss	xmm8, xmm6
	addss	xmm14, xmm7
	mulss	xmm0, xmm0
	addss	xmm13, xmm0
	cmp	r15d, DWORD PTR [rdi+48]
	jb	SHORT $LL33@Subdivide
	xor	r14d, r14d
$LN31@Subdivide:

; 188  : 		}
; 189  : 		Vars/=float(mNbPrimitives-1);

	mov	eax, DWORD PTR [rdi+48]
	movaps	xmm11, XMMWORD PTR [rsp+112]
	movaps	xmm10, XMMWORD PTR [rsp+128]
	mov	r15, QWORD PTR [rsp+208]
	dec	eax
	pxor	xmm0, xmm0

; 190  : 
; 191  : 		// Choose axis with greatest variance
; 192  : 		udword Axis = Vars.LargestAxis();

	mov	edx, r14d
	movaps	xmm9, XMMWORD PTR [rsp+144]
	cvtsi2ss xmm0, rax
	divss	xmm12, xmm0
	mulss	xmm8, xmm12
	mulss	xmm14, xmm12
	mulss	xmm13, xmm12
	movaps	xmm12, XMMWORD PTR [rsp+96]
	comiss	xmm14, xmm8
	movss	DWORD PTR Vars$93972[rbp-153], xmm8
	movaps	xmm8, XMMWORD PTR [rsp+160]
	movss	DWORD PTR Vars$93972[rbp-149], xmm14
	movss	DWORD PTR Vars$93972[rbp-145], xmm13
	movaps	xmm14, XMMWORD PTR [rsp+64]
	jbe	SHORT $LN76@Subdivide
	mov	edx, esi
$LN76@Subdivide:
	movsxd	rax, edx
	comiss	xmm13, DWORD PTR Vars$93972[rbp+rax*4-153]
	movaps	xmm13, XMMWORD PTR [rsp+80]
	jbe	SHORT $LN75@Subdivide
	mov	edx, r13d
$LN75@Subdivide:

; 193  : 
; 194  : 		// Split along the axis
; 195  : 		NbPos = Split(Axis, builder);

	mov	r8, r12
	mov	rcx, rdi

; 196  : 
; 197  : 		// Check split validity
; 198  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 199  : 	}

	jmp	$LN174@Subdivide
$LN37@Subdivide:

; 200  : 	else if(builder->mRules&SPLIT_BALANCED)

	test	al, 16
	je	$LN27@Subdivide

; 201  : 	{
; 202  : 		// Test 3 axis, take the best
; 203  : 		float Results[3];
; 204  : 		NbPos = Split(0, builder);	Results[0] = float(NbPos)/float(mNbPrimitives);

	mov	r8, rdx
	xor	edx, edx
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split

; 205  : 		NbPos = Split(1, builder);	Results[1] = float(NbPos)/float(mNbPrimitives);

	mov	esi, 1
	mov	r8, r12
	mov	ecx, eax
	mov	eax, DWORD PTR [rdi+48]
	pxor	xmm7, xmm7
	pxor	xmm0, xmm0
	mov	edx, esi
	cvtsi2ss xmm7, rcx
	mov	rcx, rdi
	cvtsi2ss xmm0, rax
	divss	xmm7, xmm0
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
	pxor	xmm6, xmm6
	mov	ecx, eax
	mov	eax, DWORD PTR [rdi+48]

; 206  : 		NbPos = Split(2, builder);	Results[2] = float(NbPos)/float(mNbPrimitives);

	mov	r13d, 2
	pxor	xmm0, xmm0
	mov	r8, r12
	mov	edx, r13d
	cvtsi2ss xmm6, rcx
	mov	rcx, rdi
	cvtsi2ss xmm0, rax
	divss	xmm6, xmm0
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split

; 207  : 		Results[0]-=0.5f;	Results[0]*=Results[0];

	movss	xmm1, DWORD PTR __real@bf000000
	mov	ecx, eax
	mov	eax, DWORD PTR [rdi+48]
	addss	xmm7, xmm1

; 208  : 		Results[1]-=0.5f;	Results[1]*=Results[1];
; 209  : 		Results[2]-=0.5f;	Results[2]*=Results[2];
; 210  : 		udword Min=0;

	mov	edx, r14d
	pxor	xmm2, xmm2
	pxor	xmm0, xmm0
	addss	xmm6, xmm1
	mulss	xmm7, xmm7
	mulss	xmm6, xmm6
	cvtsi2ss xmm2, rcx
	cvtsi2ss xmm0, rax
	divss	xmm2, xmm0

; 211  : 		if(Results[1]<Results[Min])	Min = 1;

	comiss	xmm6, xmm7
	movss	DWORD PTR Results$93985[rbp-153], xmm7
	movss	DWORD PTR Results$93985[rbp-149], xmm6
	addss	xmm2, xmm1
	mulss	xmm2, xmm2
	movss	DWORD PTR Results$93985[rbp-145], xmm2
	jae	SHORT $LN26@Subdivide
	mov	edx, esi
$LN26@Subdivide:

; 212  : 		if(Results[2]<Results[Min])	Min = 2;

	mov	eax, edx
	comiss	xmm2, DWORD PTR Results$93985[rbp+rax*4-153]
	jae	$LN75@Subdivide
	mov	edx, r13d

; 213  : 		
; 214  : 		// Split along the axis
; 215  : 		NbPos = Split(Min, builder);

	mov	r8, r12
	mov	rcx, rdi

; 216  : 
; 217  : 		// Check split validity
; 218  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 219  : 	}

	jmp	$LN174@Subdivide
$LN27@Subdivide:

; 220  : 	else if(builder->mRules&SPLIT_BESTAXIS)

	test	al, 8
	je	$LN21@Subdivide

; 221  : 	{
; 222  : 		// Test largest, then middle, then smallest axis...
; 223  : 
; 224  : 		// Sort axis
; 225  : 		Point Extents;	mBV.GetExtents(Extents);	// Box extents

	movss	xmm0, DWORD PTR __real@3f000000
	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm1, DWORD PTR [rcx+16]

; 226  : 		udword SortedAxis[] = { 0, 1, 2 };

	mov	edx, r14d
	mov	esi, 1
	mov	r13d, 2
	subss	xmm2, DWORD PTR [rcx]
	subss	xmm1, DWORD PTR [rcx+4]
	movss	xmm3, DWORD PTR [rcx+20]
	mulss	xmm2, xmm0
	mulss	xmm1, xmm0

; 227  : 		float* Keys = (float*)&Extents.x;
; 228  : 		for(udword j=0;j<3;j++)
; 229  : 		{
; 230  : 			for(udword i=0;i<2;i++)
; 231  : 			{
; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	comiss	xmm2, xmm1
	subss	xmm3, DWORD PTR [rcx+8]
	movss	DWORD PTR $T177547[rbp-153], xmm2
	mov	eax, DWORD PTR $T177547[rbp-153]
	mov	DWORD PTR SortedAxis$93994[rbp-153], edx
	mov	DWORD PTR Extents$93993[rbp-153], eax
	mulss	xmm3, xmm0
	movss	DWORD PTR $T177547[rbp-149], xmm1
	movss	DWORD PTR $T177547[rbp-145], xmm3
	mov	eax, DWORD PTR $T177547[rbp-149]
	mov	DWORD PTR SortedAxis$93994[rbp-149], esi
	mov	DWORD PTR Extents$93993[rbp-149], eax
	mov	eax, DWORD PTR $T177547[rbp-145]
	mov	DWORD PTR SortedAxis$93994[rbp-145], r13d
	mov	DWORD PTR Extents$93993[rbp-145], eax
	jae	SHORT $LN16@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	edx, esi

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$93994[rbp-149], r14d
	mov	esi, r14d
	mov	DWORD PTR SortedAxis$93994[rbp-153], edx
$LN16@Subdivide:

; 227  : 		float* Keys = (float*)&Extents.x;
; 228  : 		for(udword j=0;j<3;j++)
; 229  : 		{
; 230  : 			for(udword i=0;i<2;i++)
; 231  : 			{
; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, esi
	mov	ecx, esi
	comiss	xmm3, DWORD PTR Extents$93993[rbp+rax*4-153]
	jbe	SHORT $LN19@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	esi, r13d
	mov	DWORD PTR SortedAxis$93994[rbp-149], r13d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$93994[rbp-145], ecx
	mov	r13d, ecx
$LN19@Subdivide:

; 227  : 		float* Keys = (float*)&Extents.x;
; 228  : 		for(udword j=0;j<3;j++)
; 229  : 		{
; 230  : 			for(udword i=0;i<2;i++)
; 231  : 			{
; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, esi
	mov	ecx, edx
	mov	r8d, edx
	movss	xmm0, DWORD PTR Extents$93993[rbp+rax*4-153]
	comiss	xmm0, DWORD PTR Extents$93993[rbp+rcx*4-153]
	jbe	SHORT $LN153@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	edx, esi

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$93994[rbp-149], r8d
	mov	esi, r8d
	mov	DWORD PTR SortedAxis$93994[rbp-153], edx
$LN153@Subdivide:

; 227  : 		float* Keys = (float*)&Extents.x;
; 228  : 		for(udword j=0;j<3;j++)
; 229  : 		{
; 230  : 			for(udword i=0;i<2;i++)
; 231  : 			{
; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, r13d
	mov	ecx, esi
	mov	r8d, esi
	movss	xmm0, DWORD PTR Extents$93993[rbp+rax*4-153]
	comiss	xmm0, DWORD PTR Extents$93993[rbp+rcx*4-153]
	jbe	SHORT $LN155@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	esi, r13d
	mov	DWORD PTR SortedAxis$93994[rbp-149], r13d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$93994[rbp-145], r8d
	mov	r13d, r8d
$LN155@Subdivide:

; 227  : 		float* Keys = (float*)&Extents.x;
; 228  : 		for(udword j=0;j<3;j++)
; 229  : 		{
; 230  : 			for(udword i=0;i<2;i++)
; 231  : 			{
; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, esi
	mov	ecx, edx
	movss	xmm0, DWORD PTR Extents$93993[rbp+rax*4-153]
	comiss	xmm0, DWORD PTR Extents$93993[rbp+rcx*4-153]
	jbe	SHORT $LN160@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	DWORD PTR SortedAxis$93994[rbp-153], esi

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$93994[rbp-149], edx
	mov	esi, edx
$LN160@Subdivide:

; 227  : 		float* Keys = (float*)&Extents.x;
; 228  : 		for(udword j=0;j<3;j++)
; 229  : 		{
; 230  : 			for(udword i=0;i<2;i++)
; 231  : 			{
; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, r13d
	mov	ecx, esi
	movss	xmm0, DWORD PTR Extents$93993[rbp+rax*4-153]
	comiss	xmm0, DWORD PTR Extents$93993[rbp+rcx*4-153]
	jbe	SHORT $LN162@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	DWORD PTR SortedAxis$93994[rbp-149], r13d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$93994[rbp-145], esi
$LN162@Subdivide:

; 237  : 				}
; 238  : 			}
; 239  : 		}
; 240  : 
; 241  : 		// Find the largest axis to split along
; 242  : 		udword CurAxis = 0;

	mov	esi, r14d
	lea	r13, QWORD PTR SortedAxis$93994[rbp-153]
	npad	4
$LL13@Subdivide:

; 243  : 		ValidSplit = false;
; 244  : 		while(!ValidSplit && CurAxis!=3)

	cmp	esi, 3
	je	$LN165@Subdivide

; 245  : 		{
; 246  : 			NbPos = Split(SortedAxis[CurAxis], builder);

	mov	edx, DWORD PTR [r13]
	mov	r8, r12
	mov	rcx, rdi
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
	mov	ebx, eax

; 247  : 			// Check the subdivision has been successful
; 248  : 			if(!NbPos || NbPos==mNbPrimitives)	CurAxis++;

	test	eax, eax
	je	SHORT $LN10@Subdivide
	cmp	eax, DWORD PTR [rdi+48]
	jne	SHORT $LN3@Subdivide
$LN10@Subdivide:
	inc	esi
	add	r13, 4
	jmp	SHORT $LL13@Subdivide
$LN21@Subdivide:

; 249  : 			else								ValidSplit = true;
; 250  : 		}
; 251  : 	}
; 252  : 	else if(builder->mRules&SPLIT_FIFTY)

	test	al, 32					; 00000020H
	je	$LN7@Subdivide
$LN175@Subdivide:

; 253  : 	{
; 254  : 		// Don't even bother splitting (mainly a performance test)
; 255  : 		NbPos = mNbPrimitives>>1;

	shr	ebx, 1
$LN3@Subdivide:

; 269  : 		}
; 270  : 		else return true;
; 271  : 	}
; 272  : 
; 273  : 	// Now create children and assign their pointers.
; 274  : 	mP = builder->node_alloc();     CHECKALLOC(mP);

	cmp	QWORD PTR [r12+32], 0
	jne	SHORT $LN103@Subdivide
	lea	rcx, QWORD PTR [r12+32]
	call	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
$LN103@Subdivide:
	mov	rcx, QWORD PTR [r12+32]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [r12+32], rax
	test	rcx, rcx
	je	SHORT $LN106@Subdivide
	mov	QWORD PTR [rcx+24], r14
	mov	QWORD PTR [rcx+32], r14
	mov	QWORD PTR [rcx+40], r14
	mov	DWORD PTR [rcx+48], r14d
	jmp	SHORT $LN107@Subdivide
$LN106@Subdivide:
	mov	rcx, r14
$LN107@Subdivide:
	mov	QWORD PTR [rdi+24], rcx
	test	rcx, rcx
	je	SHORT $LN7@Subdivide

; 275  : 	mN = builder->node_alloc();		CHECKALLOC(mN);

	cmp	QWORD PTR [r12+32], 0
	jne	SHORT $LN116@Subdivide
	lea	rcx, QWORD PTR [r12+32]
	call	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
$LN116@Subdivide:
	mov	rcx, QWORD PTR [r12+32]
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [r12+32], rax
	test	rcx, rcx
	je	SHORT $LN119@Subdivide
	mov	QWORD PTR [rcx+24], r14
	mov	QWORD PTR [rcx+32], r14
	mov	QWORD PTR [rcx+40], r14
	mov	DWORD PTR [rcx+48], r14d
	jmp	SHORT $LN120@Subdivide
$LN119@Subdivide:
	mov	rcx, r14
$LN120@Subdivide:
	mov	QWORD PTR [rdi+32], rcx
	test	rcx, rcx
	je	SHORT $LN7@Subdivide

; 276  : 
; 277  : 	// Update stats
; 278  : 	builder->IncreaseCount	(2);

	add	DWORD PTR [r12+20], 2

; 279  : 
; 280  : 	// Assign children
; 281  : 	mP->mNodePrimitives	= &mNodePrimitives[0];

	mov	rcx, QWORD PTR [rdi+24]
	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rcx+40], rax

; 282  : 	mP->mNbPrimitives	= NbPos;

	mov	rax, QWORD PTR [rdi+24]

; 283  : 	mN->mNodePrimitives	= &mNodePrimitives[NbPos];

	mov	ecx, ebx
	mov	DWORD PTR [rax+48], ebx
	mov	rax, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rax+rcx*4]
	mov	rax, QWORD PTR [rdi+32]
	mov	QWORD PTR [rax+40], rdx

; 284  : 	mN->mNbPrimitives	= mNbPrimitives - NbPos;

	mov	ecx, DWORD PTR [rdi+48]
	mov	rax, QWORD PTR [rdi+32]
	sub	ecx, ebx
	mov	DWORD PTR [rax+48], ecx
$LN4@Subdivide:

; 285  : 
; 286  : 	return true;

	mov	al, 1
	jmp	SHORT $LN173@Subdivide
$LN7@Subdivide:

; 256  : 	}
; 257  : 	else return false;	// Unknown splitting rules

	xor	al, al
$LN173@Subdivide:
	movaps	xmm6, XMMWORD PTR [rsp+192]
	mov	r14, QWORD PTR [rsp+216]
	mov	r13, QWORD PTR [rsp+272]
	mov	rsi, QWORD PTR [rsp+264]
	movaps	xmm7, XMMWORD PTR [rsp+176]
$LN168@Subdivide:
	mov	rbx, QWORD PTR [rsp+256]

; 287  : }

	add	rsp, 224				; 000000e0H
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTreeNode::Subdivide
_TEXT	ENDS
PUBLIC	?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::_BuildHierarchy
pdata	SEGMENT
$pdata$?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z DD imagerel $LN7
	DD	imagerel $LN7+84
	DD	imagerel $unwind$?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
builder$ = 56
?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTreeNode::_BuildHierarchy

; 296  : {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx
$LL5@BuildHiera:

; 297  : 	// 1) Compute the global box for current node. The box is stored in mBV.
; 298  : 	builder->ComputeGlobalBox(mNodePrimitives, mNbPrimitives, mBV);

	mov	rax, QWORD PTR [rdi]
	mov	r8d, DWORD PTR [rbx+48]
	mov	rdx, QWORD PTR [rbx+40]
	mov	r9, rbx
	mov	rcx, rdi
	call	QWORD PTR [rax+8]

; 299  : 
; 300  : 	// 2) Subdivide current node
; 301  : 	Subdivide(builder);

	mov	rdx, rdi
	mov	rcx, rbx
	call	?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Subdivide

; 302  : 
; 303  : 	// 3) Recurse
; 304  : 	if(mP)	mP->_BuildHierarchy(builder);

	mov	rcx, QWORD PTR [rbx+24]
	test	rcx, rcx
	je	SHORT $LN2@BuildHiera
	mov	rdx, rdi
	call	?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::_BuildHierarchy
$LN2@BuildHiera:

; 305  : 	if(mN)	mN->_BuildHierarchy(builder);

	mov	rbx, QWORD PTR [rbx+32]
	test	rbx, rbx
	jne	SHORT $LL5@BuildHiera

; 306  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTreeNode::_BuildHierarchy
_TEXT	ENDS
PUBLIC	?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTree::Build
pdata	SEGMENT
$pdata$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN30
	DD	imagerel $LN30+47
	DD	imagerel $unwind$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$0$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN30+47
	DD	imagerel $LN30+121
	DD	imagerel $chain$0$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$2$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN30+121
	DD	imagerel $LN30+245
	DD	imagerel $chain$2$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
$chain$0$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+47
	DD	imagerel $unwind$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$2$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD 020021H
	DD	063400H
	DD	imagerel $LN30
	DD	imagerel $LN30+47
	DD	imagerel $unwind$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
builder$ = 56
?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTree::Build

; 337  : {

$LN30:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 338  : 	// Checkings
; 339  : 	if(!builder || !builder->mNbPrimitives)	return false;

	cmp	DWORD PTR [rdx+16], 0
	mov	rdi, rdx
	mov	rsi, rcx
	jne	SHORT $LN6@Build@5
	xor	al, al

; 360  : 
; 361  : 	return true;
; 362  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@Build@5:

; 340  : 
; 341  : 	// Init stats
; 342  : 	builder->SetCount(1);

	mov	QWORD PTR [rdx+20], 1

; 343  : 	builder->SetNbInvalidSplits(0);
; 344  : 
; 345  : 	// Initialize indices. This list will be modified during build.
; 346  : 	xr_free(mIndices);

	mov	rdx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+48], rbx
	xor	ebx, ebx
	test	rdx, rdx
	je	SHORT $LN16@Build@5
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rsi+56], rbx
$LN16@Build@5:

; 347  : 	mIndices	= xr_alloc<udword>(builder->mNbPrimitives);

	mov	edx, DWORD PTR [rdi+16]
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	rdx, 2
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	QWORD PTR [rsi+56], rax

; 348  : 	CHECKALLOC(mIndices);

	test	rax, rax
	jne	SHORT $LN4@Build@5
	mov	rbx, QWORD PTR [rsp+48]

; 360  : 
; 361  : 	return true;
; 362  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@Build@5:

; 349  : 	for(udword i=0;i<builder->mNbPrimitives;i++)	mIndices[i] = i;

	cmp	DWORD PTR [rdi+16], ebx
	jbe	SHORT $LN1@Build@5
	mov	rcx, rbx
$LL3@Build@5:
	mov	rax, QWORD PTR [rsi+56]
	add	rcx, 4
	mov	DWORD PTR [rcx+rax-4], ebx
	inc	ebx
	cmp	ebx, DWORD PTR [rdi+16]
	jb	SHORT $LL3@Build@5
$LN1@Build@5:

; 350  : 
; 351  : 	// Setup initial box
; 352  : 	mNodePrimitives	= mIndices;

	mov	rdx, QWORD PTR [rsi+56]

; 353  : 	mNbPrimitives	= builder->mNbPrimitives;
; 354  : 
; 355  : 	// Build the hierarchy
; 356  : 	_BuildHierarchy(builder);

	mov	r9, rsi
	mov	rcx, rdi
	mov	QWORD PTR [rsi+40], rdx
	mov	r8d, DWORD PTR [rdi+16]
	mov	DWORD PTR [rsi+48], r8d
	mov	rax, QWORD PTR [rdi]
	call	QWORD PTR [rax+8]
	mov	rdx, rdi
	mov	rcx, rsi
	call	?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Subdivide
	mov	rcx, QWORD PTR [rsi+24]
	test	rcx, rcx
	je	SHORT $LN22@Build@5
	mov	rdx, rdi
	call	?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::_BuildHierarchy
$LN22@Build@5:
	mov	rcx, QWORD PTR [rsi+32]
	test	rcx, rcx
	je	SHORT $LN21@Build@5
	mov	rdx, rdi
	call	?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::_BuildHierarchy
$LN21@Build@5:

; 357  : 
; 358  : 	// Get back total number of nodes
; 359  : 	mTotalNbNodes	= builder->GetCount();

	mov	eax, DWORD PTR [rdi+20]
	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rsi+64], eax

; 360  : 
; 361  : 	return true;
; 362  : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	al, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTree::Build
END
