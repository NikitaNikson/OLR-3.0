; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??0AABB@Meshmerizer@@QEAA@XZ			; Meshmerizer::AABB::AABB
PUBLIC	??1AABB@Meshmerizer@@QEAA@XZ			; Meshmerizer::AABB::~AABB
PUBLIC	?node_destroy@AABBTreeBuilder@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z ; Opcode::AABBTreeBuilder::node_destroy
PUBLIC	?destroy@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::destroy
PUBLIC	?access@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAPEAPEAVAABBTreeNode@2@PEAV32@@Z ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::access
PUBLIC	??_GAABBTreeNode@Opcode@@QEAAPEAXI@Z		; Opcode::AABBTreeNode::`scalar deleting destructor'
PUBLIC	?LargestAxis@icePoint@IceMaths@@QEBA?AW4PointComponent@2@XZ ; IceMaths::icePoint::LargestAxis
PUBLIC	??_0icePoint@IceMaths@@QEAAAEAV01@M@Z		; IceMaths::icePoint::operator/=
PUBLIC	?IncreaseNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXXZ ; Opcode::AABBTreeBuilder::IncreaseNbInvalidSplits
PUBLIC	?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ ; Opcode::AABBTreeBuilder::node_alloc
PUBLIC	?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::create
PUBLIC	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
PUBLIC	?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::push_back
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >::_Getal
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	??0?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAA@XZ	; xalloc<Opcode::AABBTreeNode * __ptr64>::xalloc<Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
PUBLIC	??$forward@AEBQEAVAABBTreeNode@Opcode@@@std@@YAAEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ; std::forward<Opcode::AABBTreeNode * __ptr64 const & __ptr64>
PUBLIC	??$construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV34@@Z ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEBQEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV34@@Z ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
PUBLIC	?construct@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z ; xalloc<Opcode::AABBTreeNode * __ptr64>::construct
PUBLIC	??$_Construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ; std::_Construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
PUBLIC	?_Orphan_range@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXPEAPEAVAABBTreeNode@Opcode@@0@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve
PUBLIC	?size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size
PUBLIC	?_Grow_to@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_K_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Grow_to
PUBLIC	?max_size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SA_KAEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size
PUBLIC	??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ; std::_Alloc_max_size::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	?max_size@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBA_KXZ ; xalloc<Opcode::AABBTreeNode * __ptr64>::max_size
PUBLIC	?capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::capacity
PUBLIC	?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reallocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@_K@Z ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::deallocate
PUBLIC	?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z ; xalloc<Opcode::AABBTreeNode * __ptr64>::deallocate
PUBLIC	??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z ; xr_free<Opcode::AABBTreeNode * __ptr64>
PUBLIC	?_Destroy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXPEAPEAVAABBTreeNode@Opcode@@0@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Destroy
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >
PUBLIC	??$_Ptr_cat@PEAVAABBTreeNode@Opcode@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVAABBTreeNode@Opcode@@0@Z ; std::_Ptr_cat<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >
PUBLIC	??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Umove<Opcode::AABBTreeNode * __ptr64 * __ptr64>
PUBLIC	??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z ; std::_Uninitialized_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >
PUBLIC	??$_Unchecked@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z ; std::_Unchecked<Opcode::AABBTreeNode * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >
PUBLIC	??$_Val_type@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z ; std::_Val_type<Opcode::AABBTreeNode * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$destroy@PEAVAABBTreeNode@Opcode@@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::destroy<Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$destroy@PEAVAABBTreeNode@Opcode@@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::destroy<Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z ; std::_Alloc_destroy::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
PUBLIC	?destroy@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z ; xalloc<Opcode::AABBTreeNode * __ptr64>::destroy
PUBLIC	??$_Destroy@PEAVAABBTreeNode@Opcode@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@@Z ; std::_Destroy<Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$construct@PEAVAABBTreeNode@Opcode@@PEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV23@@Z ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$forward@PEAVAABBTreeNode@Opcode@@@std@@YA$$QEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z ; std::forward<Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$construct@PEAVAABBTreeNode@Opcode@@PEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV34@@Z ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@PEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV34@@Z ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
PUBLIC	??$_Rechecked@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@std@@YAAEAPEAPEAVAABBTreeNode@Opcode@@AEAPEAPEAV12@PEAPEAV12@@Z ; std::_Rechecked<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64>
PUBLIC	?allocate@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAPEAPEAVAABBTreeNode@Opcode@@_K@Z ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::allocate
PUBLIC	?allocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAPEAPEAVAABBTreeNode@Opcode@@_KPEBX@Z ; xalloc<Opcode::AABBTreeNode * __ptr64>::allocate
PUBLIC	??$xr_alloc@PEAVAABBTreeNode@Opcode@@@@YAPEAPEAVAABBTreeNode@Opcode@@I@Z ; xr_alloc<Opcode::AABBTreeNode * __ptr64>
PUBLIC	?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Xlen
PUBLIC	?_Unused_capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Unused_capacity
PUBLIC	??$construct@PEAVAABBTreeNode@Opcode@@AEAPEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEAPEAV23@@Z ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>
PUBLIC	??$forward@AEAPEAVAABBTreeNode@Opcode@@@std@@YAAEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z ; std::forward<Opcode::AABBTreeNode * __ptr64 & __ptr64>
PUBLIC	??$construct@PEAVAABBTreeNode@Opcode@@AEAPEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV34@@Z ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEAPEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV34@@Z ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>
PUBLIC	??$addressof@QEAVAABBTreeNode@Opcode@@@std@@YAPEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ; std::addressof<Opcode::AABBTreeNode * __ptr64 const>
PUBLIC	?_Inside@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_NPEBQEAVAABBTreeNode@Opcode@@@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Inside
PUBLIC	??$xr_alloc@VAABBTreeNode@Opcode@@@@YAPEAVAABBTreeNode@Opcode@@I@Z ; xr_alloc<Opcode::AABBTreeNode>
PUBLIC	?IncreaseCount@AABBTreeBuilder@Opcode@@QEAAXI@Z	; Opcode::AABBTreeBuilder::IncreaseCount
PUBLIC	?SetCount@AABBTreeBuilder@Opcode@@QEAAXI@Z	; Opcode::AABBTreeBuilder::SetCount
PUBLIC	?SetNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXI@Z ; Opcode::AABBTreeBuilder::SetNbInvalidSplits
PUBLIC	?GetCount@AABBTreeBuilder@Opcode@@QEBAIXZ	; Opcode::AABBTreeBuilder::GetCount
PUBLIC	?GetNbNodes@AABBTree@Opcode@@QEBAIXZ		; Opcode::AABBTree::GetNbNodes
PUBLIC	?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTree::Build
PUBLIC	??1AABBTree@Opcode@@QEAA@XZ			; Opcode::AABBTree::~AABBTree
PUBLIC	??0AABBTree@Opcode@@QEAA@XZ			; Opcode::AABBTree::AABBTree
PUBLIC	?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::_BuildHierarchy
PUBLIC	?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Subdivide
PUBLIC	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
PUBLIC	?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::destroy
PUBLIC	??1AABBTreeNode@Opcode@@QEAA@XZ			; Opcode::AABBTreeNode::~AABBTreeNode
PUBLIC	??0AABBTreeNode@Opcode@@QEAA@XZ			; Opcode::AABBTreeNode::AABBTreeNode
;	COMDAT pdata
pdata	SEGMENT
$pdata$?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ DD imagerel $LN15
	DD	imagerel $LN15+71
	DD	imagerel $unwind$?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ DD imagerel $LN13
	DD	imagerel $LN13+66
	DD	imagerel $unwind$?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ DD imagerel $LN21
	DD	imagerel $LN21+129
	DD	imagerel $unwind$?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z DD imagerel $LN69
	DD	imagerel $LN69+134
	DD	imagerel $unwind$?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD imagerel $LN47
	DD	imagerel $LN47+140
	DD	imagerel $unwind$?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD imagerel $LN60
	DD	imagerel $LN60+152
	DD	imagerel $unwind$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA+45
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z DD imagerel $LN5
	DD	imagerel $LN5+43
	DD	imagerel $unwind$??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+60
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN33
	DD	imagerel $LN33+47
	DD	imagerel $unwind$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$0$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN33+47
	DD	imagerel $LN33+121
	DD	imagerel $chain$0$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$2$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN33+121
	DD	imagerel $LN33+241
	DD	imagerel $chain$2$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$??1AABBTree@Opcode@@QEAA@XZ DD imagerel $LN7
	DD	imagerel $LN7+45
	DD	imagerel $unwind$??1AABBTree@Opcode@@QEAA@XZ
$pdata$?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z DD imagerel $LN10
	DD	imagerel $LN10+84
	DD	imagerel $unwind$?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z
$pdata$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN188
	DD	imagerel $LN188+71
	DD	imagerel $unwind$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN188+71
	DD	imagerel $LN188+279
	DD	imagerel $chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$13$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN188+279
	DD	imagerel $LN188+789
	DD	imagerel $chain$13$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$14$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN188+789
	DD	imagerel $LN188+1555
	DD	imagerel $chain$14$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$15$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD imagerel $LN188+1555
	DD	imagerel $LN188+1574
	DD	imagerel $chain$15$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$pdata$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD imagerel $LN13
	DD	imagerel $LN13+69
	DD	imagerel $unwind$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
$pdata$0$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD imagerel $LN13+69
	DD	imagerel $LN13+145
	DD	imagerel $chain$0$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
$pdata$1$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD imagerel $LN13+145
	DD	imagerel $LN13+172
	DD	imagerel $chain$1$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
$pdata$?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z DD imagerel $LN35
	DD	imagerel $LN35+123
	DD	imagerel $unwind$?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z
xdata	SEGMENT
$unwind$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
$chain$0$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN33
	DD	imagerel $LN33+47
	DD	imagerel $unwind$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$2$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z DD 020021H
	DD	063400H
	DD	imagerel $LN33
	DD	imagerel $LN33+47
	DD	imagerel $unwind$?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z
$unwind$??1AABBTree@Opcode@@QEAA@XZ DD 020601H
	DD	030023206H
$unwind$?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 073001H
	DD	0203430H
	DD	01c0110H
	DD	060037004H
	DD	05002H
$chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 0a2b21H
	DD	0b782bH
	DD	0c6823H
	DD	01af418H
	DD	01be410H
	DD	022d408H
	DD	imagerel $LN188
	DD	imagerel $LN188+71
	DD	imagerel $unwind$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$13$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 0105421H
	DD	04e854H
	DD	05d846H
	DD	06c840H
	DD	07b83aH
	DD	08a834H
	DD	09981aH
	DD	0a8811H
	DD	021c408H
	DD	imagerel $LN188+71
	DD	imagerel $LN188+279
	DD	imagerel $chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$14$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 021H
	DD	imagerel $LN188+71
	DD	imagerel $LN188+279
	DD	imagerel $chain$5$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$chain$15$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z DD 021H
	DD	imagerel $LN188
	DD	imagerel $LN188+71
	DD	imagerel $unwind$?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z
$unwind$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD 0a2201H
	DD	036822H
	DD	0e6413H
	DD	0d3413H
	DD	0f00f7213H
	DD	0700be00dH
$chain$0$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD 020521H
	DD	0c5405H
	DD	imagerel $LN13
	DD	imagerel $LN13+69
	DD	imagerel $unwind$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
$chain$1$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+69
	DD	imagerel $unwind$?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z
$unwind$?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+52
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z+63
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z+79
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD 081e19H
	DD	0d741eH
	DD	0c6419H
	DD	0a3414H
	DD	0e0027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
this$ = 8
??0AABBTreeNode@Opcode@@QEAA@XZ PROC			; Opcode::AABBTreeNode::AABBTreeNode

; 58   : {

	xor	eax, eax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	DWORD PTR [rcx+48], eax

; 59   : }

	mov	rax, rcx
	ret	0
??0AABBTreeNode@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTreeNode::AABBTreeNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
this$dead$ = 8
??1AABBTreeNode@Opcode@@QEAA@XZ PROC			; Opcode::AABBTreeNode::~AABBTreeNode

; 68   : }

	ret	0
??1AABBTreeNode@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTreeNode::~AABBTreeNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
this$ = 48
_tree$ = 56
?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTreeNode::destroy

; 71   : {

$LN35:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 72   : 	if (mP)	{ mP->destroy		(_tree); _tree->node_destroy	(mP); }

	mov	rcx, QWORD PTR [rcx+24]
	xor	esi, esi
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN7@destroy
	call	?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::destroy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 49   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rdi+32]

; 12   : 	T**					access			(T* P)	{ return (T**) LPVOID(P);	}

	mov	r8, QWORD PTR [rbx+24]

; 49   : 		*access(P)		= list;

	mov	QWORD PTR [r8], rax

; 50   : 		list			= P;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR [rdi+32], rax

; 51   : 		P				= NULL;

	mov	QWORD PTR [rbx+24], rsi
$LN7@destroy:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 73   : 	if (mN)	{ mN->destroy		(_tree); _tree->node_destroy	(mN); }

	mov	rcx, QWORD PTR [rbx+32]
	test	rcx, rcx
	je	SHORT $LN33@destroy
	mov	rdx, rdi
	call	?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::destroy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 49   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rdi+32]

; 12   : 	T**					access			(T* P)	{ return (T**) LPVOID(P);	}

	mov	rcx, QWORD PTR [rbx+32]

; 49   : 		*access(P)		= list;

	mov	QWORD PTR [rcx], rax

; 50   : 		list			= P;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi+32], rax

; 51   : 		P				= NULL;

	mov	QWORD PTR [rbx+32], rsi
$LN33@destroy:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 75   : 	mNbPrimitives				= 0;

	mov	DWORD PTR [rbx+48], esi
	mov	QWORD PTR [rbx+40], rsi

; 76   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTreeNode::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
this$ = 96
axis$ = 104
builder$ = 112
?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTreeNode::Split

; 89   : {

$LN13:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H

; 90   : 	// Get node split value
; 91   : 	float SplitValue = builder->GetSplittingValueEx(mNodePrimitives, mNbPrimitives, mBV, axis);

	mov	rax, QWORD PTR [r8]
	mov	r14, r8
	mov	r8d, DWORD PTR [rcx+48]
	movaps	XMMWORD PTR [rsp+48], xmm6
	mov	r15d, edx
	mov	DWORD PTR [rsp+32], edx
	mov	rdx, QWORD PTR [rcx+40]
	mov	rdi, rcx
	mov	r9, rcx
	mov	rcx, r14
	call	QWORD PTR [rax+24]

; 92   : 
; 93   : 	udword NbPos = 0;

	xor	esi, esi

; 94   : 	// Loop through all node-related primitives. Their indices range from mNodePrimitives[0] to mNodePrimitives[mNbPrimitives-1].
; 95   : 	// Those indices map the global list in the tree builder.
; 96   : 	for(udword i=0;i<mNbPrimitives;i++)

	mov	ebx, esi
	movaps	xmm6, xmm0
	cmp	DWORD PTR [rdi+48], ebx
	jbe	SHORT $LN11@Split
	mov	QWORD PTR [rsp+96], rbp
	npad	6
$LL4@Split:

; 97   : 	{
; 98   : 		// Get index in global list
; 99   : 		udword Index = mNodePrimitives[i];

	mov	rax, QWORD PTR [rdi+40]

; 100  : 
; 101  : 		// Test against the splitting value. The primitive value is tested against the enclosing-box center.
; 102  : 		// [We only need an approximate partition of the enclosing box here.]
; 103  : 		float PrimitiveValue = builder->GetSplittingValue(Index, axis);

	mov	r9, QWORD PTR [r14]
	mov	ebp, ebx
	mov	edx, DWORD PTR [rax+rbp*4]
	mov	r8d, r15d
	mov	rcx, r14
	call	QWORD PTR [r9+16]

; 104  : 
; 105  : 		// Reorganize the list of indices in this order: positive - negative.
; 106  : 		if(PrimitiveValue > SplitValue)

	comiss	xmm0, xmm6
	jbe	SHORT $LN3@Split

; 107  : 		{
; 108  : 			// Swap entries
; 109  : 			udword Tmp = mNodePrimitives[i];

	mov	r8, QWORD PTR [rdi+40]

; 110  : 			mNodePrimitives[i] = mNodePrimitives[NbPos];

	mov	ecx, DWORD PTR [r8+rsi*4]
	mov	r9d, DWORD PTR [r8+rbp*4]
	mov	DWORD PTR [r8+rbp*4], ecx

; 111  : 			mNodePrimitives[NbPos] = Tmp;

	mov	rcx, QWORD PTR [rdi+40]
	mov	DWORD PTR [rcx+rsi*4], r9d

; 112  : 			// Count primitives assigned to positive space
; 113  : 			NbPos++;

	inc	esi
$LN3@Split:

; 94   : 	// Loop through all node-related primitives. Their indices range from mNodePrimitives[0] to mNodePrimitives[mNbPrimitives-1].
; 95   : 	// Those indices map the global list in the tree builder.
; 96   : 	for(udword i=0;i<mNbPrimitives;i++)

	inc	ebx
	cmp	ebx, DWORD PTR [rdi+48]
	jb	SHORT $LL4@Split
	mov	rbp, QWORD PTR [rsp+96]
$LN11@Split:

; 114  : 		}
; 115  : 	}
; 116  : 	return NbPos;
; 117  : }

	mov	rbx, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+48]
	mov	eax, esi
	mov	rsi, QWORD PTR [rsp+112]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTreeNode::Split
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 32
SortedAxis$3 = 32
Extents$4 = 48
Results$5 = 48
Vars$6 = 48
Extents$7 = 48
this$ = 256
builder$ = 264
?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTreeNode::Subdivide

; 140  : {

$LN188:
	push	rbp
	push	rsi
	push	rdi
	lea	rbp, QWORD PTR [rsp-71]
	sub	rsp, 224				; 000000e0H
	mov	rsi, rdx
	mov	rdi, rcx

; 141  : 	// Checkings
; 142  : 	if(!builder)	return false;

	test	rdx, rdx
	jne	SHORT $LN44@Subdivide
	xor	al, al

; 287  : }

	add	rsp, 224				; 000000e0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN44@Subdivide:
	mov	QWORD PTR [rsp+256], rbx

; 143  : 
; 144  : 	// Stop subdividing if we reach a leaf node
; 145  : 	if(mNbPrimitives==1)	return true;

	mov	ebx, DWORD PTR [rcx+48]
	cmp	ebx, 1
	je	SHORT $LN185@Subdivide

; 146  : 
; 147  : 	// Check the user-defined limit
; 148  : 	if(mNbPrimitives<=builder->mLimit)	return true;

	cmp	ebx, DWORD PTR [rdx+8]
	ja	SHORT $LN42@Subdivide
$LN185@Subdivide:
	mov	al, 1
	jmp	$LN176@Subdivide
$LN42@Subdivide:

; 149  : 
; 150  : 	bool ValidSplit = true;	// Optimism...
; 151  : 	udword NbPos	= 0;
; 152  : 	if(builder->mRules&SPLIT_LARGESTAXIS)

	mov	eax, DWORD PTR [rdx+12]
	mov	QWORD PTR [rsp+272], r13
	mov	QWORD PTR [rsp+216], r14
	mov	QWORD PTR [rsp+208], r15
	xor	r13d, r13d
	movaps	XMMWORD PTR [rsp+192], xmm6
	movaps	XMMWORD PTR [rsp+176], xmm7
	test	al, 2
	je	$LN41@Subdivide
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 380  : 		inline_	Point			operator*(float s)					const		{ return Point(x * s,   y * s,   z * s );			}

	movss	xmm0, DWORD PTR __real@3f000000

; 375  : 		inline_	Point			operator-(const Point& p)			const		{ return Point(x - p.x, y - p.y, z - p.z);			}

	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm1, DWORD PTR [rcx+16]

; 322  : 									if(Vals[_Y] > Vals[m]) m = _Y;

	mov	edx, r13d
	mov	r14d, 1

; 323  : 									if(Vals[_Z] > Vals[m]) m = _Z;

	mov	r15d, 2

; 375  : 		inline_	Point			operator-(const Point& p)			const		{ return Point(x - p.x, y - p.y, z - p.z);			}

	subss	xmm2, DWORD PTR [rcx]
	movss	xmm3, DWORD PTR [rcx+20]
	subss	xmm1, DWORD PTR [rcx+4]

; 380  : 		inline_	Point			operator*(float s)					const		{ return Point(x * s,   y * s,   z * s );			}

	mulss	xmm2, xmm0
	mulss	xmm1, xmm0

; 375  : 		inline_	Point			operator-(const Point& p)			const		{ return Point(x - p.x, y - p.y, z - p.z);			}

	subss	xmm3, DWORD PTR [rcx+8]

; 322  : 									if(Vals[_Y] > Vals[m]) m = _Y;

	comiss	xmm1, xmm2
	cmova	edx, r14d

; 380  : 		inline_	Point			operator*(float s)					const		{ return Point(x * s,   y * s,   z * s );			}

	mulss	xmm3, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h

; 116  : 		inline_			void		GetExtents(Point& extents)				const		{ extents = (mMax - mMin)*0.5f;				}

	movaps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 46   : 		inline_					Point(float _x, float _y, float _z) : x(_x), y(_y), z(_z)	{}

	movss	DWORD PTR $T2[rbp-145], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h

; 116  : 		inline_			void		GetExtents(Point& extents)				const		{ extents = (mMax - mMin)*0.5f;				}

	unpcklps xmm0, xmm1
	mov	eax, DWORD PTR $T2[rbp-145]
	mov	DWORD PTR Extents$7[rbp-145], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 323  : 									if(Vals[_Z] > Vals[m]) m = _Z;

	movsxd	rax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h

; 116  : 		inline_			void		GetExtents(Point& extents)				const		{ extents = (mMax - mMin)*0.5f;				}

	movsdx	QWORD PTR Extents$7[rbp-153], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 323  : 									if(Vals[_Z] > Vals[m]) m = _Z;

	comiss	xmm3, DWORD PTR Extents$7[rbp+rax*4-153]
	cmova	edx, r15d
$LN186@Subdivide:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 159  : 		NbPos = Split(Axis, builder);

	mov	r8, rsi
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
	mov	ebx, eax
$LN183@Subdivide:

; 196  : 
; 197  : 		// Check split validity
; 198  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;

	test	eax, eax
	je	SHORT $LN173@Subdivide
	cmp	eax, DWORD PTR [rdi+48]
	jne	$LN3@Subdivide
$LN173@Subdivide:

; 258  : 
; 259  : 	// Check the subdivision has been successful
; 260  : 	if(!ValidSplit)
; 261  : 	{
; 262  : 		// Here, all boxes lie in the same sub-space. Two strategies:
; 263  : 		// - if the tree *must* be complete, make an arbitrary 50-50 split
; 264  : 		// - else stop subdividing
; 265  : 		if(builder->mRules&SPLIT_COMPLETE)

	test	BYTE PTR [rsi+12], 1
	je	$LN4@Subdivide
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 102  : 		inline_						void		IncreaseNbInvalidSplits()		{ mNbInvalidSplits++;		}

	inc	DWORD PTR [rsi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 268  : 			NbPos = mNbPrimitives>>1;

	mov	ebx, DWORD PTR [rdi+48]
	jmp	$LN184@Subdivide
$LN41@Subdivide:

; 160  : 
; 161  : 		// Check split validity
; 162  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 163  : 	}
; 164  : 	else if(builder->mRules&SPLIT_SPLATTERPOINTS)

	test	al, 4
	je	$LN37@Subdivide

; 168  : 		for(udword i=0;i<mNbPrimitives;i++)

	mov	QWORD PTR [rsp+264], r12
	movaps	XMMWORD PTR [rsp+160], xmm8
	movaps	XMMWORD PTR [rsp+144], xmm9
	xorps	xmm8, xmm8
	mov	r14d, 1
	mov	r12d, r13d
	lea	r15d, QWORD PTR [r14+1]
	movaps	XMMWORD PTR [rsp+128], xmm10
	movaps	XMMWORD PTR [rsp+112], xmm11
	movaps	XMMWORD PTR [rsp+96], xmm12
	movaps	XMMWORD PTR [rsp+80], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 46   : 		inline_					Point(float _x, float _y, float _z) : x(_x), y(_y), z(_z)	{}

	movaps	xmm9, xmm8
	movaps	xmm10, xmm8
	movaps	XMMWORD PTR [rsp+64], xmm14
	movaps	xmm11, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 168  : 		for(udword i=0;i<mNbPrimitives;i++)

	test	ebx, ebx
	je	SHORT $LN34@Subdivide
	npad	13
$LL36@Subdivide:

; 169  : 		{
; 170  : 			udword Index = mNodePrimitives[i];

	mov	rax, QWORD PTR [rdi+40]
	mov	ecx, r12d

; 171  : 			Means.x+=builder->GetSplittingValue(Index, 0);

	xor	r8d, r8d
	mov	ebx, DWORD PTR [rax+rcx*4]
	mov	rax, QWORD PTR [rsi]
	mov	rcx, rsi
	mov	edx, ebx
	call	QWORD PTR [rax+16]

; 172  : 			Means.y+=builder->GetSplittingValue(Index, 1);

	mov	rax, QWORD PTR [rsi]
	mov	r8d, r14d
	mov	edx, ebx
	mov	rcx, rsi
	addss	xmm9, xmm0
	call	QWORD PTR [rax+16]

; 173  : 			Means.z+=builder->GetSplittingValue(Index, 2);

	mov	rax, QWORD PTR [rsi]
	mov	r8d, r15d
	mov	edx, ebx
	mov	rcx, rsi
	addss	xmm10, xmm0
	call	QWORD PTR [rax+16]
	inc	r12d
	addss	xmm11, xmm0
	cmp	r12d, DWORD PTR [rdi+48]
	jb	SHORT $LL36@Subdivide
$LN34@Subdivide:

; 175  : 		Means/=float(mNbPrimitives);

	mov	eax, DWORD PTR [rdi+48]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 420  : 		inline_	Point&			operator/=(float s)								{ s = 1.0f/s; x *= s; y *= s; z *= s; return *this; }

	movss	xmm14, DWORD PTR __real@3f800000
	xorps	xmm0, xmm0

; 46   : 		inline_					Point(float _x, float _y, float _z) : x(_x), y(_y), z(_z)	{}

	movaps	xmm12, xmm8
	movaps	xmm13, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 179  : 		for(i=0;i<mNbPrimitives;i++)

	mov	r12d, r13d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 420  : 		inline_	Point&			operator/=(float s)								{ s = 1.0f/s; x *= s; y *= s; z *= s; return *this; }

	movaps	xmm1, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 175  : 		Means/=float(mNbPrimitives);

	cvtsi2ss xmm0, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 420  : 		inline_	Point&			operator/=(float s)								{ s = 1.0f/s; x *= s; y *= s; z *= s; return *this; }

	divss	xmm1, xmm0
	mulss	xmm9, xmm1
	mulss	xmm10, xmm1
	mulss	xmm11, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 179  : 		for(i=0;i<mNbPrimitives;i++)

	test	eax, eax
	je	SHORT $LN31@Subdivide
	npad	10
$LL33@Subdivide:

; 180  : 		{
; 181  : 			udword Index = mNodePrimitives[i];

	mov	rax, QWORD PTR [rdi+40]
	mov	ecx, r12d

; 182  : 			float Cx = builder->GetSplittingValue(Index, 0);

	xor	r8d, r8d
	mov	ebx, DWORD PTR [rax+rcx*4]
	mov	rax, QWORD PTR [rsi]
	mov	rcx, rsi
	mov	edx, ebx
	call	QWORD PTR [rax+16]

; 183  : 			float Cy = builder->GetSplittingValue(Index, 1);

	mov	rax, QWORD PTR [rsi]
	mov	r8d, r14d
	mov	edx, ebx
	mov	rcx, rsi
	movaps	xmm6, xmm0
	call	QWORD PTR [rax+16]

; 184  : 			float Cz = builder->GetSplittingValue(Index, 2);

	mov	rax, QWORD PTR [rsi]
	mov	r8d, r15d
	mov	edx, ebx
	mov	rcx, rsi
	movaps	xmm7, xmm0
	call	QWORD PTR [rax+16]
	inc	r12d

; 185  : 			Vars.x += (Cx - Means.x)*(Cx - Means.x);

	subss	xmm6, xmm9

; 186  : 			Vars.y += (Cy - Means.y)*(Cy - Means.y);

	subss	xmm7, xmm10
	mulss	xmm6, xmm6
	mulss	xmm7, xmm7

; 187  : 			Vars.z += (Cz - Means.z)*(Cz - Means.z);

	subss	xmm0, xmm11
	addss	xmm8, xmm6
	addss	xmm12, xmm7
	mulss	xmm0, xmm0
	addss	xmm13, xmm0
	cmp	r12d, DWORD PTR [rdi+48]
	jb	SHORT $LL33@Subdivide
$LN31@Subdivide:

; 189  : 		Vars/=float(mNbPrimitives-1);

	mov	eax, DWORD PTR [rdi+48]
	xorps	xmm0, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 322  : 									if(Vals[_Y] > Vals[m]) m = _Y;

	mov	edx, r13d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 189  : 		Vars/=float(mNbPrimitives-1);

	dec	eax

; 195  : 		NbPos = Split(Axis, builder);

	mov	r8, rsi
	mov	rcx, rdi
	cvtsi2ss xmm0, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 420  : 		inline_	Point&			operator/=(float s)								{ s = 1.0f/s; x *= s; y *= s; z *= s; return *this; }

	divss	xmm14, xmm0
	mulss	xmm8, xmm14
	mulss	xmm12, xmm14
	mulss	xmm13, xmm14

; 322  : 									if(Vals[_Y] > Vals[m]) m = _Y;

	comiss	xmm12, xmm8

; 420  : 		inline_	Point&			operator/=(float s)								{ s = 1.0f/s; x *= s; y *= s; z *= s; return *this; }

	movss	DWORD PTR Vars$6[rbp-153], xmm8
	movss	DWORD PTR Vars$6[rbp-149], xmm12

; 322  : 									if(Vals[_Y] > Vals[m]) m = _Y;

	cmova	edx, r14d

; 323  : 									if(Vals[_Z] > Vals[m]) m = _Z;

	movsxd	rax, edx

; 420  : 		inline_	Point&			operator/=(float s)								{ s = 1.0f/s; x *= s; y *= s; z *= s; return *this; }

	movss	DWORD PTR Vars$6[rbp-145], xmm13

; 323  : 									if(Vals[_Z] > Vals[m]) m = _Z;

	comiss	xmm13, DWORD PTR Vars$6[rbp+rax*4-153]
	cmova	edx, r15d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 195  : 		NbPos = Split(Axis, builder);

	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
	mov	r12, QWORD PTR [rsp+264]
	movaps	xmm14, XMMWORD PTR [rsp+64]
	movaps	xmm13, XMMWORD PTR [rsp+80]
	movaps	xmm12, XMMWORD PTR [rsp+96]
	mov	ebx, eax
	movaps	xmm11, XMMWORD PTR [rsp+112]
	movaps	xmm10, XMMWORD PTR [rsp+128]
	movaps	xmm9, XMMWORD PTR [rsp+144]
	movaps	xmm8, XMMWORD PTR [rsp+160]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 52   : 		inline_					~Point()													{}

	jmp	$LN183@Subdivide
$LN37@Subdivide:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 200  : 	else if(builder->mRules&SPLIT_BALANCED)

	test	al, 16
	je	$LN27@Subdivide

; 201  : 	{
; 202  : 		// Test 3 axis, take the best
; 203  : 		float Results[3];
; 204  : 		NbPos = Split(0, builder);	Results[0] = float(NbPos)/float(mNbPrimitives);

	mov	r8, rdx
	xor	edx, edx
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split

; 205  : 		NbPos = Split(1, builder);	Results[1] = float(NbPos)/float(mNbPrimitives);

	mov	r14d, 1
	mov	r8, rsi
	mov	ecx, eax
	mov	eax, DWORD PTR [rdi+48]
	xorps	xmm7, xmm7
	xorps	xmm0, xmm0
	mov	edx, r14d
	cvtsi2ss xmm7, rcx
	mov	rcx, rdi
	cvtsi2ss xmm0, rax
	divss	xmm7, xmm0
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
	xorps	xmm6, xmm6
	mov	ecx, eax
	mov	eax, DWORD PTR [rdi+48]

; 206  : 		NbPos = Split(2, builder);	Results[2] = float(NbPos)/float(mNbPrimitives);

	mov	r15d, 2
	mov	r8, rsi
	mov	edx, r15d
	cvtsi2ss xmm6, rcx
	mov	rcx, rdi
	xorps	xmm0, xmm0
	cvtsi2ss xmm0, rax
	divss	xmm6, xmm0
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split

; 207  : 		Results[0]-=0.5f;	Results[0]*=Results[0];

	movss	xmm1, DWORD PTR __real@3f000000
	mov	eax, eax

; 208  : 		Results[1]-=0.5f;	Results[1]*=Results[1];
; 209  : 		Results[2]-=0.5f;	Results[2]*=Results[2];
; 210  : 		udword Min=0;
; 211  : 		if(Results[1]<Results[Min])	Min = 1;

	mov	edx, r13d
	subss	xmm7, xmm1

; 212  : 		if(Results[2]<Results[Min])	Min = 2;
; 213  : 		
; 214  : 		// Split along the axis
; 215  : 		NbPos = Split(Min, builder);

	mov	rcx, rdi
	subss	xmm6, xmm1
	xorps	xmm2, xmm2
	xorps	xmm0, xmm0
	mulss	xmm7, xmm7
	cvtsi2ss xmm2, rax
	mov	eax, DWORD PTR [rdi+48]
	mulss	xmm6, xmm6
	cvtsi2ss xmm0, rax
	comiss	xmm7, xmm6
	movss	DWORD PTR Results$5[rbp-153], xmm7
	cmova	edx, r14d
	divss	xmm2, xmm0
	movss	DWORD PTR Results$5[rbp-149], xmm6
	subss	xmm2, xmm1
	mulss	xmm2, xmm2
	movss	DWORD PTR Results$5[rbp-145], xmm2
	comiss	xmm2, DWORD PTR Results$5[rbp+rdx*4-153]
	cmovb	edx, r15d

; 216  : 
; 217  : 		// Check split validity
; 218  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 219  : 	}

	jmp	$LN186@Subdivide
$LN27@Subdivide:

; 220  : 	else if(builder->mRules&SPLIT_BESTAXIS)

	test	al, 8
	je	$LN21@Subdivide
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 380  : 		inline_	Point			operator*(float s)					const		{ return Point(x * s,   y * s,   z * s );			}

	movss	xmm0, DWORD PTR __real@3f000000

; 375  : 		inline_	Point			operator-(const Point& p)			const		{ return Point(x - p.x, y - p.y, z - p.z);			}

	movss	xmm2, DWORD PTR [rcx+12]
	movss	xmm3, DWORD PTR [rcx+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 226  : 		udword SortedAxis[] = { 0, 1, 2 };

	mov	edx, r13d
	mov	r14d, 1
	mov	r15d, 2
	mov	DWORD PTR SortedAxis$3[rbp-153], edx
	mov	DWORD PTR SortedAxis$3[rbp-149], r14d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 375  : 		inline_	Point			operator-(const Point& p)			const		{ return Point(x - p.x, y - p.y, z - p.z);			}

	subss	xmm2, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+16]
	subss	xmm3, DWORD PTR [rcx+8]

; 380  : 		inline_	Point			operator*(float s)					const		{ return Point(x * s,   y * s,   z * s );			}

	mulss	xmm2, xmm0
	mulss	xmm3, xmm0

; 375  : 		inline_	Point			operator-(const Point& p)			const		{ return Point(x - p.x, y - p.y, z - p.z);			}

	subss	xmm1, DWORD PTR [rcx+4]

; 46   : 		inline_					Point(float _x, float _y, float _z) : x(_x), y(_y), z(_z)	{}

	movss	DWORD PTR $T1[rbp-145], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h

; 116  : 		inline_			void		GetExtents(Point& extents)				const		{ extents = (mMax - mMin)*0.5f;				}

	mov	eax, DWORD PTR $T1[rbp-145]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 226  : 		udword SortedAxis[] = { 0, 1, 2 };

	mov	DWORD PTR SortedAxis$3[rbp-145], r15d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h

; 116  : 		inline_			void		GetExtents(Point& extents)				const		{ extents = (mMax - mMin)*0.5f;				}

	mov	DWORD PTR Extents$4[rbp-145], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h

; 380  : 		inline_	Point			operator*(float s)					const		{ return Point(x * s,   y * s,   z * s );			}

	mulss	xmm1, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h

; 116  : 		inline_			void		GetExtents(Point& extents)				const		{ extents = (mMax - mMin)*0.5f;				}

	movaps	xmm0, xmm2
	unpcklps xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	comiss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h

; 116  : 		inline_			void		GetExtents(Point& extents)				const		{ extents = (mMax - mMin)*0.5f;				}

	movsdx	QWORD PTR Extents$4[rbp-153], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	jae	SHORT $LN16@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	edx, r14d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$3[rbp-149], r13d
	mov	r14d, r13d
	mov	DWORD PTR SortedAxis$3[rbp-153], edx
$LN16@Subdivide:

; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, r14d
	mov	ecx, r14d
	comiss	xmm3, DWORD PTR Extents$4[rbp+rax*4-153]
	jbe	SHORT $LN19@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	r14d, r15d
	mov	DWORD PTR SortedAxis$3[rbp-149], r15d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$3[rbp-145], ecx
	mov	r15d, ecx
$LN19@Subdivide:

; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, r14d
	mov	ecx, edx
	mov	r8d, edx
	movss	xmm0, DWORD PTR Extents$4[rbp+rax*4-153]
	comiss	xmm0, DWORD PTR Extents$4[rbp+rcx*4-153]
	jbe	SHORT $LN158@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	edx, r14d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$3[rbp-149], r8d
	mov	r14d, r8d
	mov	DWORD PTR SortedAxis$3[rbp-153], edx
$LN158@Subdivide:

; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, r15d
	mov	ecx, r14d
	mov	r8d, r14d
	movss	xmm0, DWORD PTR Extents$4[rbp+rax*4-153]
	comiss	xmm0, DWORD PTR Extents$4[rbp+rcx*4-153]
	jbe	SHORT $LN160@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	r14d, r15d
	mov	DWORD PTR SortedAxis$3[rbp-149], r15d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$3[rbp-145], r8d
	mov	r15d, r8d
$LN160@Subdivide:

; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, r14d
	mov	ecx, edx
	movss	xmm0, DWORD PTR Extents$4[rbp+rax*4-153]
	comiss	xmm0, DWORD PTR Extents$4[rbp+rcx*4-153]
	jbe	SHORT $LN165@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	DWORD PTR SortedAxis$3[rbp-153], r14d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$3[rbp-149], edx
	mov	r14d, edx
$LN165@Subdivide:

; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])

	mov	eax, r15d
	mov	ecx, r14d
	movss	xmm0, DWORD PTR Extents$4[rbp+rax*4-153]
	comiss	xmm0, DWORD PTR Extents$4[rbp+rcx*4-153]
	jbe	SHORT $LN167@Subdivide

; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];

	mov	DWORD PTR SortedAxis$3[rbp-149], r15d

; 236  : 					SortedAxis[i+1] = Tmp;

	mov	DWORD PTR SortedAxis$3[rbp-145], r14d
$LN167@Subdivide:

; 237  : 				}
; 238  : 			}
; 239  : 		}
; 240  : 
; 241  : 		// Find the largest axis to split along
; 242  : 		udword CurAxis = 0;

	mov	r14d, r13d
	npad	7
$LL13@Subdivide:

; 243  : 		ValidSplit = false;
; 244  : 		while(!ValidSplit && CurAxis!=3)

	cmp	r14d, 3
	je	$LN173@Subdivide

; 245  : 		{
; 246  : 			NbPos = Split(SortedAxis[CurAxis], builder);

	mov	eax, r14d
	mov	r8, rsi
	mov	rcx, rdi
	mov	edx, DWORD PTR SortedAxis$3[rbp+rax*4-153]
	call	?Split@AABBTreeNode@Opcode@@IEAAIIPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Split
	mov	ebx, eax

; 247  : 			// Check the subdivision has been successful
; 248  : 			if(!NbPos || NbPos==mNbPrimitives)	CurAxis++;

	test	eax, eax
	je	SHORT $LN10@Subdivide
	cmp	eax, DWORD PTR [rdi+48]
	jne	SHORT $LN3@Subdivide
$LN10@Subdivide:
	inc	r14d

; 243  : 		ValidSplit = false;
; 244  : 		while(!ValidSplit && CurAxis!=3)

	jmp	SHORT $LL13@Subdivide
$LN21@Subdivide:

; 249  : 			else								ValidSplit = true;
; 250  : 		}
; 251  : 	}
; 252  : 	else if(builder->mRules&SPLIT_FIFTY)

	test	al, 32					; 00000020H
	je	$LN7@Subdivide
$LN184@Subdivide:

; 253  : 	{
; 254  : 		// Don't even bother splitting (mainly a performance test)
; 255  : 		NbPos = mNbPrimitives>>1;

	shr	ebx, 1
$LN3@Subdivide:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 40   : 		if (0==list)	block_create();

	cmp	QWORD PTR [rsi+32], r13
	jne	SHORT $LN103@Subdivide
	lea	rcx, QWORD PTR [rsi+32]
	call	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
$LN103@Subdivide:

; 41   : 
; 42   : 		T* E			= list;

	mov	rcx, QWORD PTR [rsi+32]

; 43   : 		list			= *access(list);

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rsi+32], rax

; 44   : 		return			new (E) T();

	test	rcx, rcx
	je	SHORT $LN106@Subdivide
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	mov	QWORD PTR [rcx+24], r13
	mov	QWORD PTR [rcx+32], r13
	mov	QWORD PTR [rcx+40], r13
	mov	DWORD PTR [rcx+48], r13d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 44   : 		return			new (E) T();

	jmp	SHORT $LN107@Subdivide
$LN106@Subdivide:
	mov	rcx, r13
$LN107@Subdivide:
	mov	QWORD PTR [rdi+24], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 274  : 	mP = builder->node_alloc();     CHECKALLOC(mP);

	test	rcx, rcx
	je	SHORT $LN7@Subdivide
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 40   : 		if (0==list)	block_create();

	cmp	QWORD PTR [rsi+32], r13
	jne	SHORT $LN116@Subdivide
	lea	rcx, QWORD PTR [rsi+32]
	call	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
$LN116@Subdivide:

; 41   : 
; 42   : 		T* E			= list;

	mov	rcx, QWORD PTR [rsi+32]

; 43   : 		list			= *access(list);

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rsi+32], rax

; 44   : 		return			new (E) T();

	test	rcx, rcx
	je	SHORT $LN119@Subdivide
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	mov	QWORD PTR [rcx+24], r13
	mov	QWORD PTR [rcx+32], r13
	mov	QWORD PTR [rcx+40], r13
	mov	DWORD PTR [rcx+48], r13d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 44   : 		return			new (E) T();

	jmp	SHORT $LN120@Subdivide
$LN119@Subdivide:
	mov	rcx, r13
$LN120@Subdivide:
	mov	QWORD PTR [rdi+32], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 275  : 	mN = builder->node_alloc();		CHECKALLOC(mN);

	test	rcx, rcx
	je	SHORT $LN7@Subdivide
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 99   : 		inline_						void		IncreaseCount(udword nb)		{ mCount+=nb;				}

	add	DWORD PTR [rsi+20], 2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 281  : 	mP->mNodePrimitives	= &mNodePrimitives[0];

	mov	rcx, QWORD PTR [rdi+24]
	mov	rax, QWORD PTR [rdi+40]
	mov	QWORD PTR [rcx+40], rax

; 282  : 	mP->mNbPrimitives	= NbPos;

	mov	rax, QWORD PTR [rdi+24]

; 283  : 	mN->mNodePrimitives	= &mNodePrimitives[NbPos];

	mov	ecx, ebx
	mov	DWORD PTR [rax+48], ebx
	mov	rax, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rax+rcx*4]
	mov	rax, QWORD PTR [rdi+32]
	mov	QWORD PTR [rax+40], rdx

; 284  : 	mN->mNbPrimitives	= mNbPrimitives - NbPos;

	mov	ecx, DWORD PTR [rdi+48]
	mov	rax, QWORD PTR [rdi+32]
	sub	ecx, ebx
	mov	DWORD PTR [rax+48], ecx
$LN4@Subdivide:

; 285  : 
; 286  : 	return true;

	mov	al, 1
	jmp	SHORT $LN181@Subdivide
$LN7@Subdivide:

; 256  : 	}
; 257  : 	else return false;	// Unknown splitting rules

	xor	al, al
$LN181@Subdivide:
	movaps	xmm6, XMMWORD PTR [rsp+192]
	mov	r15, QWORD PTR [rsp+208]
	mov	r14, QWORD PTR [rsp+216]
	mov	r13, QWORD PTR [rsp+272]
	movaps	xmm7, XMMWORD PTR [rsp+176]
$LN176@Subdivide:
	mov	rbx, QWORD PTR [rsp+256]

; 287  : }

	add	rsp, 224				; 000000e0H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTreeNode::Subdivide
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
this$ = 48
builder$ = 56
?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTreeNode::_BuildHierarchy

; 296  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx
	mov	rbx, rcx
$LL5@BuildHiera:

; 297  : 	// 1) Compute the global box for current node. The box is stored in mBV.
; 298  : 	builder->ComputeGlobalBox(mNodePrimitives, mNbPrimitives, mBV);

	mov	rax, QWORD PTR [rdi]
	mov	r8d, DWORD PTR [rbx+48]
	mov	rdx, QWORD PTR [rbx+40]
	mov	r9, rbx
	mov	rcx, rdi
	call	QWORD PTR [rax+8]

; 299  : 
; 300  : 	// 2) Subdivide current node
; 301  : 	Subdivide(builder);

	mov	rdx, rdi
	mov	rcx, rbx
	call	?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Subdivide

; 302  : 
; 303  : 	// 3) Recurse
; 304  : 	if(mP)	mP->_BuildHierarchy(builder);

	mov	rcx, QWORD PTR [rbx+24]
	test	rcx, rcx
	je	SHORT $LN2@BuildHiera
	mov	rdx, rdi
	call	?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::_BuildHierarchy
$LN2@BuildHiera:

; 305  : 	if(mN)	mN->_BuildHierarchy(builder);

	mov	rbx, QWORD PTR [rbx+32]
	test	rbx, rbx
	jne	SHORT $LL5@BuildHiera

; 306  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTreeNode::_BuildHierarchy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
this$ = 8
??0AABBTree@Opcode@@QEAA@XZ PROC			; Opcode::AABBTree::AABBTree

; 58   : {

	xor	eax, eax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	DWORD PTR [rcx+48], eax

; 316  : {

	mov	QWORD PTR [rcx+56], rax
	mov	DWORD PTR [rcx+64], eax

; 317  : }

	mov	rax, rcx
	ret	0
??0AABBTree@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTree::AABBTree
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
this$ = 48
??1AABBTree@Opcode@@QEAA@XZ PROC			; Opcode::AABBTree::~AABBTree

; 325  : {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rcx+56]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 325  : {

	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN3@AABBTree
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+56], 0
$LN3@AABBTree:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 327  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1AABBTree@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTree::~AABBTree
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
_TEXT	SEGMENT
this$ = 48
builder$ = 56
?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z PROC ; Opcode::AABBTree::Build

; 337  : {

$LN33:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 338  : 	// Checkings
; 339  : 	if(!builder || !builder->mNbPrimitives)	return false;

	cmp	DWORD PTR [rdx+16], 0
	mov	rdi, rdx
	mov	rsi, rcx
	jne	SHORT $LN6@Build
	xor	al, al

; 360  : 
; 361  : 	return true;
; 362  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@Build:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 98   : 		inline_						void		SetCount(udword nb)				{ mCount=nb;				}

	mov	QWORD PTR [rdx+20], 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+48], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 101  : 		inline_						void		SetNbInvalidSplits(udword nb)	{ mNbInvalidSplits=nb;		}

	xor	ebx, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN16@Build
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rsi+56], rbx
$LN16@Build:

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, DWORD PTR [rdi+16]
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	rdx, 2
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 347  : 	mIndices	= xr_alloc<udword>(builder->mNbPrimitives);

	mov	QWORD PTR [rsi+56], rax

; 348  : 	CHECKALLOC(mIndices);

	test	rax, rax
	jne	SHORT $LN4@Build
	mov	rbx, QWORD PTR [rsp+48]

; 360  : 
; 361  : 	return true;
; 362  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@Build:

; 349  : 	for(udword i=0;i<builder->mNbPrimitives;i++)	mIndices[i] = i;

	cmp	DWORD PTR [rdi+16], ebx
	jbe	SHORT $LN1@Build
	npad	2
$LL3@Build:
	mov	rax, QWORD PTR [rsi+56]
	mov	ecx, ebx
	mov	DWORD PTR [rax+rcx*4], ebx
	inc	ebx
	cmp	ebx, DWORD PTR [rdi+16]
	jb	SHORT $LL3@Build
$LN1@Build:

; 350  : 
; 351  : 	// Setup initial box
; 352  : 	mNodePrimitives	= mIndices;

	mov	rdx, QWORD PTR [rsi+56]

; 298  : 	builder->ComputeGlobalBox(mNodePrimitives, mNbPrimitives, mBV);

	mov	r9, rsi
	mov	rcx, rdi

; 350  : 
; 351  : 	// Setup initial box
; 352  : 	mNodePrimitives	= mIndices;

	mov	QWORD PTR [rsi+40], rdx

; 353  : 	mNbPrimitives	= builder->mNbPrimitives;

	mov	r8d, DWORD PTR [rdi+16]
	mov	DWORD PTR [rsi+48], r8d

; 298  : 	builder->ComputeGlobalBox(mNodePrimitives, mNbPrimitives, mBV);

	mov	rax, QWORD PTR [rdi]
	call	QWORD PTR [rax+8]

; 299  : 
; 300  : 	// 2) Subdivide current node
; 301  : 	Subdivide(builder);

	mov	rdx, rdi
	mov	rcx, rsi
	call	?Subdivide@AABBTreeNode@Opcode@@IEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::Subdivide

; 302  : 
; 303  : 	// 3) Recurse
; 304  : 	if(mP)	mP->_BuildHierarchy(builder);

	mov	rcx, QWORD PTR [rsi+24]
	test	rcx, rcx
	je	SHORT $LN22@Build
	mov	rdx, rdi
	call	?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::_BuildHierarchy
$LN22@Build:

; 305  : 	if(mN)	mN->_BuildHierarchy(builder);

	mov	rcx, QWORD PTR [rsi+32]
	test	rcx, rcx
	je	SHORT $LN21@Build
	mov	rdx, rdi
	call	?_BuildHierarchy@AABBTreeNode@Opcode@@IEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::_BuildHierarchy
$LN21@Build:

; 354  : 
; 355  : 	// Build the hierarchy
; 356  : 	_BuildHierarchy(builder);
; 357  : 
; 358  : 	// Get back total number of nodes
; 359  : 	mTotalNbNodes	= builder->GetCount();

	mov	eax, DWORD PTR [rdi+20]
	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rsi+64], eax

; 360  : 
; 361  : 	return true;
; 362  : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	al, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z ENDP ; Opcode::AABBTree::Build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.h
;	COMDAT ?GetNbNodes@AABBTree@Opcode@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?GetNbNodes@AABBTree@Opcode@@QEBAIXZ PROC		; Opcode::AABBTree::GetNbNodes, COMDAT

; 77   : 		inline_	udword				GetNbNodes()		const	{ return mTotalNbNodes;	}	//!< Catch the number of nodes

	mov	eax, DWORD PTR [rcx+64]
	ret	0
?GetNbNodes@AABBTree@Opcode@@QEBAIXZ ENDP		; Opcode::AABBTree::GetNbNodes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?GetCount@AABBTreeBuilder@Opcode@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?GetCount@AABBTreeBuilder@Opcode@@QEBAIXZ PROC		; Opcode::AABBTreeBuilder::GetCount, COMDAT

; 100  : 		inline_						udword		GetCount()				const	{ return mCount;			}

	mov	eax, DWORD PTR [rcx+20]
	ret	0
?GetCount@AABBTreeBuilder@Opcode@@QEBAIXZ ENDP		; Opcode::AABBTreeBuilder::GetCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?SetNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
nb$dead$ = 16
?SetNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXI@Z PROC ; Opcode::AABBTreeBuilder::SetNbInvalidSplits, COMDAT

; 101  : 		inline_						void		SetNbInvalidSplits(udword nb)	{ mNbInvalidSplits=nb;		}

	mov	DWORD PTR [rcx+24], 0
	ret	0
?SetNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXI@Z ENDP ; Opcode::AABBTreeBuilder::SetNbInvalidSplits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?SetCount@AABBTreeBuilder@Opcode@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
nb$dead$ = 16
?SetCount@AABBTreeBuilder@Opcode@@QEAAXI@Z PROC		; Opcode::AABBTreeBuilder::SetCount, COMDAT

; 98   : 		inline_						void		SetCount(udword nb)				{ mCount=nb;				}

	mov	DWORD PTR [rcx+20], 1
	ret	0
?SetCount@AABBTreeBuilder@Opcode@@QEAAXI@Z ENDP		; Opcode::AABBTreeBuilder::SetCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?IncreaseCount@AABBTreeBuilder@Opcode@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
nb$dead$ = 16
?IncreaseCount@AABBTreeBuilder@Opcode@@QEAAXI@Z PROC	; Opcode::AABBTreeBuilder::IncreaseCount, COMDAT

; 99   : 		inline_						void		IncreaseCount(udword nb)		{ mCount+=nb;				}

	add	DWORD PTR [rcx+20], 2
	ret	0
?IncreaseCount@AABBTreeBuilder@Opcode@@QEAAXI@Z ENDP	; Opcode::AABBTreeBuilder::IncreaseCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_alloc@VAABBTreeNode@Opcode@@@@YAPEAVAABBTreeNode@Opcode@@I@Z
_TEXT	SEGMENT
count$dead$ = 8
??$xr_alloc@VAABBTreeNode@Opcode@@@@YAPEAVAABBTreeNode@Opcode@@I@Z PROC ; xr_alloc<Opcode::AABBTreeNode>, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 917504				; 000e0000H
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
??$xr_alloc@VAABBTreeNode@Opcode@@@@YAPEAVAABBTreeNode@Opcode@@I@Z ENDP ; xr_alloc<Opcode::AABBTreeNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_NPEBQEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_NPEBQEAVAABBTreeNode@Opcode@@@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Inside, COMDAT

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1584 : 		}

	ret	0
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	xor	al, al

; 1584 : 		}

	ret	0
?_Inside@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_NPEBQEAVAABBTreeNode@Opcode@@@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QEAVAABBTreeNode@Opcode@@@std@@YAPEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@QEAVAABBTreeNode@Opcode@@@std@@YAPEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z PROC ; std::addressof<Opcode::AABBTreeNode * __ptr64 const>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@QEAVAABBTreeNode@Opcode@@@std@@YAPEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ENDP ; std::addressof<Opcode::AABBTreeNode * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEAPEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEAPEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8], rax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEAPEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVAABBTreeNode@Opcode@@AEAPEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVAABBTreeNode@Opcode@@AEAPEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV34@@Z PROC ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@PEAVAABBTreeNode@Opcode@@AEAPEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEAPEAV34@@Z ENDP ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEAVAABBTreeNode@Opcode@@@std@@YAAEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVAABBTreeNode@Opcode@@@std@@YAAEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z PROC ; std::forward<Opcode::AABBTreeNode * __ptr64 & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAPEAVAABBTreeNode@Opcode@@@std@@YAAEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z ENDP ; std::forward<Opcode::AABBTreeNode * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVAABBTreeNode@Opcode@@AEAPEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEAPEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVAABBTreeNode@Opcode@@AEAPEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEAPEAV23@@Z PROC ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAVAABBTreeNode@Opcode@@AEAPEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEAPEAV23@@Z ENDP ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 3

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Xlen, COMDAT

; 1753 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_alloc@PEAVAABBTreeNode@Opcode@@@@YAPEAPEAVAABBTreeNode@Opcode@@I@Z
_TEXT	SEGMENT
count$ = 8
??$xr_alloc@PEAVAABBTreeNode@Opcode@@@@YAPEAPEAVAABBTreeNode@Opcode@@I@Z PROC ; xr_alloc<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ecx
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	shl	rdx, 3
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
??$xr_alloc@PEAVAABBTreeNode@Opcode@@@@YAPEAPEAVAABBTreeNode@Opcode@@I@Z ENDP ; xr_alloc<Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAPEAPEAVAABBTreeNode@Opcode@@_KPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
n$ = 16
p$dead$ = 24
?allocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAPEAPEAVAABBTreeNode@Opcode@@_KPEBX@Z PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, edx
	shl	rdx, 3
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAPEAPEAVAABBTreeNode@Opcode@@_KPEBX@Z ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAPEAPEAVAABBTreeNode@Opcode@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAPEAPEAVAABBTreeNode@Opcode@@_K@Z PROC ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, edx
	shl	rdx, 3
	rex_jmp	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
?allocate@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAPEAPEAVAABBTreeNode@Opcode@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@std@@YAAEAPEAPEAVAABBTreeNode@Opcode@@AEAPEAPEAV12@PEAPEAV12@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@std@@YAAEAPEAPEAVAABBTreeNode@Opcode@@AEAPEAPEAV12@PEAPEAV12@@Z PROC ; std::_Rechecked<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@std@@YAAEAPEAPEAVAABBTreeNode@Opcode@@AEAPEAPEAV12@PEAPEAV12@@Z ENDP ; std::_Rechecked<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@PEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@PEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8], rax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@PEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVAABBTreeNode@Opcode@@PEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVAABBTreeNode@Opcode@@PEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV34@@Z PROC ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@PEAVAABBTreeNode@Opcode@@PEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV34@@Z ENDP ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PEAVAABBTreeNode@Opcode@@@std@@YA$$QEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVAABBTreeNode@Opcode@@@std@@YA$$QEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z PROC ; std::forward<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@PEAVAABBTreeNode@Opcode@@@std@@YA$$QEAPEAVAABBTreeNode@Opcode@@AEAPEAV12@@Z ENDP ; std::forward<Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVAABBTreeNode@Opcode@@PEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVAABBTreeNode@Opcode@@PEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV23@@Z PROC ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAVAABBTreeNode@Opcode@@PEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@$$QEAPEAV23@@Z ENDP ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy@PEAVAABBTreeNode@Opcode@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
_Ptr$dead$ = 8
??$_Destroy@PEAVAABBTreeNode@Opcode@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@@Z PROC ; std::_Destroy<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 55   : 	_Ptr->~_Ty();
; 56   : 	}

	ret	0
??$_Destroy@PEAVAABBTreeNode@Opcode@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; std::_Destroy<Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$dead$ = 16
?destroy@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::destroy, COMDAT

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy(p);			}

	ret	0
?destroy@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$dead$ = 24
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z PROC ; std::_Alloc_destroy::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; std::_Alloc_destroy::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAVAABBTreeNode@Opcode@@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAVAABBTreeNode@Opcode@@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z PROC ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::destroy<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}

	ret	0
??$destroy@PEAVAABBTreeNode@Opcode@@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::destroy<Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAVAABBTreeNode@Opcode@@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAVAABBTreeNode@Opcode@@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z PROC ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::destroy<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	0
??$destroy@PEAVAABBTreeNode@Opcode@@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::destroy<Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [r8], rax
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 8
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 8
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 459  : 	{	// move [_First, _Last) to raw _Dest, using _Al, scalar type

$LN4:
	sub	rsp, 56					; 00000038H

; 460  : 	return (_Uninit_move(_First, _Last, _Dest,
; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>

; 462  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z PROC ; std::_Val_type<Opcode::AABBTreeNode * __ptr64 * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z ENDP ; std::_Val_type<Opcode::AABBTreeNode * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z PROC ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z ENDP ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z PROC ; std::_Unchecked<Opcode::AABBTreeNode * __ptr64 * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAPEAVAABBTreeNode@Opcode@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@@Z ENDP ; std::_Unchecked<Opcode::AABBTreeNode * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z PROC ; std::_Uninitialized_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z ENDP ; std::_Uninitialized_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Umove<Opcode::AABBTreeNode * __ptr64 * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAPEAVAABBTreeNode@Opcode@@@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV23@00@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Umove<Opcode::AABBTreeNode * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >, COMDAT

; 90   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PEAVAABBTreeNode@Opcode@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVAABBTreeNode@Opcode@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@PEAVAABBTreeNode@Opcode@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVAABBTreeNode@Opcode@@0@Z PROC ; std::_Ptr_cat<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@PEAVAABBTreeNode@Opcode@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVAABBTreeNode@Opcode@@0@Z ENDP ; std::_Ptr_cat<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXPEAPEAVAABBTreeNode@Opcode@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXPEAPEAVAABBTreeNode@Opcode@@0@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Destroy, COMDAT

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

	ret	0
?_Destroy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXPEAPEAVAABBTreeNode@Opcode@@0@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z PROC ; xr_free<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@xr_free
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx], 0
$LN1@xr_free:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_free@PEAVAABBTreeNode@Opcode@@@@YAXAEAPEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; xr_free<Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
n$dead$ = 24
?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN3@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN3@deallocate:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	ret	0
?deallocate@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBAXPEAPEAVAABBTreeNode@Opcode@@_K@Z ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@_K@Z PROC ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::deallocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN5@deallocate
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN5@deallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 859  : 		}

	ret	0
?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reallocate, COMDAT

; 1587 : 		{	// move to array of exactly _Count elements

$LN60:
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	r14, rdx
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, edx
	shl	rdx, 3
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	rsi, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, rax
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninit_move@PEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAV12@@std@@YAPEAPEAVAABBTreeNode@Opcode@@PEAPEAV12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<Opcode::AABBTreeNode * __ptr64 * __ptr64,Opcode::AABBTreeNode * __ptr64 * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rdx, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]
	sub	rdi, rdx
	sar	rdi, 3

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN54@Reallocate
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN54@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

	lea	rax, QWORD PTR [rsi+r14*8]
	mov	QWORD PTR [rbx+16], rax

; 1607 : 		this->_Mylast = _Ptr + _Size;

	lea	rax, QWORD PTR [rsi+rdi*8]
	mov	QWORD PTR [rbx+8], rax

; 1608 : 		this->_Myfirst = _Ptr;

	mov	QWORD PTR [rbx], rsi

; 1609 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN59@Reallocate:
?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Ptr$ = 88
_Count$ = 88
?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reallocate'::`1'::catch$0

; 1592 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z$0:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR _Ptr$[rbp]
	test	rdx, rdx
	je	SHORT $LN43@catch$0
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN43@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1594 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::capacity, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1011 : 		}

	ret	0
?capacity@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBA_KXZ PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::max_size, COMDAT

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	ret	0
?max_size@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEBA_KXZ ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z PROC ; std::_Alloc_max_size::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT

; 381  : 		return (_Al.max_size());

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 382  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ENDP ; std::_Alloc_max_size::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SA_KAEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SA_KAEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z PROC ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size, COMDAT

; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 482  : 		}

	ret	0
?max_size@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SA_KAEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ENDP ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size, COMDAT

; 1153 : 		return (this->_Getal().max_size());

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1154 : 		}

	ret	0
?max_size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_K_K@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r8, QWORD PTR [rcx]
	sar	r8, 3

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to
	xor	r8d, r8d

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size, COMDAT

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1149 : 		}

	ret	0
?size@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEBA_KXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve, COMDAT

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

$LN47:
	sub	rsp, 40					; 00000028H

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, QWORD PTR [rcx+8]
	mov	rax, rdx
	sub	rax, r8
	sar	rax, 3

; 1613 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r10, QWORD PTR [rcx]

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	r9, 2305843009213693951			; 1fffffffffffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r8, r10

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	rax, r9

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sar	r8, 3

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	sub	rax, r8
	cmp	rax, 1
	jae	SHORT $LN1@Reserve

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@Reserve:

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rdx, r10

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	r8

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sar	rdx, 3

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rdx
	shr	rax, 1
	sub	r9, rax
	cmp	r9, rdx
	jae	SHORT $LN29@Reserve
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reallocate
$LN29@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rax

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN46@Reserve:
?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXPEAPEAVAABBTreeNode@Opcode@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXPEAPEAVAABBTreeNode@Opcode@@0@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEBAXPEAPEAVAABBTreeNode@Opcode@@0@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Val$ = 16
??$_Construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z PROC ; std::_Construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>, COMDAT

; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN3@Construct
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN3@Construct:

; 41   : 	}

	ret	0
??$_Construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@std@@YAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ENDP ; std::_Construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
_Val$ = 24
?construct@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z PROC ; xalloc<Opcode::AABBTreeNode * __ptr64>::construct, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN5@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN5@construct:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	std::_Construct(p, _Val);	}

	ret	0
?construct@?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z ENDP ; xalloc<Opcode::AABBTreeNode * __ptr64>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEBQEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEBQEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8], rax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAVAABBTreeNode@Opcode@@AEBQEAV23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<Opcode::AABBTreeNode * __ptr64>,Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV34@@Z PROC ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@?$allocator_traits@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@SAXAEAV?$xalloc@PEAVAABBTreeNode@Opcode@@@@PEAPEAVAABBTreeNode@Opcode@@AEBQEAV34@@Z ENDP ; std::allocator_traits<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEBQEAVAABBTreeNode@Opcode@@@std@@YAAEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAVAABBTreeNode@Opcode@@@std@@YAAEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z PROC ; std::forward<Opcode::AABBTreeNode * __ptr64 const & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEBQEAVAABBTreeNode@Opcode@@@std@@YAAEBQEAVAABBTreeNode@Opcode@@AEBQEAV12@@Z ENDP ; std::forward<Opcode::AABBTreeNode * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z PROC ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAVAABBTreeNode@Opcode@@AEBQEAV12@@?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXPEAPEAVAABBTreeNode@Opcode@@AEBQEAV23@@Z ENDP ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::construct<Opcode::AABBTreeNode * __ptr64,Opcode::AABBTreeNode * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAA@XZ PROC	; xalloc<Opcode::AABBTreeNode * __ptr64>::xalloc<Opcode::AABBTreeNode * __ptr64>, COMDAT

; 76   : 													xalloc			()										{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@PEAVAABBTreeNode@Opcode@@@@QEAA@XZ ENDP	; xalloc<Opcode::AABBTreeNode * __ptr64>::xalloc<Opcode::AABBTreeNode * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT

; 802  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >::_Wrap_alloc<xalloc<Opcode::AABBTreeNode * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >::_Getal, COMDAT

; 642  : 		return (_Alty());

	mov	rax, rdx

; 643  : 		}

	ret	0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::push_back, COMDAT

; 1243 : 		{	// insert element at end

$LN69:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]

; 1243 : 		{	// insert element at end

	mov	rdi, rdx
	mov	rbx, rcx

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN4@push_back
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	sub	rdi, rcx
	sar	rdi, 3

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN61@push_back
	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax+rdi*8]
	mov	QWORD PTR [rdx], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 8

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAX_K@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN61@push_back
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx], rax
$LN61@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 8

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
;	COMDAT ?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create, COMDAT

; 14   : 	{

$LN21:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 917504				; 000e0000H
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 18   : 		blocks.push_back	(list);

	lea	rcx, QWORD PTR [rbx+8]
	mov	rdx, rbx
	mov	QWORD PTR [rbx], rax
	call	?push_back@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAAXAEBQEAVAABBTreeNode@Opcode@@@Z ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::push_back
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	xor	eax, eax
	npad	4
$LL3@block_crea:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 23   : 			T*		E			= list+it;

	mov	rdx, QWORD PTR [rbx]

; 24   : 			*access(E)			= E+1;

	lea	rcx, QWORD PTR [rdx+56]
	add	rcx, rax
	mov	QWORD PTR [rdx+rax], rcx
	mov	rdx, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdx+112]
	add	rcx, rax
	mov	QWORD PTR [rdx+rax+56], rcx
	mov	rdx, QWORD PTR [rbx]
	lea	rcx, QWORD PTR [rdx+168]
	add	rcx, rax
	add	rax, 168				; 000000a8H
	mov	QWORD PTR [rdx+rax-56], rcx
	cmp	rax, 917448				; 000dffc8H
	jl	SHORT $LL3@block_crea

; 25   : 		}
; 26   : 		*access(list+granularity-1)	= NULL;

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rax+917448], 0

; 27   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
;	COMDAT ?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ
_TEXT	SEGMENT
this$ = 48
?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::create, COMDAT

; 39   : 	{

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 40   : 		if (0==list)	block_create();

	cmp	QWORD PTR [rcx], 0
	mov	rbx, rcx
	jne	SHORT $LN1@create
	call	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
$LN1@create:

; 41   : 
; 42   : 		T* E			= list;

	mov	rax, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	xor	ecx, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 43   : 		list			= *access(list);

	mov	rdx, QWORD PTR [rax]
	mov	QWORD PTR [rbx], rdx

; 44   : 		return			new (E) T();

	test	rax, rax
	je	SHORT $LN4@create
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	mov	QWORD PTR [rax+24], rcx
	mov	QWORD PTR [rax+32], rcx
	mov	QWORD PTR [rax+40], rcx
	mov	DWORD PTR [rax+48], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 45   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@create:

; 44   : 		return			new (E) T();

	mov	rax, rcx

; 45   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAPEAVAABBTreeNode@2@XZ ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ
_TEXT	SEGMENT
this$ = 48
?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ PROC ; Opcode::AABBTreeBuilder::node_alloc, COMDAT

; 110  : 		inline_					AABBTreeNode*	node_alloc	()					{return mPOOL.create();		}

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 40   : 		if (0==list)	block_create();

	cmp	QWORD PTR [rcx+32], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 110  : 		inline_					AABBTreeNode*	node_alloc	()					{return mPOOL.create();		}

	lea	rbx, QWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 40   : 		if (0==list)	block_create();

	jne	SHORT $LN3@node_alloc
	mov	rcx, rbx
	call	?block_create@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAXXZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::block_create
$LN3@node_alloc:

; 41   : 
; 42   : 		T* E			= list;

	mov	rax, QWORD PTR [rbx]

; 43   : 		list			= *access(list);

	mov	rcx, QWORD PTR [rax]
	mov	QWORD PTR [rbx], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	xor	ecx, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 44   : 		return			new (E) T();

	test	rax, rax
	je	SHORT $LN6@node_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	mov	QWORD PTR [rax+24], rcx
	mov	QWORD PTR [rax+32], rcx
	mov	QWORD PTR [rax+40], rcx
	mov	DWORD PTR [rax+48], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 110  : 		inline_					AABBTreeNode*	node_alloc	()					{return mPOOL.create();		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN6@node_alloc:
	mov	rax, rcx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?node_alloc@AABBTreeBuilder@Opcode@@QEAAPEAVAABBTreeNode@2@XZ ENDP ; Opcode::AABBTreeBuilder::node_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?IncreaseNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?IncreaseNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXXZ PROC ; Opcode::AABBTreeBuilder::IncreaseNbInvalidSplits, COMDAT

; 102  : 		inline_						void		IncreaseNbInvalidSplits()		{ mNbInvalidSplits++;		}

	inc	DWORD PTR [rcx+24]
	ret	0
?IncreaseNbInvalidSplits@AABBTreeBuilder@Opcode@@QEAAXXZ ENDP ; Opcode::AABBTreeBuilder::IncreaseNbInvalidSplits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
;	COMDAT ??_0icePoint@IceMaths@@QEAAAEAV01@M@Z
_TEXT	SEGMENT
this$ = 8
s$ = 16
??_0icePoint@IceMaths@@QEAAAEAV01@M@Z PROC		; IceMaths::icePoint::operator/=, COMDAT

; 420  : 		inline_	Point&			operator/=(float s)								{ s = 1.0f/s; x *= s; y *= s; z *= s; return *this; }

	movss	xmm2, DWORD PTR __real@3f800000
	mov	rax, rcx
	divss	xmm2, xmm1
	movaps	xmm0, xmm2
	movaps	xmm1, xmm2
	mulss	xmm2, DWORD PTR [rcx+8]
	mulss	xmm0, DWORD PTR [rcx]
	mulss	xmm1, DWORD PTR [rcx+4]
	movss	DWORD PTR [rcx+8], xmm2
	movss	DWORD PTR [rcx], xmm0
	movss	DWORD PTR [rcx+4], xmm1
	ret	0
??_0icePoint@IceMaths@@QEAAAEAV01@M@Z ENDP		; IceMaths::icePoint::operator/=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_point.h
;	COMDAT ?LargestAxis@icePoint@IceMaths@@QEBA?AW4PointComponent@2@XZ
_TEXT	SEGMENT
this$ = 8
?LargestAxis@icePoint@IceMaths@@QEBA?AW4PointComponent@2@XZ PROC ; IceMaths::icePoint::LargestAxis, COMDAT

; 320  : 									const float* Vals = &x;
; 321  : 									PointComponent m = _X;
; 322  : 									if(Vals[_Y] > Vals[m]) m = _Y;

	movss	xmm0, DWORD PTR [rcx]
	xor	eax, eax
	mov	edx, 1
	comiss	xmm0, DWORD PTR [rcx+4]

; 323  : 									if(Vals[_Z] > Vals[m]) m = _Z;

	mov	r8d, 2
	cmovb	eax, edx
	movsxd	rdx, eax
	movss	xmm0, DWORD PTR [rcx+rdx*4]
	comiss	xmm0, DWORD PTR [rcx+8]
	cmovb	eax, r8d

; 324  : 									return m;
; 325  : 								}

	ret	0
?LargestAxis@icePoint@IceMaths@@QEBA?AW4PointComponent@2@XZ ENDP ; IceMaths::icePoint::LargestAxis
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_GAABBTreeNode@Opcode@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 8
__flags$dead$ = 16
??_GAABBTreeNode@Opcode@@QEAAPEAXI@Z PROC		; Opcode::AABBTreeNode::`scalar deleting destructor', COMDAT
	mov	rax, rcx
	ret	0
??_GAABBTreeNode@Opcode@@QEAAPEAXI@Z ENDP		; Opcode::AABBTreeNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
;	COMDAT ?access@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAPEAPEAVAABBTreeNode@2@PEAV32@@Z
_TEXT	SEGMENT
this$dead$ = 8
P$ = 16
?access@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAPEAPEAVAABBTreeNode@2@PEAV32@@Z PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::access, COMDAT

; 12   : 	T**					access			(T* P)	{ return (T**) LPVOID(P);	}

	mov	rax, rdx
	ret	0
?access@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@AEAAPEAPEAVAABBTreeNode@2@PEAV32@@Z ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::access
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
;	COMDAT ?destroy@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z
_TEXT	SEGMENT
this$ = 8
P$ = 16
?destroy@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::destroy, COMDAT

; 48   : 		P->~T			();
; 49   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rcx]

; 12   : 	T**					access			(T* P)	{ return (T**) LPVOID(P);	}

	mov	r8, QWORD PTR [rdx]

; 48   : 		P->~T			();
; 49   : 		*access(P)		= list;

	mov	QWORD PTR [r8], rax

; 50   : 		list			= P;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 51   : 		P				= NULL;

	mov	QWORD PTR [rdx], 0

; 52   : 	}

	ret	0
?destroy@?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?node_destroy@AABBTreeBuilder@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z
_TEXT	SEGMENT
this$ = 8
n$ = 16
?node_destroy@AABBTreeBuilder@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z PROC ; Opcode::AABBTreeBuilder::node_destroy, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 49   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rcx+32]

; 12   : 	T**					access			(T* P)	{ return (T**) LPVOID(P);	}

	mov	r8, QWORD PTR [rdx]

; 49   : 		*access(P)		= list;

	mov	QWORD PTR [r8], rax

; 50   : 		list			= P;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx+32], rax

; 51   : 		P				= NULL;

	mov	QWORD PTR [rdx], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 111  : 		inline_						void		node_destroy(AABBTreeNode* &n)	{return mPOOL.destroy(n);	}

	ret	0
?node_destroy@AABBTreeBuilder@Opcode@@QEAAXAEAPEAVAABBTreeNode@2@@Z ENDP ; Opcode::AABBTreeBuilder::node_destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
;	COMDAT ??1AABB@Meshmerizer@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1AABB@Meshmerizer@@QEAA@XZ PROC			; Meshmerizer::AABB::~AABB, COMDAT

; 38   : 		inline_						~AABB()	{}

	ret	0
??1AABB@Meshmerizer@@QEAA@XZ ENDP			; Meshmerizer::AABB::~AABB
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
;	COMDAT ??0AABB@Meshmerizer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AABB@Meshmerizer@@QEAA@XZ PROC			; Meshmerizer::AABB::AABB, COMDAT

; 36   : 		inline_						AABB()	{}

	mov	rax, rcx
	ret	0
??0AABB@Meshmerizer@@QEAA@XZ ENDP			; Meshmerizer::AABB::AABB
_TEXT	ENDS
END
