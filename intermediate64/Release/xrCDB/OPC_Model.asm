; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0FL@HIPFHKCC@OPCODE?5WARNING?3?5found?5?$CFd?5degener@ ; `string'
PUBLIC	??_R4AABBTreeBuilder@Opcode@@6B@		; Opcode::AABBTreeBuilder::`RTTI Complete Object Locator'
PUBLIC	??_7AABBTreeBuilder@Opcode@@6B@			; Opcode::AABBTreeBuilder::`vftable'
PUBLIC	??_R0?AVAABBTreeOfTrianglesBuilder@Opcode@@@8	; Opcode::AABBTreeOfTrianglesBuilder `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@AABBTreeOfTrianglesBuilder@Opcode@@8 ; Opcode::AABBTreeOfTrianglesBuilder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVAABBTreeBuilder@Opcode@@@8		; Opcode::AABBTreeBuilder `RTTI Type Descriptor'
PUBLIC	??_R2AABBTreeBuilder@Opcode@@8			; Opcode::AABBTreeBuilder::`RTTI Base Class Array'
PUBLIC	??_R3AABBTreeBuilder@Opcode@@8			; Opcode::AABBTreeBuilder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@AABBTreeBuilder@Opcode@@8		; Opcode::AABBTreeBuilder::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2AABBTreeOfTrianglesBuilder@Opcode@@8	; Opcode::AABBTreeOfTrianglesBuilder::`RTTI Base Class Array'
PUBLIC	??_R3AABBTreeOfTrianglesBuilder@Opcode@@8	; Opcode::AABBTreeOfTrianglesBuilder::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4AABBTreeOfTrianglesBuilder@Opcode@@6B@	; Opcode::AABBTreeOfTrianglesBuilder::`RTTI Complete Object Locator'
PUBLIC	??_7AABBTreeOfTrianglesBuilder@Opcode@@6B@	; Opcode::AABBTreeOfTrianglesBuilder::`vftable'
;	COMDAT ??_7AABBTreeOfTrianglesBuilder@Opcode@@6B@
CONST	SEGMENT
??_7AABBTreeOfTrianglesBuilder@Opcode@@6B@ DQ FLAT:??_R4AABBTreeOfTrianglesBuilder@Opcode@@6B@ ; Opcode::AABBTreeOfTrianglesBuilder::`vftable'
	DQ	FLAT:??_EAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z
	DQ	FLAT:?ComputeGlobalBox@AABBTreeOfTrianglesBuilder@Opcode@@UEBA_NPEBIIAEAVAABB@Meshmerizer@@@Z
	DQ	FLAT:?GetSplittingValue@AABBTreeOfTrianglesBuilder@Opcode@@UEBAMII@Z
	DQ	FLAT:?GetSplittingValueEx@AABBTreeBuilder@Opcode@@UEBAMPEBIIAEBVAABB@Meshmerizer@@I@Z
	DQ	FLAT:?GetSplittingValue@AABBTreeOfTrianglesBuilder@Opcode@@UEBAMPEBIIAEBVAABB@Meshmerizer@@I@Z
CONST	ENDS
;	COMDAT ??_R4AABBTreeOfTrianglesBuilder@Opcode@@6B@
rdata$r	SEGMENT
??_R4AABBTreeOfTrianglesBuilder@Opcode@@6B@ DD 01H	; Opcode::AABBTreeOfTrianglesBuilder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVAABBTreeOfTrianglesBuilder@Opcode@@@8
	DD	imagerel ??_R3AABBTreeOfTrianglesBuilder@Opcode@@8
	DD	imagerel ??_R4AABBTreeOfTrianglesBuilder@Opcode@@6B@
rdata$r	ENDS
;	COMDAT ??_R3AABBTreeOfTrianglesBuilder@Opcode@@8
rdata$r	SEGMENT
??_R3AABBTreeOfTrianglesBuilder@Opcode@@8 DD 00H	; Opcode::AABBTreeOfTrianglesBuilder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2AABBTreeOfTrianglesBuilder@Opcode@@8
rdata$r	ENDS
;	COMDAT ??_R2AABBTreeOfTrianglesBuilder@Opcode@@8
rdata$r	SEGMENT
??_R2AABBTreeOfTrianglesBuilder@Opcode@@8 DD imagerel ??_R1A@?0A@EA@AABBTreeOfTrianglesBuilder@Opcode@@8 ; Opcode::AABBTreeOfTrianglesBuilder::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@AABBTreeBuilder@Opcode@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AABBTreeBuilder@Opcode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AABBTreeBuilder@Opcode@@8 DD imagerel ??_R0?AVAABBTreeBuilder@Opcode@@@8 ; Opcode::AABBTreeBuilder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3AABBTreeBuilder@Opcode@@8
rdata$r	ENDS
;	COMDAT ??_R3AABBTreeBuilder@Opcode@@8
rdata$r	SEGMENT
??_R3AABBTreeBuilder@Opcode@@8 DD 00H			; Opcode::AABBTreeBuilder::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2AABBTreeBuilder@Opcode@@8
rdata$r	ENDS
;	COMDAT ??_R2AABBTreeBuilder@Opcode@@8
rdata$r	SEGMENT
??_R2AABBTreeBuilder@Opcode@@8 DD imagerel ??_R1A@?0A@EA@AABBTreeBuilder@Opcode@@8 ; Opcode::AABBTreeBuilder::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVAABBTreeBuilder@Opcode@@@8
data$r	SEGMENT
??_R0?AVAABBTreeBuilder@Opcode@@@8 DQ FLAT:??_7type_info@@6B@ ; Opcode::AABBTreeBuilder `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVAABBTreeBuilder@Opcode@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AABBTreeOfTrianglesBuilder@Opcode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AABBTreeOfTrianglesBuilder@Opcode@@8 DD imagerel ??_R0?AVAABBTreeOfTrianglesBuilder@Opcode@@@8 ; Opcode::AABBTreeOfTrianglesBuilder::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3AABBTreeOfTrianglesBuilder@Opcode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAABBTreeOfTrianglesBuilder@Opcode@@@8
data$r	SEGMENT
??_R0?AVAABBTreeOfTrianglesBuilder@Opcode@@@8 DQ FLAT:??_7type_info@@6B@ ; Opcode::AABBTreeOfTrianglesBuilder `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVAABBTreeOfTrianglesBuilder@Opcode@@', 00H
data$r	ENDS
;	COMDAT ??_7AABBTreeBuilder@Opcode@@6B@
CONST	SEGMENT
??_7AABBTreeBuilder@Opcode@@6B@ DQ FLAT:??_R4AABBTreeBuilder@Opcode@@6B@ ; Opcode::AABBTreeBuilder::`vftable'
	DQ	FLAT:??_EAABBTreeBuilder@Opcode@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:?GetSplittingValueEx@AABBTreeBuilder@Opcode@@UEBAMPEBIIAEBVAABB@Meshmerizer@@I@Z
CONST	ENDS
;	COMDAT ??_R4AABBTreeBuilder@Opcode@@6B@
rdata$r	SEGMENT
??_R4AABBTreeBuilder@Opcode@@6B@ DD 01H			; Opcode::AABBTreeBuilder::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVAABBTreeBuilder@Opcode@@@8
	DD	imagerel ??_R3AABBTreeBuilder@Opcode@@8
	DD	imagerel ??_R4AABBTreeBuilder@Opcode@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0FL@HIPFHKCC@OPCODE?5WARNING?3?5found?5?$CFd?5degener@
CONST	SEGMENT
??_C@_0FL@HIPFHKCC@OPCODE?5WARNING?3?5found?5?$CFd?5degener@ DB 'OPCODE W'
	DB	'ARNING: found %d degenerate faces in model! Collision might r'
	DB	'eport wrong results!', 0aH, 00H		; `string'
PUBLIC	??0AABBTreeOfTrianglesBuilder@Opcode@@QEAA@XZ	; Opcode::AABBTreeOfTrianglesBuilder::AABBTreeOfTrianglesBuilder
PUBLIC	?GetSplittingValueEx@AABBTreeBuilder@Opcode@@UEBAMPEBIIAEBVAABB@Meshmerizer@@I@Z ; Opcode::AABBTreeBuilder::GetSplittingValueEx
PUBLIC	?GetCenter@AABB@Meshmerizer@@QEBAMI@Z		; Meshmerizer::AABB::GetCenter
PUBLIC	??_GAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z ; Opcode::AABBTreeOfTrianglesBuilder::`scalar deleting destructor'
PUBLIC	??1AABBTreeBuilder@Opcode@@UEAA@XZ		; Opcode::AABBTreeBuilder::~AABBTreeBuilder
PUBLIC	??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::~poolSS<Opcode::AABBTreeNode,16384>
PUBLIC	??A?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAAAEAPEAVAABBTreeNode@Opcode@@_K@Z ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::operator[]
PUBLIC	?begin@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@2@XZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::begin
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAA@PEAPEAVAABBTreeNode@Opcode@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAA@PEAPEAVAABBTreeNode@Opcode@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+=
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBAAEAPEAVAABBTreeNode@Opcode@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator*
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBAAEBQEAVAABBTreeNode@Opcode@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator*
PUBLIC	??$xr_free@VAABBTreeNode@Opcode@@@@YAXAEAPEAVAABBTreeNode@Opcode@@@Z ; xr_free<Opcode::AABBTreeNode>
PUBLIC	?size@?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEBAIXZ ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size
PUBLIC	??1?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::~xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	??1?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::~vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	?_Tidy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXXZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Tidy
PUBLIC	??_GAABBTreeBuilder@Opcode@@UEAAPEAXI@Z		; Opcode::AABBTreeBuilder::`scalar deleting destructor'
PUBLIC	??0AABBTreeBuilder@Opcode@@QEAA@XZ		; Opcode::AABBTreeBuilder::AABBTreeBuilder
PUBLIC	??0?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::poolSS<Opcode::AABBTreeNode,16384>
PUBLIC	??0?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	??0?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@QEAA@AEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> >::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> >
PUBLIC	??1AABBTreeOfTrianglesBuilder@Opcode@@UEAA@XZ	; Opcode::AABBTreeOfTrianglesBuilder::~AABBTreeOfTrianglesBuilder
PUBLIC	??_GAABBTree@Opcode@@QEAAPEAXI@Z		; Opcode::AABBTree::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$00VAABBOptimizedTree@Opcode@@@@QEAAXAEAPEAVAABBOptimizedTree@Opcode@@@Z ; xr_special_free<1,Opcode::AABBOptimizedTree>::operator()
PUBLIC	??R?$xr_special_free@$0A@VAABBTree@Opcode@@@@QEAAXAEAPEAVAABBTree@Opcode@@@Z ; xr_special_free<0,Opcode::AABBTree>::operator()
PUBLIC	??$xr_new@VAABBCollisionTree@Opcode@@@@YAPEAVAABBCollisionTree@Opcode@@XZ ; xr_new<Opcode::AABBCollisionTree>
PUBLIC	??$xr_new@VAABBQuantizedTree@Opcode@@@@YAPEAVAABBQuantizedTree@Opcode@@XZ ; xr_new<Opcode::AABBQuantizedTree>
PUBLIC	??$xr_new@VAABBNoLeafTree@Opcode@@@@YAPEAVAABBNoLeafTree@Opcode@@XZ ; xr_new<Opcode::AABBNoLeafTree>
PUBLIC	??$xr_new@VAABBQuantizedNoLeafTree@Opcode@@@@YAPEAVAABBQuantizedNoLeafTree@Opcode@@XZ ; xr_new<Opcode::AABBQuantizedNoLeafTree>
PUBLIC	??$xr_new@VAABBTree@Opcode@@@@YAPEAVAABBTree@Opcode@@XZ ; xr_new<Opcode::AABBTree>
PUBLIC	??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z ; xr_delete<Opcode::AABBOptimizedTree>
PUBLIC	??$xr_delete@VAABBTree@Opcode@@@@YAXAEAPEAVAABBTree@Opcode@@@Z ; xr_delete<Opcode::AABBTree>
PUBLIC	??0OPCODECREATE@Opcode@@QEAA@XZ			; Opcode::OPCODECREATE::OPCODECREATE
PUBLIC	?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z ; Opcode::OPCODE_Model::Build
PUBLIC	??0OPCODE_Model@Opcode@@QEAA@XZ			; Opcode::OPCODE_Model::OPCODE_Model
PUBLIC	??1OPCODE_Model@Opcode@@QEAA@XZ			; Opcode::OPCODE_Model::~OPCODE_Model
EXTRN	??_EAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z:PROC ; Opcode::AABBTreeOfTrianglesBuilder::`vector deleting destructor'
EXTRN	??_EAABBTreeBuilder@Opcode@@UEAAPEAXI@Z:PROC	; Opcode::AABBTreeBuilder::`vector deleting destructor'
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+70
	DD	imagerel $unwind$??_GAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD imagerel $LN59
	DD	imagerel $LN59+16
	DD	imagerel $unwind$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD imagerel $LN59+16
	DD	imagerel $LN59+38
	DD	imagerel $chain$0$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD imagerel $LN59+38
	DD	imagerel $LN59+106
	DD	imagerel $chain$1$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD imagerel $LN59+106
	DD	imagerel $LN59+120
	DD	imagerel $chain$2$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD imagerel $LN59+120
	DD	imagerel $LN59+156
	DD	imagerel $chain$3$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_free@VAABBTreeNode@Opcode@@@@YAXAEAPEAVAABBTreeNode@Opcode@@@Z DD imagerel $LN5
	DD	imagerel $LN5+43
	DD	imagerel $unwind$??$xr_free@VAABBTreeNode@Opcode@@@@YAXAEAPEAVAABBTreeNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+49
	DD	imagerel $unwind$??1?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+49
	DD	imagerel $unwind$??1?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXXZ DD imagerel $LN16
	DD	imagerel $LN16+49
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GAABBTreeBuilder@Opcode@@UEAAPEAXI@Z DD imagerel $LN13
	DD	imagerel $LN13+70
	DD	imagerel $unwind$??_GAABBTreeBuilder@Opcode@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GAABBTree@Opcode@@QEAAPEAXI@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??_GAABBTree@Opcode@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$00VAABBOptimizedTree@Opcode@@@@QEAAXAEAPEAVAABBOptimizedTree@Opcode@@@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$??R?$xr_special_free@$00VAABBOptimizedTree@Opcode@@@@QEAAXAEAPEAVAABBOptimizedTree@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$0A@VAABBTree@Opcode@@@@QEAAXAEAPEAVAABBTree@Opcode@@@Z DD imagerel $LN17
	DD	imagerel $LN17+73
	DD	imagerel $unwind$??R?$xr_special_free@$0A@VAABBTree@Opcode@@@@QEAAXAEAPEAVAABBTree@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VAABBCollisionTree@Opcode@@@@YAPEAVAABBCollisionTree@Opcode@@XZ DD imagerel $LN12
	DD	imagerel $LN12+62
	DD	imagerel $unwind$??$xr_new@VAABBCollisionTree@Opcode@@@@YAPEAVAABBCollisionTree@Opcode@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VAABBQuantizedTree@Opcode@@@@YAPEAVAABBQuantizedTree@Opcode@@XZ DD imagerel $LN12
	DD	imagerel $LN12+62
	DD	imagerel $unwind$??$xr_new@VAABBQuantizedTree@Opcode@@@@YAPEAVAABBQuantizedTree@Opcode@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VAABBNoLeafTree@Opcode@@@@YAPEAVAABBNoLeafTree@Opcode@@XZ DD imagerel $LN12
	DD	imagerel $LN12+62
	DD	imagerel $unwind$??$xr_new@VAABBNoLeafTree@Opcode@@@@YAPEAVAABBNoLeafTree@Opcode@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VAABBQuantizedNoLeafTree@Opcode@@@@YAPEAVAABBQuantizedNoLeafTree@Opcode@@XZ DD imagerel $LN12
	DD	imagerel $LN12+62
	DD	imagerel $unwind$??$xr_new@VAABBQuantizedNoLeafTree@Opcode@@@@YAPEAVAABBQuantizedNoLeafTree@Opcode@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VAABBTree@Opcode@@@@YAPEAVAABBTree@Opcode@@XZ DD imagerel $LN12
	DD	imagerel $LN12+67
	DD	imagerel $unwind$??$xr_new@VAABBTree@Opcode@@@@YAPEAVAABBTree@Opcode@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z DD imagerel $LN7
	DD	imagerel $LN7+17
	DD	imagerel $unwind$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z DD imagerel $LN7+17
	DD	imagerel $LN7+69
	DD	imagerel $chain$0$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z DD imagerel $LN7+69
	DD	imagerel $LN7+75
	DD	imagerel $chain$1$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@VAABBTree@Opcode@@@@YAXAEAPEAVAABBTree@Opcode@@@Z DD imagerel $LN20
	DD	imagerel $LN20+85
	DD	imagerel $unwind$??$xr_delete@VAABBTree@Opcode@@@@YAXAEAPEAVAABBTree@Opcode@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z DD imagerel $LN120
	DD	imagerel $LN120+65
	DD	imagerel $unwind$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z
$pdata$0$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z DD imagerel $LN120+65
	DD	imagerel $LN120+497
	DD	imagerel $chain$0$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z
$pdata$1$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z DD imagerel $LN120+497
	DD	imagerel $LN120+518
	DD	imagerel $chain$1$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z
$pdata$??1OPCODE_Model@Opcode@@QEAA@XZ DD imagerel $LN27
	DD	imagerel $LN27+138
	DD	imagerel $unwind$??1OPCODE_Model@Opcode@@QEAA@XZ
xdata	SEGMENT
$unwind$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z DD 061201H
	DD	0146412H
	DD	0135412H
	DD	0700bf212H
$chain$0$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z DD 020821H
	DD	0123408H
	DD	imagerel $LN120
	DD	imagerel $LN120+65
	DD	imagerel $unwind$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z
$chain$1$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z DD 021H
	DD	imagerel $LN120
	DD	imagerel $LN120+65
	DD	imagerel $unwind$?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z
$unwind$??1OPCODE_Model@Opcode@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@VAABBTree@Opcode@@@@YAXAEAPEAVAABBTree@Opcode@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+17
	DD	imagerel $unwind$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN7
	DD	imagerel $LN7+17
	DD	imagerel $unwind$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VAABBTree@Opcode@@@@YAPEAVAABBTree@Opcode@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VAABBQuantizedNoLeafTree@Opcode@@@@YAPEAVAABBQuantizedNoLeafTree@Opcode@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VAABBNoLeafTree@Opcode@@@@YAPEAVAABBNoLeafTree@Opcode@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VAABBQuantizedTree@Opcode@@@@YAPEAVAABBQuantizedTree@Opcode@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VAABBCollisionTree@Opcode@@@@YAPEAVAABBCollisionTree@Opcode@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$0A@VAABBTree@Opcode@@@@QEAAXAEAPEAVAABBTree@Opcode@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$00VAABBOptimizedTree@Opcode@@@@QEAAXAEAPEAVAABBOptimizedTree@Opcode@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GAABBTree@Opcode@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GAABBTreeBuilder@Opcode@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@VAABBTreeNode@Opcode@@@@YAXAEAPEAVAABBTreeNode@Opcode@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+16
	DD	imagerel $unwind$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD 021H
	DD	imagerel $LN59+16
	DD	imagerel $LN59+38
	DD	imagerel $chain$0$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD 020521H
	DD	066405H
	DD	imagerel $LN59+16
	DD	imagerel $LN59+38
	DD	imagerel $chain$0$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD 020521H
	DD	077405H
	DD	imagerel $LN59
	DD	imagerel $LN59+16
	DD	imagerel $unwind$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ DD 040a01H
	DD	08340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
_TEXT	SEGMENT
this$ = 48
??1OPCODE_Model@Opcode@@QEAA@XZ PROC			; Opcode::OPCODE_Model::~OPCODE_Model

; 168  : {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 151  : 	if (ptr) 

	mov	rbx, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 168  : {

	mov	rdi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	rbx, rbx
	je	SHORT $LN3@OPCODE_Mod
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rbx+56]
	test	rdx, rdx
	je	SHORT $LN13@OPCODE_Mod
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+56], 0
$LN13@OPCODE_Mod:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = NULL;

	mov	QWORD PTR [rdi], 0
$LN3@OPCODE_Mod:

; 151  : 	if (ptr) 

	mov	rcx, QWORD PTR [rdi+8]
	test	rcx, rcx
	je	SHORT $LN21@OPCODE_Mod

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR [rdi+8]
	xor	edx, edx
	mov	r8, QWORD PTR [rcx]
	mov	rbx, rax
	call	QWORD PTR [r8]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	rdx, rbx
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = NULL;

	mov	QWORD PTR [rdi+8], 0
$LN21@OPCODE_Mod:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 174  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1OPCODE_Model@Opcode@@QEAA@XZ ENDP			; Opcode::OPCODE_Model::~OPCODE_Model
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
_TEXT	SEGMENT
this$ = 8
??0OPCODE_Model@Opcode@@QEAA@XZ PROC			; Opcode::OPCODE_Model::OPCODE_Model

; 156  : {

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	WORD PTR [rcx+16], ax

; 157  : #ifdef __MESHMERIZER_H__	// Collision hulls only supported within ICE !
; 158  : 	mHull	= null;
; 159  : #endif // __MESHMERIZER_H__
; 160  : }

	mov	rax, rcx
	ret	0
??0OPCODE_Model@Opcode@@QEAA@XZ ENDP			; Opcode::OPCODE_Model::OPCODE_Model
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
_TEXT	SEGMENT
TB$ = 32
this$ = 144
create$ = 152
?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z PROC ; Opcode::OPCODE_Model::Build

; 184  : {

$LN120:
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 128				; 00000080H

; 185  : 	// 1) Checkings
; 186  : 	if(!create.NbTris || !create.Tris || !create.Verts)	return false;

	mov	rbp, QWORD PTR [rdx+8]
	mov	rsi, rdx
	mov	rdi, rcx
	test	rbp, rbp
	je	SHORT $LN23@Build
	cmp	QWORD PTR [rdx+16], 0
	je	SHORT $LN23@Build

; 187  : 
; 188  : 	// In this lib, we only support complete trees
; 189  : 	if(!(create.Rules&SPLIT_COMPLETE))	return SetIceError;//("OPCODE WARNING: supports complete trees only! Use SPLIT_COMPLETE.\n");

	test	BYTE PTR [rdx+24], 1
	jne	SHORT $LN16@Build
$LN23@Build:
	xor	al, al
	jmp	$LN25@Build
$LN16@Build:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 72					; 00000048H
	mov	QWORD PTR [rsp+144], rbx
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	xor	ebx, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, rax

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN34@Build
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbx
	mov	QWORD PTR [rax+40], rbx
	mov	DWORD PTR [rax+48], ebx

; 59   : }
; 60   : 
; 61   : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 62   : /**
; 63   :  *	Destructor.
; 64   :  */
; 65   : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 66   : AABBTreeNode::~AABBTreeNode()
; 67   : {
; 68   : }
; 69   : 
; 70   : void  AABBTreeNode::destroy		(AABBTreeBuilder*	_tree)
; 71   : {
; 72   : 	if (mP)	{ mP->destroy		(_tree); _tree->node_destroy	(mP); }
; 73   : 	if (mN)	{ mN->destroy		(_tree); _tree->node_destroy	(mN); }
; 74   : 	mNodePrimitives				= null;	// This was just a shortcut to the global list => no release
; 75   : 	mNbPrimitives				= 0;
; 76   : }
; 77   : 
; 78   : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 79   : /**
; 80   :  *	Splits the node along a given axis.
; 81   :  *	The list of indices is reorganized according to the split values.
; 82   :  *	\param		axis		[in] splitting axis index
; 83   :  *	\param		builder		[in] the tree builder
; 84   :  *	\return		the number of primitives assigned to the first child
; 85   :  *	\warning	this method reorganizes the internal list of primitives
; 86   :  */
; 87   : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 88   : udword AABBTreeNode::Split(udword axis, AABBTreeBuilder* builder)
; 89   : {
; 90   : 	// Get node split value
; 91   : 	float SplitValue = builder->GetSplittingValueEx(mNodePrimitives, mNbPrimitives, mBV, axis);
; 92   : 
; 93   : 	udword NbPos = 0;
; 94   : 	// Loop through all node-related primitives. Their indices range from mNodePrimitives[0] to mNodePrimitives[mNbPrimitives-1].
; 95   : 	// Those indices map the global list in the tree builder.
; 96   : 	for(udword i=0;i<mNbPrimitives;i++)
; 97   : 	{
; 98   : 		// Get index in global list
; 99   : 		udword Index = mNodePrimitives[i];
; 100  : 
; 101  : 		// Test against the splitting value. The primitive value is tested against the enclosing-box center.
; 102  : 		// [We only need an approximate partition of the enclosing box here.]
; 103  : 		float PrimitiveValue = builder->GetSplittingValue(Index, axis);
; 104  : 
; 105  : 		// Reorganize the list of indices in this order: positive - negative.
; 106  : 		if(PrimitiveValue > SplitValue)
; 107  : 		{
; 108  : 			// Swap entries
; 109  : 			udword Tmp = mNodePrimitives[i];
; 110  : 			mNodePrimitives[i] = mNodePrimitives[NbPos];
; 111  : 			mNodePrimitives[NbPos] = Tmp;
; 112  : 			// Count primitives assigned to positive space
; 113  : 			NbPos++;
; 114  : 		}
; 115  : 	}
; 116  : 	return NbPos;
; 117  : }
; 118  : 
; 119  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 120  : /**
; 121  :  *	Subdivides the node.
; 122  :  *	
; 123  :  *	          N
; 124  :  *	        /   \
; 125  :  *	      /       \
; 126  :  *	   N/2         N/2
; 127  :  *	  /   \       /   \
; 128  :  *	N/4   N/4   N/4   N/4
; 129  :  *	(etc)
; 130  :  *
; 131  :  *	A well-balanced tree should have a O(log n) depth.
; 132  :  *	A degenerate tree would have a O(n) depth.
; 133  :  *	Note a perfectly-balanced tree is not well-suited to collision detection anyway.
; 134  :  *
; 135  :  *	\param		builder		[in] the tree builder
; 136  :  *	\return		true if success
; 137  :  */
; 138  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 139  : bool AABBTreeNode::Subdivide(AABBTreeBuilder* builder)
; 140  : {
; 141  : 	// Checkings
; 142  : 	if(!builder)	return false;
; 143  : 
; 144  : 	// Stop subdividing if we reach a leaf node
; 145  : 	if(mNbPrimitives==1)	return true;
; 146  : 
; 147  : 	// Check the user-defined limit
; 148  : 	if(mNbPrimitives<=builder->mLimit)	return true;
; 149  : 
; 150  : 	bool ValidSplit = true;	// Optimism...
; 151  : 	udword NbPos	= 0;
; 152  : 	if(builder->mRules&SPLIT_LARGESTAXIS)
; 153  : 	{
; 154  : 		// Find the largest axis to split along
; 155  : 		Point Extents;	mBV.GetExtents(Extents);	// Box extents
; 156  : 		udword Axis	= Extents.LargestAxis();		// Index of largest axis
; 157  : 
; 158  : 		// Split along the axis
; 159  : 		NbPos = Split(Axis, builder);
; 160  : 
; 161  : 		// Check split validity
; 162  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 163  : 	}
; 164  : 	else if(builder->mRules&SPLIT_SPLATTERPOINTS)
; 165  : 	{
; 166  : 		// Compute the means
; 167  : 		Point Means(0.0f, 0.0f, 0.0f);
; 168  : 		for(udword i=0;i<mNbPrimitives;i++)
; 169  : 		{
; 170  : 			udword Index = mNodePrimitives[i];
; 171  : 			Means.x+=builder->GetSplittingValue(Index, 0);
; 172  : 			Means.y+=builder->GetSplittingValue(Index, 1);
; 173  : 			Means.z+=builder->GetSplittingValue(Index, 2);
; 174  : 		}
; 175  : 		Means/=float(mNbPrimitives);
; 176  : 
; 177  : 		// Compute variances
; 178  : 		Point Vars(0.0f, 0.0f, 0.0f);
; 179  : 		for(i=0;i<mNbPrimitives;i++)
; 180  : 		{
; 181  : 			udword Index = mNodePrimitives[i];
; 182  : 			float Cx = builder->GetSplittingValue(Index, 0);
; 183  : 			float Cy = builder->GetSplittingValue(Index, 1);
; 184  : 			float Cz = builder->GetSplittingValue(Index, 2);
; 185  : 			Vars.x += (Cx - Means.x)*(Cx - Means.x);
; 186  : 			Vars.y += (Cy - Means.y)*(Cy - Means.y);
; 187  : 			Vars.z += (Cz - Means.z)*(Cz - Means.z);
; 188  : 		}
; 189  : 		Vars/=float(mNbPrimitives-1);
; 190  : 
; 191  : 		// Choose axis with greatest variance
; 192  : 		udword Axis = Vars.LargestAxis();
; 193  : 
; 194  : 		// Split along the axis
; 195  : 		NbPos = Split(Axis, builder);
; 196  : 
; 197  : 		// Check split validity
; 198  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 199  : 	}
; 200  : 	else if(builder->mRules&SPLIT_BALANCED)
; 201  : 	{
; 202  : 		// Test 3 axis, take the best
; 203  : 		float Results[3];
; 204  : 		NbPos = Split(0, builder);	Results[0] = float(NbPos)/float(mNbPrimitives);
; 205  : 		NbPos = Split(1, builder);	Results[1] = float(NbPos)/float(mNbPrimitives);
; 206  : 		NbPos = Split(2, builder);	Results[2] = float(NbPos)/float(mNbPrimitives);
; 207  : 		Results[0]-=0.5f;	Results[0]*=Results[0];
; 208  : 		Results[1]-=0.5f;	Results[1]*=Results[1];
; 209  : 		Results[2]-=0.5f;	Results[2]*=Results[2];
; 210  : 		udword Min=0;
; 211  : 		if(Results[1]<Results[Min])	Min = 1;
; 212  : 		if(Results[2]<Results[Min])	Min = 2;
; 213  : 		
; 214  : 		// Split along the axis
; 215  : 		NbPos = Split(Min, builder);
; 216  : 
; 217  : 		// Check split validity
; 218  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 219  : 	}
; 220  : 	else if(builder->mRules&SPLIT_BESTAXIS)
; 221  : 	{
; 222  : 		// Test largest, then middle, then smallest axis...
; 223  : 
; 224  : 		// Sort axis
; 225  : 		Point Extents;	mBV.GetExtents(Extents);	// Box extents
; 226  : 		udword SortedAxis[] = { 0, 1, 2 };
; 227  : 		float* Keys = (float*)&Extents.x;
; 228  : 		for(udword j=0;j<3;j++)
; 229  : 		{
; 230  : 			for(udword i=0;i<2;i++)
; 231  : 			{
; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])
; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];
; 236  : 					SortedAxis[i+1] = Tmp;
; 237  : 				}
; 238  : 			}
; 239  : 		}
; 240  : 
; 241  : 		// Find the largest axis to split along
; 242  : 		udword CurAxis = 0;
; 243  : 		ValidSplit = false;
; 244  : 		while(!ValidSplit && CurAxis!=3)
; 245  : 		{
; 246  : 			NbPos = Split(SortedAxis[CurAxis], builder);
; 247  : 			// Check the subdivision has been successful
; 248  : 			if(!NbPos || NbPos==mNbPrimitives)	CurAxis++;
; 249  : 			else								ValidSplit = true;
; 250  : 		}
; 251  : 	}
; 252  : 	else if(builder->mRules&SPLIT_FIFTY)
; 253  : 	{
; 254  : 		// Don't even bother splitting (mainly a performance test)
; 255  : 		NbPos = mNbPrimitives>>1;
; 256  : 	}
; 257  : 	else return false;	// Unknown splitting rules
; 258  : 
; 259  : 	// Check the subdivision has been successful
; 260  : 	if(!ValidSplit)
; 261  : 	{
; 262  : 		// Here, all boxes lie in the same sub-space. Two strategies:
; 263  : 		// - if the tree *must* be complete, make an arbitrary 50-50 split
; 264  : 		// - else stop subdividing
; 265  : 		if(builder->mRules&SPLIT_COMPLETE)
; 266  : 		{
; 267  : 			builder->IncreaseNbInvalidSplits();
; 268  : 			NbPos = mNbPrimitives>>1;
; 269  : 		}
; 270  : 		else return true;
; 271  : 	}
; 272  : 
; 273  : 	// Now create children and assign their pointers.
; 274  : 	mP = builder->node_alloc();     CHECKALLOC(mP);
; 275  : 	mN = builder->node_alloc();		CHECKALLOC(mN);
; 276  : 
; 277  : 	// Update stats
; 278  : 	builder->IncreaseCount	(2);
; 279  : 
; 280  : 	// Assign children
; 281  : 	mP->mNodePrimitives	= &mNodePrimitives[0];
; 282  : 	mP->mNbPrimitives	= NbPos;
; 283  : 	mN->mNodePrimitives	= &mNodePrimitives[NbPos];
; 284  : 	mN->mNbPrimitives	= mNbPrimitives - NbPos;
; 285  : 
; 286  : 	return true;
; 287  : }
; 288  : 
; 289  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 290  : /**
; 291  :  *	Recursive hierarchy building in a top-down fashion.
; 292  :  *	\param		builder		[in] the tree builder
; 293  :  */
; 294  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 295  : void AABBTreeNode::_BuildHierarchy(AABBTreeBuilder* builder)
; 296  : {
; 297  : 	// 1) Compute the global box for current node. The box is stored in mBV.
; 298  : 	builder->ComputeGlobalBox(mNodePrimitives, mNbPrimitives, mBV);
; 299  : 
; 300  : 	// 2) Subdivide current node
; 301  : 	Subdivide(builder);
; 302  : 
; 303  : 	// 3) Recurse
; 304  : 	if(mP)	mP->_BuildHierarchy(builder);
; 305  : 	if(mN)	mN->_BuildHierarchy(builder);
; 306  : }
; 307  : 
; 308  : 
; 309  : 
; 310  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 311  : /**
; 312  :  *	Constructor.
; 313  :  */
; 314  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 315  : AABBTree::AABBTree() : mIndices(null), mTotalNbNodes(0)
; 316  : {

	mov	QWORD PTR [rax+56], rbx
	mov	DWORD PTR [rax+64], ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	jmp	SHORT $LN35@Build
$LN34@Build:
	mov	rcx, rbx
$LN35@Build:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 204  : 	mSource = xr_new<AABBTree>();

	mov	QWORD PTR [rdi], rcx

; 205  : 	CHECKALLOC(mSource);

	test	rcx, rcx
	jne	SHORT $LN10@Build
	xor	al, al
	jmp	$LN118@Build
$LN10@Build:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 133  : 												AABBTreeOfTrianglesBuilder() : mTriList(null), mVerts(null), mNbTriangles(0)	{}

	lea	rax, OFFSET FLAT:??_7AABBTreeOfTrianglesBuilder@Opcode@@6B@
	xorps	xmm0, xmm0
	lea	rdx, QWORD PTR TB$[rsp]
	mov	QWORD PTR TB$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 211  : 	TB.mVerts			= create.Verts;

	mov	rax, QWORD PTR [rsi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 53   : 													mNbInvalidSplits(0)		{}

	mov	DWORD PTR TB$[rsp+8], ebx
	movdqa	XMMWORD PTR TB$[rsp+48], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 211  : 	TB.mVerts			= create.Verts;

	mov	QWORD PTR TB$[rsp+72], rax

; 212  : 	TB.mRules			= create.Rules;

	mov	eax, DWORD PTR [rsi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 53   : 													mNbInvalidSplits(0)		{}

	mov	QWORD PTR TB$[rsp+20], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 212  : 	TB.mRules			= create.Rules;

	mov	DWORD PTR TB$[rsp+12], eax

; 213  : 	TB.mNbPrimitives	= create.NbTris;

	mov	eax, DWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR TB$[rsp+40], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 31   : 		list				= 0;

	mov	QWORD PTR TB$[rsp+32], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 133  : 												AABBTreeOfTrianglesBuilder() : mTriList(null), mVerts(null), mNbTriangles(0)	{}

	mov	DWORD PTR TB$[rsp+80], ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 210  : 	TB.mTriList			= Tris;

	mov	QWORD PTR TB$[rsp+64], rbp

; 213  : 	TB.mNbPrimitives	= create.NbTris;

	mov	DWORD PTR TB$[rsp+16], eax
	call	?Build@AABBTree@Opcode@@QEAA_NPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTree::Build

; 214  : 	if(!mSource->Build(&TB))	return false;

	test	al, al
	je	$LN21@Build

; 215  : 
; 216  : 	// 3) Create an optimized tree according to user-settings
; 217  : 	// 3-1) Create the correct class
; 218  : 	mNoLeaf		= create.NoLeaf;

	movzx	eax, BYTE PTR [rsi+28]
	mov	BYTE PTR [rdi+16], al

; 219  : 	mQuantized	= create.Quantized;

	movzx	ecx, BYTE PTR [rsi+29]
	mov	BYTE PTR [rdi+17], cl

; 220  : 
; 221  : 	if(mNoLeaf)

	test	al, al
	je	SHORT $LN8@Build

; 223  : 		if(mQuantized)	mTree = xr_new<AABBQuantizedNoLeafTree>();

	test	cl, cl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 223  : 		if(mQuantized)	mTree = xr_new<AABBQuantizedNoLeafTree>();

	je	SHORT $LN7@Build
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edx, 48					; 00000030H
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	$LN100@Build
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 487  : {

	lea	rcx, OFFSET FLAT:??_7AABBQuantizedNoLeafTree@Opcode@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 131  : 											AABBOptimizedTree() : mNbNodes(0)		{}

	mov	DWORD PTR [rax+8], ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 487  : {

	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	jmp	SHORT $LN101@Build
$LN7@Build:

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edx, 24
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN100@Build
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 260  : {

	lea	rcx, OFFSET FLAT:??_7AABBNoLeafTree@Opcode@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 131  : 											AABBOptimizedTree() : mNbNodes(0)		{}

	mov	DWORD PTR [rax+8], ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 260  : {

	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	jmp	SHORT $LN101@Build
$LN8@Build:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 228  : 		if(mQuantized)	mTree = xr_new<AABBQuantizedTree>();

	test	cl, cl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 228  : 		if(mQuantized)	mTree = xr_new<AABBQuantizedTree>();

	je	SHORT $LN4@Build
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edx, 48					; 00000030H
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN100@Build
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 410  : {

	lea	rcx, OFFSET FLAT:??_7AABBQuantizedTree@Opcode@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 131  : 											AABBOptimizedTree() : mNbNodes(0)		{}

	mov	DWORD PTR [rax+8], ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 410  : {

	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	jmp	SHORT $LN101@Build
$LN4@Build:

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edx, 24
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN100@Build
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 206  : {

	lea	rcx, OFFSET FLAT:??_7AABBCollisionTree@Opcode@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 131  : 											AABBOptimizedTree() : mNbNodes(0)		{}

	mov	DWORD PTR [rax+8], ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 206  : {

	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	jmp	SHORT $LN101@Build
$LN100@Build:
	mov	rax, rbx
$LN101@Build:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 233  : 	if(!mTree->Build(mSource))	return false;

	mov	rdx, QWORD PTR [rdi]
	mov	QWORD PTR [rdi+8], rax
	mov	rcx, rax
	mov	rax, QWORD PTR [rax]
	call	QWORD PTR [rax+16]
	test	al, al
	je	SHORT $LN21@Build

; 234  : 
; 235  : 	// 3-3) Delete generic tree if needed
; 236  : 	if(!create.KeepOriginal)	{

	cmp	BYTE PTR [rsi+30], 0
	jne	SHORT $LN1@Build

; 237  : 		mSource->destroy	(&TB)		;

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR TB$[rsp]
	call	?destroy@AABBTreeNode@Opcode@@QEAAXPEAVAABBTreeBuilder@2@@Z ; Opcode::AABBTreeNode::destroy

; 238  : 		xr_delete			(mSource)	;	

	mov	rcx, rdi
	call	??$xr_delete@VAABBTree@Opcode@@@@YAXAEAPEAVAABBTree@Opcode@@@Z ; xr_delete<Opcode::AABBTree>
$LN1@Build:

; 258  : 	return true;

	mov	bl, 1
	jmp	SHORT $LN22@Build
$LN21@Build:
	xor	bl, bl
$LN22@Build:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 55   : 		virtual									~AABBTreeBuilder()			{}

	lea	rax, OFFSET FLAT:??_7AABBTreeBuilder@Opcode@@6B@
	lea	rcx, QWORD PTR TB$[rsp+32]
	mov	QWORD PTR TB$[rsp], rax
	call	??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::~poolSS<Opcode::AABBTreeNode,16384>
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp

; 258  : 	return true;

	movzx	eax, bl
$LN118@Build:
	mov	rbx, QWORD PTR [rsp+144]
$LN25@Build:

; 259  : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?Build@OPCODE_Model@Opcode@@QEAA_NAEBUOPCODECREATE@2@@Z ENDP ; Opcode::OPCODE_Model::Build
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_model.cpp
_TEXT	SEGMENT
this$ = 8
??0OPCODECREATE@Opcode@@QEAA@XZ PROC			; Opcode::OPCODECREATE::OPCODECREATE

; 137  : 	NbTris			= 0;

	xor	eax, eax

; 138  : 	NbVerts			= 0;
; 139  : 	Tris			= null;
; 140  : 	Verts			= null;
; 141  : 	Rules			= SPLIT_COMPLETE | SPLIT_LARGESTAXIS;

	mov	DWORD PTR [rcx+24], 3

; 142  : 	NoLeaf			= true;

	mov	WORD PTR [rcx+28], 257			; 00000101H
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 143  : 	Quantized		= true;
; 144  : #ifdef __MESHMERIZER_H__
; 145  : 	CollisionHull	= false;
; 146  : #endif // __MESHMERIZER_H__
; 147  : 	KeepOriginal	= false;

	mov	BYTE PTR [rcx+30], al

; 148  : }

	mov	rax, rcx
	ret	0
??0OPCODECREATE@Opcode@@QEAA@XZ ENDP			; Opcode::OPCODECREATE::OPCODECREATE
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@VAABBTree@Opcode@@@@YAXAEAPEAVAABBTree@Opcode@@@Z
_TEXT	SEGMENT
ptr$ = 48
??$xr_delete@VAABBTree@Opcode@@@@YAXAEAPEAVAABBTree@Opcode@@@Z PROC ; xr_delete<Opcode::AABBTree>, COMDAT

; 150  : {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 151  : 	if (ptr) 

	mov	rdi, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdi, rdi
	je	SHORT $LN1@xr_delete
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rdi+56]
	test	rdx, rdx
	je	SHORT $LN11@xr_delete
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rdi+56], 0
$LN11@xr_delete:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = NULL;

	mov	QWORD PTR [rbx], 0
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$xr_delete@VAABBTree@Opcode@@@@YAXAEAPEAVAABBTree@Opcode@@@Z ENDP ; xr_delete<Opcode::AABBTree>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z
_TEXT	SEGMENT
ptr$ = 48
??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z PROC ; xr_delete<Opcode::AABBOptimizedTree>, COMDAT

; 150  : {

$LN7:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 151  : 	if (ptr) 

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN1@xr_delete
	mov	QWORD PTR [rsp+48], rbx

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR [rdi]
	mov	r8, QWORD PTR [rcx]
	xor	edx, edx
	mov	rbx, rax
	call	QWORD PTR [r8]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	rdx, rbx
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	rbx, QWORD PTR [rsp+48]

; 152  : 	{
; 153  : 		xr_special_free<xrcore::is_polymorphic<T>::result,T>()(ptr);
; 154  : 		ptr = NULL;

	mov	QWORD PTR [rdi], 0
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$xr_delete@VAABBOptimizedTree@Opcode@@@@YAXAEAPEAVAABBOptimizedTree@Opcode@@@Z ENDP ; xr_delete<Opcode::AABBOptimizedTree>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VAABBTree@Opcode@@@@YAPEAVAABBTree@Opcode@@XZ
_TEXT	SEGMENT
??$xr_new@VAABBTree@Opcode@@@@YAPEAVAABBTree@Opcode@@XZ PROC ; xr_new<Opcode::AABBTree>, COMDAT

; 67   : {

$LN12:
	sub	rsp, 40					; 00000028H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 72					; 00000048H
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z
	mov	rcx, rax

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabbtree.cpp

; 58   : {

	xor	eax, eax
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+32], rax
	mov	QWORD PTR [rcx+40], rax
	mov	DWORD PTR [rcx+48], eax

; 59   : }
; 60   : 
; 61   : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 62   : /**
; 63   :  *	Destructor.
; 64   :  */
; 65   : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 66   : AABBTreeNode::~AABBTreeNode()
; 67   : {
; 68   : }
; 69   : 
; 70   : void  AABBTreeNode::destroy		(AABBTreeBuilder*	_tree)
; 71   : {
; 72   : 	if (mP)	{ mP->destroy		(_tree); _tree->node_destroy	(mP); }
; 73   : 	if (mN)	{ mN->destroy		(_tree); _tree->node_destroy	(mN); }
; 74   : 	mNodePrimitives				= null;	// This was just a shortcut to the global list => no release
; 75   : 	mNbPrimitives				= 0;
; 76   : }
; 77   : 
; 78   : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 79   : /**
; 80   :  *	Splits the node along a given axis.
; 81   :  *	The list of indices is reorganized according to the split values.
; 82   :  *	\param		axis		[in] splitting axis index
; 83   :  *	\param		builder		[in] the tree builder
; 84   :  *	\return		the number of primitives assigned to the first child
; 85   :  *	\warning	this method reorganizes the internal list of primitives
; 86   :  */
; 87   : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 88   : udword AABBTreeNode::Split(udword axis, AABBTreeBuilder* builder)
; 89   : {
; 90   : 	// Get node split value
; 91   : 	float SplitValue = builder->GetSplittingValueEx(mNodePrimitives, mNbPrimitives, mBV, axis);
; 92   : 
; 93   : 	udword NbPos = 0;
; 94   : 	// Loop through all node-related primitives. Their indices range from mNodePrimitives[0] to mNodePrimitives[mNbPrimitives-1].
; 95   : 	// Those indices map the global list in the tree builder.
; 96   : 	for(udword i=0;i<mNbPrimitives;i++)
; 97   : 	{
; 98   : 		// Get index in global list
; 99   : 		udword Index = mNodePrimitives[i];
; 100  : 
; 101  : 		// Test against the splitting value. The primitive value is tested against the enclosing-box center.
; 102  : 		// [We only need an approximate partition of the enclosing box here.]
; 103  : 		float PrimitiveValue = builder->GetSplittingValue(Index, axis);
; 104  : 
; 105  : 		// Reorganize the list of indices in this order: positive - negative.
; 106  : 		if(PrimitiveValue > SplitValue)
; 107  : 		{
; 108  : 			// Swap entries
; 109  : 			udword Tmp = mNodePrimitives[i];
; 110  : 			mNodePrimitives[i] = mNodePrimitives[NbPos];
; 111  : 			mNodePrimitives[NbPos] = Tmp;
; 112  : 			// Count primitives assigned to positive space
; 113  : 			NbPos++;
; 114  : 		}
; 115  : 	}
; 116  : 	return NbPos;
; 117  : }
; 118  : 
; 119  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 120  : /**
; 121  :  *	Subdivides the node.
; 122  :  *	
; 123  :  *	          N
; 124  :  *	        /   \
; 125  :  *	      /       \
; 126  :  *	   N/2         N/2
; 127  :  *	  /   \       /   \
; 128  :  *	N/4   N/4   N/4   N/4
; 129  :  *	(etc)
; 130  :  *
; 131  :  *	A well-balanced tree should have a O(log n) depth.
; 132  :  *	A degenerate tree would have a O(n) depth.
; 133  :  *	Note a perfectly-balanced tree is not well-suited to collision detection anyway.
; 134  :  *
; 135  :  *	\param		builder		[in] the tree builder
; 136  :  *	\return		true if success
; 137  :  */
; 138  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 139  : bool AABBTreeNode::Subdivide(AABBTreeBuilder* builder)
; 140  : {
; 141  : 	// Checkings
; 142  : 	if(!builder)	return false;
; 143  : 
; 144  : 	// Stop subdividing if we reach a leaf node
; 145  : 	if(mNbPrimitives==1)	return true;
; 146  : 
; 147  : 	// Check the user-defined limit
; 148  : 	if(mNbPrimitives<=builder->mLimit)	return true;
; 149  : 
; 150  : 	bool ValidSplit = true;	// Optimism...
; 151  : 	udword NbPos	= 0;
; 152  : 	if(builder->mRules&SPLIT_LARGESTAXIS)
; 153  : 	{
; 154  : 		// Find the largest axis to split along
; 155  : 		Point Extents;	mBV.GetExtents(Extents);	// Box extents
; 156  : 		udword Axis	= Extents.LargestAxis();		// Index of largest axis
; 157  : 
; 158  : 		// Split along the axis
; 159  : 		NbPos = Split(Axis, builder);
; 160  : 
; 161  : 		// Check split validity
; 162  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 163  : 	}
; 164  : 	else if(builder->mRules&SPLIT_SPLATTERPOINTS)
; 165  : 	{
; 166  : 		// Compute the means
; 167  : 		Point Means(0.0f, 0.0f, 0.0f);
; 168  : 		for(udword i=0;i<mNbPrimitives;i++)
; 169  : 		{
; 170  : 			udword Index = mNodePrimitives[i];
; 171  : 			Means.x+=builder->GetSplittingValue(Index, 0);
; 172  : 			Means.y+=builder->GetSplittingValue(Index, 1);
; 173  : 			Means.z+=builder->GetSplittingValue(Index, 2);
; 174  : 		}
; 175  : 		Means/=float(mNbPrimitives);
; 176  : 
; 177  : 		// Compute variances
; 178  : 		Point Vars(0.0f, 0.0f, 0.0f);
; 179  : 		for(i=0;i<mNbPrimitives;i++)
; 180  : 		{
; 181  : 			udword Index = mNodePrimitives[i];
; 182  : 			float Cx = builder->GetSplittingValue(Index, 0);
; 183  : 			float Cy = builder->GetSplittingValue(Index, 1);
; 184  : 			float Cz = builder->GetSplittingValue(Index, 2);
; 185  : 			Vars.x += (Cx - Means.x)*(Cx - Means.x);
; 186  : 			Vars.y += (Cy - Means.y)*(Cy - Means.y);
; 187  : 			Vars.z += (Cz - Means.z)*(Cz - Means.z);
; 188  : 		}
; 189  : 		Vars/=float(mNbPrimitives-1);
; 190  : 
; 191  : 		// Choose axis with greatest variance
; 192  : 		udword Axis = Vars.LargestAxis();
; 193  : 
; 194  : 		// Split along the axis
; 195  : 		NbPos = Split(Axis, builder);
; 196  : 
; 197  : 		// Check split validity
; 198  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 199  : 	}
; 200  : 	else if(builder->mRules&SPLIT_BALANCED)
; 201  : 	{
; 202  : 		// Test 3 axis, take the best
; 203  : 		float Results[3];
; 204  : 		NbPos = Split(0, builder);	Results[0] = float(NbPos)/float(mNbPrimitives);
; 205  : 		NbPos = Split(1, builder);	Results[1] = float(NbPos)/float(mNbPrimitives);
; 206  : 		NbPos = Split(2, builder);	Results[2] = float(NbPos)/float(mNbPrimitives);
; 207  : 		Results[0]-=0.5f;	Results[0]*=Results[0];
; 208  : 		Results[1]-=0.5f;	Results[1]*=Results[1];
; 209  : 		Results[2]-=0.5f;	Results[2]*=Results[2];
; 210  : 		udword Min=0;
; 211  : 		if(Results[1]<Results[Min])	Min = 1;
; 212  : 		if(Results[2]<Results[Min])	Min = 2;
; 213  : 		
; 214  : 		// Split along the axis
; 215  : 		NbPos = Split(Min, builder);
; 216  : 
; 217  : 		// Check split validity
; 218  : 		if(!NbPos || NbPos==mNbPrimitives)	ValidSplit = false;
; 219  : 	}
; 220  : 	else if(builder->mRules&SPLIT_BESTAXIS)
; 221  : 	{
; 222  : 		// Test largest, then middle, then smallest axis...
; 223  : 
; 224  : 		// Sort axis
; 225  : 		Point Extents;	mBV.GetExtents(Extents);	// Box extents
; 226  : 		udword SortedAxis[] = { 0, 1, 2 };
; 227  : 		float* Keys = (float*)&Extents.x;
; 228  : 		for(udword j=0;j<3;j++)
; 229  : 		{
; 230  : 			for(udword i=0;i<2;i++)
; 231  : 			{
; 232  : 				if(Keys[SortedAxis[i]]<Keys[SortedAxis[i+1]])
; 233  : 				{
; 234  : 					udword Tmp = SortedAxis[i];
; 235  : 					SortedAxis[i] = SortedAxis[i+1];
; 236  : 					SortedAxis[i+1] = Tmp;
; 237  : 				}
; 238  : 			}
; 239  : 		}
; 240  : 
; 241  : 		// Find the largest axis to split along
; 242  : 		udword CurAxis = 0;
; 243  : 		ValidSplit = false;
; 244  : 		while(!ValidSplit && CurAxis!=3)
; 245  : 		{
; 246  : 			NbPos = Split(SortedAxis[CurAxis], builder);
; 247  : 			// Check the subdivision has been successful
; 248  : 			if(!NbPos || NbPos==mNbPrimitives)	CurAxis++;
; 249  : 			else								ValidSplit = true;
; 250  : 		}
; 251  : 	}
; 252  : 	else if(builder->mRules&SPLIT_FIFTY)
; 253  : 	{
; 254  : 		// Don't even bother splitting (mainly a performance test)
; 255  : 		NbPos = mNbPrimitives>>1;
; 256  : 	}
; 257  : 	else return false;	// Unknown splitting rules
; 258  : 
; 259  : 	// Check the subdivision has been successful
; 260  : 	if(!ValidSplit)
; 261  : 	{
; 262  : 		// Here, all boxes lie in the same sub-space. Two strategies:
; 263  : 		// - if the tree *must* be complete, make an arbitrary 50-50 split
; 264  : 		// - else stop subdividing
; 265  : 		if(builder->mRules&SPLIT_COMPLETE)
; 266  : 		{
; 267  : 			builder->IncreaseNbInvalidSplits();
; 268  : 			NbPos = mNbPrimitives>>1;
; 269  : 		}
; 270  : 		else return true;
; 271  : 	}
; 272  : 
; 273  : 	// Now create children and assign their pointers.
; 274  : 	mP = builder->node_alloc();     CHECKALLOC(mP);
; 275  : 	mN = builder->node_alloc();		CHECKALLOC(mN);
; 276  : 
; 277  : 	// Update stats
; 278  : 	builder->IncreaseCount	(2);
; 279  : 
; 280  : 	// Assign children
; 281  : 	mP->mNodePrimitives	= &mNodePrimitives[0];
; 282  : 	mP->mNbPrimitives	= NbPos;
; 283  : 	mN->mNodePrimitives	= &mNodePrimitives[NbPos];
; 284  : 	mN->mNbPrimitives	= mNbPrimitives - NbPos;
; 285  : 
; 286  : 	return true;
; 287  : }
; 288  : 
; 289  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 290  : /**
; 291  :  *	Recursive hierarchy building in a top-down fashion.
; 292  :  *	\param		builder		[in] the tree builder
; 293  :  */
; 294  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 295  : void AABBTreeNode::_BuildHierarchy(AABBTreeBuilder* builder)
; 296  : {
; 297  : 	// 1) Compute the global box for current node. The box is stored in mBV.
; 298  : 	builder->ComputeGlobalBox(mNodePrimitives, mNbPrimitives, mBV);
; 299  : 
; 300  : 	// 2) Subdivide current node
; 301  : 	Subdivide(builder);
; 302  : 
; 303  : 	// 3) Recurse
; 304  : 	if(mP)	mP->_BuildHierarchy(builder);
; 305  : 	if(mN)	mN->_BuildHierarchy(builder);
; 306  : }
; 307  : 
; 308  : 
; 309  : 
; 310  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 311  : /**
; 312  :  *	Constructor.
; 313  :  */
; 314  : ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
; 315  : AABBTree::AABBTree() : mIndices(null), mTotalNbNodes(0)
; 316  : {

	mov	QWORD PTR [rcx+56], rax
	mov	DWORD PTR [rcx+64], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	rax, rcx

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@xr_new:
	add	rsp, 40					; 00000028H
	ret	0
??$xr_new@VAABBTree@Opcode@@@@YAPEAVAABBTree@Opcode@@XZ ENDP ; xr_new<Opcode::AABBTree>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VAABBQuantizedNoLeafTree@Opcode@@@@YAPEAVAABBQuantizedNoLeafTree@Opcode@@XZ
_TEXT	SEGMENT
??$xr_new@VAABBQuantizedNoLeafTree@Opcode@@@@YAPEAVAABBQuantizedNoLeafTree@Opcode@@XZ PROC ; xr_new<Opcode::AABBQuantizedNoLeafTree>, COMDAT

; 67   : {

$LN12:
	sub	rsp, 40					; 00000028H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 48					; 00000030H
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 487  : {

	lea	rcx, OFFSET FLAT:??_7AABBQuantizedNoLeafTree@Opcode@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 131  : 											AABBOptimizedTree() : mNbNodes(0)		{}

	mov	DWORD PTR [rax+8], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 487  : {

	mov	QWORD PTR [rax+16], 0
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@xr_new:
	add	rsp, 40					; 00000028H
	ret	0
??$xr_new@VAABBQuantizedNoLeafTree@Opcode@@@@YAPEAVAABBQuantizedNoLeafTree@Opcode@@XZ ENDP ; xr_new<Opcode::AABBQuantizedNoLeafTree>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VAABBNoLeafTree@Opcode@@@@YAPEAVAABBNoLeafTree@Opcode@@XZ
_TEXT	SEGMENT
??$xr_new@VAABBNoLeafTree@Opcode@@@@YAPEAVAABBNoLeafTree@Opcode@@XZ PROC ; xr_new<Opcode::AABBNoLeafTree>, COMDAT

; 67   : {

$LN12:
	sub	rsp, 40					; 00000028H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 24
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 260  : {

	lea	rcx, OFFSET FLAT:??_7AABBNoLeafTree@Opcode@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 131  : 											AABBOptimizedTree() : mNbNodes(0)		{}

	mov	DWORD PTR [rax+8], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 260  : {

	mov	QWORD PTR [rax+16], 0
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@xr_new:
	add	rsp, 40					; 00000028H
	ret	0
??$xr_new@VAABBNoLeafTree@Opcode@@@@YAPEAVAABBNoLeafTree@Opcode@@XZ ENDP ; xr_new<Opcode::AABBNoLeafTree>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VAABBQuantizedTree@Opcode@@@@YAPEAVAABBQuantizedTree@Opcode@@XZ
_TEXT	SEGMENT
??$xr_new@VAABBQuantizedTree@Opcode@@@@YAPEAVAABBQuantizedTree@Opcode@@XZ PROC ; xr_new<Opcode::AABBQuantizedTree>, COMDAT

; 67   : {

$LN12:
	sub	rsp, 40					; 00000028H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 48					; 00000030H
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 410  : {

	lea	rcx, OFFSET FLAT:??_7AABBQuantizedTree@Opcode@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 131  : 											AABBOptimizedTree() : mNbNodes(0)		{}

	mov	DWORD PTR [rax+8], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 410  : {

	mov	QWORD PTR [rax+16], 0
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@xr_new:
	add	rsp, 40					; 00000028H
	ret	0
??$xr_new@VAABBQuantizedTree@Opcode@@@@YAPEAVAABBQuantizedTree@Opcode@@XZ ENDP ; xr_new<Opcode::AABBQuantizedTree>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VAABBCollisionTree@Opcode@@@@YAPEAVAABBCollisionTree@Opcode@@XZ
_TEXT	SEGMENT
??$xr_new@VAABBCollisionTree@Opcode@@@@YAPEAVAABBCollisionTree@Opcode@@XZ PROC ; xr_new<Opcode::AABBCollisionTree>, COMDAT

; 67   : {

$LN12:
	sub	rsp, 40					; 00000028H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	edx, 24
	call	QWORD PTR __imp_?mem_alloc@xrMemory@@QEAAPEAX_K@Z

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 206  : {

	lea	rcx, OFFSET FLAT:??_7AABBCollisionTree@Opcode@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 131  : 											AABBOptimizedTree() : mNbNodes(0)		{}

	mov	DWORD PTR [rax+8], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.cpp

; 206  : {

	mov	QWORD PTR [rax+16], 0
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@xr_new:
	add	rsp, 40					; 00000028H
	ret	0
??$xr_new@VAABBCollisionTree@Opcode@@@@YAPEAVAABBCollisionTree@Opcode@@XZ ENDP ; xr_new<Opcode::AABBCollisionTree>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@VAABBTree@Opcode@@@@QEAAXAEAPEAVAABBTree@Opcode@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$ = 56
??R?$xr_special_free@$0A@VAABBTree@Opcode@@@@QEAAXAEAPEAVAABBTree@Opcode@@@Z PROC ; xr_special_free<0,Opcode::AABBTree>::operator(), COMDAT

; 142  : 	{

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 143  : 		ptr->~T			();

	mov	rdi, QWORD PTR [rdx]
	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rdi+56]
	test	rdx, rdx
	je	SHORT $LN8@operator
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rdi+56], 0
$LN8@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A

; 145  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 144  : 		Memory.mem_free	(ptr);

	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
??R?$xr_special_free@$0A@VAABBTree@Opcode@@@@QEAAXAEAPEAVAABBTree@Opcode@@@Z ENDP ; xr_special_free<0,Opcode::AABBTree>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VAABBOptimizedTree@Opcode@@@@QEAAXAEAPEAVAABBOptimizedTree@Opcode@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$ = 56
??R?$xr_special_free@$00VAABBOptimizedTree@Opcode@@@@QEAAXAEAPEAVAABBOptimizedTree@Opcode@@@Z PROC ; xr_special_free<1,Opcode::AABBOptimizedTree>::operator(), COMDAT

; 131  : 	{

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR [rbx]
	xor	edx, edx
	mov	r8, QWORD PTR [rcx]
	mov	rdi, rax
	call	QWORD PTR [r8]

; 134  : 		Memory.mem_free	(_real_ptr);

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	rdx, rdi

; 135  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 134  : 		Memory.mem_free	(_real_ptr);

	rex_jmp	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
??R?$xr_special_free@$00VAABBOptimizedTree@Opcode@@@@QEAAXAEAPEAVAABBOptimizedTree@Opcode@@@Z ENDP ; xr_special_free<1,Opcode::AABBOptimizedTree>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GAABBTree@Opcode@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GAABBTree@Opcode@@QEAAPEAXI@Z PROC			; Opcode::AABBTree::`scalar deleting destructor', COMDAT
$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rcx+56]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN14@scalar
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx+56], 0
$LN14@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GAABBTree@Opcode@@QEAAPEAXI@Z ENDP			; Opcode::AABBTree::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ??1AABBTreeOfTrianglesBuilder@Opcode@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1AABBTreeOfTrianglesBuilder@Opcode@@UEAA@XZ PROC	; Opcode::AABBTreeOfTrianglesBuilder::~AABBTreeOfTrianglesBuilder, COMDAT

; 55   : 		virtual									~AABBTreeBuilder()			{}

	lea	rax, OFFSET FLAT:??_7AABBTreeBuilder@Opcode@@6B@
	add	rcx, 32					; 00000020H
	mov	QWORD PTR [rcx-32], rax
	jmp	??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::~poolSS<Opcode::AABBTreeNode,16384>
??1AABBTreeOfTrianglesBuilder@Opcode@@UEAA@XZ ENDP	; Opcode::AABBTreeOfTrianglesBuilder::~AABBTreeOfTrianglesBuilder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> >::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> >, COMDAT

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 485  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> >::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@QEAA@AEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@QEAA@AEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@@std@@QEAA@AEBV?$xalloc@PEAVAABBTreeNode@Opcode@@@@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >::_Vector_alloc<0,std::_Vec_base_types<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 681  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ PROC ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	rax, rcx
	ret	0
??0?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ ENDP ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
;	COMDAT ??0?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::poolSS<Opcode::AABBTreeNode,16384>, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+16], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+24], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 31   : 		list				= 0;

	mov	QWORD PTR [rcx], rax

; 32   : 	}

	mov	rax, rcx
	ret	0
??0?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::poolSS<Opcode::AABBTreeNode,16384>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ??0AABBTreeBuilder@Opcode@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AABBTreeBuilder@Opcode@@QEAA@XZ PROC			; Opcode::AABBTreeBuilder::AABBTreeBuilder, COMDAT

; 53   : 													mNbInvalidSplits(0)		{}

	mov	QWORD PTR [rcx+12], 2147483647		; 7fffffffH
	lea	rax, OFFSET FLAT:??_7AABBTreeBuilder@Opcode@@6B@
	mov	QWORD PTR [rcx], rax
	xor	eax, eax
	mov	DWORD PTR [rcx+8], eax
	mov	QWORD PTR [rcx+20], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx+40], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+48], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+56], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 31   : 		list				= 0;

	mov	QWORD PTR [rcx+32], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 53   : 													mNbInvalidSplits(0)		{}

	mov	rax, rcx
	ret	0
??0AABBTreeBuilder@Opcode@@QEAA@XZ ENDP			; Opcode::AABBTreeBuilder::AABBTreeBuilder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GAABBTreeBuilder@Opcode@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GAABBTreeBuilder@Opcode@@UEAAPEAXI@Z PROC		; Opcode::AABBTreeBuilder::`scalar deleting destructor', COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 55   : 		virtual									~AABBTreeBuilder()			{}

	lea	rax, OFFSET FLAT:??_7AABBTreeBuilder@Opcode@@6B@
	mov	rdi, rcx
	add	rcx, 32					; 00000020H
	mov	QWORD PTR [rcx-32], rax
	mov	ebx, edx
	call	??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::~poolSS<Opcode::AABBTreeNode,16384>
	test	bl, 1
	je	SHORT $LN11@scalar
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	rdx, rdi
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN11@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GAABBTreeBuilder@Opcode@@UEAAPEAXI@Z ENDP		; Opcode::AABBTreeBuilder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXXZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Tidy, COMDAT

; 1622 : 		{	// free all storage

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN1@Tidy:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@IEAAXXZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::~vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT

; 944  : 		{	// destroy the object

$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]

; 944  : 		{	// destroy the object

	mov	rbx, rcx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN3@vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN3@vector:

; 945  : 		_Tidy();
; 946  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA@XZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::~vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ PROC ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::~xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >, COMDAT
$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN5@xr_vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN5@xr_vector:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAA@XZ ENDP ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::~xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?size@?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEBAIXZ PROC ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEBAIXZ ENDP ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_free@VAABBTreeNode@Opcode@@@@YAXAEAPEAVAABBTreeNode@Opcode@@@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@VAABBTreeNode@Opcode@@@@YAXAEAPEAVAABBTreeNode@Opcode@@@Z PROC ; xr_free<Opcode::AABBTreeNode>, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rdx, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rdx, rdx
	je	SHORT $LN1@xr_free
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rbx], 0
$LN1@xr_free:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$xr_free@VAABBTreeNode@Opcode@@@@YAXAEAPEAVAABBTreeNode@Opcode@@@Z ENDP ; xr_free<Opcode::AABBTreeNode>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBAAEBQEAVAABBTreeNode@Opcode@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBAAEBQEAVAABBTreeNode@Opcode@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBAAEBQEAVAABBTreeNode@Opcode@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBAAEAPEAVAABBTreeNode@Opcode@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBAAEAPEAVAABBTreeNode@Opcode@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBAAEAPEAVAABBTreeNode@Opcode@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 171  : 		return (*this);

	mov	rax, rcx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax+r8*8]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx

; 368  : 		}

	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAA@PEAPEAVAABBTreeNode@Opcode@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAA@PEAPEAVAABBTreeNode@Opcode@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAA@PEAPEAVAABBTreeNode@Opcode@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAA@PEAPEAVAABBTreeNode@Opcode@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAA@PEAPEAVAABBTreeNode@Opcode@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@std@@QEAA@PEAPEAVAABBTreeNode@Opcode@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Opcode::AABBTreeNode * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@2@XZ PROC ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVAABBTreeNode@Opcode@@@std@@@std@@@2@XZ ENDP ; std::vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??A?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAAAEAPEAVAABBTreeNode@Opcode@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAAAEAPEAVAABBTreeNode@Opcode@@_K@Z PROC ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::operator[], COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rax+rdx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 138  : 	reference operator[]		(size_type _Pos)					{ {VERIFY(_Pos<size());} return (*(begin() + _Pos)); }

	ret	0
??A?$xr_vector@PEAVAABBTreeNode@Opcode@@V?$xalloc@PEAVAABBTreeNode@Opcode@@@@@@QEAAAEAPEAVAABBTreeNode@Opcode@@_K@Z ENDP ; xr_vector<Opcode::AABBTreeNode * __ptr64,xalloc<Opcode::AABBTreeNode * __ptr64> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
;	COMDAT ??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ PROC ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::~poolSS<Opcode::AABBTreeNode,16384>, COMDAT

; 34   : 	{

$LN59:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 35   : 		for (u32 b=0; b<blocks.size(); b++)

	xor	ebp, ebp
	mov	QWORD PTR [rsp+56], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	rax, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 34   : 	{

	mov	rbx, rcx

; 35   : 		for (u32 b=0; b<blocks.size(); b++)

	mov	edi, ebp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sar	rax, 3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 35   : 		for (u32 b=0; b<blocks.size(); b++)

	test	eax, eax
	je	SHORT $LN1@poolSS
	mov	QWORD PTR [rsp+48], rsi
	npad	5
$LL3@poolSS:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	lea	rsi, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rdx, rdx
	je	SHORT $LN2@poolSS
	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
	mov	QWORD PTR [rsi], rbp
$LN2@poolSS:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rbx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 35   : 		for (u32 b=0; b<blocks.size(); b++)

	inc	edi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	rax, QWORD PTR [rbx+8]
	sar	rax, 3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 35   : 		for (u32 b=0; b<blocks.size(); b++)

	cmp	edi, eax
	jb	SHORT $LL3@poolSS
	mov	rsi, QWORD PTR [rsp+48]
$LN1@poolSS:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdx, QWORD PTR [rbx+8]
	mov	rdi, QWORD PTR [rsp+56]
	test	rdx, rdx
	je	SHORT $LN40@poolSS
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	mov	QWORD PTR [rbx+8], rbp

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+16], rbp

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+24], rbp
$LN40@poolSS:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 37   : 	}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ENDP ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::~poolSS<Opcode::AABBTreeNode,16384>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ??1AABBTreeBuilder@Opcode@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1AABBTreeBuilder@Opcode@@UEAA@XZ PROC			; Opcode::AABBTreeBuilder::~AABBTreeBuilder, COMDAT

; 55   : 		virtual									~AABBTreeBuilder()			{}

	lea	rax, OFFSET FLAT:??_7AABBTreeBuilder@Opcode@@6B@
	add	rcx, 32					; 00000020H
	mov	QWORD PTR [rcx-32], rax
	jmp	??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::~poolSS<Opcode::AABBTreeNode,16384>
??1AABBTreeBuilder@Opcode@@UEAA@XZ ENDP			; Opcode::AABBTreeBuilder::~AABBTreeBuilder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_GAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z PROC	; Opcode::AABBTreeOfTrianglesBuilder::`scalar deleting destructor', COMDAT
$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 55   : 		virtual									~AABBTreeBuilder()			{}

	lea	rax, OFFSET FLAT:??_7AABBTreeBuilder@Opcode@@6B@
	mov	rdi, rcx
	add	rcx, 32					; 00000020H
	mov	QWORD PTR [rcx-32], rax
	mov	ebx, edx
	call	??1?$poolSS@VAABBTreeNode@Opcode@@$0EAAA@@Opcode@@QEAA@XZ ; Opcode::poolSS<Opcode::AABBTreeNode,16384>::~poolSS<Opcode::AABBTreeNode,16384>
	test	bl, 1
	je	SHORT $LN13@scalar
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rcx, QWORD PTR __imp_?Memory@@3VxrMemory@@A
	mov	rdx, rdi
	call	QWORD PTR __imp_?mem_free@xrMemory@@QEAAXPEAX@Z
$LN13@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GAABBTreeOfTrianglesBuilder@Opcode@@UEAAPEAXI@Z ENDP	; Opcode::AABBTreeOfTrianglesBuilder::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
;	COMDAT ?GetCenter@AABB@Meshmerizer@@QEBAMI@Z
_TEXT	SEGMENT
this$ = 8
axis$ = 16
?GetCenter@AABB@Meshmerizer@@QEBAMI@Z PROC		; Meshmerizer::AABB::GetCenter, COMDAT

; 119  : 		inline_			float		GetCenter(udword axis)					const		{ return (((const float*)mMax)[axis] + ((const float*)mMin)[axis])*0.5f;	}

	mov	eax, edx
	movss	xmm0, DWORD PTR [rcx+rax*4+12]
	addss	xmm0, DWORD PTR [rcx+rax*4]
	mulss	xmm0, DWORD PTR __real@3f000000
	ret	0
?GetCenter@AABB@Meshmerizer@@QEBAMI@Z ENDP		; Meshmerizer::AABB::GetCenter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ?GetSplittingValueEx@AABBTreeBuilder@Opcode@@UEBAMPEBIIAEBVAABB@Meshmerizer@@I@Z
_TEXT	SEGMENT
this$ = 8
primitives$ = 16
nb_prims$ = 24
global_box$ = 32
axis$ = 40
?GetSplittingValueEx@AABBTreeBuilder@Opcode@@UEBAMPEBIIAEBVAABB@Meshmerizer@@I@Z PROC ; Opcode::AABBTreeBuilder::GetSplittingValueEx, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_aabb.h

; 119  : 		inline_			float		GetCenter(udword axis)					const		{ return (((const float*)mMax)[axis] + ((const float*)mMin)[axis])*0.5f;	}

	mov	eax, DWORD PTR axis$[rsp]
	movss	xmm0, DWORD PTR [r9+rax*4+12]
	addss	xmm0, DWORD PTR [r9+rax*4]
	mulss	xmm0, DWORD PTR __real@3f000000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 92   : 									}

	ret	0
?GetSplittingValueEx@AABBTreeBuilder@Opcode@@UEBAMPEBIIAEBVAABB@Meshmerizer@@I@Z ENDP ; Opcode::AABBTreeBuilder::GetSplittingValueEx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h
;	COMDAT ??0AABBTreeOfTrianglesBuilder@Opcode@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0AABBTreeOfTrianglesBuilder@Opcode@@QEAA@XZ PROC	; Opcode::AABBTreeOfTrianglesBuilder::AABBTreeOfTrianglesBuilder, COMDAT

; 53   : 													mNbInvalidSplits(0)		{}

	xor	edx, edx
	mov	QWORD PTR [rcx+12], 2147483647		; 7fffffffH

; 133  : 												AABBTreeOfTrianglesBuilder() : mTriList(null), mVerts(null), mNbTriangles(0)	{}

	lea	rax, OFFSET FLAT:??_7AABBTreeOfTrianglesBuilder@Opcode@@6B@

; 53   : 													mNbInvalidSplits(0)		{}

	mov	DWORD PTR [rcx+8], edx
	mov	QWORD PTR [rcx+20], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx+40], rdx

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+48], rdx

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+56], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrpool.h

; 31   : 		list				= 0;

	mov	QWORD PTR [rcx+32], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_treebuilders.h

; 133  : 												AABBTreeOfTrianglesBuilder() : mTriList(null), mVerts(null), mNbTriangles(0)	{}

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+64], rdx
	mov	QWORD PTR [rcx+72], rdx
	mov	rax, rcx
	mov	DWORD PTR [rcx+80], edx
	ret	0
??0AABBTreeOfTrianglesBuilder@Opcode@@QEAA@XZ ENDP	; Opcode::AABBTreeOfTrianglesBuilder::AABBTreeOfTrianglesBuilder
_TEXT	ENDS
END
