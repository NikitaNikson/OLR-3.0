; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_?ID@CPU@@3U_processor_info@@A:BYTE
EPS	DD	03727c5acr			; 1e-005
PUBLIC	?epsilon@?$numeric_limits@M@std@@SAMXZ		; std::numeric_limits<float>::epsilon
PUBLIC	?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,0,0>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,0,1>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,1,0>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,1,1>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,0,0>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,0,1>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,1,0>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,1,1>::_tri
PUBLIC	?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,0,0>::_tri
PUBLIC	?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,0,1>::_tri
PUBLIC	?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,1,0>::_tri
PUBLIC	?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,1,1>::_tri
PUBLIC	?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,0,0>::_tri
PUBLIC	?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,0,1>::_tri
PUBLIC	?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,1,0>::_tri
PUBLIC	?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,1,1>::_tri
PUBLIC	?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<0,0,0,0>::_prim
PUBLIC	?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,0,0,0>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,0,0,0>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z	; ray_collider<0,0,0,1>::_prim
PUBLIC	?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,0,0,1>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,0,0,1>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z	; ray_collider<0,0,1,0>::_prim
PUBLIC	?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,0,1,0>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,0,1,0>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z	; ray_collider<0,0,1,1>::_prim
PUBLIC	?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,0,1,1>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,0,1,1>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z	; ray_collider<0,1,0,0>::_prim
PUBLIC	?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,1,0,0>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,1,0,0>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z	; ray_collider<0,1,0,1>::_prim
PUBLIC	?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,1,0,1>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,1,0,1>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z	; ray_collider<0,1,1,0>::_prim
PUBLIC	?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,1,1,0>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,1,1,0>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z	; ray_collider<0,1,1,1>::_prim
PUBLIC	?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,1,1,1>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,1,1,1>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z	; ray_collider<1,0,0,0>::_prim
PUBLIC	?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,0,0,0>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,0,0,0>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z	; ray_collider<1,0,0,1>::_prim
PUBLIC	?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,0,0,1>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,0,0,1>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z	; ray_collider<1,0,1,0>::_prim
PUBLIC	?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,0,1,0>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,0,1,0>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z	; ray_collider<1,0,1,1>::_prim
PUBLIC	?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,0,1,1>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,0,1,1>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z	; ray_collider<1,1,0,0>::_prim
PUBLIC	?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,1,0,0>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,1,0,0>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z	; ray_collider<1,1,0,1>::_prim
PUBLIC	?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,1,0,1>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,1,0,1>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z	; ray_collider<1,1,1,0>::_prim
PUBLIC	?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,1,1,0>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,1,1,0>::_box_fpu
PUBLIC	?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z	; ray_collider<1,1,1,1>::_prim
PUBLIC	?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,1,1,1>::_box_sse
PUBLIC	?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,1,1,1>::_box_fpu
PUBLIC	?distance_to_sqr@?$_vector3@M@@QEBAMAEBU1@@Z	; _vector3<float>::distance_to_sqr
PUBLIC	?div@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z		; _vector3<float>::div
PUBLIC	?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,0>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,0,0,0>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,1>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,0,0,1>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,0>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,0,1,0>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,1>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,0,1,1>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,0>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,1,0,0>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,1>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,1,0,1>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,0>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,1,1,0>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,1>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,1,1,1>::_init
PUBLIC	?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,0>::_stab
PUBLIC	?_init@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,0,0,0>::_init
PUBLIC	?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,1>::_stab
PUBLIC	?_init@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,0,0,1>::_init
PUBLIC	?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,0>::_stab
PUBLIC	?_init@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,0,1,0>::_init
PUBLIC	?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,1>::_stab
PUBLIC	?_init@?$ray_collider@$00$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,0,1,1>::_init
PUBLIC	?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,0>::_stab
PUBLIC	?_init@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,1,0,0>::_init
PUBLIC	?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,1>::_stab
PUBLIC	?_init@?$ray_collider@$00$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,1,0,1>::_init
PUBLIC	?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,0>::_stab
PUBLIC	?_init@?$ray_collider@$00$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,1,1,0>::_init
PUBLIC	?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,1>::_stab
PUBLIC	?_init@?$ray_collider@$00$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,1,1,1>::_init
PUBLIC	??A?$_vector3@M@@QEBAAEAMH@Z			; _vector3<float>::operator[]
PUBLIC	??A?$_vector3@M@@QEAAAEAMH@Z			; _vector3<float>::operator[]
PUBLIC	?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z ; CDB::COLLIDER::ray_query
PUBLIC	?isect_sse@@YAHAEBUaabb_t@@AEBUray_t@@AEAM@Z	; isect_sse
PUBLIC	?isect_fpu@@YAHAEBU?$_vector3@M@@0AEBUray_t@@AEAU1@@Z ; isect_fpu
PUBLIC	?uf@@YAAEAIAEAM@Z				; uf
	ALIGN	4

flt_plus_inf DD	01H DUP (?)
ps_cst_plus_inf DD 04H DUP (?)
ps_cst_minus_inf DD 04H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+305
	DD	imagerel $LN45+577
	DD	imagerel $chain$0$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+577
	DD	imagerel $LN45+630
	DD	imagerel $chain$1$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+305
	DD	imagerel $LN45+577
	DD	imagerel $chain$0$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+577
	DD	imagerel $LN45+630
	DD	imagerel $chain$1$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+305
	DD	imagerel $LN45+577
	DD	imagerel $chain$0$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+577
	DD	imagerel $LN45+630
	DD	imagerel $chain$1$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+305
	DD	imagerel $LN45+577
	DD	imagerel $chain$0$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+577
	DD	imagerel $LN45+630
	DD	imagerel $chain$1$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+624
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+624
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+624
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+624
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+305
	DD	imagerel $LN45+577
	DD	imagerel $chain$0$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+577
	DD	imagerel $LN45+630
	DD	imagerel $chain$1$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+305
	DD	imagerel $LN45+577
	DD	imagerel $chain$0$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+577
	DD	imagerel $LN45+630
	DD	imagerel $chain$1$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+305
	DD	imagerel $LN45+577
	DD	imagerel $chain$0$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+577
	DD	imagerel $LN45+630
	DD	imagerel $chain$1$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+305
	DD	imagerel $LN45+577
	DD	imagerel $chain$0$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN45+577
	DD	imagerel $LN45+630
	DD	imagerel $chain$1$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+624
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+624
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+624
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+624
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN33+58
	DD	imagerel $LN33+254
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN33+254
	DD	imagerel $LN33+262
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z DD imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z DD imagerel $LN34+58
	DD	imagerel $LN34+458
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z DD imagerel $LN34+458
	DD	imagerel $LN34+466
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN33+58
	DD	imagerel $LN33+254
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN33+254
	DD	imagerel $LN33+262
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z DD imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z DD imagerel $LN34+58
	DD	imagerel $LN34+458
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z DD imagerel $LN34+458
	DD	imagerel $LN34+466
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z DD imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z DD imagerel $LN33+58
	DD	imagerel $LN33+254
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z DD imagerel $LN33+254
	DD	imagerel $LN33+262
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD imagerel $LN34+58
	DD	imagerel $LN34+458
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD imagerel $LN34+458
	DD	imagerel $LN34+466
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z DD imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z DD imagerel $LN33+58
	DD	imagerel $LN33+254
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z DD imagerel $LN33+254
	DD	imagerel $LN33+262
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD imagerel $LN34+58
	DD	imagerel $LN34+458
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD imagerel $LN34+458
	DD	imagerel $LN34+466
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN33+58
	DD	imagerel $LN33+254
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN33+254
	DD	imagerel $LN33+262
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z DD imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z DD imagerel $LN34+58
	DD	imagerel $LN34+458
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z DD imagerel $LN34+458
	DD	imagerel $LN34+466
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN33+58
	DD	imagerel $LN33+254
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN33+254
	DD	imagerel $LN33+262
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z DD imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z DD imagerel $LN34+58
	DD	imagerel $LN34+458
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z DD imagerel $LN34+458
	DD	imagerel $LN34+466
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z DD imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z DD imagerel $LN33+58
	DD	imagerel $LN33+254
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z DD imagerel $LN33+254
	DD	imagerel $LN33+262
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD imagerel $LN34+58
	DD	imagerel $LN34+458
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD imagerel $LN34+458
	DD	imagerel $LN34+466
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z DD imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z DD imagerel $LN33+58
	DD	imagerel $LN33+254
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z DD imagerel $LN33+254
	DD	imagerel $LN33+262
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD imagerel $LN34+58
	DD	imagerel $LN34+458
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD imagerel $LN34+458
	DD	imagerel $LN34+466
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD imagerel $LN10
	DD	imagerel $LN10+263
	DD	imagerel $unwind$?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN276
	DD	imagerel $LN276+637
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN322
	DD	imagerel $LN322+872
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN322
	DD	imagerel $LN322+872
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN329
	DD	imagerel $LN329+895
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN329
	DD	imagerel $LN329+895
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN322
	DD	imagerel $LN322+872
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN322
	DD	imagerel $LN322+872
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN329
	DD	imagerel $LN329+895
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN329
	DD	imagerel $LN329+895
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN316
	DD	imagerel $LN316+625
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN316
	DD	imagerel $LN316+625
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN323
	DD	imagerel $LN323+635
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN323
	DD	imagerel $LN323+635
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN316
	DD	imagerel $LN316+625
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN316
	DD	imagerel $LN316+625
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN323
	DD	imagerel $LN323+635
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN323
	DD	imagerel $LN323+635
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD imagerel $LN706
	DD	imagerel $LN706+1083
	DD	imagerel $unwind$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isect_sse@@YAHAEBUaabb_t@@AEBUray_t@@AEAM@Z DD imagerel $LN4
	DD	imagerel $LN4+148
	DD	imagerel $unwind$?isect_sse@@YAHAEBUaabb_t@@AEBUray_t@@AEAM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eflt_plus_inf@@YAXXZ DD imagerel ??__Eflt_plus_inf@@YAXXZ
	DD	imagerel ??__Eflt_plus_inf@@YAXXZ+32
	DD	imagerel $unwind$??__Eflt_plus_inf@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?isect_fpu@@YAHAEBU?$_vector3@M@@0AEBUray_t@@AEAU1@@Z DD imagerel $LN271
	DD	imagerel $LN271+619
	DD	imagerel $unwind$?isect_fpu@@YAHAEBU?$_vector3@M@@0AEBUray_t@@AEAU1@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isect_fpu@@YAHAEBU?$_vector3@M@@0AEBUray_t@@AEAU1@@Z DD 020601H
	DD	030021206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eflt_plus_inf@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?isect_sse@@YAHAEBUaabb_t@@AEBUray_t@@AEAM@Z DD 030c01H
	DD	0680cH
	DD	02204H
xdata	ENDS
xdata	SEGMENT
$unwind$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD 0a1f01H
	DD	015e41fH
	DD	014741fH
	DD	013641fH
	DD	012341fH
	DD	05015f21fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 0c4101H
	DD	047841H
	DD	056826H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 0c4101H
	DD	047841H
	DD	056826H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 0c4101H
	DD	047841H
	DD	056826H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 0c4101H
	DD	047841H
	DD	056826H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 0c4101H
	DD	047841H
	DD	056826H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 0c4101H
	DD	047841H
	DD	056826H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 0c4101H
	DD	047841H
	DD	056826H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 0c4101H
	DD	047841H
	DD	056826H
	DD	0117417H
	DD	0106417H
	DD	0f3417H
	DD	05010b217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6b01H
	DD	04f86bH
	DD	05e865H
	DD	06d85fH
	DD	07c859H
	DD	08b854H
	DD	09a84fH
	DD	0a984aH
	DD	0b883eH
	DD	0c7825H
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6b01H
	DD	04f86bH
	DD	05e865H
	DD	06d85fH
	DD	07c859H
	DD	08b854H
	DD	09a84fH
	DD	0a984aH
	DD	0b883eH
	DD	0c7825H
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6b01H
	DD	04f86bH
	DD	05e865H
	DD	06d85fH
	DD	07c859H
	DD	08b854H
	DD	09a84fH
	DD	0a984aH
	DD	0b883eH
	DD	0c7825H
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6b01H
	DD	04f86bH
	DD	05e865H
	DD	06d85fH
	DD	07c859H
	DD	08b854H
	DD	09a84fH
	DD	0a984aH
	DD	0b883eH
	DD	0c7825H
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6b01H
	DD	04f86bH
	DD	05e865H
	DD	06d85fH
	DD	07c859H
	DD	08b854H
	DD	09a84fH
	DD	0a984aH
	DD	0b883eH
	DD	0c7825H
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6b01H
	DD	04f86bH
	DD	05e865H
	DD	06d85fH
	DD	07c859H
	DD	08b854H
	DD	09a84fH
	DD	0a984aH
	DD	0b883eH
	DD	0c7825H
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6b01H
	DD	04f86bH
	DD	05e865H
	DD	06d85fH
	DD	07c859H
	DD	08b854H
	DD	09a84fH
	DD	0a984aH
	DD	0b883eH
	DD	0c7825H
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6b01H
	DD	04f86bH
	DD	05e865H
	DD	06d85fH
	DD	07c859H
	DD	08b854H
	DD	09a84fH
	DD	0a984aH
	DD	0b883eH
	DD	0c7825H
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN34
	DD	imagerel $LN34+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 094a01H
	DD	01984aH
	DD	028822H
	DD	03781cH
	DD	046817H
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z DD 031901H
	DD	026819H
	DD	06207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD 020521H
	DD	036805H
	DD	imagerel $LN33
	DD	imagerel $LN33+58
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD 040801H
	DD	070047208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z DD 0176801H
	DD	0f868H
	DD	01e863H
	DD	02d84aH
	DD	03c840H
	DD	04b83bH
	DD	05a836H
	DD	069831H
	DD	078826H
	DD	087821H
	DD	096818H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z DD 0176801H
	DD	0f868H
	DD	01e863H
	DD	02d84aH
	DD	03c840H
	DD	04b83bH
	DD	05a836H
	DD	069831H
	DD	078826H
	DD	087821H
	DD	096818H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z DD 0176801H
	DD	0f868H
	DD	01e863H
	DD	02d84aH
	DD	03c840H
	DD	04b83bH
	DD	05a836H
	DD	069831H
	DD	078826H
	DD	087821H
	DD	096818H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 0176801H
	DD	0f868H
	DD	01e863H
	DD	02d84aH
	DD	03c840H
	DD	04b83bH
	DD	05a836H
	DD	069831H
	DD	078826H
	DD	087821H
	DD	096818H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD 020521H
	DD	077805H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD 0135d01H
	DD	0f85dH
	DD	01e851H
	DD	02d83cH
	DD	03c837H
	DD	04b832H
	DD	05a82dH
	DD	069822H
	DD	086818H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD 020521H
	DD	077805H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD 0135d01H
	DD	0f85dH
	DD	01e851H
	DD	02d83cH
	DD	03c837H
	DD	04b832H
	DD	05a82dH
	DD	069822H
	DD	086818H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD 020521H
	DD	077805H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD 0135d01H
	DD	0f85dH
	DD	01e851H
	DD	02d83cH
	DD	03c837H
	DD	04b832H
	DD	05a82dH
	DD	069822H
	DD	086818H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 020521H
	DD	077805H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 0135d01H
	DD	0f85dH
	DD	01e851H
	DD	02d83cH
	DD	03c837H
	DD	04b832H
	DD	05a82dH
	DD	069822H
	DD	086818H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z DD 0176801H
	DD	0f868H
	DD	01e863H
	DD	02d84aH
	DD	03c840H
	DD	04b83bH
	DD	05a836H
	DD	069831H
	DD	078826H
	DD	087821H
	DD	096818H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z DD 0176801H
	DD	0f868H
	DD	01e863H
	DD	02d84aH
	DD	03c840H
	DD	04b83bH
	DD	05a836H
	DD	069831H
	DD	078826H
	DD	087821H
	DD	096818H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z DD 0176801H
	DD	0f868H
	DD	01e863H
	DD	02d84aH
	DD	03c840H
	DD	04b83bH
	DD	05a836H
	DD	069831H
	DD	078826H
	DD	087821H
	DD	096818H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 0176801H
	DD	0f868H
	DD	01e863H
	DD	02d84aH
	DD	03c840H
	DD	04b83bH
	DD	05a836H
	DD	069831H
	DD	078826H
	DD	087821H
	DD	096818H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD 020521H
	DD	077805H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD 0135d01H
	DD	0f85dH
	DD	01e851H
	DD	02d83cH
	DD	03c837H
	DD	04b832H
	DD	05a82dH
	DD	069822H
	DD	086818H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD 020521H
	DD	077805H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD 0135d01H
	DD	0f85dH
	DD	01e851H
	DD	02d83cH
	DD	03c837H
	DD	04b832H
	DD	05a82dH
	DD	069822H
	DD	086818H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD 020521H
	DD	077805H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD 0135d01H
	DD	0f85dH
	DD	01e851H
	DD	02d83cH
	DD	03c837H
	DD	04b832H
	DD	05a82dH
	DD	069822H
	DD	086818H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 021H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 020521H
	DD	077805H
	DD	imagerel $LN45
	DD	imagerel $LN45+305
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 0135d01H
	DD	0f85dH
	DD	01e851H
	DD	02d83cH
	DD	03c837H
	DD	04b832H
	DD	05a82dH
	DD	069822H
	DD	086818H
	DD	012010bH
	DD	03004H
flt_plus_inf$initializer$ DQ FLAT:??__Eflt_plus_inf@@YAXXZ
ps_cst_plus_inf$initializer$ DQ FLAT:??__Eps_cst_plus_inf@@YAXXZ
ps_cst_minus_inf$initializer$ DQ FLAT:??__Eps_cst_minus_inf@@YAXXZ
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?uf@@YAAEAIAEAM@Z
_TEXT	SEGMENT
x$ = 8
?uf@@YAAEAIAEAM@Z PROC					; uf, COMDAT

; 35   : ICF u32&	uf			(float &x)	{ return (u32&)x; }

	mov	rax, rcx
	ret	0
?uf@@YAAEAIAEAM@Z ENDP					; uf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?isect_fpu@@YAHAEBU?$_vector3@M@@0AEBUray_t@@AEAU1@@Z
_TEXT	SEGMENT
MaxT$ = 0
min$ = 32
max$ = 40
ray$ = 48
coord$ = 56
?isect_fpu@@YAHAEBU?$_vector3@M@@0AEBUray_t@@AEAU1@@Z PROC ; isect_fpu, COMDAT

; 37   : {

$LN271:
	push	rbx
	sub	rsp, 16

; 38   : 	Fvector				MaxT;
; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000

; 40   : 	BOOL Inside			= TRUE;
; 41   : 
; 42   : 	// Find candidate planes.
; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm4, DWORD PTR [r8]
	movss	xmm3, DWORD PTR [rcx]
	mov	ebx, 1
	xor	r10d, r10d
	mov	eax, ebx
	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	comiss	xmm4, xmm3
	movss	DWORD PTR MaxT$[rsp+4], xmm2
	movss	DWORD PTR MaxT$[rsp], xmm0
	movss	DWORD PTR MaxT$[rsp+8], xmm1
	jae	SHORT $LN34@isect_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	mov	eax, r10d
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [r8+16], eax
	je	SHORT $LN30@isect_fpu
	movss	xmm0, DWORD PTR [rcx]

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN265@isect_fpu
$LN34@isect_fpu:
	movss	xmm3, DWORD PTR [rdx]
	comiss	xmm4, xmm3
	jbe	SHORT $LN30@isect_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	mov	eax, r10d
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [r8+16], eax
	je	SHORT $LN30@isect_fpu
	movss	xmm0, DWORD PTR [rdx]
$LN265@isect_fpu:
	subss	xmm0, DWORD PTR [r8]
	mulss	xmm0, DWORD PTR [r8+16]
	movss	DWORD PTR MaxT$[rsp], xmm0
$LN30@isect_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [rcx+4]
	comiss	xmm4, xmm3
	jae	SHORT $LN29@isect_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	mov	eax, r10d
	movss	DWORD PTR [r9+4], xmm3

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [r8+20], eax
	je	SHORT $LN25@isect_fpu
	movss	xmm2, DWORD PTR [rcx+4]

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN266@isect_fpu
$LN29@isect_fpu:
	movss	xmm3, DWORD PTR [rdx+4]
	comiss	xmm4, xmm3
	jbe	SHORT $LN25@isect_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	mov	eax, r10d
	movss	DWORD PTR [r9+4], xmm3

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [r8+20], eax
	je	SHORT $LN25@isect_fpu
	movss	xmm2, DWORD PTR [rdx+4]
$LN266@isect_fpu:
	subss	xmm2, DWORD PTR [r8+4]
	mulss	xmm2, DWORD PTR [r8+20]
	movss	DWORD PTR MaxT$[rsp+4], xmm2
$LN25@isect_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm3, DWORD PTR [rcx+8]
	comiss	xmm4, xmm3
	jae	$LN24@isect_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm3

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [r8+24], r10d
	je	SHORT $LN19@isect_fpu
	movss	xmm1, DWORD PTR [rcx+8]
$LN267@isect_fpu:
	subss	xmm1, DWORD PTR [r8+8]
	mulss	xmm1, DWORD PTR [r8+24]
	movss	DWORD PTR MaxT$[rsp+8], xmm1
$LN19@isect_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r11d, 2
	cmova	r10d, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$[rsp+rax*4]
	cmova	r10d, r11d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$[rsp+rax*4], -2147483648	; 80000000H
	jne	$LN5@isect_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r10d, r10d
	jne	$LN15@isect_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [r8+36]
	addss	xmm3, DWORD PTR [r8+4]
	movss	DWORD PTR [r9+4], xmm3

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, DWORD PTR [rcx+4]
	jb	$LN5@isect_fpu
	comiss	xmm3, DWORD PTR [rdx+4]
	ja	$LN5@isect_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [r8+40]
	addss	xmm0, DWORD PTR [r8+8]
	movss	DWORD PTR [r9+8], xmm0

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, DWORD PTR [rcx+8]
	jb	$LN5@isect_fpu
	comiss	xmm0, DWORD PTR [rdx+8]
	ja	$LN5@isect_fpu

; 90   : 		return true;

	mov	eax, ebx

; 107  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN24@isect_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	movss	xmm3, DWORD PTR [rdx+8]
	comiss	xmm4, xmm3
	jbe	SHORT $LN20@isect_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm3

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [r8+24], r10d
	je	$LN19@isect_fpu
	movss	xmm1, DWORD PTR [rdx+8]

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN267@isect_fpu
$LN20@isect_fpu:
	test	eax, eax
	je	$LN19@isect_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [r8]
	movsdx	QWORD PTR [r9], xmm0
	mov	ecx, DWORD PTR [r8+8]
	mov	DWORD PTR [r9+8], ecx
$LN269@isect_fpu:

; 74   : 		return		true;

	mov	eax, ebx

; 107  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN15@isect_fpu:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r10d, ebx
	jne	SHORT $LN10@isect_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [r8+32]
	addss	xmm0, DWORD PTR [r8]
	movss	DWORD PTR [r9], xmm0

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN5@isect_fpu
	comiss	xmm0, DWORD PTR [rdx]
	ja	SHORT $LN5@isect_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [r8+40]
	addss	xmm2, DWORD PTR [r8+8]
	movss	DWORD PTR [r9+8], xmm2

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, DWORD PTR [rcx+8]
	jb	SHORT $LN5@isect_fpu
	comiss	xmm2, DWORD PTR [rdx+8]
	ja	SHORT $LN5@isect_fpu

; 97   : 		return true;

	mov	eax, ebx

; 107  : }

	add	rsp, 16
	pop	rbx
	ret	0
$LN10@isect_fpu:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r10d, r11d
	jne	SHORT $LN5@isect_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [r8+32]
	addss	xmm0, DWORD PTR [r8]
	movss	DWORD PTR [r9], xmm0

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, DWORD PTR [rcx]
	jb	SHORT $LN5@isect_fpu
	comiss	xmm0, DWORD PTR [rdx]
	ja	SHORT $LN5@isect_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [r8+36]
	addss	xmm1, DWORD PTR [r8+4]
	movss	DWORD PTR [r9+4], xmm1

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, DWORD PTR [rcx+4]
	jb	SHORT $LN5@isect_fpu
	comiss	xmm1, DWORD PTR [rdx+4]
	jbe	$LN269@isect_fpu
$LN5@isect_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	eax, eax

; 107  : }

	add	rsp, 16
	pop	rbx
	ret	0
?isect_fpu@@YAHAEBU?$_vector3@M@@0AEBUray_t@@AEAU1@@Z ENDP ; isect_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ??__Eflt_plus_inf@@YAXXZ
text$di	SEGMENT
??__Eflt_plus_inf@@YAXXZ PROC				; `dynamic initializer for 'flt_plus_inf'', COMDAT

; 122  : static const float flt_plus_inf = -logf(0);	// let's keep C and C++ compilers happy.

	sub	rsp, 40					; 00000028H
	xorps	xmm0, xmm0
	call	logf
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR flt_plus_inf, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__Eflt_plus_inf@@YAXXZ ENDP				; `dynamic initializer for 'flt_plus_inf''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ??__Eps_cst_plus_inf@@YAXXZ
text$di	SEGMENT
??__Eps_cst_plus_inf@@YAXXZ PROC			; `dynamic initializer for 'ps_cst_plus_inf'', COMDAT

; 124  : 	ps_cst_plus_inf	[4]	=	{  flt_plus_inf,  flt_plus_inf,  flt_plus_inf,  flt_plus_inf },

	movss	xmm0, DWORD PTR flt_plus_inf
	shufps	xmm0, xmm0, 0
	movaps	XMMWORD PTR ps_cst_plus_inf, xmm0
	ret	0
??__Eps_cst_plus_inf@@YAXXZ ENDP			; `dynamic initializer for 'ps_cst_plus_inf''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ??__Eps_cst_minus_inf@@YAXXZ
text$di	SEGMENT
??__Eps_cst_minus_inf@@YAXXZ PROC			; `dynamic initializer for 'ps_cst_minus_inf'', COMDAT

; 125  : 	ps_cst_minus_inf[4]	=	{ -flt_plus_inf, -flt_plus_inf, -flt_plus_inf, -flt_plus_inf };

	movss	xmm0, DWORD PTR flt_plus_inf
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	shufps	xmm0, xmm0, 0
	movaps	XMMWORD PTR ps_cst_minus_inf, xmm0
	ret	0
??__Eps_cst_minus_inf@@YAXXZ ENDP			; `dynamic initializer for 'ps_cst_minus_inf''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?isect_sse@@YAHAEBUaabb_t@@AEBUray_t@@AEAM@Z
_TEXT	SEGMENT
box$ = 32
ray$ = 40
dist$ = 48
?isect_sse@@YAHAEBUaabb_t@@AEBUray_t@@AEAM@Z PROC	; isect_sse, COMDAT

; 127  : ICF BOOL isect_sse			(const aabb_t &box, const ray_t &ray, float &dist)	{

$LN4:
	sub	rsp, 24

; 128  : 	// you may already have those values hanging around somewhere
; 129  : 	const __m128
; 130  : 		plus_inf	= loadps(ps_cst_plus_inf),
; 131  : 		minus_inf	= loadps(ps_cst_minus_inf);
; 132  : 
; 133  : 	// use whatever's apropriate to load.
; 134  : 	const __m128
; 135  : 		box_min		= loadps(&box.min),
; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rsp], xmm6
	movaps	xmm6, XMMWORD PTR [rcx]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);
; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);
; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);
; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);
; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);
; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);
; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);
; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);
; 159  : 	const __m128 lmin0 = rotatelps(lmin);
; 160  : 	lmax = minss(lmax, lmax0);
; 161  : 	lmin = maxss(lmin, lmin0);
; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);
; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 165  : 	lmax = minss(lmax, lmax1);
; 166  : 	lmin = maxss(lmin, lmin1);
; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	subps	xmm6, XMMWORD PTR [rdx]
	subps	xmm2, XMMWORD PTR [rdx]
	mulps	xmm6, XMMWORD PTR [rdx+16]
	mulps	xmm2, XMMWORD PTR [rdx+16]
	mov	edx, 1
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r8], xmm6

; 171  : 	//storess	(lmax, &rs.t_far);
; 172  : 
; 173  : 	return  ret;
; 174  : }

	movaps	xmm6, XMMWORD PTR [rsp]
	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx
	add	rsp, 24
	ret	0
?isect_sse@@YAHAEBUaabb_t@@AEBUray_t@@AEAM@Z ENDP	; isect_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
_TEXT	SEGMENT
RC$1 = 32
RC$2 = 32
RC$3 = 32
RC$4 = 32
RC$5 = 32
RC$6 = 32
RC$7 = 32
RC$8 = 32
RC$9 = 32
RC$10 = 32
RC$11 = 32
RC$12 = 32
this$ = 144
m_def$ = 152
r_start$ = 160
r_dir$ = 168
r_range$ = 176
?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z PROC ; CDB::COLLIDER::ray_query

; 345  : {

$LN706:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	mov	QWORD PTR [rsp+32], r14
	push	rbp
	mov	rbp, rsp
	sub	rsp, 128				; 00000080H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 101  : 			if (S_READY!=status)

	cmp	DWORD PTR [rdx+16], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 345  : {

	mov	rdi, r9
	mov	rsi, r8
	mov	rbx, rdx
	mov	r14, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 101  : 			if (S_READY!=status)

	je	SHORT $LN33@ray_query

; 102  : 			{
; 103  : 				Log						("! WARNING: syncronized CDB::query");
; 104  : 				xrCriticalSection*	C	= (xrCriticalSection*) &cs;
; 105  : 				C->Enter				();

	mov	rcx, rdx
	call	QWORD PTR __imp_?Enter@xrCriticalSection@@QEAAXXZ

; 106  : 				C->Leave				();

	mov	rcx, rbx
	call	QWORD PTR __imp_?Leave@xrCriticalSection@@QEAAXXZ
$LN33@ray_query:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	rax, QWORD PTR [rbx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	xmm0, DWORD PTR [rsi]
	movss	xmm1, DWORD PTR [rsi+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR RC$12[rbp-128], r14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	r8, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [r14+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR RC$12[rbp-96], xmm0
	movss	xmm0, DWORD PTR [rsi+8]
	movss	DWORD PTR RC$12[rbp-92], xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	rdx, QWORD PTR [r8+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [r14+24], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 353  : 	if (CPU::ID.feature&_CPU_FEATURE_SSE)	{

	mov	rax, QWORD PTR __imp_?ID@CPU@@3U_processor_info@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR RC$12[rbp-88], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 353  : 	if (CPU::ID.feature&_CPU_FEATURE_SSE)	{

	test	BYTE PTR [rax+108], 4

; 354  : 		// SSE
; 355  : 		// Binary dispatcher
; 356  : 		if (ray_mode&OPT_CULL)		{

	mov	eax, DWORD PTR [r14]
	je	$LN30@ray_query
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm4, DWORD PTR [rdi]
	movss	xmm2, DWORD PTR [rdi+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 361  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$12[rbp-128]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm3
	movaps	xmm1, xmm3
	divss	xmm0, xmm4
	divss	xmm1, xmm2

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR RC$12[rbp-64], xmm4
	movss	DWORD PTR RC$12[rbp-60], xmm2

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR RC$12[rbp-80], xmm0
	movss	xmm0, DWORD PTR [rdi+8]
	movss	DWORD PTR RC$12[rbp-76], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR RC$12[rbp-56], xmm0

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm3, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR r_range$[rbp-128]
	movss	DWORD PTR RC$12[rbp-48], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR RC$12[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 197  : 		rRange2			= R*R;

	movss	DWORD PTR RC$12[rbp-44], xmm0

; 354  : 		// SSE
; 355  : 		// Binary dispatcher
; 356  : 		if (ray_mode&OPT_CULL)		{

	test	al, 1
	je	SHORT $LN29@ray_query

; 357  : 			if (ray_mode&OPT_ONLYFIRST)		{

	test	al, 2
	je	SHORT $LN28@ray_query

; 358  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	al, 4

; 191  : 		tris			= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR RC$12[rbp-120], rax

; 192  : 		verts			= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR RC$12[rbp-112], rax

; 358  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	je	SHORT $LN27@ray_query

; 361  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,1>::_stab

; 362  : 				} else {

	jmp	$LN1@ray_query
$LN27@ray_query:

; 363  : 					ray_collider<true,true,true,false>		RC;
; 364  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 365  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,0>::_stab

; 366  : 				}
; 367  : 			} else {

	jmp	$LN1@ray_query
$LN28@ray_query:

; 368  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	al, 4

; 191  : 		tris			= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR RC$11[rbp-120], rax

; 192  : 		verts			= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR RC$11[rbp-112], rax

; 368  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	je	SHORT $LN24@ray_query

; 369  : 					ray_collider<true,true,false,true>		RC;
; 370  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 371  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,1>::_stab

; 372  : 				} else {

	jmp	$LN1@ray_query
$LN24@ray_query:

; 373  : 					ray_collider<true,true,false,false>		RC;
; 374  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 375  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,0>::_stab

; 376  : 				}
; 377  : 			}
; 378  : 		} else {

	jmp	$LN1@ray_query
$LN29@ray_query:

; 379  : 			if (ray_mode&OPT_ONLYFIRST)		{

	test	al, 2
	je	SHORT $LN21@ray_query

; 380  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	al, 4

; 191  : 		tris			= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR RC$10[rbp-120], rax

; 192  : 		verts			= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR RC$10[rbp-112], rax

; 380  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	je	SHORT $LN20@ray_query

; 381  : 					ray_collider<true,false,true,true>		RC;
; 382  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 383  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,1>::_stab

; 384  : 				} else {

	jmp	$LN1@ray_query
$LN20@ray_query:

; 385  : 					ray_collider<true,false,true,false>		RC;
; 386  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 387  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,0>::_stab

; 388  : 				}
; 389  : 			} else {

	jmp	$LN1@ray_query
$LN21@ray_query:

; 390  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	al, 4

; 191  : 		tris			= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR RC$9[rbp-120], rax

; 192  : 		verts			= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR RC$9[rbp-112], rax

; 390  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	je	SHORT $LN17@ray_query

; 391  : 					ray_collider<true,false,false,true>		RC;
; 392  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 393  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,1>::_stab

; 394  : 				} else {

	jmp	$LN1@ray_query
$LN17@ray_query:

; 395  : 					ray_collider<true,false,false,false>	RC;
; 396  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 397  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,0>::_stab

; 398  : 				}
; 399  : 			}
; 400  : 		}
; 401  : 	} else {

	jmp	$LN1@ray_query
$LN30@ray_query:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm2, DWORD PTR __real@3f800000
	movss	xmm3, DWORD PTR [rdi]
	movss	xmm5, DWORD PTR [rdi+4]
	movaps	xmm0, xmm2
	movaps	xmm1, xmm2
	divss	xmm0, xmm3
	divss	xmm1, xmm5
	movss	xmm4, DWORD PTR [rdi+8]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	movss	DWORD PTR RC$8[rbp-64], xmm3
	movss	DWORD PTR RC$8[rbp-60], xmm5
	movss	DWORD PTR RC$8[rbp-56], xmm4

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR RC$8[rbp-80], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR r_range$[rbp-128]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR RC$8[rbp-76], xmm1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR RC$8[rbp-48], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 197  : 		rRange2			= R*R;

	movss	DWORD PTR RC$8[rbp-44], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR RC$8[rbp-72], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm2, DWORD PTR __real@34000000

; 402  : 		// FPU
; 403  : 		// Binary dispatcher
; 404  : 		if (ray_mode&OPT_CULL)		{

	test	al, 1
	je	$LN14@ray_query

; 405  : 			if (ray_mode&OPT_ONLYFIRST)		{

	test	al, 2
	je	$LN13@ray_query

; 406  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	al, 4

; 191  : 		tris			= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR RC$8[rbp-120], rax

; 192  : 		verts			= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR RC$8[rbp-112], rax

; 406  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	je	SHORT $LN12@ray_query

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm3, xmm2
	ja	SHORT $LN425@ray_query
	mov	DWORD PTR RC$8[rbp-80], 0
$LN425@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm5, xmm2
	ja	SHORT $LN423@ray_query
	mov	DWORD PTR RC$8[rbp-76], 0
$LN423@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm4, xmm2
	ja	SHORT $LN421@ray_query
	mov	DWORD PTR RC$8[rbp-72], 0
$LN421@ray_query:

; 407  : 					ray_collider<false,true,true,true>		RC;
; 408  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 409  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$8[rbp-128]
	call	?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,1>::_stab

; 410  : 				} else {

	jmp	$LN1@ray_query
$LN12@ray_query:

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm3, xmm2
	ja	SHORT $LN460@ray_query
	mov	DWORD PTR RC$7[rbp-80], 0
$LN460@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm5, xmm2
	ja	SHORT $LN458@ray_query
	mov	DWORD PTR RC$7[rbp-76], 0
$LN458@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm4, xmm2
	ja	SHORT $LN456@ray_query
	mov	DWORD PTR RC$7[rbp-72], 0
$LN456@ray_query:

; 411  : 					ray_collider<false,true,true,false>		RC;
; 412  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 413  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$7[rbp-128]
	call	?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,0>::_stab

; 414  : 				}
; 415  : 			} else {

	jmp	$LN1@ray_query
$LN13@ray_query:

; 416  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	al, 4

; 191  : 		tris			= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR RC$6[rbp-120], rax

; 192  : 		verts			= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR RC$6[rbp-112], rax

; 416  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	je	SHORT $LN9@ray_query

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm3, xmm2
	ja	SHORT $LN495@ray_query
	mov	DWORD PTR RC$6[rbp-80], 0
$LN495@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm5, xmm2
	ja	SHORT $LN493@ray_query
	mov	DWORD PTR RC$6[rbp-76], 0
$LN493@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm4, xmm2
	ja	SHORT $LN491@ray_query
	mov	DWORD PTR RC$6[rbp-72], 0
$LN491@ray_query:

; 417  : 					ray_collider<false,true,false,true>		RC;
; 418  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 419  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$6[rbp-128]
	call	?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,1>::_stab

; 420  : 				} else {

	jmp	$LN1@ray_query
$LN9@ray_query:

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm3, xmm2
	ja	SHORT $LN530@ray_query
	mov	DWORD PTR RC$5[rbp-80], 0
$LN530@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm5, xmm2
	ja	SHORT $LN528@ray_query
	mov	DWORD PTR RC$5[rbp-76], 0
$LN528@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm4, xmm2
	ja	SHORT $LN526@ray_query
	mov	DWORD PTR RC$5[rbp-72], 0
$LN526@ray_query:

; 421  : 					ray_collider<false,true,false,false>	RC;
; 422  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 423  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$5[rbp-128]
	call	?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,0>::_stab

; 424  : 				}
; 425  : 			}
; 426  : 		} else {

	jmp	$LN1@ray_query
$LN14@ray_query:

; 427  : 			if (ray_mode&OPT_ONLYFIRST)		{

	test	al, 2
	je	$LN6@ray_query

; 428  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	al, 4

; 191  : 		tris			= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR RC$4[rbp-120], rax

; 192  : 		verts			= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR RC$4[rbp-112], rax

; 428  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	je	SHORT $LN5@ray_query

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm3, xmm2
	ja	SHORT $LN565@ray_query
	mov	DWORD PTR RC$4[rbp-80], 0
$LN565@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm5, xmm2
	ja	SHORT $LN563@ray_query
	mov	DWORD PTR RC$4[rbp-76], 0
$LN563@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm4, xmm2
	ja	SHORT $LN561@ray_query
	mov	DWORD PTR RC$4[rbp-72], 0
$LN561@ray_query:

; 429  : 					ray_collider<false,false,true,true>		RC;
; 430  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 431  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$4[rbp-128]
	call	?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,1>::_stab

; 432  : 				} else {

	jmp	$LN1@ray_query
$LN5@ray_query:

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm3, xmm2
	ja	SHORT $LN600@ray_query
	mov	DWORD PTR RC$3[rbp-80], 0
$LN600@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm5, xmm2
	ja	SHORT $LN598@ray_query
	mov	DWORD PTR RC$3[rbp-76], 0
$LN598@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm4, xmm2
	ja	SHORT $LN596@ray_query
	mov	DWORD PTR RC$3[rbp-72], 0
$LN596@ray_query:

; 433  : 					ray_collider<false,false,true,false>	RC;
; 434  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 435  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$3[rbp-128]
	call	?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,0>::_stab

; 436  : 				}
; 437  : 			} else {

	jmp	SHORT $LN1@ray_query
$LN6@ray_query:

; 438  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	al, 4

; 191  : 		tris			= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR RC$2[rbp-120], rax

; 192  : 		verts			= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR RC$2[rbp-112], rax

; 438  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	je	SHORT $LN2@ray_query

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm3, xmm2
	ja	SHORT $LN635@ray_query
	mov	DWORD PTR RC$2[rbp-80], 0
$LN635@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm5, xmm2
	ja	SHORT $LN633@ray_query
	mov	DWORD PTR RC$2[rbp-76], 0
$LN633@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm4, xmm2
	ja	SHORT $LN631@ray_query
	mov	DWORD PTR RC$2[rbp-72], 0
$LN631@ray_query:

; 439  : 					ray_collider<false,false,false,true>	RC;
; 440  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 441  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$2[rbp-128]
	call	?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,1>::_stab

; 442  : 				} else {

	jmp	SHORT $LN1@ray_query
$LN2@ray_query:

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm3, xmm2
	ja	SHORT $LN670@ray_query
	mov	DWORD PTR RC$1[rbp-80], 0
$LN670@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm5, xmm2
	ja	SHORT $LN668@ray_query
	mov	DWORD PTR RC$1[rbp-76], 0
$LN668@ray_query:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm4, xmm2
	ja	SHORT $LN666@ray_query
	mov	DWORD PTR RC$1[rbp-72], 0
$LN666@ray_query:

; 443  : 					ray_collider<false,false,false,false>	RC;
; 444  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 445  : 					RC._stab(N);

	lea	rcx, QWORD PTR RC$1[rbp-128]
	call	?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,0>::_stab
$LN1@ray_query:

; 446  : 				}
; 447  : 			}
; 448  : 		}
; 449  : 	}
; 450  : }

	lea	r11, QWORD PTR [rsp+128]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	mov	r14, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z ENDP ; CDB::COLLIDER::ray_query
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ??A?$_vector3@M@@QEAAAEAMH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$_vector3@M@@QEAAAEAMH@Z PROC			; _vector3<float>::operator[], COMDAT

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, edx
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
??A?$_vector3@M@@QEAAAEAMH@Z ENDP			; _vector3<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ??A?$_vector3@M@@QEBAAEAMH@Z
_TEXT	SEGMENT
this$ = 8
i$ = 16
??A?$_vector3@M@@QEBAAEAMH@Z PROC			; _vector3<float>::operator[], COMDAT

; 21   : 	ICF	T&			operator[] (int i)	const			{ return *((T*)this + i); }

	movsxd	rax, edx
	lea	rax, QWORD PTR [rcx+rax*4]
	ret	0
??A?$_vector3@M@@QEBAAEAMH@Z ENDP			; _vector3<float>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,1,1,1>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 189  : 	{

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [r10+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r10+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
	movss	DWORD PTR [r10+84], xmm0

; 198  : 		if (!bUseSSE)	{
; 199  : 			// for FPU - zero out inf
; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$00$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,1,1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
box$1 = 32
d$2 = 112
this$ = 112
node$ = 120
?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,1,1,1>::_stab, COMDAT

; 317  : 	{

$LN323:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 317  : 	{

	mov	rdi, rcx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	esi, 1
	movaps	XMMWORD PTR [rsp+64], xmm7
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	xorps	xmm7, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 317  : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN1@stab
	npad	9
$LL312@stab:

; 323  : 			if (d>rRange)																	return;

	movss	xmm0, DWORD PTR d$2[rbp-96]
	comiss	xmm0, DWORD PTR [rdi+80]
	ja	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z ; ray_collider<1,1,1,1>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 336  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN318@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rbx, QWORD PTR [rbx+32]

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], ecx

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], ecx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rdi+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rdi+32]
	mulps	xmm6, XMMWORD PTR [rdi+48]
	mulps	xmm2, XMMWORD PTR [rdi+48]

; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm5, xmm6

; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf

; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf

; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm5, xmm0

; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm6, xmm2

; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm5

; 159  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H

; 160  : 	lmax = minss(lmax, lmax0);

	minss	xmm5, xmm0

; 161  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm6, xmm1

; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movhlps	xmm0, xmm5

; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);

	movhlps	xmm1, xmm6

; 165  : 	lmax = minss(lmax, lmax1);

	minss	xmm5, xmm0

; 166  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm6, xmm1

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL312@stab
	jmp	SHORT $LN1@stab
$LN318@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z ; ray_collider<1,1,1,1>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,1,1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,1,1,0>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 189  : 	{

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [r10+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r10+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
	movss	DWORD PTR [r10+84], xmm0

; 198  : 		if (!bUseSSE)	{
; 199  : 			// for FPU - zero out inf
; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$00$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,1,1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
box$1 = 32
d$2 = 112
this$ = 112
node$ = 120
?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,1,1,0>::_stab, COMDAT

; 317  : 	{

$LN323:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 317  : 	{

	mov	rdi, rcx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	esi, 1
	movaps	XMMWORD PTR [rsp+64], xmm7
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	xorps	xmm7, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 317  : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN1@stab
	npad	9
$LL312@stab:

; 323  : 			if (d>rRange)																	return;

	movss	xmm0, DWORD PTR d$2[rbp-96]
	comiss	xmm0, DWORD PTR [rdi+80]
	ja	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z ; ray_collider<1,1,1,0>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 336  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN318@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rbx, QWORD PTR [rbx+32]

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], ecx

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], ecx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rdi+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rdi+32]
	mulps	xmm6, XMMWORD PTR [rdi+48]
	mulps	xmm2, XMMWORD PTR [rdi+48]

; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm5, xmm6

; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf

; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf

; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm5, xmm0

; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm6, xmm2

; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm5

; 159  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H

; 160  : 	lmax = minss(lmax, lmax0);

	minss	xmm5, xmm0

; 161  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm6, xmm1

; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movhlps	xmm0, xmm5

; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);

	movhlps	xmm1, xmm6

; 165  : 	lmax = minss(lmax, lmax1);

	minss	xmm5, xmm0

; 166  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm6, xmm1

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL312@stab
	jmp	SHORT $LN1@stab
$LN318@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z ; ray_collider<1,1,1,0>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,1,1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,1,0,1>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 189  : 	{

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [r10+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r10+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
	movss	DWORD PTR [r10+84], xmm0

; 198  : 		if (!bUseSSE)	{
; 199  : 			// for FPU - zero out inf
; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$00$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,1,0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
box$1 = 32
d$2 = 112
this$ = 112
node$ = 120
?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,1,0,1>::_stab, COMDAT

; 317  : 	{

$LN316:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 317  : 	{

	mov	rdi, rcx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	esi, 1
	movaps	XMMWORD PTR [rsp+64], xmm7
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	xorps	xmm7, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 317  : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN1@stab
	npad	9
$LL306@stab:

; 323  : 			if (d>rRange)																	return;

	movss	xmm0, DWORD PTR d$2[rbp-96]
	comiss	xmm0, DWORD PTR [rdi+80]
	ja	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z ; ray_collider<1,1,0,1>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN311@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rbx, QWORD PTR [rbx+32]

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rdi+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rdi+32]
	mulps	xmm6, XMMWORD PTR [rdi+48]
	mulps	xmm2, XMMWORD PTR [rdi+48]

; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm5, xmm6

; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf

; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf

; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm5, xmm0

; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm6, xmm2

; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm5

; 159  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H

; 160  : 	lmax = minss(lmax, lmax0);

	minss	xmm5, xmm0

; 161  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm6, xmm1

; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movhlps	xmm0, xmm5

; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);

	movhlps	xmm1, xmm6

; 165  : 	lmax = minss(lmax, lmax1);

	minss	xmm5, xmm0

; 166  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm6, xmm1

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL306@stab
	jmp	SHORT $LN1@stab
$LN311@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z ; ray_collider<1,1,0,1>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,1,0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,1,0,0>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 189  : 	{

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [r10+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r10+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
	movss	DWORD PTR [r10+84], xmm0

; 198  : 		if (!bUseSSE)	{
; 199  : 			// for FPU - zero out inf
; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,1,0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
box$1 = 32
d$2 = 112
this$ = 112
node$ = 120
?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,1,0,0>::_stab, COMDAT

; 317  : 	{

$LN316:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 317  : 	{

	mov	rdi, rcx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	esi, 1
	movaps	XMMWORD PTR [rsp+64], xmm7
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	xorps	xmm7, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 317  : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN1@stab
	npad	9
$LL306@stab:

; 323  : 			if (d>rRange)																	return;

	movss	xmm0, DWORD PTR d$2[rbp-96]
	comiss	xmm0, DWORD PTR [rdi+80]
	ja	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z ; ray_collider<1,1,0,0>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN311@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rbx, QWORD PTR [rbx+32]

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rdi+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rdi+32]
	mulps	xmm6, XMMWORD PTR [rdi+48]
	mulps	xmm2, XMMWORD PTR [rdi+48]

; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm5, xmm6

; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf

; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf

; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm5, xmm0

; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm6, xmm2

; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm5

; 159  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H

; 160  : 	lmax = minss(lmax, lmax0);

	minss	xmm5, xmm0

; 161  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm6, xmm1

; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movhlps	xmm0, xmm5

; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);

	movhlps	xmm1, xmm6

; 165  : 	lmax = minss(lmax, lmax1);

	minss	xmm5, xmm0

; 166  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm6, xmm1

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL306@stab
	jmp	SHORT $LN1@stab
$LN311@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z ; ray_collider<1,1,0,0>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,1,0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,0,1,1>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 189  : 	{

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [r10+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r10+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
	movss	DWORD PTR [r10+84], xmm0

; 198  : 		if (!bUseSSE)	{
; 199  : 			// for FPU - zero out inf
; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$00$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,0,1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
box$1 = 32
d$2 = 112
this$ = 112
node$ = 120
?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,0,1,1>::_stab, COMDAT

; 317  : 	{

$LN323:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 317  : 	{

	mov	rdi, rcx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	esi, 1
	movaps	XMMWORD PTR [rsp+64], xmm7
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	xorps	xmm7, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 317  : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN1@stab
	npad	9
$LL312@stab:

; 323  : 			if (d>rRange)																	return;

	movss	xmm0, DWORD PTR d$2[rbp-96]
	comiss	xmm0, DWORD PTR [rdi+80]
	ja	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z ; ray_collider<1,0,1,1>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 336  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN318@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rbx, QWORD PTR [rbx+32]

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], ecx

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], ecx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rdi+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rdi+32]
	mulps	xmm6, XMMWORD PTR [rdi+48]
	mulps	xmm2, XMMWORD PTR [rdi+48]

; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm5, xmm6

; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf

; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf

; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm5, xmm0

; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm6, xmm2

; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm5

; 159  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H

; 160  : 	lmax = minss(lmax, lmax0);

	minss	xmm5, xmm0

; 161  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm6, xmm1

; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movhlps	xmm0, xmm5

; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);

	movhlps	xmm1, xmm6

; 165  : 	lmax = minss(lmax, lmax1);

	minss	xmm5, xmm0

; 166  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm6, xmm1

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL312@stab
	jmp	SHORT $LN1@stab
$LN318@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z ; ray_collider<1,0,1,1>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,0,1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,0,1,0>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 189  : 	{

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [r10+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r10+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
	movss	DWORD PTR [r10+84], xmm0

; 198  : 		if (!bUseSSE)	{
; 199  : 			// for FPU - zero out inf
; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,0,1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
box$1 = 32
d$2 = 112
this$ = 112
node$ = 120
?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,0,1,0>::_stab, COMDAT

; 317  : 	{

$LN323:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 317  : 	{

	mov	rdi, rcx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	esi, 1
	movaps	XMMWORD PTR [rsp+64], xmm7
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	xorps	xmm7, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 317  : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN1@stab
	npad	9
$LL312@stab:

; 323  : 			if (d>rRange)																	return;

	movss	xmm0, DWORD PTR d$2[rbp-96]
	comiss	xmm0, DWORD PTR [rdi+80]
	ja	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z ; ray_collider<1,0,1,0>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 336  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN318@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rbx, QWORD PTR [rbx+32]

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], ecx

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], ecx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rdi+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rdi+32]
	mulps	xmm6, XMMWORD PTR [rdi+48]
	mulps	xmm2, XMMWORD PTR [rdi+48]

; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm5, xmm6

; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf

; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf

; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm5, xmm0

; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm6, xmm2

; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm5

; 159  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H

; 160  : 	lmax = minss(lmax, lmax0);

	minss	xmm5, xmm0

; 161  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm6, xmm1

; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movhlps	xmm0, xmm5

; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);

	movhlps	xmm1, xmm6

; 165  : 	lmax = minss(lmax, lmax1);

	minss	xmm5, xmm0

; 166  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm6, xmm1

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL312@stab
	jmp	SHORT $LN1@stab
$LN318@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z ; ray_collider<1,0,1,0>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,0,1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,0,0,1>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 189  : 	{

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [r10+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r10+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
	movss	DWORD PTR [r10+84], xmm0

; 198  : 		if (!bUseSSE)	{
; 199  : 			// for FPU - zero out inf
; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,0,0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
box$1 = 32
d$2 = 112
this$ = 112
node$ = 120
?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,0,0,1>::_stab, COMDAT

; 317  : 	{

$LN316:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 317  : 	{

	mov	rdi, rcx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	esi, 1
	movaps	XMMWORD PTR [rsp+64], xmm7
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	xorps	xmm7, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 317  : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN1@stab
	npad	9
$LL306@stab:

; 323  : 			if (d>rRange)																	return;

	movss	xmm0, DWORD PTR d$2[rbp-96]
	comiss	xmm0, DWORD PTR [rdi+80]
	ja	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z ; ray_collider<1,0,0,1>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN311@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rbx, QWORD PTR [rbx+32]

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rdi+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rdi+32]
	mulps	xmm6, XMMWORD PTR [rdi+48]
	mulps	xmm2, XMMWORD PTR [rdi+48]

; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm5, xmm6

; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf

; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf

; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm5, xmm0

; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm6, xmm2

; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm5

; 159  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H

; 160  : 	lmax = minss(lmax, lmax0);

	minss	xmm5, xmm0

; 161  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm6, xmm1

; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movhlps	xmm0, xmm5

; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);

	movhlps	xmm1, xmm6

; 165  : 	lmax = minss(lmax, lmax1);

	minss	xmm5, xmm0

; 166  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm6, xmm1

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL306@stab
	jmp	SHORT $LN1@stab
$LN311@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z ; ray_collider<1,0,0,1>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,0,0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,0,0,0>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 190  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 189  : 	{

	mov	r10, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [r10+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
	mov	DWORD PTR [r10+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 197  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
	movss	DWORD PTR [r10+84], xmm0

; 198  : 		if (!bUseSSE)	{
; 199  : 			// for FPU - zero out inf
; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,0,0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
box$1 = 32
d$2 = 112
this$ = 112
node$ = 120
?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,0,0,0>::_stab, COMDAT

; 317  : 	{

$LN316:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	rbp
	mov	rbp, rsp
	sub	rsp, 96					; 00000060H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+80], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 317  : 	{

	mov	rdi, rcx

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	esi, 1
	movaps	XMMWORD PTR [rsp+64], xmm7
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	xorps	xmm7, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 317  : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm0, xmm5
	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN1@stab
	npad	9
$LL306@stab:

; 323  : 			if (d>rRange)																	return;

	movss	xmm0, DWORD PTR d$2[rbp-96]
	comiss	xmm0, DWORD PTR [rdi+80]
	ja	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<1,0,0,0>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN311@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rbx, QWORD PTR [rbx+32]

; 218  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;

	mov	DWORD PTR box$1[rbp-84], 0

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR box$1[rbp-68], 0

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-96], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-80], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-92], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-76], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-88], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR box$1[rbp-72], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 135  : 		box_min		= loadps(&box.min),

	movaps	xmm6, XMMWORD PTR box$1[rbp-96]

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR box$1[rbp-80]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rdi+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rdi+32]
	mulps	xmm6, XMMWORD PTR [rdi+48]
	mulps	xmm2, XMMWORD PTR [rdi+48]

; 143  : 
; 144  : 	// the order we use for those min/max is vital to filter out
; 145  : 	// NaNs that happens when an inv_dir is +/- inf and
; 146  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 147  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm5, xmm6

; 148  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 149  : 
; 150  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf

; 151  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf

; 152  : 
; 153  : 	// now that we're back on our feet, test those slabs.
; 154  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm5, xmm0

; 155  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm6, xmm2

; 156  : 
; 157  : 	// unfold back. try to hide the latency of the shufps & co.
; 158  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm5

; 159  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm6
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H

; 160  : 	lmax = minss(lmax, lmax0);

	minss	xmm5, xmm0

; 161  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm6, xmm1

; 162  : 
; 163  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movhlps	xmm0, xmm5

; 164  : 	const __m128 lmin1 = muxhps(lmin,lmin);

	movhlps	xmm1, xmm6

; 165  : 	lmax = minss(lmax, lmax1);

	minss	xmm5, xmm0

; 166  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm6, xmm1

; 167  : 
; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm5, xmm7

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR d$2[rbp-96], xmm6
	cmovae	ecx, esi
	comiss	xmm5, xmm6
	cmovae	eax, esi
	test	ecx, eax

; 318  : 		// Actual ray/aabb test
; 319  : 		if (bUseSSE)			{
; 320  : 			// use SSE
; 321  : 			float		d;
; 322  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL306@stab
	jmp	SHORT $LN1@stab
$LN311@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<1,0,0,0>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+80]
	movaps	xmm7, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+96]
	mov	rbx, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	rbp
	ret	0
?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,0,0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,1,1,1>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rdx, QWORD PTR D$[rsp]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [rcx+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	movss	DWORD PTR [rcx+80], xmm0
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN5@init
	mov	DWORD PTR [rcx+48], eax
$LN5@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN3@init
	mov	DWORD PTR [rcx+52], eax
$LN3@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN1@init
	mov	DWORD PTR [rcx+56], eax
$LN1@init:

; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$0A@$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,1,1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,1,1,1>::_stab, COMDAT

; 317  : 	{

$LN329:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	mov	esi, 1
	mov	rdi, rdx
	mov	rbx, rcx
	lea	ebp, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	12
$LL312@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdi]
	movss	xmm10, DWORD PTR [rdi+4]
	movss	xmm9, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm15
	movaps	xmm1, xmm15
	movaps	xmm0, xmm15

; 40   : 	BOOL Inside			= TRUE;

	mov	eax, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm14, xmm5
	movaps	xmm11, xmm10
	movaps	xmm13, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm12, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdi+12]
	addss	xmm10, DWORD PTR [rdi+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm14, DWORD PTR [rdi+12]
	subss	xmm11, DWORD PTR [rdi+16]
	subss	xmm13, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm12, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm9, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm2
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm0

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN61@stab

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm14

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN323@stab
$LN61@stab:
	comiss	xmm12, xmm5
	jbe	SHORT $LN57@stab

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm5

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm5
$LN323@stab:
	subss	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN57@stab:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm4, xmm11
	jae	SHORT $LN56@stab

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm11

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm11

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN324@stab
$LN56@stab:
	comiss	xmm4, xmm10
	jbe	SHORT $LN52@stab

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm10

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm10
$LN324@stab:
	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN52@stab:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm3, xmm13
	jae	$LN51@stab

; 62   : 		coord[2]	= min[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm13
	je	SHORT $LN46@stab
	movaps	xmm2, xmm13
$LN325@stab:

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	subss	xmm2, xmm3
	mulss	xmm2, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm2
$LN46@stab:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	ecx, ecx
	comiss	xmm1, xmm0
	cmova	ecx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm2, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	ecx, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN1@stab

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN42@stab

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
	ja	$LN1@stab

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm0
$LN327@stab:
	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm13
	jb	$LN1@stab
	comiss	xmm6, xmm9

; 90   : 		return true;

	jmp	$LN326@stab
$LN51@stab:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm9
	jbe	SHORT $LN47@stab

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm9
	je	SHORT $LN46@stab
	movaps	xmm2, xmm9

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN325@stab
$LN47@stab:
	test	eax, eax
	je	$LN46@stab

; 73   : 		coord		= ray.pos;

	mov	eax, DWORD PTR [rbx+40]
	movsdx	xmm0, QWORD PTR [rbx+32]
	movsdx	QWORD PTR P$2[rsp], xmm0

; 74   : 		return		true;

	movss	xmm7, DWORD PTR P$2[rsp+4]
	movss	xmm8, DWORD PTR P$2[rsp]
	mov	DWORD PTR P$2[rsp+8], eax
	movss	xmm6, DWORD PTR P$2[rsp+8]
	jmp	SHORT $LN321@stab
$LN42@stab:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN37@stab

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 97   : 		return true;

	jmp	$LN327@stab
$LN37@stab:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN1@stab

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm2
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
$LN326@stab:
	ja	SHORT $LN1@stab
$LN321@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm12
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 328  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z ; ray_collider<0,1,1,1>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 336  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN318@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rdi, QWORD PTR [rdi+32]
	jmp	$LL312@stab
$LN318@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z ; ray_collider<0,1,1,1>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,1,1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,1,1,0>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rdx, QWORD PTR D$[rsp]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [rcx+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	movss	DWORD PTR [rcx+80], xmm0
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN5@init
	mov	DWORD PTR [rcx+48], eax
$LN5@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN3@init
	mov	DWORD PTR [rcx+52], eax
$LN3@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN1@init
	mov	DWORD PTR [rcx+56], eax
$LN1@init:

; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,1,1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,1,1,0>::_stab, COMDAT

; 317  : 	{

$LN329:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	mov	esi, 1
	mov	rdi, rdx
	mov	rbx, rcx
	lea	ebp, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	12
$LL312@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdi]
	movss	xmm10, DWORD PTR [rdi+4]
	movss	xmm9, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm15
	movaps	xmm1, xmm15
	movaps	xmm0, xmm15

; 40   : 	BOOL Inside			= TRUE;

	mov	eax, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm14, xmm5
	movaps	xmm11, xmm10
	movaps	xmm13, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm12, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdi+12]
	addss	xmm10, DWORD PTR [rdi+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm14, DWORD PTR [rdi+12]
	subss	xmm11, DWORD PTR [rdi+16]
	subss	xmm13, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm12, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm9, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm2
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm0

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN61@stab

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm14

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN323@stab
$LN61@stab:
	comiss	xmm12, xmm5
	jbe	SHORT $LN57@stab

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm5

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm5
$LN323@stab:
	subss	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN57@stab:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm4, xmm11
	jae	SHORT $LN56@stab

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm11

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm11

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN324@stab
$LN56@stab:
	comiss	xmm4, xmm10
	jbe	SHORT $LN52@stab

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm10

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm10
$LN324@stab:
	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN52@stab:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm3, xmm13
	jae	$LN51@stab

; 62   : 		coord[2]	= min[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm13
	je	SHORT $LN46@stab
	movaps	xmm2, xmm13
$LN325@stab:

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	subss	xmm2, xmm3
	mulss	xmm2, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm2
$LN46@stab:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	ecx, ecx
	comiss	xmm1, xmm0
	cmova	ecx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm2, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	ecx, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN1@stab

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN42@stab

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
	ja	$LN1@stab

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm0
$LN327@stab:
	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm13
	jb	$LN1@stab
	comiss	xmm6, xmm9

; 90   : 		return true;

	jmp	$LN326@stab
$LN51@stab:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm9
	jbe	SHORT $LN47@stab

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm9
	je	SHORT $LN46@stab
	movaps	xmm2, xmm9

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN325@stab
$LN47@stab:
	test	eax, eax
	je	$LN46@stab

; 73   : 		coord		= ray.pos;

	mov	eax, DWORD PTR [rbx+40]
	movsdx	xmm0, QWORD PTR [rbx+32]
	movsdx	QWORD PTR P$2[rsp], xmm0

; 74   : 		return		true;

	movss	xmm7, DWORD PTR P$2[rsp+4]
	movss	xmm8, DWORD PTR P$2[rsp]
	mov	DWORD PTR P$2[rsp+8], eax
	movss	xmm6, DWORD PTR P$2[rsp+8]
	jmp	SHORT $LN321@stab
$LN42@stab:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN37@stab

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 97   : 		return true;

	jmp	$LN327@stab
$LN37@stab:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN1@stab

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm2
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
$LN326@stab:
	ja	SHORT $LN1@stab
$LN321@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm12
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 328  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z ; ray_collider<0,1,1,0>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 336  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN318@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rdi, QWORD PTR [rdi+32]
	jmp	$LL312@stab
$LN318@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z ; ray_collider<0,1,1,0>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,1,1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,1,0,1>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rdx, QWORD PTR D$[rsp]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [rcx+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	movss	DWORD PTR [rcx+80], xmm0
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN5@init
	mov	DWORD PTR [rcx+48], eax
$LN5@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN3@init
	mov	DWORD PTR [rcx+52], eax
$LN3@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN1@init
	mov	DWORD PTR [rcx+56], eax
$LN1@init:

; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,1,0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,1,0,1>::_stab, COMDAT

; 317  : 	{

$LN322:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	mov	esi, 1
	mov	rdi, rdx
	mov	rbx, rcx
	lea	ebp, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	12
$LL306@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdi]
	movss	xmm10, DWORD PTR [rdi+4]
	movss	xmm9, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm15
	movaps	xmm1, xmm15
	movaps	xmm0, xmm15

; 40   : 	BOOL Inside			= TRUE;

	mov	eax, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm14, xmm5
	movaps	xmm11, xmm10
	movaps	xmm13, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm12, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdi+12]
	addss	xmm10, DWORD PTR [rdi+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm14, DWORD PTR [rdi+12]
	subss	xmm11, DWORD PTR [rdi+16]
	subss	xmm13, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm12, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm9, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm2
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm0

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN61@stab

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm14

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN316@stab
$LN61@stab:
	comiss	xmm12, xmm5
	jbe	SHORT $LN57@stab

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm5

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm5
$LN316@stab:
	subss	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN57@stab:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm4, xmm11
	jae	SHORT $LN56@stab

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm11

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm11

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN317@stab
$LN56@stab:
	comiss	xmm4, xmm10
	jbe	SHORT $LN52@stab

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm10

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm10
$LN317@stab:
	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN52@stab:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm3, xmm13
	jae	$LN51@stab

; 62   : 		coord[2]	= min[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm13
	je	SHORT $LN46@stab
	movaps	xmm2, xmm13
$LN318@stab:

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	subss	xmm2, xmm3
	mulss	xmm2, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm2
$LN46@stab:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	ecx, ecx
	comiss	xmm1, xmm0
	cmova	ecx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm2, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	ecx, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN1@stab

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN42@stab

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
	ja	$LN1@stab

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm0
$LN320@stab:
	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm13
	jb	$LN1@stab
	comiss	xmm6, xmm9

; 90   : 		return true;

	jmp	$LN319@stab
$LN51@stab:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm9
	jbe	SHORT $LN47@stab

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm9
	je	SHORT $LN46@stab
	movaps	xmm2, xmm9

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN318@stab
$LN47@stab:
	test	eax, eax
	je	$LN46@stab

; 73   : 		coord		= ray.pos;

	mov	eax, DWORD PTR [rbx+40]
	movsdx	xmm0, QWORD PTR [rbx+32]
	movsdx	QWORD PTR P$2[rsp], xmm0

; 74   : 		return		true;

	movss	xmm7, DWORD PTR P$2[rsp+4]
	movss	xmm8, DWORD PTR P$2[rsp]
	mov	DWORD PTR P$2[rsp+8], eax
	movss	xmm6, DWORD PTR P$2[rsp+8]
	jmp	SHORT $LN314@stab
$LN42@stab:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN37@stab

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 97   : 		return true;

	jmp	$LN320@stab
$LN37@stab:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN1@stab

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm2
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	SHORT $LN1@stab
	comiss	xmm7, xmm10
$LN319@stab:
	ja	SHORT $LN1@stab
$LN314@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm12
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 328  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z ; ray_collider<0,1,0,1>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN311@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rdi, QWORD PTR [rdi+32]
	jmp	$LL306@stab
$LN311@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z ; ray_collider<0,1,0,1>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,1,0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,1,0,0>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rdx, QWORD PTR D$[rsp]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [rcx+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	movss	DWORD PTR [rcx+80], xmm0
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN5@init
	mov	DWORD PTR [rcx+48], eax
$LN5@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN3@init
	mov	DWORD PTR [rcx+52], eax
$LN3@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN1@init
	mov	DWORD PTR [rcx+56], eax
$LN1@init:

; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,1,0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,1,0,0>::_stab, COMDAT

; 317  : 	{

$LN322:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	mov	esi, 1
	mov	rdi, rdx
	mov	rbx, rcx
	lea	ebp, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	12
$LL306@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdi]
	movss	xmm10, DWORD PTR [rdi+4]
	movss	xmm9, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm15
	movaps	xmm1, xmm15
	movaps	xmm0, xmm15

; 40   : 	BOOL Inside			= TRUE;

	mov	eax, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm14, xmm5
	movaps	xmm11, xmm10
	movaps	xmm13, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm12, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdi+12]
	addss	xmm10, DWORD PTR [rdi+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm14, DWORD PTR [rdi+12]
	subss	xmm11, DWORD PTR [rdi+16]
	subss	xmm13, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm12, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm9, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm2
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm0

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN61@stab

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm14

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN316@stab
$LN61@stab:
	comiss	xmm12, xmm5
	jbe	SHORT $LN57@stab

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm5

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm5
$LN316@stab:
	subss	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN57@stab:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm4, xmm11
	jae	SHORT $LN56@stab

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm11

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm11

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN317@stab
$LN56@stab:
	comiss	xmm4, xmm10
	jbe	SHORT $LN52@stab

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm10

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm10
$LN317@stab:
	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN52@stab:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm3, xmm13
	jae	$LN51@stab

; 62   : 		coord[2]	= min[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm13
	je	SHORT $LN46@stab
	movaps	xmm2, xmm13
$LN318@stab:

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	subss	xmm2, xmm3
	mulss	xmm2, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm2
$LN46@stab:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	ecx, ecx
	comiss	xmm1, xmm0
	cmova	ecx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm2, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	ecx, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN1@stab

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN42@stab

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
	ja	$LN1@stab

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm0
$LN320@stab:
	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm13
	jb	$LN1@stab
	comiss	xmm6, xmm9

; 90   : 		return true;

	jmp	$LN319@stab
$LN51@stab:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm9
	jbe	SHORT $LN47@stab

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm9
	je	SHORT $LN46@stab
	movaps	xmm2, xmm9

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN318@stab
$LN47@stab:
	test	eax, eax
	je	$LN46@stab

; 73   : 		coord		= ray.pos;

	mov	eax, DWORD PTR [rbx+40]
	movsdx	xmm0, QWORD PTR [rbx+32]
	movsdx	QWORD PTR P$2[rsp], xmm0

; 74   : 		return		true;

	movss	xmm7, DWORD PTR P$2[rsp+4]
	movss	xmm8, DWORD PTR P$2[rsp]
	mov	DWORD PTR P$2[rsp+8], eax
	movss	xmm6, DWORD PTR P$2[rsp+8]
	jmp	SHORT $LN314@stab
$LN42@stab:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN37@stab

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 97   : 		return true;

	jmp	$LN320@stab
$LN37@stab:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN1@stab

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm2
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	SHORT $LN1@stab
	comiss	xmm7, xmm10
$LN319@stab:
	ja	SHORT $LN1@stab
$LN314@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm12
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 328  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z ; ray_collider<0,1,0,0>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN311@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rdi, QWORD PTR [rdi+32]
	jmp	$LL306@stab
$LN311@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z ; ray_collider<0,1,0,0>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,1,0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,0,1,1>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rdx, QWORD PTR D$[rsp]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [rcx+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	movss	DWORD PTR [rcx+80], xmm0
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN5@init
	mov	DWORD PTR [rcx+48], eax
$LN5@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN3@init
	mov	DWORD PTR [rcx+52], eax
$LN3@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN1@init
	mov	DWORD PTR [rcx+56], eax
$LN1@init:

; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,0,1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,0,1,1>::_stab, COMDAT

; 317  : 	{

$LN329:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	mov	esi, 1
	mov	rdi, rdx
	mov	rbx, rcx
	lea	ebp, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	12
$LL312@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdi]
	movss	xmm10, DWORD PTR [rdi+4]
	movss	xmm9, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm15
	movaps	xmm1, xmm15
	movaps	xmm0, xmm15

; 40   : 	BOOL Inside			= TRUE;

	mov	eax, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm14, xmm5
	movaps	xmm11, xmm10
	movaps	xmm13, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm12, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdi+12]
	addss	xmm10, DWORD PTR [rdi+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm14, DWORD PTR [rdi+12]
	subss	xmm11, DWORD PTR [rdi+16]
	subss	xmm13, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm12, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm9, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm2
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm0

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN61@stab

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm14

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN323@stab
$LN61@stab:
	comiss	xmm12, xmm5
	jbe	SHORT $LN57@stab

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm5

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm5
$LN323@stab:
	subss	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN57@stab:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm4, xmm11
	jae	SHORT $LN56@stab

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm11

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm11

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN324@stab
$LN56@stab:
	comiss	xmm4, xmm10
	jbe	SHORT $LN52@stab

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm10

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm10
$LN324@stab:
	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN52@stab:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm3, xmm13
	jae	$LN51@stab

; 62   : 		coord[2]	= min[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm13
	je	SHORT $LN46@stab
	movaps	xmm2, xmm13
$LN325@stab:

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	subss	xmm2, xmm3
	mulss	xmm2, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm2
$LN46@stab:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	ecx, ecx
	comiss	xmm1, xmm0
	cmova	ecx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm2, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	ecx, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN1@stab

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN42@stab

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
	ja	$LN1@stab

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm0
$LN327@stab:
	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm13
	jb	$LN1@stab
	comiss	xmm6, xmm9

; 90   : 		return true;

	jmp	$LN326@stab
$LN51@stab:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm9
	jbe	SHORT $LN47@stab

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm9
	je	SHORT $LN46@stab
	movaps	xmm2, xmm9

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN325@stab
$LN47@stab:
	test	eax, eax
	je	$LN46@stab

; 73   : 		coord		= ray.pos;

	mov	eax, DWORD PTR [rbx+40]
	movsdx	xmm0, QWORD PTR [rbx+32]
	movsdx	QWORD PTR P$2[rsp], xmm0

; 74   : 		return		true;

	movss	xmm7, DWORD PTR P$2[rsp+4]
	movss	xmm8, DWORD PTR P$2[rsp]
	mov	DWORD PTR P$2[rsp+8], eax
	movss	xmm6, DWORD PTR P$2[rsp+8]
	jmp	SHORT $LN321@stab
$LN42@stab:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN37@stab

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 97   : 		return true;

	jmp	$LN327@stab
$LN37@stab:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN1@stab

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm2
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
$LN326@stab:
	ja	SHORT $LN1@stab
$LN321@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm12
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 328  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z ; ray_collider<0,0,1,1>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 336  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN318@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rdi, QWORD PTR [rdi+32]
	jmp	$LL312@stab
$LN318@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z ; ray_collider<0,0,1,1>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,0,1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,0,1,0>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rdx, QWORD PTR D$[rsp]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [rcx+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	movss	DWORD PTR [rcx+80], xmm0
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN5@init
	mov	DWORD PTR [rcx+48], eax
$LN5@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN3@init
	mov	DWORD PTR [rcx+52], eax
$LN3@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN1@init
	mov	DWORD PTR [rcx+56], eax
$LN1@init:

; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,0,1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,0,1,0>::_stab, COMDAT

; 317  : 	{

$LN329:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	mov	esi, 1
	mov	rdi, rdx
	mov	rbx, rcx
	lea	ebp, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	12
$LL312@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdi]
	movss	xmm10, DWORD PTR [rdi+4]
	movss	xmm9, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm15
	movaps	xmm1, xmm15
	movaps	xmm0, xmm15

; 40   : 	BOOL Inside			= TRUE;

	mov	eax, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm14, xmm5
	movaps	xmm11, xmm10
	movaps	xmm13, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm12, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdi+12]
	addss	xmm10, DWORD PTR [rdi+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm14, DWORD PTR [rdi+12]
	subss	xmm11, DWORD PTR [rdi+16]
	subss	xmm13, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm12, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm9, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm2
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm0

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN61@stab

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm14

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN323@stab
$LN61@stab:
	comiss	xmm12, xmm5
	jbe	SHORT $LN57@stab

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm5

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm5
$LN323@stab:
	subss	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN57@stab:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm4, xmm11
	jae	SHORT $LN56@stab

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm11

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm11

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN324@stab
$LN56@stab:
	comiss	xmm4, xmm10
	jbe	SHORT $LN52@stab

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm10

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm10
$LN324@stab:
	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN52@stab:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm3, xmm13
	jae	$LN51@stab

; 62   : 		coord[2]	= min[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm13
	je	SHORT $LN46@stab
	movaps	xmm2, xmm13
$LN325@stab:

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	subss	xmm2, xmm3
	mulss	xmm2, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm2
$LN46@stab:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	ecx, ecx
	comiss	xmm1, xmm0
	cmova	ecx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm2, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	ecx, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN1@stab

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN42@stab

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
	ja	$LN1@stab

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm0
$LN327@stab:
	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm13
	jb	$LN1@stab
	comiss	xmm6, xmm9

; 90   : 		return true;

	jmp	$LN326@stab
$LN51@stab:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm9
	jbe	SHORT $LN47@stab

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm9
	je	SHORT $LN46@stab
	movaps	xmm2, xmm9

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN325@stab
$LN47@stab:
	test	eax, eax
	je	$LN46@stab

; 73   : 		coord		= ray.pos;

	mov	eax, DWORD PTR [rbx+40]
	movsdx	xmm0, QWORD PTR [rbx+32]
	movsdx	QWORD PTR P$2[rsp], xmm0

; 74   : 		return		true;

	movss	xmm7, DWORD PTR P$2[rsp+4]
	movss	xmm8, DWORD PTR P$2[rsp]
	mov	DWORD PTR P$2[rsp+8], eax
	movss	xmm6, DWORD PTR P$2[rsp+8]
	jmp	SHORT $LN321@stab
$LN42@stab:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN37@stab

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 97   : 		return true;

	jmp	$LN327@stab
$LN37@stab:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN1@stab

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm2
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
$LN326@stab:
	ja	SHORT $LN1@stab
$LN321@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm12
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 328  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z ; ray_collider<0,0,1,0>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 336  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN318@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rdi, QWORD PTR [rdi+32]
	jmp	$LL312@stab
$LN318@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z ; ray_collider<0,0,1,0>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,0,1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,0,0,1>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rdx, QWORD PTR D$[rsp]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [rcx+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	movss	DWORD PTR [rcx+80], xmm0
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN5@init
	mov	DWORD PTR [rcx+48], eax
$LN5@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN3@init
	mov	DWORD PTR [rcx+52], eax
$LN3@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN1@init
	mov	DWORD PTR [rcx+56], eax
$LN1@init:

; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,0,0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,0,0,1>::_stab, COMDAT

; 317  : 	{

$LN322:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	mov	esi, 1
	mov	rdi, rdx
	mov	rbx, rcx
	lea	ebp, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	12
$LL306@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdi]
	movss	xmm10, DWORD PTR [rdi+4]
	movss	xmm9, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm15
	movaps	xmm1, xmm15
	movaps	xmm0, xmm15

; 40   : 	BOOL Inside			= TRUE;

	mov	eax, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm14, xmm5
	movaps	xmm11, xmm10
	movaps	xmm13, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm12, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdi+12]
	addss	xmm10, DWORD PTR [rdi+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm14, DWORD PTR [rdi+12]
	subss	xmm11, DWORD PTR [rdi+16]
	subss	xmm13, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm12, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm9, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm2
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm0

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN61@stab

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm14

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN316@stab
$LN61@stab:
	comiss	xmm12, xmm5
	jbe	SHORT $LN57@stab

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm5

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm5
$LN316@stab:
	subss	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN57@stab:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm4, xmm11
	jae	SHORT $LN56@stab

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm11

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm11

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN317@stab
$LN56@stab:
	comiss	xmm4, xmm10
	jbe	SHORT $LN52@stab

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm10

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm10
$LN317@stab:
	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN52@stab:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm3, xmm13
	jae	$LN51@stab

; 62   : 		coord[2]	= min[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm13
	je	SHORT $LN46@stab
	movaps	xmm2, xmm13
$LN318@stab:

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	subss	xmm2, xmm3
	mulss	xmm2, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm2
$LN46@stab:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	ecx, ecx
	comiss	xmm1, xmm0
	cmova	ecx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm2, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	ecx, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN1@stab

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN42@stab

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
	ja	$LN1@stab

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm0
$LN320@stab:
	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm13
	jb	$LN1@stab
	comiss	xmm6, xmm9

; 90   : 		return true;

	jmp	$LN319@stab
$LN51@stab:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm9
	jbe	SHORT $LN47@stab

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm9
	je	SHORT $LN46@stab
	movaps	xmm2, xmm9

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN318@stab
$LN47@stab:
	test	eax, eax
	je	$LN46@stab

; 73   : 		coord		= ray.pos;

	mov	eax, DWORD PTR [rbx+40]
	movsdx	xmm0, QWORD PTR [rbx+32]
	movsdx	QWORD PTR P$2[rsp], xmm0

; 74   : 		return		true;

	movss	xmm7, DWORD PTR P$2[rsp+4]
	movss	xmm8, DWORD PTR P$2[rsp]
	mov	DWORD PTR P$2[rsp+8], eax
	movss	xmm6, DWORD PTR P$2[rsp+8]
	jmp	SHORT $LN314@stab
$LN42@stab:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN37@stab

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 97   : 		return true;

	jmp	$LN320@stab
$LN37@stab:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN1@stab

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm2
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	SHORT $LN1@stab
	comiss	xmm7, xmm10
$LN319@stab:
	ja	SHORT $LN1@stab
$LN314@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm12
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 328  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z ; ray_collider<0,0,0,1>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN311@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rdi, QWORD PTR [rdi+32]
	jmp	$LL306@stab
$LN311@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z ; ray_collider<0,0,0,1>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,0,0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,0,0,0>::_init, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm1, DWORD PTR __real@3f800000
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	rdx, QWORD PTR C$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 191  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movaps	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 192  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	mov	rdx, QWORD PTR D$[rsp]

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	DWORD PTR [rcx+40], eax

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 196  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	DWORD PTR [rcx+56], xmm1

; 24   : 	ICF SelfRef	set(const _vector3<float> &v)			{ x = T(v.x);	y = T(v.y);	z = T(v.z);	return *this;	};

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
	mov	DWORD PTR [rcx+72], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	movss	DWORD PTR [rcx+80], xmm0
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 200  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN5@init
	mov	DWORD PTR [rcx+48], eax
$LN5@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 201  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN3@init
	mov	DWORD PTR [rcx+52], eax
$LN3@init:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 202  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN1@init
	mov	DWORD PTR [rcx+56], eax
$LN1@init:

; 203  : 		}
; 204  : 	}

	ret	0
?_init@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,0,0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,0,0,0>::_stab, COMDAT

; 317  : 	{

$LN322:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	mov	esi, 1
	mov	rdi, rdx
	mov	rbx, rcx
	lea	ebp, QWORD PTR [rsi+1]
	movaps	XMMWORD PTR [rax-56], xmm8
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	12
$LL306@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdi]
	movss	xmm10, DWORD PTR [rdi+4]
	movss	xmm9, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm15
	movaps	xmm1, xmm15
	movaps	xmm0, xmm15

; 40   : 	BOOL Inside			= TRUE;

	mov	eax, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm14, xmm5
	movaps	xmm11, xmm10
	movaps	xmm13, xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm12, DWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdi+12]
	addss	xmm10, DWORD PTR [rdi+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm14, DWORD PTR [rdi+12]
	subss	xmm11, DWORD PTR [rdi+16]
	subss	xmm13, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm12, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm9, DWORD PTR [rdi+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm2
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm0

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN61@stab

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm14

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN316@stab
$LN61@stab:
	comiss	xmm12, xmm5
	jbe	SHORT $LN57@stab

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm5

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN57@stab
	movaps	xmm0, xmm5
$LN316@stab:
	subss	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN57@stab:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm4, xmm11
	jae	SHORT $LN56@stab

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm11

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm11

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN317@stab
$LN56@stab:
	comiss	xmm4, xmm10
	jbe	SHORT $LN52@stab

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm10

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN52@stab
	movaps	xmm1, xmm10
$LN317@stab:
	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN52@stab:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm3, xmm13
	jae	$LN51@stab

; 62   : 		coord[2]	= min[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm13
	je	SHORT $LN46@stab
	movaps	xmm2, xmm13
$LN318@stab:

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	subss	xmm2, xmm3
	mulss	xmm2, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm2
$LN46@stab:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	ecx, ecx
	comiss	xmm1, xmm0
	cmova	ecx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm2, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	ecx, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN1@stab

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN42@stab

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	$LN1@stab
	comiss	xmm7, xmm10
	ja	$LN1@stab

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm0
$LN320@stab:
	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm13
	jb	$LN1@stab
	comiss	xmm6, xmm9

; 90   : 		return true;

	jmp	$LN319@stab
$LN51@stab:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm9
	jbe	SHORT $LN47@stab

; 66   : 		coord[2]	= max[2];
; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm9
	je	SHORT $LN46@stab
	movaps	xmm2, xmm9

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN318@stab
$LN47@stab:
	test	eax, eax
	je	$LN46@stab

; 73   : 		coord		= ray.pos;

	mov	eax, DWORD PTR [rbx+40]
	movsdx	xmm0, QWORD PTR [rbx+32]
	movsdx	QWORD PTR P$2[rsp], xmm0

; 74   : 		return		true;

	movss	xmm7, DWORD PTR P$2[rsp+4]
	movss	xmm8, DWORD PTR P$2[rsp]
	mov	DWORD PTR P$2[rsp+8], eax
	movss	xmm6, DWORD PTR P$2[rsp+8]
	jmp	SHORT $LN314@stab
$LN42@stab:

; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN37@stab

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 97   : 		return true;

	jmp	$LN320@stab
$LN37@stab:

; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN1@stab

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm2
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm12

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm14
	jb	$LN1@stab
	comiss	xmm8, xmm5
	ja	$LN1@stab

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm11
	jb	SHORT $LN1@stab
	comiss	xmm7, xmm10
$LN319@stab:
	ja	SHORT $LN1@stab
$LN314@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	movaps	xmm0, xmm6
	subss	xmm2, xmm12
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 328  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 332  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<0,0,0,0>::_prim

; 333  : 		else					_stab	(node->GetPos());

	jmp	SHORT $LN4@stab
$LN5@stab:
	call	?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi+32], sil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN311@stab

; 340  : 		else					_stab	(node->GetNeg());

	mov	rdi, QWORD PTR [rdi+32]
	jmp	$LL306@stab
$LN311@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 339  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<0,0,0,0>::_prim
$LN1@stab:

; 341  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,0,0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?div@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?div@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z PROC		; _vector3<float>::div, COMDAT

; 44   : 	ICF	SelfRef	div(const Self &v)						{ x/=v.x;	y/=v.y;  z/=v.z;			return *this;	};

	movss	xmm0, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+4]
	mov	rax, rcx
	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx], xmm0
	divss	xmm1, DWORD PTR [rdx+4]
	movss	xmm0, DWORD PTR [rcx+8]
	movss	DWORD PTR [rcx+4], xmm1
	divss	xmm0, DWORD PTR [rdx+8]
	movss	DWORD PTR [rcx+8], xmm0
	ret	0
?div@?$_vector3@M@@QEAAAEAU1@AEBU1@@Z ENDP		; _vector3<float>::div
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?distance_to_sqr@?$_vector3@M@@QEBAMAEBU1@@Z
_TEXT	SEGMENT
this$ = 8
v$ = 16
?distance_to_sqr@?$_vector3@M@@QEBAMAEBU1@@Z PROC	; _vector3<float>::distance_to_sqr, COMDAT

; 287  : 	{	return (x-v.x)*(x-v.x) + (y-v.y)*(y-v.y) + (z-v.z)*(z-v.z);	}

	movss	xmm2, DWORD PTR [rcx+4]
	movss	xmm0, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+8]
	subss	xmm0, DWORD PTR [rdx]
	subss	xmm2, DWORD PTR [rdx+4]
	subss	xmm1, DWORD PTR [rdx+8]
	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm0, xmm2
	addss	xmm0, xmm1
	ret	0
?distance_to_sqr@?$_vector3@M@@QEBAMAEBU1@@Z ENDP	; _vector3<float>::distance_to_sqr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,1,1,1>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,1,1,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,1,1,1>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,1,1,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
_TEXT	SEGMENT
v$ = 96
this$ = 96
u$ = 104
prim$ = 104
r$ = 112
?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z PROC	; ray_collider<1,1,1,1>::_prim, COMDAT

; 269  : 	{

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,1,1>::_tri
	test	al, al
	je	$LN2@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 276  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN4@prim

; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();

	mov	r8, QWORD PTR [rcx+16]

; 279  : 				if (r<R.range)	{

	comiss	xmm6, DWORD PTR [r8+52]
	jae	$LN31@prim

; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 283  : 					R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [r8+52], xmm6
	mov	DWORD PTR [r8+48], esi
	movss	DWORD PTR [r8+56], xmm0
	movss	DWORD PTR [r8+60], xmm1

; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 287  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r8+40], rcx

; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {

	jmp	$LN32@prim
$LN4@prim:

; 292  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 296  : 				R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	mov	r9, rax
	mov	DWORD PTR [rax+48], esi
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 300  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN32@prim:

; 301  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 302  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN2@prim:

; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();
; 306  : 			R.id		= prim;
; 307  : 			R.range		= r;
; 308  : 			R.u			= u;
; 309  : 			R.v			= v;
; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 313  : 			R.dummy		= tris[prim].dummy;
; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z ENDP	; ray_collider<1,1,1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,1,1,0>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,1,1,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,1,1,0>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,1,1,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
u$ = 96
this$ = 96
r$ = 104
prim$ = 104
v$ = 112
?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z PROC	; ray_collider<1,1,1,0>::_prim, COMDAT

; 269  : 	{

$LN33:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,1,0>::_tri
	test	al, al
	je	$LN6@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim

; 273  : 		
; 274  : 		if (bNearest)	
; 275  : 		{
; 276  : 			if (dest->r_count())	
; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();
; 279  : 				if (r<R.range)	{
; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;
; 283  : 					R.v			= v;
; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 287  : 					R.dummy		= tris[prim].dummy;
; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {
; 292  : 				RESULT& R	= dest->r_add();
; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;
; 296  : 				R.v			= v;
; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 300  : 				R.dummy		= tris[prim].dummy;
; 301  : 				rRange		= r;
; 302  : 				rRange2		= r*r;
; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 306  : 			R.id		= prim;

	mov	DWORD PTR [rax+48], esi

; 307  : 			R.range		= r;
; 308  : 			R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 309  : 			R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 313  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN6@prim:

; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z ENDP	; ray_collider<1,1,1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,1,0,1>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,1,0,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,1,0,1>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,1,0,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
v$ = 96
this$ = 96
u$ = 104
prim$ = 104
r$ = 112
?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z PROC	; ray_collider<1,1,0,1>::_prim, COMDAT

; 269  : 	{

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,0,1>::_tri
	test	al, al
	je	$LN2@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 276  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN4@prim

; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();

	mov	r8, QWORD PTR [rcx+16]

; 279  : 				if (r<R.range)	{

	comiss	xmm6, DWORD PTR [r8+52]
	jae	$LN31@prim

; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 283  : 					R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [r8+52], xmm6
	mov	DWORD PTR [r8+48], esi
	movss	DWORD PTR [r8+56], xmm0
	movss	DWORD PTR [r8+60], xmm1

; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 287  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r8+40], rcx

; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {

	jmp	$LN32@prim
$LN4@prim:

; 292  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 296  : 				R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	mov	r9, rax
	mov	DWORD PTR [rax+48], esi
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 300  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN32@prim:

; 301  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 302  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN2@prim:

; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();
; 306  : 			R.id		= prim;
; 307  : 			R.range		= r;
; 308  : 			R.u			= u;
; 309  : 			R.v			= v;
; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 313  : 			R.dummy		= tris[prim].dummy;
; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z ENDP	; ray_collider<1,1,0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,1,0,0>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,1,0,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,1,0,0>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,1,0,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
u$ = 96
this$ = 96
r$ = 104
prim$ = 104
v$ = 112
?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z PROC	; ray_collider<1,1,0,0>::_prim, COMDAT

; 269  : 	{

$LN33:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,0,0>::_tri
	test	al, al
	je	$LN6@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim

; 273  : 		
; 274  : 		if (bNearest)	
; 275  : 		{
; 276  : 			if (dest->r_count())	
; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();
; 279  : 				if (r<R.range)	{
; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;
; 283  : 					R.v			= v;
; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 287  : 					R.dummy		= tris[prim].dummy;
; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {
; 292  : 				RESULT& R	= dest->r_add();
; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;
; 296  : 				R.v			= v;
; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 300  : 				R.dummy		= tris[prim].dummy;
; 301  : 				rRange		= r;
; 302  : 				rRange2		= r*r;
; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 306  : 			R.id		= prim;

	mov	DWORD PTR [rax+48], esi

; 307  : 			R.range		= r;
; 308  : 			R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 309  : 			R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 313  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN6@prim:

; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z ENDP	; ray_collider<1,1,0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,0,1,1>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,0,1,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,0,1,1>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,0,1,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z
_TEXT	SEGMENT
v$ = 96
this$ = 96
u$ = 104
prim$ = 104
r$ = 112
?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z PROC	; ray_collider<1,0,1,1>::_prim, COMDAT

; 269  : 	{

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,1,1>::_tri
	test	al, al
	je	$LN2@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 276  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN4@prim

; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();

	mov	r8, QWORD PTR [rcx+16]

; 279  : 				if (r<R.range)	{

	comiss	xmm6, DWORD PTR [r8+52]
	jae	$LN31@prim

; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 283  : 					R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [r8+52], xmm6
	mov	DWORD PTR [r8+48], esi
	movss	DWORD PTR [r8+56], xmm0
	movss	DWORD PTR [r8+60], xmm1

; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 287  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r8+40], rcx

; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {

	jmp	$LN32@prim
$LN4@prim:

; 292  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 296  : 				R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	mov	r9, rax
	mov	DWORD PTR [rax+48], esi
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 300  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN32@prim:

; 301  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 302  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN2@prim:

; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();
; 306  : 			R.id		= prim;
; 307  : 			R.range		= r;
; 308  : 			R.u			= u;
; 309  : 			R.v			= v;
; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 313  : 			R.dummy		= tris[prim].dummy;
; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z ENDP	; ray_collider<1,0,1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,0,1,0>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,0,1,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,0,1,0>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,0,1,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
u$ = 96
this$ = 96
r$ = 104
prim$ = 104
v$ = 112
?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z PROC	; ray_collider<1,0,1,0>::_prim, COMDAT

; 269  : 	{

$LN33:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,1,0>::_tri
	test	al, al
	je	$LN6@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim

; 273  : 		
; 274  : 		if (bNearest)	
; 275  : 		{
; 276  : 			if (dest->r_count())	
; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();
; 279  : 				if (r<R.range)	{
; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;
; 283  : 					R.v			= v;
; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 287  : 					R.dummy		= tris[prim].dummy;
; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {
; 292  : 				RESULT& R	= dest->r_add();
; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;
; 296  : 				R.v			= v;
; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 300  : 				R.dummy		= tris[prim].dummy;
; 301  : 				rRange		= r;
; 302  : 				rRange2		= r*r;
; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 306  : 			R.id		= prim;

	mov	DWORD PTR [rax+48], esi

; 307  : 			R.range		= r;
; 308  : 			R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 309  : 			R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 313  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN6@prim:

; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z ENDP	; ray_collider<1,0,1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,0,0,1>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,0,0,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,0,0,1>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,0,0,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
v$ = 96
this$ = 96
u$ = 104
prim$ = 104
r$ = 112
?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z PROC	; ray_collider<1,0,0,1>::_prim, COMDAT

; 269  : 	{

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,0,1>::_tri
	test	al, al
	je	$LN2@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 276  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN4@prim

; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();

	mov	r8, QWORD PTR [rcx+16]

; 279  : 				if (r<R.range)	{

	comiss	xmm6, DWORD PTR [r8+52]
	jae	$LN31@prim

; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 283  : 					R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [r8+52], xmm6
	mov	DWORD PTR [r8+48], esi
	movss	DWORD PTR [r8+56], xmm0
	movss	DWORD PTR [r8+60], xmm1

; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 287  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r8+40], rcx

; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {

	jmp	$LN32@prim
$LN4@prim:

; 292  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 296  : 				R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	mov	r9, rax
	mov	DWORD PTR [rax+48], esi
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 300  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN32@prim:

; 301  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 302  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN2@prim:

; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();
; 306  : 			R.id		= prim;
; 307  : 			R.range		= r;
; 308  : 			R.u			= u;
; 309  : 			R.v			= v;
; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 313  : 			R.dummy		= tris[prim].dummy;
; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z ENDP	; ray_collider<1,0,0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,0,0,0>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,0,0,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,0,0,0>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,0,0,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
u$ = 96
this$ = 96
r$ = 104
prim$ = 104
v$ = 112
?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z PROC	; ray_collider<1,0,0,0>::_prim, COMDAT

; 269  : 	{

$LN33:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,0,0>::_tri
	test	al, al
	je	$LN6@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim

; 273  : 		
; 274  : 		if (bNearest)	
; 275  : 		{
; 276  : 			if (dest->r_count())	
; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();
; 279  : 				if (r<R.range)	{
; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;
; 283  : 					R.v			= v;
; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 287  : 					R.dummy		= tris[prim].dummy;
; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {
; 292  : 				RESULT& R	= dest->r_add();
; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;
; 296  : 				R.v			= v;
; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 300  : 				R.dummy		= tris[prim].dummy;
; 301  : 				rRange		= r;
; 302  : 				rRange2		= r*r;
; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 306  : 			R.id		= prim;

	mov	DWORD PTR [rax+48], esi

; 307  : 			R.range		= r;
; 308  : 			R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 309  : 			R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 313  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN6@prim:

; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z ENDP	; ray_collider<1,0,0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,1,1,1>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,1,1,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,1,1,1>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,1,1,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
_TEXT	SEGMENT
v$ = 96
this$ = 96
u$ = 104
prim$ = 104
r$ = 112
?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z PROC	; ray_collider<0,1,1,1>::_prim, COMDAT

; 269  : 	{

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,1,1>::_tri
	test	al, al
	je	$LN2@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 276  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN4@prim

; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();

	mov	r8, QWORD PTR [rcx+16]

; 279  : 				if (r<R.range)	{

	comiss	xmm6, DWORD PTR [r8+52]
	jae	$LN31@prim

; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 283  : 					R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [r8+52], xmm6
	mov	DWORD PTR [r8+48], esi
	movss	DWORD PTR [r8+56], xmm0
	movss	DWORD PTR [r8+60], xmm1

; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 287  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r8+40], rcx

; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {

	jmp	$LN32@prim
$LN4@prim:

; 292  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 296  : 				R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	mov	r9, rax
	mov	DWORD PTR [rax+48], esi
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 300  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN32@prim:

; 301  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 302  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN2@prim:

; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();
; 306  : 			R.id		= prim;
; 307  : 			R.range		= r;
; 308  : 			R.u			= u;
; 309  : 			R.v			= v;
; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 313  : 			R.dummy		= tris[prim].dummy;
; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z ENDP	; ray_collider<0,1,1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,1,1,0>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,1,1,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,1,1,0>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,1,1,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
u$ = 96
this$ = 96
r$ = 104
prim$ = 104
v$ = 112
?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z PROC	; ray_collider<0,1,1,0>::_prim, COMDAT

; 269  : 	{

$LN33:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,1,0>::_tri
	test	al, al
	je	$LN6@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim

; 273  : 		
; 274  : 		if (bNearest)	
; 275  : 		{
; 276  : 			if (dest->r_count())	
; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();
; 279  : 				if (r<R.range)	{
; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;
; 283  : 					R.v			= v;
; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 287  : 					R.dummy		= tris[prim].dummy;
; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {
; 292  : 				RESULT& R	= dest->r_add();
; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;
; 296  : 				R.v			= v;
; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 300  : 				R.dummy		= tris[prim].dummy;
; 301  : 				rRange		= r;
; 302  : 				rRange2		= r*r;
; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 306  : 			R.id		= prim;

	mov	DWORD PTR [rax+48], esi

; 307  : 			R.range		= r;
; 308  : 			R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 309  : 			R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 313  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN6@prim:

; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z ENDP	; ray_collider<0,1,1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,1,0,1>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,1,0,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,1,0,1>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,1,0,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
v$ = 96
this$ = 96
u$ = 104
prim$ = 104
r$ = 112
?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z PROC	; ray_collider<0,1,0,1>::_prim, COMDAT

; 269  : 	{

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,0,1>::_tri
	test	al, al
	je	$LN2@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 276  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN4@prim

; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();

	mov	r8, QWORD PTR [rcx+16]

; 279  : 				if (r<R.range)	{

	comiss	xmm6, DWORD PTR [r8+52]
	jae	$LN31@prim

; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 283  : 					R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [r8+52], xmm6
	mov	DWORD PTR [r8+48], esi
	movss	DWORD PTR [r8+56], xmm0
	movss	DWORD PTR [r8+60], xmm1

; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 287  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r8+40], rcx

; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {

	jmp	$LN32@prim
$LN4@prim:

; 292  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 296  : 				R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	mov	r9, rax
	mov	DWORD PTR [rax+48], esi
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 300  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN32@prim:

; 301  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 302  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN2@prim:

; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();
; 306  : 			R.id		= prim;
; 307  : 			R.range		= r;
; 308  : 			R.u			= u;
; 309  : 			R.v			= v;
; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 313  : 			R.dummy		= tris[prim].dummy;
; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z ENDP	; ray_collider<0,1,0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,1,0,0>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,1,0,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,1,0,0>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,1,0,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
u$ = 96
this$ = 96
r$ = 104
prim$ = 104
v$ = 112
?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z PROC	; ray_collider<0,1,0,0>::_prim, COMDAT

; 269  : 	{

$LN33:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,0,0>::_tri
	test	al, al
	je	$LN6@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim

; 273  : 		
; 274  : 		if (bNearest)	
; 275  : 		{
; 276  : 			if (dest->r_count())	
; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();
; 279  : 				if (r<R.range)	{
; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;
; 283  : 					R.v			= v;
; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 287  : 					R.dummy		= tris[prim].dummy;
; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {
; 292  : 				RESULT& R	= dest->r_add();
; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;
; 296  : 				R.v			= v;
; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 300  : 				R.dummy		= tris[prim].dummy;
; 301  : 				rRange		= r;
; 302  : 				rRange2		= r*r;
; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 306  : 			R.id		= prim;

	mov	DWORD PTR [rax+48], esi

; 307  : 			R.range		= r;
; 308  : 			R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 309  : 			R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 313  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN6@prim:

; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z ENDP	; ray_collider<0,1,0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,0,1,1>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,0,1,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,0,1,1>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,0,1,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z
_TEXT	SEGMENT
v$ = 96
this$ = 96
u$ = 104
prim$ = 104
r$ = 112
?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z PROC	; ray_collider<0,0,1,1>::_prim, COMDAT

; 269  : 	{

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,1,1>::_tri
	test	al, al
	je	$LN2@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 276  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN4@prim

; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();

	mov	r8, QWORD PTR [rcx+16]

; 279  : 				if (r<R.range)	{

	comiss	xmm6, DWORD PTR [r8+52]
	jae	$LN31@prim

; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 283  : 					R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [r8+52], xmm6
	mov	DWORD PTR [r8+48], esi
	movss	DWORD PTR [r8+56], xmm0
	movss	DWORD PTR [r8+60], xmm1

; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 287  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r8+40], rcx

; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {

	jmp	$LN32@prim
$LN4@prim:

; 292  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 296  : 				R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	mov	r9, rax
	mov	DWORD PTR [rax+48], esi
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 300  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN32@prim:

; 301  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 302  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN2@prim:

; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();
; 306  : 			R.id		= prim;
; 307  : 			R.range		= r;
; 308  : 			R.u			= u;
; 309  : 			R.v			= v;
; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 313  : 			R.dummy		= tris[prim].dummy;
; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z ENDP	; ray_collider<0,0,1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,0,1,0>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,0,1,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,0,1,0>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,0,1,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
u$ = 96
this$ = 96
r$ = 104
prim$ = 104
v$ = 112
?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z PROC	; ray_collider<0,0,1,0>::_prim, COMDAT

; 269  : 	{

$LN33:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,1,0>::_tri
	test	al, al
	je	$LN6@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim

; 273  : 		
; 274  : 		if (bNearest)	
; 275  : 		{
; 276  : 			if (dest->r_count())	
; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();
; 279  : 				if (r<R.range)	{
; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;
; 283  : 					R.v			= v;
; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 287  : 					R.dummy		= tris[prim].dummy;
; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {
; 292  : 				RESULT& R	= dest->r_add();
; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;
; 296  : 				R.v			= v;
; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 300  : 				R.dummy		= tris[prim].dummy;
; 301  : 				rRange		= r;
; 302  : 				rRange2		= r*r;
; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 306  : 			R.id		= prim;

	mov	DWORD PTR [rax+48], esi

; 307  : 			R.range		= r;
; 308  : 			R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 309  : 			R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 313  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN6@prim:

; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z ENDP	; ray_collider<0,0,1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,0,0,1>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,0,0,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,0,0,1>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,0,0,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
v$ = 96
this$ = 96
u$ = 104
prim$ = 104
r$ = 112
?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z PROC	; ray_collider<0,0,0,1>::_prim, COMDAT

; 269  : 	{

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,0,1>::_tri
	test	al, al
	je	$LN2@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+24]
	sub	rax, QWORD PTR [rcx+16]
	sar	rax, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 276  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN4@prim

; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();

	mov	r8, QWORD PTR [rcx+16]

; 279  : 				if (r<R.range)	{

	comiss	xmm6, DWORD PTR [r8+52]
	jae	$LN31@prim

; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 283  : 					R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [r8+52], xmm6
	mov	DWORD PTR [r8+48], esi
	movss	DWORD PTR [r8+56], xmm0
	movss	DWORD PTR [r8+60], xmm1

; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 287  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r8+40], rcx

; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {

	jmp	$LN32@prim
$LN4@prim:

; 292  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 296  : 				R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	mov	r9, rax
	mov	DWORD PTR [rax+48], esi
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 300  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN32@prim:

; 301  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 302  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN2@prim:

; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();
; 306  : 			R.id		= prim;
; 307  : 			R.range		= r;
; 308  : 			R.u			= u;
; 309  : 			R.v			= v;
; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 313  : 			R.dummy		= tris[prim].dummy;
; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z ENDP	; ray_collider<0,0,0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,0,0,0>::_box_fpu, COMDAT

; 208  : 	{

$LN276:
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm1, DWORD PTR [rdx+4]
	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	XMMWORD PTR [rsp+48], xmm7
	movaps	XMMWORD PTR [rsp+32], xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 40   : 	BOOL Inside			= TRUE;

	mov	edx, 1
	mov	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [r8+4]
	movss	xmm3, DWORD PTR [r8]
	movss	xmm4, DWORD PTR [r8+8]
	movaps	xmm7, xmm1
	movaps	xmm8, xmm2
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+16], xmm9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm8, xmm3
	subss	xmm7, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 43   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm9, xmm8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm1, DWORD PTR __real@bf800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm6, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, xmm2
	addss	xmm4, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 39   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm2, xmm1
	movaps	xmm0, xmm1
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
	movss	DWORD PTR MaxT$1[rsp], xmm0
	movss	DWORD PTR MaxT$1[rsp+8], xmm1

; 43   : 	if(ray.pos[0] < min[0]) {

	jae	SHORT $LN40@box_fpu

; 44   : 		coord[0]	= min[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm8

; 47   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN271@box_fpu
$LN40@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN36@box_fpu

; 48   : 		coord[0]	= max[0];
; 49   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 50   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN36@box_fpu
	movaps	xmm0, xmm3
$LN271@box_fpu:
	subss	xmm0, DWORD PTR [rcx+32]
	mulss	xmm0, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm0
$LN36@box_fpu:

; 51   : 	}
; 52   : 	if(ray.pos[1] < min[1]) {

	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm9, xmm7
	jae	SHORT $LN35@box_fpu

; 53   : 		coord[1]	= min[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm7

; 56   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN272@box_fpu
$LN35@box_fpu:
	comiss	xmm9, xmm5
	jbe	SHORT $LN31@box_fpu

; 57   : 		coord[1]	= max[1];
; 58   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 59   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN31@box_fpu
	movaps	xmm2, xmm5
$LN272@box_fpu:
	subss	xmm2, DWORD PTR [rcx+36]
	mulss	xmm2, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm2
$LN31@box_fpu:

; 60   : 	}
; 61   : 	if(ray.pos[2] < min[2]) {

	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm9, xmm6
	jae	$LN30@box_fpu

; 62   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN25@box_fpu
	movaps	xmm1, xmm6
$LN273@box_fpu:
	subss	xmm1, DWORD PTR [rcx+40]
	mulss	xmm1, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm1
$LN25@box_fpu:

; 75   : 	}
; 76   : 
; 77   : 	// Get largest of the maxT's for final choice of intersection
; 78   : 	u32 WhichPlane = 0;
; 79   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	xor	r8d, r8d
	comiss	xmm2, xmm0

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	cmova	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 80   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm1, DWORD PTR MaxT$1[rsp+rax*4]
	cmova	r8d, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 20   : 	ICF	T&			operator[] (int i)					{ return *((T*)this + i); }

	movsxd	rax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 83   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	test	DWORD PTR MaxT$1[rsp+rax*4], -2147483648 ; 80000000H
	jne	$LN11@box_fpu

; 84   : 
; 85   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN21@box_fpu

; 86   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm0
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 87   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm3, xmm7
	movss	DWORD PTR [r9+4], xmm3
	jb	$LN11@box_fpu
	comiss	xmm3, xmm5
	ja	$LN11@box_fpu

; 88   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm0, DWORD PTR [rcx+72]
	addss	xmm0, DWORD PTR [rcx+40]

; 89   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm0, xmm6
	movss	DWORD PTR [r9+8], xmm0
	jb	$LN11@box_fpu
	comiss	xmm0, xmm4
	jmp	$LN274@box_fpu
$LN30@box_fpu:

; 65   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN26@box_fpu

; 66   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 67   : 		Inside		= FALSE;
; 68   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN25@box_fpu
	movaps	xmm1, xmm4

; 69   : 	}
; 70   : 
; 71   : 	// Ray ray.pos inside bounding box
; 72   : 	if(Inside)		{

	jmp	$LN273@box_fpu
$LN26@box_fpu:
	test	eax, eax
	je	$LN25@box_fpu

; 73   : 		coord		= ray.pos;

	movsdx	xmm0, QWORD PTR [rcx+32]
	movsdx	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 74   : 		return		true;

	jmp	SHORT $LN41@box_fpu
$LN21@box_fpu:

; 90   : 		return true;
; 91   : 	}
; 92   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN16@box_fpu

; 93   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 94   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 95   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 96   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm2, xmm6
	movss	DWORD PTR [r9+8], xmm2
	jb	SHORT $LN11@box_fpu
	comiss	xmm2, xmm4
	jmp	SHORT $LN274@box_fpu
$LN16@box_fpu:

; 97   : 		return true;
; 98   : 	}
; 99   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN11@box_fpu

; 100  : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm0, xmm1
	mulss	xmm0, DWORD PTR [rcx+64]
	addss	xmm0, DWORD PTR [rcx+32]

; 101  : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm0, xmm8
	movss	DWORD PTR [r9], xmm0
	jb	SHORT $LN11@box_fpu
	comiss	xmm0, xmm3
	ja	SHORT $LN11@box_fpu

; 102  : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm1, DWORD PTR [rcx+68]
	addss	xmm1, DWORD PTR [rcx+36]

; 103  : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm1, xmm7
	movss	DWORD PTR [r9+4], xmm1
	jb	SHORT $LN11@box_fpu
	comiss	xmm1, xmm5
$LN274@box_fpu:
	jbe	SHORT $LN41@box_fpu
$LN11@box_fpu:

; 104  : 		return true;
; 105  : 	}
; 106  : 	return false;

	xor	edx, edx
$LN41@box_fpu:

; 209  : 		Fbox		BB;
; 210  : 		BB.min.sub	(bCenter,bExtents);
; 211  : 		BB.max.add	(bCenter,bExtents);
; 212  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);
; 213  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	mov	eax, edx
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,0,0,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
box$ = 0
this$ = 64
bCenter$ = 72
bExtents$ = 80
dist$ = 88
?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,0,0,0>::_box_sse, COMDAT

; 216  : 	{

$LN10:
	mov	rax, rsp
	sub	rsp, 56					; 00000038H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	edx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm2, DWORD PTR [r8+8]
	movss	xmm4, DWORD PTR [r8+4]
	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR box$[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 219  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;

	mov	DWORD PTR [rax-28], 0
	mov	DWORD PTR [rax-44], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-32], xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 136  : 		box_max		= loadps(&box.max),

	movaps	xmm2, XMMWORD PTR [rax-40]
	movaps	xmm6, XMMWORD PTR box$[rsp]

; 137  : 		pos			= loadps(&ray.pos),
; 138  : 		inv_dir		= loadps(&ray.inv_dir);
; 139  : 
; 140  : 	// use a div if inverted directions aren't available
; 141  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm6, XMMWORD PTR [rcx+32]

; 142  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm2, XMMWORD PTR [rcx+32]
	mulps	xmm6, XMMWORD PTR [rcx+48]
	mulps	xmm2, XMMWORD PTR [rcx+48]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	mov	ecx, 0
	mov	eax, ecx
	movaps	xmm5, xmm6
	maxps	xmm6, XMMWORD PTR ps_cst_minus_inf
	movaps	xmm0, xmm2
	minps	xmm0, XMMWORD PTR ps_cst_plus_inf
	minps	xmm5, XMMWORD PTR ps_cst_plus_inf
	maxps	xmm2, XMMWORD PTR ps_cst_minus_inf
	maxps	xmm5, xmm0
	minps	xmm6, xmm2
	movaps	xmm1, xmm6
	movaps	xmm0, xmm5
	shufps	xmm0, xmm5, 57				; 00000039H
	shufps	xmm1, xmm6, 57				; 00000039H
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	movhlps	xmm0, xmm5
	movhlps	xmm1, xmm6
	minss	xmm5, xmm0
	maxss	xmm6, xmm1
	xorps	xmm0, xmm0
	comiss	xmm5, xmm6

; 169  : 
; 170  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm6

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+32]

; 168  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	cmovae	eax, edx
	comiss	xmm5, xmm0
	cmovae	ecx, edx
	and	eax, ecx

; 220  :         return 		isect_sse	(box,ray,dist);
; 221  : 	}

	add	rsp, 56					; 00000038H
	ret	0
?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,0,0,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
u$ = 96
this$ = 96
r$ = 104
prim$ = 104
v$ = 112
?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z PROC	; ray_collider<0,0,0,0>::_prim, COMDAT

; 269  : 	{

$LN33:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 64					; 00000040H

; 270  : 		float	u,v,r;
; 271  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	rax, QWORD PTR [rcx+8]
	mov	esi, edx
	lea	r9, QWORD PTR v$[rsp]
	lea	rdi, QWORD PTR [rsi+rsi*2]
	lea	r8, QWORD PTR u$[rsp]
	mov	rbx, rcx
	lea	rdx, QWORD PTR [rax+rdi*8]
	lea	rax, QWORD PTR r$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,0,0>::_tri
	test	al, al
	je	$LN6@prim

; 272  : 		if (r<=0 || r>rRange)					return;

	movaps	XMMWORD PTR [rsp+48], xmm6
	movss	xmm6, DWORD PTR r$[rsp]
	xorps	xmm0, xmm0
	comiss	xmm6, xmm0
	jbe	$LN31@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN31@prim

; 273  : 		
; 274  : 		if (bNearest)	
; 275  : 		{
; 276  : 			if (dest->r_count())	
; 277  : 			{
; 278  : 				RESULT& R = *dest->r_begin();
; 279  : 				if (r<R.range)	{
; 280  : 					R.id		= prim;
; 281  : 					R.range		= r;
; 282  : 					R.u			= u;
; 283  : 					R.v			= v;
; 284  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 285  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 286  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 287  : 					R.dummy		= tris[prim].dummy;
; 288  : 					rRange		= r;
; 289  : 					rRange2		= r*r;
; 290  : 				}
; 291  : 			} else {
; 292  : 				RESULT& R	= dest->r_add();
; 293  : 				R.id		= prim;
; 294  : 				R.range		= r;
; 295  : 				R.u			= u;
; 296  : 				R.v			= v;
; 297  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 298  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 299  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 300  : 				R.dummy		= tris[prim].dummy;
; 301  : 				rRange		= r;
; 302  : 				rRange2		= r*r;
; 303  : 			}
; 304  : 		} else {
; 305  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 306  : 			R.id		= prim;

	mov	DWORD PTR [rax+48], esi

; 307  : 			R.range		= r;
; 308  : 			R.u			= u;

	movss	xmm0, DWORD PTR u$[rsp]

; 309  : 			R.v			= v;

	movss	xmm1, DWORD PTR v$[rsp]
	movss	DWORD PTR [rax+52], xmm6
	movss	DWORD PTR [rax+56], xmm0
	movss	DWORD PTR [rax+60], xmm1

; 310  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsdx	xmm0, QWORD PTR [rcx+r8*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	eax, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [r9+8], eax

; 311  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 312  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [rax+rdx*4]
	movsdx	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 313  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rax+rdi*8+16]
	mov	QWORD PTR [r9+40], rcx
$LN31@prim:
	movaps	xmm6, XMMWORD PTR [rsp+48]
$LN6@prim:

; 314  : 		}
; 315  : 	}

	add	rsp, 64					; 00000040H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z ENDP	; ray_collider<0,0,0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,1,1,1>::_tri, COMDAT

; 224  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm8, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm12, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
	subss	xmm14, xmm3

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm12, xmm15
	subss	xmm12, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm2
	subss	xmm9, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm8

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm8, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm8, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm9
	movaps	xmm7, xmm6
	movaps	xmm1, xmm8
	mulss	xmm7, xmm10
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 240  : 			if (det < EPS)  return false;

	comiss	xmm7, DWORD PTR __real@3727c5ac
	jb	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm4, xmm3
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm4
	movaps	xmm0, xmm5
	mulss	xmm3, xmm6
	mulss	xmm0, xmm12

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm8
	xorps	xmm8, xmm8
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 243  : 			if (u < 0.f || u > det) return false;

	comiss	xmm3, xmm8
	movss	DWORD PTR [r8], xmm3
	jb	$LN9@tri
	comiss	xmm3, xmm7
	ja	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm9
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm5, xmm4
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm4, xmm2
	movaps	xmm1, xmm5
	mulss	xmm4, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 246  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm4, xmm8
	movss	DWORD PTR [r9], xmm4
	jb	SHORT $LN9@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN9@tri

; 249  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 248  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 249  : 			range	*= inv_det;

	mulss	xmm2, xmm0

; 250  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 251  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [rax], xmm2
	movss	DWORD PTR [r8], xmm3
	movss	DWORD PTR [r9], xmm4

; 252  : 		}
; 253  : 		else
; 254  : 		{			
; 255  : 			if (det > -EPS && det < EPS) return false;
; 256  : 			inv_det = 1.0f / det;
; 257  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 259  : 			if (u < 0.0f || u > 1.0f)    return false;
; 260  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@tri
$LN9@tri:

; 243  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN13@tri:

; 266  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,1,1,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,1,1,0>::_tri, COMDAT

; 224  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm8, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm12, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
	subss	xmm14, xmm3

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm12, xmm15
	subss	xmm12, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm2
	subss	xmm9, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm8

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm8, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm8, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm9
	movaps	xmm7, xmm6
	movaps	xmm1, xmm8
	mulss	xmm7, xmm10
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 240  : 			if (det < EPS)  return false;

	comiss	xmm7, DWORD PTR __real@3727c5ac
	jb	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm4, xmm3
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm4
	movaps	xmm0, xmm5
	mulss	xmm3, xmm6
	mulss	xmm0, xmm12

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm8
	xorps	xmm8, xmm8
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 243  : 			if (u < 0.f || u > det) return false;

	comiss	xmm3, xmm8
	movss	DWORD PTR [r8], xmm3
	jb	$LN9@tri
	comiss	xmm3, xmm7
	ja	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm9
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm5, xmm4
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm4, xmm2
	movaps	xmm1, xmm5
	mulss	xmm4, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 246  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm4, xmm8
	movss	DWORD PTR [r9], xmm4
	jb	SHORT $LN9@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN9@tri

; 249  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 248  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 249  : 			range	*= inv_det;

	mulss	xmm2, xmm0

; 250  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 251  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [rax], xmm2
	movss	DWORD PTR [r8], xmm3
	movss	DWORD PTR [r9], xmm4

; 252  : 		}
; 253  : 		else
; 254  : 		{			
; 255  : 			if (det > -EPS && det < EPS) return false;
; 256  : 			inv_det = 1.0f / det;
; 257  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 259  : 			if (u < 0.0f || u > 1.0f)    return false;
; 260  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@tri
$LN9@tri:

; 243  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN13@tri:

; 266  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,1,1,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,1,0,1>::_tri, COMDAT

; 224  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm8, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm12, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
	subss	xmm14, xmm3

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm12, xmm15
	subss	xmm12, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm2
	subss	xmm9, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm8

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm8, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm8, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm9
	movaps	xmm7, xmm6
	movaps	xmm1, xmm8
	mulss	xmm7, xmm10
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 240  : 			if (det < EPS)  return false;

	comiss	xmm7, DWORD PTR __real@3727c5ac
	jb	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm4, xmm3
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm4
	movaps	xmm0, xmm5
	mulss	xmm3, xmm6
	mulss	xmm0, xmm12

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm8
	xorps	xmm8, xmm8
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 243  : 			if (u < 0.f || u > det) return false;

	comiss	xmm3, xmm8
	movss	DWORD PTR [r8], xmm3
	jb	$LN9@tri
	comiss	xmm3, xmm7
	ja	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm9
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm5, xmm4
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm4, xmm2
	movaps	xmm1, xmm5
	mulss	xmm4, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 246  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm4, xmm8
	movss	DWORD PTR [r9], xmm4
	jb	SHORT $LN9@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN9@tri

; 249  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 248  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 249  : 			range	*= inv_det;

	mulss	xmm2, xmm0

; 250  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 251  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [rax], xmm2
	movss	DWORD PTR [r8], xmm3
	movss	DWORD PTR [r9], xmm4

; 252  : 		}
; 253  : 		else
; 254  : 		{			
; 255  : 			if (det > -EPS && det < EPS) return false;
; 256  : 			inv_det = 1.0f / det;
; 257  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 259  : 			if (u < 0.0f || u > 1.0f)    return false;
; 260  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@tri
$LN9@tri:

; 243  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN13@tri:

; 266  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,1,0,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,1,0,0>::_tri, COMDAT

; 224  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm8, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm12, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
	subss	xmm14, xmm3

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm12, xmm15
	subss	xmm12, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm2
	subss	xmm9, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm8

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm8, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm8, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm9
	movaps	xmm7, xmm6
	movaps	xmm1, xmm8
	mulss	xmm7, xmm10
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 240  : 			if (det < EPS)  return false;

	comiss	xmm7, DWORD PTR __real@3727c5ac
	jb	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm4, xmm3
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm4
	movaps	xmm0, xmm5
	mulss	xmm3, xmm6
	mulss	xmm0, xmm12

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm8
	xorps	xmm8, xmm8
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 243  : 			if (u < 0.f || u > det) return false;

	comiss	xmm3, xmm8
	movss	DWORD PTR [r8], xmm3
	jb	$LN9@tri
	comiss	xmm3, xmm7
	ja	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm9
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm5, xmm4
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm4, xmm2
	movaps	xmm1, xmm5
	mulss	xmm4, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 246  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm4, xmm8
	movss	DWORD PTR [r9], xmm4
	jb	SHORT $LN9@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN9@tri

; 249  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 248  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 249  : 			range	*= inv_det;

	mulss	xmm2, xmm0

; 250  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 251  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [rax], xmm2
	movss	DWORD PTR [r8], xmm3
	movss	DWORD PTR [r9], xmm4

; 252  : 		}
; 253  : 		else
; 254  : 		{			
; 255  : 			if (det > -EPS && det < EPS) return false;
; 256  : 			inv_det = 1.0f / det;
; 257  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 259  : 			if (u < 0.0f || u > 1.0f)    return false;
; 260  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@tri
$LN9@tri:

; 243  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN13@tri:

; 266  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,1,0,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
pvec$1$ = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,0,1,1>::_tri, COMDAT

; 224  : 	{

$LN45:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-56], xmm9

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm9, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm3, xmm1
	movaps	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rsp+16], xmm14
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp], xmm15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm14, DWORD PTR [rbx+r11*4+4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+4]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm3, xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm12, DWORD PTR [rbx+r11*4+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm3, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm9

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm9, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm9, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	movaps	xmm2, xmm6
	mulss	xmm0, xmm10
	movaps	xmm1, xmm9
	mulss	xmm2, xmm11
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR pvec$1$[rsp], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 255  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN5@tri
	comiss	xmm2, DWORD PTR __real@3727c5ac
	jae	SHORT $LN5@tri
	xor	al, al
	jmp	$LN13@tri
$LN5@tri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [rcx+32]
	movss	xmm3, DWORD PTR [rcx+36]
	movaps	XMMWORD PTR [rsp+112], xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [rbx+r11*4+4]
	subss	xmm4, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm5, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR pvec$1$[rsp]
	mulss	xmm5, xmm6
	movaps	xmm1, xmm2
	addss	xmm5, xmm0
	mulss	xmm1, xmm9
	xorps	xmm9, xmm9
	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm5, xmm9
	movss	DWORD PTR [r8], xmm5
	jb	$LN3@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN3@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm10
	movaps	xmm0, xmm2
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm4, xmm3
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm4
	mulss	xmm3, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm3, xmm9
	movss	DWORD PTR [r9], xmm3
	jb	SHORT $LN3@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN3@tri

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	addss	xmm2, xmm6
	mulss	xmm4, xmm15
	addss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN43@tri
$LN3@tri:

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN43@tri:
	movaps	xmm7, XMMWORD PTR [rsp+112]
$LN13@tri:

; 266  : 	}

	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,0,1,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
pvec$1$ = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,0,1,0>::_tri, COMDAT

; 224  : 	{

$LN45:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-56], xmm9

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm9, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm3, xmm1
	movaps	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rsp+16], xmm14
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp], xmm15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm14, DWORD PTR [rbx+r11*4+4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+4]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm3, xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm12, DWORD PTR [rbx+r11*4+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm3, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm9

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm9, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm9, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	movaps	xmm2, xmm6
	mulss	xmm0, xmm10
	movaps	xmm1, xmm9
	mulss	xmm2, xmm11
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR pvec$1$[rsp], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 255  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN5@tri
	comiss	xmm2, DWORD PTR __real@3727c5ac
	jae	SHORT $LN5@tri
	xor	al, al
	jmp	$LN13@tri
$LN5@tri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [rcx+32]
	movss	xmm3, DWORD PTR [rcx+36]
	movaps	XMMWORD PTR [rsp+112], xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [rbx+r11*4+4]
	subss	xmm4, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm5, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR pvec$1$[rsp]
	mulss	xmm5, xmm6
	movaps	xmm1, xmm2
	addss	xmm5, xmm0
	mulss	xmm1, xmm9
	xorps	xmm9, xmm9
	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm5, xmm9
	movss	DWORD PTR [r8], xmm5
	jb	$LN3@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN3@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm10
	movaps	xmm0, xmm2
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm4, xmm3
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm4
	mulss	xmm3, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm3, xmm9
	movss	DWORD PTR [r9], xmm3
	jb	SHORT $LN3@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN3@tri

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	addss	xmm2, xmm6
	mulss	xmm4, xmm15
	addss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN43@tri
$LN3@tri:

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN43@tri:
	movaps	xmm7, XMMWORD PTR [rsp+112]
$LN13@tri:

; 266  : 	}

	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,0,1,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
pvec$1$ = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,0,0,1>::_tri, COMDAT

; 224  : 	{

$LN45:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-56], xmm9

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm9, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm3, xmm1
	movaps	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rsp+16], xmm14
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp], xmm15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm14, DWORD PTR [rbx+r11*4+4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+4]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm3, xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm12, DWORD PTR [rbx+r11*4+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm3, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm9

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm9, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm9, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	movaps	xmm2, xmm6
	mulss	xmm0, xmm10
	movaps	xmm1, xmm9
	mulss	xmm2, xmm11
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR pvec$1$[rsp], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 255  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN5@tri
	comiss	xmm2, DWORD PTR __real@3727c5ac
	jae	SHORT $LN5@tri
	xor	al, al
	jmp	$LN13@tri
$LN5@tri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [rcx+32]
	movss	xmm3, DWORD PTR [rcx+36]
	movaps	XMMWORD PTR [rsp+112], xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [rbx+r11*4+4]
	subss	xmm4, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm5, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR pvec$1$[rsp]
	mulss	xmm5, xmm6
	movaps	xmm1, xmm2
	addss	xmm5, xmm0
	mulss	xmm1, xmm9
	xorps	xmm9, xmm9
	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm5, xmm9
	movss	DWORD PTR [r8], xmm5
	jb	$LN3@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN3@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm10
	movaps	xmm0, xmm2
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm4, xmm3
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm4
	mulss	xmm3, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm3, xmm9
	movss	DWORD PTR [r9], xmm3
	jb	SHORT $LN3@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN3@tri

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	addss	xmm2, xmm6
	mulss	xmm4, xmm15
	addss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN43@tri
$LN3@tri:

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN43@tri:
	movaps	xmm7, XMMWORD PTR [rsp+112]
$LN13@tri:

; 266  : 	}

	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,0,0,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
pvec$1$ = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,0,0,0>::_tri, COMDAT

; 224  : 	{

$LN45:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-56], xmm9

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm9, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm3, xmm1
	movaps	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rsp+16], xmm14
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp], xmm15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm14, DWORD PTR [rbx+r11*4+4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+4]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm3, xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm12, DWORD PTR [rbx+r11*4+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm3, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm9

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm9, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm9, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	movaps	xmm2, xmm6
	mulss	xmm0, xmm10
	movaps	xmm1, xmm9
	mulss	xmm2, xmm11
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR pvec$1$[rsp], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 255  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN5@tri
	comiss	xmm2, DWORD PTR __real@3727c5ac
	jae	SHORT $LN5@tri
	xor	al, al
	jmp	$LN13@tri
$LN5@tri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [rcx+32]
	movss	xmm3, DWORD PTR [rcx+36]
	movaps	XMMWORD PTR [rsp+112], xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [rbx+r11*4+4]
	subss	xmm4, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm5, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR pvec$1$[rsp]
	mulss	xmm5, xmm6
	movaps	xmm1, xmm2
	addss	xmm5, xmm0
	mulss	xmm1, xmm9
	xorps	xmm9, xmm9
	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm5, xmm9
	movss	DWORD PTR [r8], xmm5
	jb	$LN3@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN3@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm10
	movaps	xmm0, xmm2
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm4, xmm3
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm4
	mulss	xmm3, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm3, xmm9
	movss	DWORD PTR [r9], xmm3
	jb	SHORT $LN3@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN3@tri

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	addss	xmm2, xmm6
	mulss	xmm4, xmm15
	addss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN43@tri
$LN3@tri:

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN43@tri:
	movaps	xmm7, XMMWORD PTR [rsp+112]
$LN13@tri:

; 266  : 	}

	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,0,0,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,1,1,1>::_tri, COMDAT

; 224  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm8, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm12, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
	subss	xmm14, xmm3

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm12, xmm15
	subss	xmm12, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm2
	subss	xmm9, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm8

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm8, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm8, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm9
	movaps	xmm7, xmm6
	movaps	xmm1, xmm8
	mulss	xmm7, xmm10
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 240  : 			if (det < EPS)  return false;

	comiss	xmm7, DWORD PTR __real@3727c5ac
	jb	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm4, xmm3
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm4
	movaps	xmm0, xmm5
	mulss	xmm3, xmm6
	mulss	xmm0, xmm12

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm8
	xorps	xmm8, xmm8
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 243  : 			if (u < 0.f || u > det) return false;

	comiss	xmm3, xmm8
	movss	DWORD PTR [r8], xmm3
	jb	$LN9@tri
	comiss	xmm3, xmm7
	ja	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm9
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm5, xmm4
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm4, xmm2
	movaps	xmm1, xmm5
	mulss	xmm4, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 246  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm4, xmm8
	movss	DWORD PTR [r9], xmm4
	jb	SHORT $LN9@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN9@tri

; 249  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 248  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 249  : 			range	*= inv_det;

	mulss	xmm2, xmm0

; 250  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 251  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [rax], xmm2
	movss	DWORD PTR [r8], xmm3
	movss	DWORD PTR [r9], xmm4

; 252  : 		}
; 253  : 		else
; 254  : 		{			
; 255  : 			if (det > -EPS && det < EPS) return false;
; 256  : 			inv_det = 1.0f / det;
; 257  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 259  : 			if (u < 0.0f || u > 1.0f)    return false;
; 260  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@tri
$LN9@tri:

; 243  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN13@tri:

; 266  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,1,1,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,1,1,0>::_tri, COMDAT

; 224  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm8, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm12, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
	subss	xmm14, xmm3

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm12, xmm15
	subss	xmm12, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm2
	subss	xmm9, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm8

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm8, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm8, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm9
	movaps	xmm7, xmm6
	movaps	xmm1, xmm8
	mulss	xmm7, xmm10
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 240  : 			if (det < EPS)  return false;

	comiss	xmm7, DWORD PTR __real@3727c5ac
	jb	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm4, xmm3
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm4
	movaps	xmm0, xmm5
	mulss	xmm3, xmm6
	mulss	xmm0, xmm12

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm8
	xorps	xmm8, xmm8
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 243  : 			if (u < 0.f || u > det) return false;

	comiss	xmm3, xmm8
	movss	DWORD PTR [r8], xmm3
	jb	$LN9@tri
	comiss	xmm3, xmm7
	ja	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm9
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm5, xmm4
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm4, xmm2
	movaps	xmm1, xmm5
	mulss	xmm4, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 246  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm4, xmm8
	movss	DWORD PTR [r9], xmm4
	jb	SHORT $LN9@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN9@tri

; 249  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 248  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 249  : 			range	*= inv_det;

	mulss	xmm2, xmm0

; 250  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 251  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [rax], xmm2
	movss	DWORD PTR [r8], xmm3
	movss	DWORD PTR [r9], xmm4

; 252  : 		}
; 253  : 		else
; 254  : 		{			
; 255  : 			if (det > -EPS && det < EPS) return false;
; 256  : 			inv_det = 1.0f / det;
; 257  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 259  : 			if (u < 0.0f || u > 1.0f)    return false;
; 260  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@tri
$LN9@tri:

; 243  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN13@tri:

; 266  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,1,1,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,1,0,1>::_tri, COMDAT

; 224  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm8, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm12, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
	subss	xmm14, xmm3

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm12, xmm15
	subss	xmm12, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm2
	subss	xmm9, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm8

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm8, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm8, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm9
	movaps	xmm7, xmm6
	movaps	xmm1, xmm8
	mulss	xmm7, xmm10
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 240  : 			if (det < EPS)  return false;

	comiss	xmm7, DWORD PTR __real@3727c5ac
	jb	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm4, xmm3
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm4
	movaps	xmm0, xmm5
	mulss	xmm3, xmm6
	mulss	xmm0, xmm12

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm8
	xorps	xmm8, xmm8
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 243  : 			if (u < 0.f || u > det) return false;

	comiss	xmm3, xmm8
	movss	DWORD PTR [r8], xmm3
	jb	$LN9@tri
	comiss	xmm3, xmm7
	ja	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm9
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm5, xmm4
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm4, xmm2
	movaps	xmm1, xmm5
	mulss	xmm4, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 246  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm4, xmm8
	movss	DWORD PTR [r9], xmm4
	jb	SHORT $LN9@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN9@tri

; 249  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 248  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 249  : 			range	*= inv_det;

	mulss	xmm2, xmm0

; 250  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 251  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [rax], xmm2
	movss	DWORD PTR [r8], xmm3
	movss	DWORD PTR [r9], xmm4

; 252  : 		}
; 253  : 		else
; 254  : 		{			
; 255  : 			if (det > -EPS && det < EPS) return false;
; 256  : 			inv_det = 1.0f / det;
; 257  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 259  : 			if (u < 0.0f || u > 1.0f)    return false;
; 260  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@tri
$LN9@tri:

; 243  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN13@tri:

; 266  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,1,0,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,1,0,0>::_tri, COMDAT

; 224  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm8, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm12, xmm1
	movaps	XMMWORD PTR [rsp+32], xmm13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm0, xmm6
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
	subss	xmm14, xmm3

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm12, xmm15
	subss	xmm12, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm2
	subss	xmm9, xmm2

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm8

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm8, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm8, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm12
	mulss	xmm0, xmm9
	movaps	xmm7, xmm6
	movaps	xmm1, xmm8
	mulss	xmm7, xmm10
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 240  : 			if (det < EPS)  return false;

	comiss	xmm7, DWORD PTR __real@3727c5ac
	jb	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm4, xmm3
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm3, xmm4
	movaps	xmm0, xmm5
	mulss	xmm3, xmm6
	mulss	xmm0, xmm12

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm3, xmm0
	movaps	xmm1, xmm2
	mulss	xmm1, xmm8
	xorps	xmm8, xmm8
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 243  : 			if (u < 0.f || u > det) return false;

	comiss	xmm3, xmm8
	movss	DWORD PTR [r8], xmm3
	jb	$LN9@tri
	comiss	xmm3, xmm7
	ja	$LN9@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm4

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm4, xmm9
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm5, xmm4
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm4, xmm2
	movaps	xmm1, xmm5
	mulss	xmm4, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 246  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm4, xmm8
	movss	DWORD PTR [r9], xmm4
	jb	SHORT $LN9@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN9@tri

; 249  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 248  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 249  : 			range	*= inv_det;

	mulss	xmm2, xmm0

; 250  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 251  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [rax], xmm2
	movss	DWORD PTR [r8], xmm3
	movss	DWORD PTR [r9], xmm4

; 252  : 		}
; 253  : 		else
; 254  : 		{			
; 255  : 			if (det > -EPS && det < EPS) return false;
; 256  : 			inv_det = 1.0f / det;
; 257  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 259  : 			if (u < 0.0f || u > 1.0f)    return false;
; 260  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN13@tri
$LN9@tri:

; 243  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN13@tri:

; 266  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,1,0,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
pvec$1$ = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,0,1,1>::_tri, COMDAT

; 224  : 	{

$LN45:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-56], xmm9

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm9, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm3, xmm1
	movaps	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rsp+16], xmm14
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp], xmm15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm14, DWORD PTR [rbx+r11*4+4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+4]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm3, xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm12, DWORD PTR [rbx+r11*4+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm3, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm9

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm9, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm9, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	movaps	xmm2, xmm6
	mulss	xmm0, xmm10
	movaps	xmm1, xmm9
	mulss	xmm2, xmm11
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR pvec$1$[rsp], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 255  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN5@tri
	comiss	xmm2, DWORD PTR __real@3727c5ac
	jae	SHORT $LN5@tri
	xor	al, al
	jmp	$LN13@tri
$LN5@tri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [rcx+32]
	movss	xmm3, DWORD PTR [rcx+36]
	movaps	XMMWORD PTR [rsp+112], xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [rbx+r11*4+4]
	subss	xmm4, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm5, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR pvec$1$[rsp]
	mulss	xmm5, xmm6
	movaps	xmm1, xmm2
	addss	xmm5, xmm0
	mulss	xmm1, xmm9
	xorps	xmm9, xmm9
	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm5, xmm9
	movss	DWORD PTR [r8], xmm5
	jb	$LN3@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN3@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm10
	movaps	xmm0, xmm2
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm4, xmm3
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm4
	mulss	xmm3, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm3, xmm9
	movss	DWORD PTR [r9], xmm3
	jb	SHORT $LN3@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN3@tri

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	addss	xmm2, xmm6
	mulss	xmm4, xmm15
	addss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN43@tri
$LN3@tri:

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN43@tri:
	movaps	xmm7, XMMWORD PTR [rsp+112]
$LN13@tri:

; 266  : 	}

	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,0,1,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
pvec$1$ = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,0,1,0>::_tri, COMDAT

; 224  : 	{

$LN45:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-56], xmm9

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm9, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm3, xmm1
	movaps	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rsp+16], xmm14
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp], xmm15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm14, DWORD PTR [rbx+r11*4+4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+4]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm3, xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm12, DWORD PTR [rbx+r11*4+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm3, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm9

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm9, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm9, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	movaps	xmm2, xmm6
	mulss	xmm0, xmm10
	movaps	xmm1, xmm9
	mulss	xmm2, xmm11
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR pvec$1$[rsp], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 255  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN5@tri
	comiss	xmm2, DWORD PTR __real@3727c5ac
	jae	SHORT $LN5@tri
	xor	al, al
	jmp	$LN13@tri
$LN5@tri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [rcx+32]
	movss	xmm3, DWORD PTR [rcx+36]
	movaps	XMMWORD PTR [rsp+112], xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [rbx+r11*4+4]
	subss	xmm4, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm5, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR pvec$1$[rsp]
	mulss	xmm5, xmm6
	movaps	xmm1, xmm2
	addss	xmm5, xmm0
	mulss	xmm1, xmm9
	xorps	xmm9, xmm9
	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm5, xmm9
	movss	DWORD PTR [r8], xmm5
	jb	$LN3@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN3@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm10
	movaps	xmm0, xmm2
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm4, xmm3
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm4
	mulss	xmm3, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm3, xmm9
	movss	DWORD PTR [r9], xmm3
	jb	SHORT $LN3@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN3@tri

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	addss	xmm2, xmm6
	mulss	xmm4, xmm15
	addss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN43@tri
$LN3@tri:

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN43@tri:
	movaps	xmm7, XMMWORD PTR [rsp+112]
$LN13@tri:

; 266  : 	}

	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,0,1,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
pvec$1$ = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,0,0,1>::_tri, COMDAT

; 224  : 	{

$LN45:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-56], xmm9

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm9, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm3, xmm1
	movaps	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rsp+16], xmm14
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp], xmm15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm14, DWORD PTR [rbx+r11*4+4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+4]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm3, xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm12, DWORD PTR [rbx+r11*4+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm3, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm9

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm9, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm9, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	movaps	xmm2, xmm6
	mulss	xmm0, xmm10
	movaps	xmm1, xmm9
	mulss	xmm2, xmm11
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR pvec$1$[rsp], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 255  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN5@tri
	comiss	xmm2, DWORD PTR __real@3727c5ac
	jae	SHORT $LN5@tri
	xor	al, al
	jmp	$LN13@tri
$LN5@tri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [rcx+32]
	movss	xmm3, DWORD PTR [rcx+36]
	movaps	XMMWORD PTR [rsp+112], xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [rbx+r11*4+4]
	subss	xmm4, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm5, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR pvec$1$[rsp]
	mulss	xmm5, xmm6
	movaps	xmm1, xmm2
	addss	xmm5, xmm0
	mulss	xmm1, xmm9
	xorps	xmm9, xmm9
	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm5, xmm9
	movss	DWORD PTR [r8], xmm5
	jb	$LN3@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN3@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm10
	movaps	xmm0, xmm2
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm4, xmm3
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm4
	mulss	xmm3, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm3, xmm9
	movss	DWORD PTR [r9], xmm3
	jb	SHORT $LN3@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN3@tri

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	addss	xmm2, xmm6
	mulss	xmm4, xmm15
	addss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN43@tri
$LN3@tri:

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN43@tri:
	movaps	xmm7, XMMWORD PTR [rsp+112]
$LN13@tri:

; 266  : 	}

	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,0,0,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
pvec$1$ = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,0,0,0>::_tri, COMDAT

; 224  : 	{

$LN45:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	xmm1, DWORD PTR [rcx+68]
	movaps	XMMWORD PTR [rax-24], xmm6
	movss	xmm6, DWORD PTR [rcx+72]
	movaps	XMMWORD PTR [rax-56], xmm9

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movss	xmm9, DWORD PTR [rcx+64]
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm3, xmm1
	movaps	xmm0, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 229  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [rdx]
	lea	r11, QWORD PTR [rax+rax*2]

; 230  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
	movaps	XMMWORD PTR [rsp+16], xmm14
	lea	r10, QWORD PTR [rax+rax*2]

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp], xmm15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rbx+r11*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 231  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm14, DWORD PTR [rbx+r11*4+4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm11, DWORD PTR [rbx+r11*4+4]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	mulss	xmm0, xmm14
	mulss	xmm3, xmm15

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm12, DWORD PTR [rbx+r11*4+8]

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	subss	xmm3, xmm0

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm13, xmm5

; 274  : 		y = v1.z  * v2.x  - v1.x  * v2.z ;

	movaps	xmm0, xmm9

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm9, xmm14
	mulss	xmm0, xmm15
	mulss	xmm1, xmm13
	mulss	xmm6, xmm13
	subss	xmm6, xmm0
	subss	xmm9, xmm1

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm10, xmm5

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm3
	movaps	xmm2, xmm6
	mulss	xmm0, xmm10
	movaps	xmm1, xmm9
	mulss	xmm2, xmm11
	mulss	xmm1, xmm12
	addss	xmm2, xmm0

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movss	DWORD PTR pvec$1$[rsp], xmm3

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 255  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN5@tri
	comiss	xmm2, DWORD PTR __real@3727c5ac
	jae	SHORT $LN5@tri
	xor	al, al
	jmp	$LN13@tri
$LN5@tri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm4, DWORD PTR [rcx+32]
	movss	xmm3, DWORD PTR [rcx+36]
	movaps	XMMWORD PTR [rsp+112], xmm7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm3, DWORD PTR [rbx+r11*4+4]
	subss	xmm4, xmm5
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 256  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm4
	movaps	xmm5, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm0, DWORD PTR pvec$1$[rsp]
	mulss	xmm5, xmm6
	movaps	xmm1, xmm2
	addss	xmm5, xmm0
	mulss	xmm1, xmm9
	xorps	xmm9, xmm9
	addss	xmm5, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 258  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm5, xmm9
	movss	DWORD PTR [r8], xmm5
	jb	$LN3@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN3@tri
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 273  : 		x = v1.y  * v2.z  - v1.z  * v2.y ;

	movaps	xmm6, xmm3

; 275  : 		z = v1.x  * v2.y  - v1.y  * v2.x ;

	mulss	xmm3, xmm10
	movaps	xmm0, xmm2
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm4, xmm3
	subss	xmm2, xmm0

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	movaps	xmm0, xmm6
	mulss	xmm0, DWORD PTR [rcx+64]
	movaps	xmm3, xmm2
	movaps	xmm1, xmm4
	mulss	xmm3, DWORD PTR [rcx+68]
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 261  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 262  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm3, xmm9
	movss	DWORD PTR [r9], xmm3
	jb	SHORT $LN3@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN3@tri

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 268  : 	{	return x*v.x + y*v.y + z*v.z; }

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	addss	xmm2, xmm6
	mulss	xmm4, xmm15
	addss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_ray.cpp

; 263  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 264  : 		}
; 265  : 		return true;

	mov	al, 1
	jmp	SHORT $LN43@tri
$LN3@tri:

; 259  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN43@tri:
	movaps	xmm7, XMMWORD PTR [rsp+112]
$LN13@tri:

; 266  : 	}

	movaps	xmm15, XMMWORD PTR [rsp]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,0,0,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\limits
;	COMDAT ?epsilon@?$numeric_limits@M@std@@SAMXZ
_TEXT	SEGMENT
?epsilon@?$numeric_limits@M@std@@SAMXZ PROC		; std::numeric_limits<float>::epsilon, COMDAT

; 1082 : 		return (FLT_EPSILON);

	movss	xmm0, DWORD PTR __real@34000000

; 1083 : 		}

	ret	0
?epsilon@?$numeric_limits@M@std@@SAMXZ ENDP		; std::numeric_limits<float>::epsilon
_TEXT	ENDS
END
