; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z ; svector<_vector3<float>,48>::resize
PUBLIC	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z	; frustum_collider<0,0>::_prim
PUBLIC	?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<0,0>::_box
PUBLIC	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z	; frustum_collider<0,1>::_prim
PUBLIC	?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<0,1>::_box
PUBLIC	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z	; frustum_collider<1,0>::_prim
PUBLIC	?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<1,0>::_box
PUBLIC	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z	; frustum_collider<1,1>::_prim
PUBLIC	?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<1,1>::_box
PUBLIC	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab
PUBLIC	?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<0,0>::_init
PUBLIC	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab
PUBLIC	?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<0,1>::_init
PUBLIC	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab
PUBLIC	?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<1,0>::_init
PUBLIC	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab
PUBLIC	?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<1,1>::_init
PUBLIC	?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z ; CDB::COLLIDER::frustum_query
PUBLIC	?getMask@CFrustum@@QEBAIXZ			; CFrustum::getMask
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z DD imagerel $LN31
	DD	imagerel $LN31+148
	DD	imagerel $unwind$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z DD imagerel $LN31
	DD	imagerel $LN31+148
	DD	imagerel $unwind$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD imagerel $LN31
	DD	imagerel $LN31+313
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD imagerel $LN31
	DD	imagerel $LN31+313
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN36
	DD	imagerel $LN36+353
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN43
	DD	imagerel $LN43+376
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN36
	DD	imagerel $LN36+353
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN43
	DD	imagerel $LN43+376
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD imagerel $LN132
	DD	imagerel $LN132+236
	DD	imagerel $unwind$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
xdata	SEGMENT
$unwind$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 061e01H
	DD	04681eH
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 061e01H
	DD	04681eH
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 061e01H
	DD	04681eH
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 061e01H
	DD	04681eH
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 031e01H
	DD	04681eH
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD 071301H
	DD	09b6413H
	DD	09a3413H
	DD	0980113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 031e01H
	DD	04681eH
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD 071301H
	DD	09b6413H
	DD	09a3413H
	DD	0980113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 031e01H
	DD	04681eH
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 031e01H
	DD	04681eH
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
;	COMDAT ?getMask@CFrustum@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?getMask@CFrustum@@QEBAIXZ PROC				; CFrustum::getMask, COMDAT

; 79   : 	u32				getMask				() const { return (1<<p_count)-1; }

	mov	ecx, DWORD PTR [rcx+240]
	mov	eax, 1
	shl	eax, cl
	dec	eax
	ret	0
?getMask@CFrustum@@QEBAIXZ ENDP				; CFrustum::getMask
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
_TEXT	SEGMENT
BC$1 = 32
BC$2 = 32
this$ = 80
m_def$ = 88
F$ = 96
?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z PROC ; CDB::COLLIDER::frustum_query

; 81   : {

$LN132:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 101  : 			if (S_READY!=status)

	cmp	DWORD PTR [rdx+16], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 81   : {

	mov	rsi, r8
	mov	rbx, rdx
	mov	rdi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 101  : 			if (S_READY!=status)

	je	SHORT $LN9@frustum_qu

; 102  : 			{
; 103  : 				Log						("! WARNING: syncronized CDB::query");
; 104  : 				xrCriticalSection*	C	= (xrCriticalSection*) &cs;
; 105  : 				C->Enter				();

	mov	rcx, rdx
	call	QWORD PTR __imp_?Enter@xrCriticalSection@@QEAAXXZ

; 106  : 				C->Leave				();

	mov	rcx, rbx
	call	QWORD PTR __imp_?Leave@xrCriticalSection@@QEAAXXZ
$LN9@frustum_qu:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	rax, QWORD PTR [rbx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 79   : 	u32				getMask				() const { return (1<<p_count)-1; }

	mov	ecx, DWORD PTR [rsi+240]
	mov	r8d, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	r9, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 79   : 	u32				getMask				() const { return (1<<p_count)-1; }

	shl	r8d, cl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 150  : 		IMPLEMENT_COLLISION_TREE(AABBNoLeafTree, AABBNoLeafNode)

	mov	rdx, QWORD PTR [r9+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rdi+24], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 91   : 	if (frustum_mode&OPT_FULL_TEST) 

	mov	eax, DWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\frustum.h

; 79   : 	u32				getMask				() const { return (1<<p_count)-1; }

	dec	r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 22   : 		dest		= CL;

	mov	QWORD PTR BC$2[rsp], rdi

; 25   : 		F			= _F;

	mov	QWORD PTR BC$2[rsp+24], rsi

; 94   : 		{
; 95   : 			frustum_collider<true,true> BC;
; 96   : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 97   : 			BC._stab	(N,mask);

	lea	rcx, QWORD PTR BC$2[rsp]
	test	al, 8
	je	SHORT $LN6@frustum_qu

; 92   : 	{
; 93   : 		if (frustum_mode&OPT_ONLYFIRST)

	test	al, 2

; 23   : 		tris		= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR BC$2[rsp+8], rax

; 24   : 		verts		= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR BC$2[rsp+16], rax

; 92   : 	{
; 93   : 		if (frustum_mode&OPT_ONLYFIRST)

	je	SHORT $LN5@frustum_qu

; 94   : 		{
; 95   : 			frustum_collider<true,true> BC;
; 96   : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 97   : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN5@frustum_qu:

; 98   : 		} else {
; 99   : 			frustum_collider<true,false> BC;
; 100  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 101  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN6@frustum_qu:

; 102  : 		}
; 103  : 	} else {
; 104  : 		if (frustum_mode&OPT_ONLYFIRST)

	test	al, 2

; 23   : 		tris		= T;

	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR BC$1[rsp+8], rax

; 24   : 		verts		= V;

	mov	rax, QWORD PTR [rbx+40]
	mov	QWORD PTR BC$1[rsp+16], rax

; 102  : 		}
; 103  : 	} else {
; 104  : 		if (frustum_mode&OPT_ONLYFIRST)

	je	SHORT $LN2@frustum_qu

; 105  : 		{
; 106  : 			frustum_collider<false,true> BC;
; 107  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 108  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
$LN2@frustum_qu:

; 109  : 		} else {
; 110  : 			frustum_collider<false,false> BC;
; 111  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 112  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z ENDP ; CDB::COLLIDER::frustum_query
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<1,1>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<1,1>::_stab, COMDAT

; 62   : 	{

$LN43:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 62   : 	{

	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]

; 62   : 	{

	mov	rbx, rdx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-44], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN1@stab
	npad	10
$LL33@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ; frustum_collider<1,1>::_prim

; 69   : 		else					_stab	(node->GetPos(),mask);

	jmp	SHORT $LN4@stab
$LN5@stab:
	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 72   : 		if (bFirst && dest->r_count())												return;

	test	ecx, ecx
	jne	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN38@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rdi+24]
	lea	r8, QWORD PTR mask$[rsp]
	lea	rdx, QWORD PTR mM$1[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+12], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+4], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+16], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL33@stab

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN38@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ; frustum_collider<1,1>::_prim
$LN1@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<1,0>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<1,0>::_stab, COMDAT

; 62   : 	{

$LN36:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 62   : 	{

	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]

; 62   : 	{

	mov	rbx, rdx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-44], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN1@stab
	npad	10
$LL27@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ; frustum_collider<1,0>::_prim

; 69   : 		else					_stab	(node->GetPos(),mask);

	jmp	SHORT $LN4@stab
$LN5@stab:
	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN31@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rdi+24]
	lea	r8, QWORD PTR mask$[rsp]
	lea	rdx, QWORD PTR mM$1[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+12], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+4], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+16], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL27@stab

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN31@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ; frustum_collider<1,0>::_prim
$LN1@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<0,1>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<0,1>::_stab, COMDAT

; 62   : 	{

$LN43:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 62   : 	{

	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]

; 62   : 	{

	mov	rbx, rdx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-44], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN1@stab
	npad	10
$LL33@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ; frustum_collider<0,1>::_prim

; 69   : 		else					_stab	(node->GetPos(),mask);

	jmp	SHORT $LN4@stab
$LN5@stab:
	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb.h

; 186  : 		ICF int			r_count			()	{	return rd.size();			};

	mov	rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 72   : 		if (bFirst && dest->r_count())												return;

	test	ecx, ecx
	jne	$LN1@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN38@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rdi+24]
	lea	r8, QWORD PTR mask$[rsp]
	lea	rdx, QWORD PTR mM$1[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+12], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+4], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+16], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL33@stab

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN38@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ; frustum_collider<0,1>::_prim
$LN1@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<0,0>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<0,0>::_stab, COMDAT

; 62   : 	{

$LN36:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx+4]
	movss	xmm3, DWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 62   : 	{

	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]

; 62   : 	{

	mov	rbx, rdx

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rdx]
	movaps	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rdx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, DWORD PTR [rdx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-44], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rdx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rdx+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-36], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN1@stab
	npad	10
$LL27@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN5@stab
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ; frustum_collider<0,0>::_prim

; 69   : 		else					_stab	(node->GetPos(),mask);

	jmp	SHORT $LN4@stab
$LN5@stab:
	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab
$LN4@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN31@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rdi+24]
	lea	r8, QWORD PTR mask$[rsp]
	lea	rdx, QWORD PTR mM$1[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movss	xmm3, DWORD PTR [rbx+8]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, DWORD PTR [rbx+12]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+12], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm5, DWORD PTR [rbx+16]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+4], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+16], xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm3, DWORD PTR [rbx+20]

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL27@stab

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN31@stab:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\opc_optimizedtree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ; frustum_collider<0,0>::_prim
$LN1@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<1,1>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [r8+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [r8+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
	mov	r8, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-56], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-44], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1
	movss	DWORD PTR [rax-36], xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<1,1>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
_TEXT	SEGMENT
src$1 = 32
dst$2 = 624
this$ = 1232
prim$ = 1240
?_prim@?$frustum_collider@$00$00@@QEAAXK@Z PROC		; frustum_collider<1,1>::_prim, COMDAT

; 35   : 	{

$LN31:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 1216				; 000004c0H

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	r10, QWORD PTR [rcx+16]
	mov	r9, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 32   : 	IC void		resize(int c)				{ VERIFY(c<=dim); count=c;				}

	mov	DWORD PTR [rax-616], 3

; 22   : 	{}

	mov	DWORD PTR [rax-24], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 35   : 	{

	mov	edi, edx
	mov	rbx, rcx

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	lea	r8, QWORD PTR [rdi+rdi*2]

; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))

	lea	rdx, QWORD PTR src$1[rsp]
	mov	eax, DWORD PTR [r9+r8*8]
	lea	rsi, QWORD PTR [r8*8]
	lea	r8, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+r8*4]
	movsdx	QWORD PTR src$1[rsp], xmm0
	mov	eax, DWORD PTR [r10+r8*4+8]
	lea	r8, QWORD PTR dst$2[rsp]
	mov	DWORD PTR src$1[rsp+8], eax
	mov	eax, DWORD PTR [r9+rsi+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+rcx*4]
	movsdx	QWORD PTR src$1[rsp+12], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	DWORD PTR src$1[rsp+20], eax
	mov	eax, DWORD PTR [r9+rsi+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+rcx*4]
	movsdx	QWORD PTR src$1[rsp+24], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	rcx, QWORD PTR [rbx+24]
	mov	DWORD PTR src$1[rsp+32], eax
	call	?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ; CFrustum::ClipPoly
	test	rax, rax
	je	SHORT $LN2@prim

; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	r8, QWORD PTR [rbx+16]
	mov	r9, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax+48], edi
	mov	r10, rax
	add	r9, rsi
	mov	ecx, DWORD PTR [r9]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [r8+rdx*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [rax+8], ecx

; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];

	mov	ecx, DWORD PTR [r9+4]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [r8+rdx*4]
	movsdx	QWORD PTR [rax+12], xmm0
	mov	eax, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [r10+20], eax

; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];

	mov	eax, DWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r8+rcx*4]
	movsdx	QWORD PTR [r10+24], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+32], eax

; 49   : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [r9+16]
	mov	QWORD PTR [r10+40], rax
$LN2@prim:

; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();
; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];
; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	lea	r11, QWORD PTR [rsp+1216]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ENDP		; frustum_collider<1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<1,0>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [r8+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [r8+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
	mov	r8, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-56], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-44], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1
	movss	DWORD PTR [rax-36], xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<1,0>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
src$1 = 32
dst$2 = 624
this$ = 1232
prim$ = 1240
?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z PROC	; frustum_collider<1,0>::_prim, COMDAT

; 35   : 	{

$LN31:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 1216				; 000004c0H

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	r10, QWORD PTR [rcx+16]
	mov	r9, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h

; 32   : 	IC void		resize(int c)				{ VERIFY(c<=dim); count=c;				}

	mov	DWORD PTR [rax-616], 3

; 22   : 	{}

	mov	DWORD PTR [rax-24], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 35   : 	{

	mov	edi, edx
	mov	rbx, rcx

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	lea	r8, QWORD PTR [rdi+rdi*2]

; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))

	lea	rdx, QWORD PTR src$1[rsp]
	mov	eax, DWORD PTR [r9+r8*8]
	lea	rsi, QWORD PTR [r8*8]
	lea	r8, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+r8*4]
	movsdx	QWORD PTR src$1[rsp], xmm0
	mov	eax, DWORD PTR [r10+r8*4+8]
	lea	r8, QWORD PTR dst$2[rsp]
	mov	DWORD PTR src$1[rsp+8], eax
	mov	eax, DWORD PTR [r9+rsi+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+rcx*4]
	movsdx	QWORD PTR src$1[rsp+12], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	DWORD PTR src$1[rsp+20], eax
	mov	eax, DWORD PTR [r9+rsi+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r10+rcx*4]
	movsdx	QWORD PTR src$1[rsp+24], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	rcx, QWORD PTR [rbx+24]
	mov	DWORD PTR src$1[rsp+32], eax
	call	?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ; CFrustum::ClipPoly
	test	rax, rax
	je	SHORT $LN2@prim

; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	r8, QWORD PTR [rbx+16]
	mov	r9, QWORD PTR [rbx+8]
	mov	DWORD PTR [rax+48], edi
	mov	r10, rax
	add	r9, rsi
	mov	ecx, DWORD PTR [r9]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [r8+rdx*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [rax+8], ecx

; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];

	mov	ecx, DWORD PTR [r9+4]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [r8+rdx*4]
	movsdx	QWORD PTR [rax+12], xmm0
	mov	eax, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [r10+20], eax

; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];

	mov	eax, DWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r8+rcx*4]
	movsdx	QWORD PTR [r10+24], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+32], eax

; 49   : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [r9+16]
	mov	QWORD PTR [r10+40], rax
$LN2@prim:

; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();
; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];
; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	lea	r11, QWORD PTR [rsp+1216]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ENDP	; frustum_collider<1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<0,1>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [r8+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [r8+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
	mov	r8, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-56], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-44], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1
	movss	DWORD PTR [rax-36], xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<0,1>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 48
prim$ = 56
?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z PROC	; frustum_collider<0,1>::_prim, COMDAT

; 35   : 	{

$LN31:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];
; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))
; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();
; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];
; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];
; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];
; 49   : 				R.dummy		= tris[prim].dummy;
; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rcx]
	mov	ebx, edx
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	rdx, QWORD PTR [rdi+8]
	lea	r8, QWORD PTR [rbx+rbx*2]
	mov	DWORD PTR [rax+48], ebx
	mov	ecx, DWORD PTR [rdx+r8*8]

; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	r10, rax
	lea	r9, QWORD PTR [rdx+r8*8]
	mov	r8, QWORD PTR [rdi+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [r8+rdx*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [rax+8], ecx
	mov	eax, DWORD PTR [r9+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r8+rcx*4]
	movsdx	QWORD PTR [r10+12], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+20], eax
	mov	eax, DWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r8+rcx*4]
	movsdx	QWORD PTR [r10+24], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+32], eax
	mov	rax, QWORD PTR [r9+16]
	mov	QWORD PTR [r10+40], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ENDP	; frustum_collider<0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<0,0>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [r8+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm5
	movss	xmm6, DWORD PTR [r8]
	movss	xmm1, DWORD PTR [rdx+8]
	movss	xmm2, DWORD PTR [r8+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
	mov	r8, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	subss	xmm0, xmm6

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm6, xmm5

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-56], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-44], xmm6

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm4, xmm3

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-52], xmm0

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	movss	DWORD PTR [rax-40], xmm4

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 31   : 	ICF SelfRef	add(const Self &a, const Self &v)		{ x=a.x+v.x;y=a.y+v.y;	z=a.z+v.z;		return *this;	};

	addss	xmm2, xmm1
	movss	DWORD PTR [rax-36], xmm2

; 36   : 	ICF	SelfRef	sub(const Self &a, const Self &v)		{ x=a.x-v.x;y=a.y-v.y;	z=a.z-v.z;		return *this;	};

	movss	DWORD PTR [rax-48], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<0,0>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcdb\xrcdb_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 48
prim$ = 56
?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z PROC	; frustum_collider<0,0>::_prim, COMDAT

; 35   : 	{

$LN31:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];
; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))
; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();
; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];
; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];
; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];
; 49   : 				R.dummy		= tris[prim].dummy;
; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rcx]
	mov	ebx, edx
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	rdx, QWORD PTR [rdi+8]
	lea	r8, QWORD PTR [rbx+rbx*2]
	mov	DWORD PTR [rax+48], ebx
	mov	ecx, DWORD PTR [rdx+r8*8]

; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	r10, rax
	lea	r9, QWORD PTR [rdx+r8*8]
	mov	r8, QWORD PTR [rdi+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsdx	xmm0, QWORD PTR [r8+rdx*4]
	movsdx	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [rax+8], ecx
	mov	eax, DWORD PTR [r9+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r8+rcx*4]
	movsdx	QWORD PTR [r10+12], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+20], eax
	mov	eax, DWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsdx	xmm0, QWORD PTR [r8+rcx*4]
	movsdx	QWORD PTR [r10+24], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+32], eax
	mov	rax, QWORD PTR [r9+16]
	mov	QWORD PTR [r10+40], rax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ENDP	; frustum_collider<0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fixedvector.h
;	COMDAT ?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
c$dead$ = 16
?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z PROC	; svector<_vector3<float>,48>::resize, COMDAT

; 32   : 	IC void		resize(int c)				{ VERIFY(c<=dim); count=c;				}

	mov	DWORD PTR [rcx+576], 3
	ret	0
?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z ENDP	; svector<_vector3<float>,48>::resize
_TEXT	ENDS
END
