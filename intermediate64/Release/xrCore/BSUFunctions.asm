; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CO@NOFKPEC@Win95GetModuleBaseName?5Invalid?5s@ ; `string'
EXTRN	__imp_SetLastError:PROC
EXTRN	__imp_lstrcpynA:PROC
EXTRN	__imp_lstrlenA:PROC
EXTRN	__imp_IsBadWritePtr:PROC
EXTRN	__imp_SymCleanup:PROC
EXTRN	__imp_SymInitialize:PROC
EXTRN	__imp_SymLoadModule64:PROC
;	COMDAT ??_C@_0CO@NOFKPEC@Win95GetModuleBaseName?5Invalid?5s@
CONST	SEGMENT
??_C@_0CO@NOFKPEC@Win95GetModuleBaseName?5Invalid?5s@ DB 'Win95GetModuleB'
	DB	'aseName Invalid string buffer', 0aH, 00H	; `string'
PI_MUL_2 DD	040c90fdbr			; 6.28319
pdata	SEGMENT
$pdata$?Win95GetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z DD imagerel ?Win95GetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z
	DD	imagerel ?Win95GetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z+236
	DD	imagerel $unwind$?Win95GetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?Win95GetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z DD 071201H
	DD	0296412H
	DD	0283412H
	DD	0260112H
	DD	0700bH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\bsufunctions.cpp
xdata	ENDS
_TEXT	SEGMENT
szBuff$ = 32
hModule$ = 320
lpBaseName$ = 328
nSize$ = 336
?Win95GetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z PROC ; Win95GetModuleBaseName

; 46   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 304				; 00000130H
	mov	rsi, rdx
	mov	rdi, rcx

; 47   :     ASSERT ( FALSE == IsBadWritePtr ( lpBaseName , nSize ) ) ;
; 48   :     if ( TRUE == IsBadWritePtr ( lpBaseName , nSize ) )

	mov	edx, r8d
	mov	rcx, rsi
	mov	ebx, r8d
	call	QWORD PTR __imp_IsBadWritePtr
	cmp	eax, 1
	jne	SHORT $LN4@Win95GetMo

; 49   :     {
; 50   :         TRACE0 ( "Win95GetModuleBaseName Invalid string buffer\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CO@NOFKPEC@Win95GetModuleBaseName?5Invalid?5s@
	call	?Log@@YAXPEBD@Z				; Log

; 51   :         SetLastError ( ERROR_INVALID_PARAMETER ) ;

	mov	ecx, 87					; 00000057H
	call	QWORD PTR __imp_SetLastError
$LN14@Win95GetMo:

; 52   :         return ( 0 ) ;

	xor	eax, eax
	jmp	$LN5@Win95GetMo
$LN4@Win95GetMo:

; 53   :     }
; 54   : 
; 55   :     // This could blow the stack...
; 56   :     char szBuff[ MAX_PATH + 1 ] ;
; 57   :     DWORD dwRet = GetModuleFileName ( hModule , szBuff , MAX_PATH ) ;

	lea	rdx, QWORD PTR szBuff$[rsp]
	mov	r8d, 260				; 00000104H
	mov	rcx, rdi
	call	QWORD PTR __imp_GetModuleFileNameA

; 58   :     ASSERT ( 0 != dwRet ) ;
; 59   :     if ( 0 == dwRet )

	test	eax, eax

; 60   :     {
; 61   :         return ( 0 ) ;

	je	SHORT $LN14@Win95GetMo

; 62   :     }
; 63   : 
; 64   :     // Find the last '\' mark.
; 65   :     char * pStart = strrchr ( szBuff , '\\' ) ;

	lea	rcx, QWORD PTR szBuff$[rsp]
	mov	edx, 92					; 0000005cH
	call	QWORD PTR __imp_strrchr
	mov	rdi, rax

; 66   :     int iMin ;
; 67   :     if ( NULL != pStart )

	test	rax, rax
	je	SHORT $LN2@Win95GetMo

; 68   :     {
; 69   :         // Move up one character.
; 70   :         pStart++ ;

	inc	rdi

; 71   :         //lint -e666
; 72   :         iMin = min ( (int)nSize , (lstrlen ( pStart ) + 1) ) ;

	mov	rcx, rdi
	call	QWORD PTR __imp_lstrlenA
	inc	eax
	cmp	ebx, eax
	jl	SHORT $LN8@Win95GetMo
	mov	rcx, rdi
	call	QWORD PTR __imp_lstrlenA
	lea	ebx, DWORD PTR [rax+1]
$LN8@Win95GetMo:

; 73   :         //lint +e666
; 74   :         lstrcpyn ( lpBaseName , pStart , iMin ) ;

	mov	rdx, rdi

; 75   :     }
; 76   :     else

	jmp	SHORT $LN13@Win95GetMo
$LN2@Win95GetMo:

; 77   :     {
; 78   :         // Copy the szBuff buffer in.
; 79   :         //lint -e666
; 80   :         iMin = min ( (int)nSize , (lstrlen ( szBuff ) + 1) ) ;

	lea	rcx, QWORD PTR szBuff$[rsp]
	call	QWORD PTR __imp_lstrlenA
	inc	eax
	cmp	ebx, eax
	jl	SHORT $LN10@Win95GetMo
	lea	rcx, QWORD PTR szBuff$[rsp]
	call	QWORD PTR __imp_lstrlenA
	lea	ebx, DWORD PTR [rax+1]
$LN10@Win95GetMo:

; 81   :         //lint +e666
; 82   :         lstrcpyn ( lpBaseName , szBuff , iMin ) ;

	lea	rdx, QWORD PTR szBuff$[rsp]
$LN13@Win95GetMo:
	mov	r8d, ebx
	mov	rcx, rsi
	call	QWORD PTR __imp_lstrcpynA

; 83   :     }
; 84   :     // Always NULL terminate.
; 85   :     lpBaseName[ iMin ] = '\0' ;

	movsxd	rax, ebx
	mov	BYTE PTR [rax+rsi], 0

; 86   :     return ( (DWORD)(iMin - 1) ) ;

	lea	eax, DWORD PTR [rbx-1]
$LN5@Win95GetMo:

; 87   : }

	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?Win95GetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z ENDP ; Win95GetModuleBaseName
PUBLIC	BSUGetModuleBaseName
pdata	SEGMENT
$pdata$BSUGetModuleBaseName DD imagerel $LN7
	DD	imagerel $LN7+124
	DD	imagerel $unwind$BSUGetModuleBaseName
pdata	ENDS
xdata	SEGMENT
$unwind$BSUGetModuleBaseName DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
hProcess$ = 48
hModule$ = 56
lpBaseName$ = 64
nSize$ = 72
BSUGetModuleBaseName PROC

; 24   : {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, r9d
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 25   :     if ( TRUE == IsNT ( ) )

	call	IsNT
	cmp	eax, 1
	jne	SHORT $LN1@BSUGetModu

; 26   :     {
; 27   :         // Call the NT version.  It is in NT4ProcessInfo because that is
; 28   :         // where all the PSAPI wrappers are kept.
; 29   :         return ( NTGetModuleBaseName ( hProcess     ,
; 30   :                                        hModule      ,
; 31   :                                        lpBaseName   ,
; 32   :                                        nSize         ) ) ;

	call	?InitPSAPI@@YAHXZ			; InitPSAPI
	test	eax, eax
	jne	SHORT $LN4@BSUGetModu
	lea	edx, QWORD PTR [rax+1]
	mov	ecx, 1114				; 0000045aH
	call	QWORD PTR __imp_SetLastErrorEx
	xor	eax, eax
	jmp	SHORT $LN2@BSUGetModu
$LN4@BSUGetModu:
	mov	r9d, ebx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rbp
	call	QWORD PTR g_pGetModuleBaseName
	jmp	SHORT $LN2@BSUGetModu
$LN1@BSUGetModu:

; 33   :     }
; 34   :     return ( Win95GetModuleBaseName ( hProcess     ,
; 35   :                                       hModule      ,
; 36   :                                       lpBaseName   ,
; 37   :                                       nSize         ) ) ;

	mov	r8d, ebx
	mov	rdx, rdi
	mov	rcx, rsi
	call	?Win95GetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z ; Win95GetModuleBaseName
$LN2@BSUGetModu:

; 38   : 
; 39   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
BSUGetModuleBaseName ENDP
PUBLIC	BSUSymInitialize
pdata	SEGMENT
$pdata$BSUSymInitialize DD imagerel $LN50
	DD	imagerel $LN50+342
	DD	imagerel $unwind$BSUSymInitialize
$pdata$0$BSUSymInitialize DD imagerel $LN50+342
	DD	imagerel $LN50+522
	DD	imagerel $chain$0$BSUSymInitialize
$pdata$1$BSUSymInitialize DD imagerel $LN50+522
	DD	imagerel $LN50+546
	DD	imagerel $chain$1$BSUSymInitialize
$pdata$2$BSUSymInitialize DD imagerel $LN50+546
	DD	imagerel $LN50+574
	DD	imagerel $chain$2$BSUSymInitialize
$pdata$3$BSUSymInitialize DD imagerel $LN50+574
	DD	imagerel $LN50+663
	DD	imagerel $chain$3$BSUSymInitialize
pdata	ENDS
xdata	SEGMENT
$unwind$BSUSymInitialize DD 091d01H
	DD	046641dH
	DD	045341dH
	DD	040011dH
	DD	0700cc00eH
	DD	0500bH
$chain$0$BSUSymInitialize DD 020821H
	DD	044d408H
	DD	imagerel $LN50
	DD	imagerel $LN50+342
	DD	imagerel $unwind$BSUSymInitialize
$chain$1$BSUSymInitialize DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+342
	DD	imagerel $unwind$BSUSymInitialize
$chain$2$BSUSymInitialize DD 020021H
	DD	044d400H
	DD	imagerel $LN50
	DD	imagerel $LN50+342
	DD	imagerel $unwind$BSUSymInitialize
$chain$3$BSUSymInitialize DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+342
	DD	imagerel $unwind$BSUSymInitialize
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
dwCount$99351 = 64
$T273851 = 72
$T273843 = 72
$T273839 = 72
stOSVI$273812 = 80
szModName$99361 = 240
dwPID$ = 544
hProcess$ = 552
UserSearchPath$ = 560
fInvadeProcess$ = 568
BSUSymInitialize PROC

; 94   : {

$LN50:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rbp
	push	rdi
	push	r12
	lea	rbp, QWORD PTR [rsp-256]
	sub	rsp, 512				; 00000200H
	mov	ebx, r9d
	mov	r12, r8
	mov	rsi, rdx
	mov	edi, ecx

; 95   :     // If this is any flavor of NT or fInvadeProcess is FALSE, just call
; 96   :     // SymInitialize itself
; 97   :     if ( ( TRUE == IsNT ( ) ) || ( FALSE == fInvadeProcess ) )

	call	IsNT
	cmp	eax, 1
	je	$LN11@BSUSymInit
	test	ebx, ebx
	je	$LN11@BSUSymInit

; 102  :     }
; 103  :     else
; 104  :     {
; 105  :         // This is Win9x and the user wants to invade!
; 106  : 
; 107  :         // The first step is to initialize the symbol engine.  If it
; 108  :         // fails, there is not much I can do.
; 109  :         BOOL bSymInit = ::SymInitialize ( hProcess       ,
; 110  :                                           UserSearchPath ,
; 111  :                                           fInvadeProcess  ) ;

	mov	r8d, ebx
	mov	rdx, r12
	mov	rcx, rsi
	call	QWORD PTR __imp_SymInitialize

; 112  :         ASSERT ( FALSE != bSymInit ) ;
; 113  :         if ( FALSE == bSymInit )

	test	eax, eax

; 114  :         {
; 115  :             return ( FALSE ) ;

	je	$LN49@BSUSymInit

; 116  :         }
; 117  : 
; 118  :         DWORD dwCount ;
; 119  :         // Find out how many modules there are.  This is a BSU function.
; 120  :         if ( FALSE == GetLoadedModules ( dwPID    ,
; 121  :                                          0        ,
; 122  :                                          NULL     ,
; 123  :                                          &dwCount  ) )

	lea	rcx, QWORD PTR dwCount$99351[rsp]
	mov	edx, 4
	call	QWORD PTR __imp_IsBadWritePtr
	cmp	eax, 1
	je	$LN18@BSUSymInit
	lea	rcx, QWORD PTR stOSVI$273812[rsp]
	xor	edx, edx
	mov	r8d, 148				; 00000094H
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16
	lea	rcx, QWORD PTR stOSVI$273812[rsp]
	mov	DWORD PTR stOSVI$273812[rsp], 148	; 00000094H
	call	QWORD PTR __imp_GetVersionExA
	test	eax, eax
	jne	SHORT $LN17@BSUSymInit
	lea	rcx, OFFSET FLAT:??_C@_0BG@NMFPCNDP@GetVersionEx?5failed?$CB?6?$AA@
	call	?Log@@YAXPEBD@Z				; Log

; 124  :         {
; 125  :             ASSERT ( !"GetLoadedModules failed" ) ;
; 126  :             // Clean up the symbol engine and leave.
; 127  :             VERIFY ( ::SymCleanup ( hProcess ) ) ;

	mov	rcx, rsi
	call	QWORD PTR __imp_SymCleanup

; 128  :             return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN13@BSUSymInit

; 116  :         }
; 117  : 
; 118  :         DWORD dwCount ;
; 119  :         // Find out how many modules there are.  This is a BSU function.
; 120  :         if ( FALSE == GetLoadedModules ( dwPID    ,
; 121  :                                          0        ,
; 122  :                                          NULL     ,
; 123  :                                          &dwCount  ) )

$LN17@BSUSymInit:
	cmp	DWORD PTR stOSVI$273812[rsp+16], 2
	jne	SHORT $LN16@BSUSymInit
	cmp	DWORD PTR stOSVI$273812[rsp+4], 4
	jne	SHORT $LN16@BSUSymInit
	lea	r9, QWORD PTR dwCount$99351[rsp]
	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, edi
	call	?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z ; NT4GetLoadedModules
	jmp	SHORT $LN15@BSUSymInit
$LN16@BSUSymInit:
	lea	r9, QWORD PTR dwCount$99351[rsp]
	xor	r8d, r8d
	xor	edx, edx
	mov	ecx, edi
	call	?TLHELPGetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z ; TLHELPGetLoadedModules
$LN15@BSUSymInit:
	test	eax, eax
	je	$LN45@BSUSymInit

; 129  :         }
; 130  :         // Allocate something big enough to hold the list.
; 131  :         HMODULE * paMods = new HMODULE[ dwCount ] ;

	mov	ecx, DWORD PTR dwCount$99351[rsp]
	mov	eax, 8
	mul	rcx
	mov	rcx, -1
	mov	edx, 1
	cmovo	rax, rcx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	test	rax, rax
	cmovne	rdx, rax
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 132  : 
; 133  :         // Get the list for real.
; 134  :         if ( FALSE == GetLoadedModules ( dwPID    ,
; 135  :                                          dwCount  ,
; 136  :                                          paMods   ,
; 137  :                                          &dwCount  ) )

	mov	ebx, DWORD PTR dwCount$99351[rsp]
	lea	rcx, QWORD PTR dwCount$99351[rsp]
	mov	edx, 4
	mov	r12, rax
	call	QWORD PTR __imp_IsBadWritePtr
	cmp	eax, 1
	je	$LN27@BSUSymInit
	lea	r9, QWORD PTR dwCount$99351[rsp]
	mov	r8, r12
	mov	edx, ebx
	mov	ecx, edi
	call	GetLoadedModules
	test	eax, eax
	je	$LN46@BSUSymInit

; 145  :         }
; 146  :         // The module filename.
; 147  :         TCHAR szModName [ MAX_PATH ] ;
; 148  :         for ( UINT uiCurr = 0 ; uiCurr < dwCount ; uiCurr++ )

	mov	QWORD PTR [rsp+544], r13
	xor	r13d, r13d
	mov	ebx, r13d
	cmp	DWORD PTR dwCount$99351[rsp], ebx
	jbe	$LN4@BSUSymInit
	mov	rdi, r12
$LL6@BSUSymInit:

; 149  :         {
; 150  :             // Get the module's filename.
; 151  :             if ( FALSE == GetModuleFileName ( paMods[ uiCurr ]     ,
; 152  :                                               szModName            ,
; 153  :                                               sizeof ( szModName )  ) )

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, QWORD PTR szModName$99361[rbp-256]
	mov	r8d, 260				; 00000104H
	call	QWORD PTR __imp_GetModuleFileNameA
	test	eax, eax
	je	$LN42@BSUSymInit

; 161  :             }
; 162  : 
; 163  :             // In order to get the symbol engine to work outside a
; 164  :             // debugger, it needs a handle to the image.  Yes, this
; 165  :             // will leak but the OS will close it down when the process
; 166  :             // ends.
; 167  :             HANDLE hFile = CreateFile ( szModName       ,
; 168  :                                         GENERIC_READ    ,
; 169  :                                         FILE_SHARE_READ ,
; 170  :                                         NULL            ,
; 171  :                                         OPEN_EXISTING   ,
; 172  :                                         0               ,
; 173  :                                         0                ) ;

	xor	r9d, r9d
	mov	QWORD PTR [rsp+48], r13
	lea	rcx, QWORD PTR szModName$99361[rbp-256]
	lea	r8d, QWORD PTR [r9+1]
	mov	edx, -2147483648			; 80000000H
	mov	DWORD PTR [rsp+40], r13d
	mov	DWORD PTR [rsp+32], 3
	call	QWORD PTR __imp_CreateFileA

; 174  : 
; 175  :             // For whatever reason, SymLoadModule can return zero, but
; 176  :             // it still loads the modules.  Sheez.
; 177  :             if ( FALSE == SymLoadModule ( hProcess               ,
; 178  :                                           hFile                  ,
; 179  :                                           szModName              ,
; 180  :                                           NULL                   ,
; 181  :                                          (DWORD)paMods[ uiCurr ] ,
; 182  :                                           0                       ) )

	mov	ecx, DWORD PTR [rdi]
	mov	DWORD PTR [rsp+40], r13d
	mov	QWORD PTR [rsp+32], rcx
	lea	r8, QWORD PTR szModName$99361[rbp-256]
	mov	rcx, rsi
	xor	r9d, r9d
	mov	rdx, rax
	call	QWORD PTR __imp_SymLoadModule64
	test	rax, rax
	jne	SHORT $LN5@BSUSymInit

; 183  :             {
; 184  :                 // Check the last error value.  If it is zero, then all
; 185  :                 // I can assume is that it worked.
; 186  :                 DWORD dwLastErr = GetLastError ( ) ;

	call	QWORD PTR __imp_GetLastError

; 187  :                 ASSERT ( ERROR_SUCCESS == dwLastErr ) ;
; 188  :                 if ( ERROR_SUCCESS != dwLastErr )

	test	eax, eax
	jne	SHORT $LN42@BSUSymInit
$LN5@BSUSymInit:

; 145  :         }
; 146  :         // The module filename.
; 147  :         TCHAR szModName [ MAX_PATH ] ;
; 148  :         for ( UINT uiCurr = 0 ; uiCurr < dwCount ; uiCurr++ )

	inc	ebx
	add	rdi, 8
	cmp	ebx, DWORD PTR dwCount$99351[rsp]
	jb	SHORT $LL6@BSUSymInit
$LN4@BSUSymInit:

; 189  :                 {
; 190  :                     // Clean up the symbol engine and leave.
; 191  :                     VERIFY ( ::SymCleanup ( hProcess ) ) ;
; 192  :                     // Free the memory that I allocated earlier.
; 193  :                     delete [] paMods ;
; 194  :                     return ( FALSE ) ;
; 195  :                 }
; 196  :             }
; 197  :         }
; 198  :         delete [] paMods ;

	lea	rcx, QWORD PTR $T273851[rsp]
	mov	QWORD PTR $T273851[rsp], r12
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>

; 199  :     }
; 200  :     return ( TRUE ) ;

	mov	eax, 1
$LN48@BSUSymInit:
	mov	r13, QWORD PTR [rsp+544]
$LN13@BSUSymInit:

; 201  : }

	lea	r11, QWORD PTR [rsp+512]
	mov	rbx, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r12
	pop	rdi
	pop	rbp
	ret	0
$LN42@BSUSymInit:

; 154  :             {
; 155  :                 ASSERT ( !"GetModuleFileName failed!" ) ;
; 156  :                 // Clean up the symbol engine and leave.
; 157  :                 VERIFY ( ::SymCleanup ( hProcess ) ) ;

	mov	rcx, rsi
	call	QWORD PTR __imp_SymCleanup

; 158  :                 // Free the memory that I allocated earlier.
; 159  :                 delete [] paMods ;

	lea	rcx, QWORD PTR $T273843[rsp]
	mov	QWORD PTR $T273843[rsp], r12
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>

; 160  :                 return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN48@BSUSymInit

; 132  : 
; 133  :         // Get the list for real.
; 134  :         if ( FALSE == GetLoadedModules ( dwPID    ,
; 135  :                                          dwCount  ,
; 136  :                                          paMods   ,
; 137  :                                          &dwCount  ) )

$LN27@BSUSymInit:
	mov	edx, 1
	lea	ecx, QWORD PTR [rdx+86]
	call	QWORD PTR __imp_SetLastErrorEx
$LN46@BSUSymInit:

; 138  :         {
; 139  :             ASSERT ( !"GetLoadedModules failed" ) ;
; 140  :             // Clean up the symbol engine and leave.
; 141  :             VERIFY ( ::SymCleanup ( hProcess ) ) ;

	mov	rcx, rsi
	call	QWORD PTR __imp_SymCleanup

; 142  :             // Free the memory that I allocated earlier.
; 143  :             delete [] paMods ;

	lea	rcx, QWORD PTR $T273839[rsp]
	mov	QWORD PTR $T273839[rsp], r12
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>

; 144  :             return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN13@BSUSymInit

; 116  :         }
; 117  : 
; 118  :         DWORD dwCount ;
; 119  :         // Find out how many modules there are.  This is a BSU function.
; 120  :         if ( FALSE == GetLoadedModules ( dwPID    ,
; 121  :                                          0        ,
; 122  :                                          NULL     ,
; 123  :                                          &dwCount  ) )

$LN18@BSUSymInit:
	mov	edx, 1
	lea	ecx, QWORD PTR [rdx+86]
	call	QWORD PTR __imp_SetLastErrorEx
$LN45@BSUSymInit:

; 124  :         {
; 125  :             ASSERT ( !"GetLoadedModules failed" ) ;
; 126  :             // Clean up the symbol engine and leave.
; 127  :             VERIFY ( ::SymCleanup ( hProcess ) ) ;

	mov	rcx, rsi
	call	QWORD PTR __imp_SymCleanup
$LN49@BSUSymInit:

; 128  :             return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN13@BSUSymInit
$LN11@BSUSymInit:

; 98   :     {
; 99   :         return ( ::SymInitialize ( hProcess       ,
; 100  :                                    UserSearchPath ,
; 101  :                                    fInvadeProcess  ) ) ;

	mov	r8d, ebx
	mov	rdx, r12
	mov	rcx, rsi
	call	QWORD PTR __imp_SymInitialize
	jmp	$LN13@BSUSymInit
BSUSymInitialize ENDP
END
