; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?d_len@@3PAEA					; d_len
PUBLIC	?d_code@@3PAEA					; d_code
PUBLIC	?p_code@@3PAEA					; p_code
PUBLIC	?p_len@@3PAEA					; p_len
PUBLIC	?son@@3PAHA					; son
PUBLIC	?prnt@@3PAHA					; prnt
PUBLIC	?freq@@3PAIA					; freq
PUBLIC	?tim_size@@3IA					; tim_size
PUBLIC	?len@@3IA					; len
PUBLIC	?code@@3IA					; code
PUBLIC	?dad@@3PAHA					; dad
PUBLIC	?rson@@3PAHA					; rson
PUBLIC	?lson@@3PAHA					; lson
PUBLIC	?match_length@@3HA				; match_length
PUBLIC	?match_position@@3HA				; match_position
PUBLIC	?text_buf@@3PAEA				; text_buf
PUBLIC	?codesize@@3IA					; codesize
PUBLIC	?textsize@@3IA					; textsize
?son@@3PAHA DD	0273H DUP (?)				; son
?prnt@@3PAHA DD	03aeH DUP (?)				; prnt
?freq@@3PAIA DD	0274H DUP (?)				; freq
?tim_size@@3IA DD 01H DUP (?)				; tim_size
?len@@3IA DD	01H DUP (?)				; len
?code@@3IA DD	01H DUP (?)				; code
?dad@@3PAHA DD	01001H DUP (?)				; dad
?rson@@3PAHA DD	01101H DUP (?)				; rson
?lson@@3PAHA DD	01001H DUP (?)				; lson
?match_length@@3HA DD 01H DUP (?)			; match_length
?match_position@@3HA DD 01H DUP (?)			; match_position
?text_buf@@3PAEA DB 0103cH DUP (?)			; text_buf
?codesize@@3IA DD 01H DUP (?)				; codesize
?textsize@@3IA DD 01H DUP (?)				; textsize
_BSS	ENDS
	ORG $+8
?d_len@@3PAEA DB 03H					; d_len
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
?d_code@@3PAEA DB 00H					; d_code
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01eH
	DB	01eH
	DB	01fH
	DB	01fH
	DB	020H
	DB	020H
	DB	021H
	DB	021H
	DB	022H
	DB	022H
	DB	023H
	DB	023H
	DB	024H
	DB	024H
	DB	025H
	DB	025H
	DB	026H
	DB	026H
	DB	027H
	DB	027H
	DB	028H
	DB	028H
	DB	029H
	DB	029H
	DB	02aH
	DB	02aH
	DB	02bH
	DB	02bH
	DB	02cH
	DB	02cH
	DB	02dH
	DB	02dH
	DB	02eH
	DB	02eH
	DB	02fH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
?p_code@@3PAEA DB 00H					; p_code
	DB	020H
	DB	030H
	DB	040H
	DB	050H
	DB	058H
	DB	060H
	DB	068H
	DB	070H
	DB	078H
	DB	080H
	DB	088H
	DB	090H
	DB	094H
	DB	098H
	DB	09cH
	DB	0a0H
	DB	0a4H
	DB	0a8H
	DB	0acH
	DB	0b0H
	DB	0b4H
	DB	0b8H
	DB	0bcH
	DB	0c0H
	DB	0c2H
	DB	0c4H
	DB	0c6H
	DB	0c8H
	DB	0caH
	DB	0ccH
	DB	0ceH
	DB	0d0H
	DB	0d2H
	DB	0d4H
	DB	0d6H
	DB	0d8H
	DB	0daH
	DB	0dcH
	DB	0deH
	DB	0e0H
	DB	0e2H
	DB	0e4H
	DB	0e6H
	DB	0e8H
	DB	0eaH
	DB	0ecH
	DB	0eeH
	DB	0f0H
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
	DB	0fbH
	DB	0fcH
	DB	0fdH
	DB	0feH
	DB	0ffH
?p_len@@3PAEA DB 03H					; p_len
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
PUBLIC	?xr_realloc@@YAPEAXPEAX_K@Z			; xr_realloc
PUBLIC	?Decode@@YAXXZ					; Decode
PUBLIC	?Encode@@YAXXZ					; Encode
PUBLIC	?DecodePosition@@YAHXZ				; DecodePosition
PUBLIC	?DecodeChar@@YAHXZ				; DecodeChar
PUBLIC	?EncodePosition@@YAXI@Z				; EncodePosition
PUBLIC	?EncodeChar@@YAXI@Z				; EncodeChar
PUBLIC	?update@@YAXH@Z					; update
PUBLIC	?reconst@@YAXXZ					; reconst
PUBLIC	?StartHuff@@YAXXZ				; StartHuff
PUBLIC	?DeleteNode@@YAXH@Z				; DeleteNode
PUBLIC	?InsertNode@@YAXH@Z				; InsertNode
PUBLIC	?InitTree@@YAXXZ				; InitTree
PUBLIC	?PutFlush@LZfs@@QEAAXXZ				; LZfs::PutFlush
PUBLIC	?PutCode@LZfs@@QEAAXHI@Z			; LZfs::PutCode
PUBLIC	?GetByte@LZfs@@QEAAHXZ				; LZfs::GetByte
PUBLIC	?GetBit@LZfs@@QEAAHXZ				; LZfs::GetBit
PUBLIC	?OutPointer@LZfs@@QEAAPEAEXZ			; LZfs::OutPointer
PUBLIC	?OutSize@LZfs@@QEAAIXZ				; LZfs::OutSize
PUBLIC	?InputSize@LZfs@@QEAAIXZ			; LZfs::InputSize
PUBLIC	?Init_Output@LZfs@@QEAAXH@Z			; LZfs::Init_Output
PUBLIC	?Init_Input@LZfs@@QEAAXPEAE0@Z			; LZfs::Init_Input
PUBLIC	??0LZfs@@QEAA@XZ				; LZfs::LZfs
PUBLIC	?_putb@LZfs@@QEAAXH@Z				; LZfs::_putb
PUBLIC	?_getb@LZfs@@QEAAHXZ				; LZfs::_getb
PUBLIC	?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z		; _compressLZ
PUBLIC	?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z		; _decompressLZ
	ALIGN	4

fs	DB	040H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?Decode@@YAXXZ DD imagerel $LN53
	DD	imagerel $LN53+139
	DD	imagerel $unwind$?Decode@@YAXXZ
$pdata$2$?Decode@@YAXXZ DD imagerel $LN53+139
	DD	imagerel $LN53+304
	DD	imagerel $chain$2$?Decode@@YAXXZ
$pdata$6$?Decode@@YAXXZ DD imagerel $LN53+304
	DD	imagerel $LN53+682
	DD	imagerel $chain$6$?Decode@@YAXXZ
$pdata$7$?Decode@@YAXXZ DD imagerel $LN53+682
	DD	imagerel $LN53+704
	DD	imagerel $chain$7$?Decode@@YAXXZ
$pdata$8$?Decode@@YAXXZ DD imagerel $LN53+704
	DD	imagerel $LN53+709
	DD	imagerel $chain$8$?Decode@@YAXXZ
$pdata$?Encode@@YAXXZ DD imagerel $LN176
	DD	imagerel $LN176+128
	DD	imagerel $unwind$?Encode@@YAXXZ
$pdata$6$?Encode@@YAXXZ DD imagerel $LN176+128
	DD	imagerel $LN176+2353
	DD	imagerel $chain$6$?Encode@@YAXXZ
$pdata$7$?Encode@@YAXXZ DD imagerel $LN176+2353
	DD	imagerel $LN176+2473
	DD	imagerel $chain$7$?Encode@@YAXXZ
$pdata$8$?Encode@@YAXXZ DD imagerel $LN176+2473
	DD	imagerel $LN176+2479
	DD	imagerel $chain$8$?Encode@@YAXXZ
$pdata$?DecodePosition@@YAHXZ DD imagerel $LN24
	DD	imagerel $LN24+215
	DD	imagerel $unwind$?DecodePosition@@YAHXZ
$pdata$?DecodeChar@@YAHXZ DD imagerel $LN23
	DD	imagerel $LN23+195
	DD	imagerel $unwind$?DecodeChar@@YAHXZ
$pdata$?EncodePosition@@YAXI@Z DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$?EncodePosition@@YAXI@Z
$pdata$?EncodeChar@@YAXI@Z DD imagerel $LN11
	DD	imagerel $LN11+107
	DD	imagerel $unwind$?EncodeChar@@YAXI@Z
$pdata$?update@@YAXH@Z DD imagerel $LN19
	DD	imagerel $LN19+257
	DD	imagerel $unwind$?update@@YAXH@Z
$pdata$?reconst@@YAXXZ DD imagerel $LN35
	DD	imagerel $LN35+378
	DD	imagerel $unwind$?reconst@@YAXXZ
$pdata$?StartHuff@@YAXXZ DD imagerel $LN23
	DD	imagerel $LN23+369
	DD	imagerel $unwind$?StartHuff@@YAXXZ
$pdata$?DeleteNode@@YAXH@Z DD imagerel $LN20
	DD	imagerel $LN20+81
	DD	imagerel $unwind$?DeleteNode@@YAXH@Z
$pdata$1$?DeleteNode@@YAXH@Z DD imagerel $LN20+81
	DD	imagerel $LN20+259
	DD	imagerel $chain$1$?DeleteNode@@YAXH@Z
$pdata$2$?DeleteNode@@YAXH@Z DD imagerel $LN20+259
	DD	imagerel $LN20+332
	DD	imagerel $chain$2$?DeleteNode@@YAXH@Z
$pdata$?InsertNode@@YAXH@Z DD imagerel $LN36
	DD	imagerel $LN36+531
	DD	imagerel $unwind$?InsertNode@@YAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PutFlush@LZfs@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+29
	DD	imagerel $unwind$?PutFlush@LZfs@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PutCode@LZfs@@QEAAXHI@Z DD imagerel $LN7
	DD	imagerel $LN7+163
	DD	imagerel $unwind$?PutCode@LZfs@@QEAAXHI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Init_Output@LZfs@@QEAAXH@Z DD imagerel $LN6
	DD	imagerel $LN6+55
	DD	imagerel $unwind$?Init_Output@LZfs@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_putb@LZfs@@QEAAXH@Z DD imagerel $LN9
	DD	imagerel $LN9+133
	DD	imagerel $unwind$?_putb@LZfs@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+99
	DD	imagerel $unwind$?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z
$pdata$?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+99
	DD	imagerel $unwind$?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_putb@LZfs@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Init_Output@LZfs@@QEAAXH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PutCode@LZfs@@QEAAXHI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PutFlush@LZfs@@QEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
xdata	SEGMENT
$unwind$?Decode@@YAXXZ DD 010401H
	DD	06204H
$chain$2$?Decode@@YAXXZ DD 061c21H
	DD	04f41cH
	DD	06c417H
	DD	083405H
	DD	imagerel $LN53
	DD	imagerel $LN53+139
	DD	imagerel $unwind$?Decode@@YAXXZ
$chain$6$?Decode@@YAXXZ DD 081421H
	DD	05e414H
	DD	0b740fH
	DD	0a640aH
	DD	095405H
	DD	imagerel $LN53+139
	DD	imagerel $LN53+304
	DD	imagerel $chain$2$?Decode@@YAXXZ
$chain$7$?Decode@@YAXXZ DD 021H
	DD	imagerel $LN53+139
	DD	imagerel $LN53+304
	DD	imagerel $chain$2$?Decode@@YAXXZ
$chain$8$?Decode@@YAXXZ DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+139
	DD	imagerel $unwind$?Decode@@YAXXZ
$unwind$?Encode@@YAXXZ DD 020601H
	DD	030029206H
$chain$6$?Encode@@YAXXZ DD 0e2321H
	DD	04f423H
	DD	05e41eH
	DD	06d419H
	DD	07c414H
	DD	08740fH
	DD	09640aH
	DD	0f5405H
	DD	imagerel $LN176
	DD	imagerel $LN176+128
	DD	imagerel $unwind$?Encode@@YAXXZ
$chain$7$?Encode@@YAXXZ DD 040021H
	DD	07c400H
	DD	087400H
	DD	imagerel $LN176
	DD	imagerel $LN176+128
	DD	imagerel $unwind$?Encode@@YAXXZ
$chain$8$?Encode@@YAXXZ DD 021H
	DD	imagerel $LN176
	DD	imagerel $LN176+128
	DD	imagerel $unwind$?Encode@@YAXXZ
$unwind$?DecodePosition@@YAHXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?DecodeChar@@YAHXZ DD 020601H
	DD	030023206H
$unwind$?EncodePosition@@YAXI@Z DD 020601H
	DD	030023206H
$unwind$?EncodeChar@@YAXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?update@@YAXH@Z DD 020601H
	DD	030023206H
$unwind$?reconst@@YAXXZ DD 0a1401H
	DD	0f3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
$unwind$?StartHuff@@YAXXZ DD 020501H
	DD	017405H
$unwind$?DeleteNode@@YAXH@Z DD 030701H
	DD	047407H
	DD	0e007H
$chain$1$?DeleteNode@@YAXH@Z DD 040a21H
	DD	03640aH
	DD	023405H
	DD	imagerel $LN20
	DD	imagerel $LN20+81
	DD	imagerel $unwind$?DeleteNode@@YAXH@Z
$chain$2$?DeleteNode@@YAXH@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+81
	DD	imagerel $unwind$?DeleteNode@@YAXH@Z
$unwind$?InsertNode@@YAXH@Z DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0e016f018H
$unwind$?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
dest$ = 48
dest_sz$ = 56
src$ = 64
src_sz$ = 72
?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z PROC		; _decompressLZ

; 662  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 663  : 	u8*	start = (u8*) src;
; 664  : 	fs.Init_Input(start,start+src_sz);

	mov	eax, r9d
	mov	rdi, rdx
	mov	rbx, rcx
	add	rax, r8

; 85   : 		in_start	= _start;

	mov	QWORD PTR fs+16, r8

; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;

	mov	QWORD PTR fs+32, r8
	mov	QWORD PTR fs+24, rax

; 88   : 		
; 89   : 		// bitwise input/output
; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	xor	eax, eax
	mov	QWORD PTR fs+8, rax
	mov	QWORD PTR fs, rax

; 665  :     Decode();

	call	?Decode@@YAXXZ				; Decode

; 666  : 	*dest		= fs.OutPointer();

	mov	rax, QWORD PTR fs+40
	mov	QWORD PTR [rbx], rax

; 91   : 	}
; 92   : 	IC void		Init_Output(int _rsize) {
; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);
; 95   : 		out_end		= out_start + _rsize;
; 96   : 		out_iterator= out_start;
; 97   : 	}
; 98   : 	IC u32		InputSize	() {
; 99   : 		return u32(in_end-in_start);
; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);

	mov	eax, DWORD PTR fs+56

; 668  : }

	mov	rbx, QWORD PTR [rsp+48]

; 91   : 	}
; 92   : 	IC void		Init_Output(int _rsize) {
; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);
; 95   : 		out_end		= out_start + _rsize;
; 96   : 		out_iterator= out_start;
; 97   : 	}
; 98   : 	IC u32		InputSize	() {
; 99   : 		return u32(in_end-in_start);
; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);

	sub	eax, DWORD PTR fs+40

; 667  : 	*dest_sz	= fs.OutSize();

	mov	DWORD PTR [rdi], eax

; 668  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z ENDP		; _decompressLZ
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
dest$ = 48
dest_sz$ = 56
src$ = 64
src_sz$ = 72
?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z PROC		; _compressLZ

; 653  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 654  : 	u8*	start = (u8*) src;
; 655  : 	fs.Init_Input(start,start+src_sz);

	mov	eax, r9d
	mov	rdi, rdx
	mov	rbx, rcx
	add	rax, r8

; 85   : 		in_start	= _start;

	mov	QWORD PTR fs+16, r8

; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;

	mov	QWORD PTR fs+32, r8
	mov	QWORD PTR fs+24, rax

; 88   : 		
; 89   : 		// bitwise input/output
; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	xor	eax, eax
	mov	QWORD PTR fs+8, rax
	mov	QWORD PTR fs, rax

; 656  :     Encode();

	call	?Encode@@YAXXZ				; Encode

; 657  : 	*dest		= fs.OutPointer();

	mov	rax, QWORD PTR fs+40
	mov	QWORD PTR [rbx], rax

; 91   : 	}
; 92   : 	IC void		Init_Output(int _rsize) {
; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);
; 95   : 		out_end		= out_start + _rsize;
; 96   : 		out_iterator= out_start;
; 97   : 	}
; 98   : 	IC u32		InputSize	() {
; 99   : 		return u32(in_end-in_start);
; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);

	mov	eax, DWORD PTR fs+56

; 659  : }

	mov	rbx, QWORD PTR [rsp+48]

; 91   : 	}
; 92   : 	IC void		Init_Output(int _rsize) {
; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);
; 95   : 		out_end		= out_start + _rsize;
; 96   : 		out_iterator= out_start;
; 97   : 	}
; 98   : 	IC u32		InputSize	() {
; 99   : 		return u32(in_end-in_start);
; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);

	sub	eax, DWORD PTR fs+40

; 658  : 	*dest_sz	= fs.OutSize();

	mov	DWORD PTR [rdi], eax

; 659  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z ENDP		; _compressLZ
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?_getb@LZfs@@QEAAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?_getb@LZfs@@QEAAHXZ PROC				; LZfs::_getb, COMDAT

; 65   : 		if (in_iterator==in_end) return EOF;

	mov	rcx, QWORD PTR fs+32
	cmp	rcx, QWORD PTR fs+24
	jne	SHORT $LN1@getb
	or	eax, -1

; 67   : 	}

	ret	0
$LN1@getb:

; 66   : 		return *in_iterator++;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR fs+32, rcx

; 67   : 	}

	ret	0
?_getb@LZfs@@QEAAHXZ ENDP				; LZfs::_getb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?_putb@LZfs@@QEAAXH@Z
_TEXT	SEGMENT
this$dead$ = 48
c$ = 56
?_putb@LZfs@@QEAAXH@Z PROC				; LZfs::_putb, COMDAT

; 68   : 	IC void		_putb(int c) {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 69   : 		if (out_iterator==out_end) {

	mov	rax, QWORD PTR fs+56
	mov	rbx, QWORD PTR fs+48
	mov	edi, edx
	cmp	rax, rbx
	jne	SHORT $LN6@putb

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	rdx, QWORD PTR fs+40
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	ebx, edx

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rbx+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	ecx, ebx
	add	rcx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	QWORD PTR fs+56, rcx

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+48, rax

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rcx], dil
	inc	QWORD PTR fs+56

; 76   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@putb:
	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rax], dl
	inc	QWORD PTR fs+56
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_putb@LZfs@@QEAAXH@Z ENDP				; LZfs::_putb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ??0LZfs@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??0LZfs@@QEAA@XZ PROC					; LZfs::LZfs, COMDAT

; 79   : 		in_start	= in_end	= in_iterator = 0;

	xor	eax, eax
	mov	QWORD PTR fs+32, rax
	mov	QWORD PTR fs+24, rax
	mov	QWORD PTR fs+16, rax

; 80   : 		out_start	= out_end	= out_iterator = 0;

	mov	QWORD PTR fs+56, rax
	mov	QWORD PTR fs+48, rax
	mov	QWORD PTR fs+40, rax

; 81   : 	}

	lea	rax, OFFSET FLAT:fs
	ret	0
??0LZfs@@QEAA@XZ ENDP					; LZfs::LZfs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?Init_Input@LZfs@@QEAAXPEAE0@Z
_TEXT	SEGMENT
this$dead$ = 8
_start$ = 16
_end$ = 24
?Init_Input@LZfs@@QEAAXPEAE0@Z PROC			; LZfs::Init_Input, COMDAT

; 84   : 		// input
; 85   : 		in_start	= _start;
; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;
; 88   : 		
; 89   : 		// bitwise input/output
; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	xor	eax, eax
	mov	QWORD PTR fs+16, rdx
	mov	QWORD PTR fs+24, r8
	mov	QWORD PTR fs+8, rax
	mov	QWORD PTR fs, rax
	mov	QWORD PTR fs+32, rdx

; 91   : 	}

	ret	0
?Init_Input@LZfs@@QEAAXPEAE0@Z ENDP			; LZfs::Init_Input
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?Init_Output@LZfs@@QEAAXH@Z
_TEXT	SEGMENT
this$dead$ = 48
_rsize$ = 56
?Init_Output@LZfs@@QEAAXH@Z PROC			; LZfs::Init_Output, COMDAT

; 92   : 	IC void		Init_Output(int _rsize) {

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);

	movsxd	rbx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 110  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	rdx, rbx
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 96   : 		out_iterator= out_start;

	mov	QWORD PTR fs+56, rax
	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR fs+48, rcx

; 97   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?Init_Output@LZfs@@QEAAXH@Z ENDP			; LZfs::Init_Output
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?InputSize@LZfs@@QEAAIXZ
_TEXT	SEGMENT
this$dead$ = 8
?InputSize@LZfs@@QEAAIXZ PROC				; LZfs::InputSize, COMDAT

; 99   : 		return u32(in_end-in_start);

	mov	rax, QWORD PTR fs+24
	sub	rax, QWORD PTR fs+16

; 100  : 	}

	ret	0
?InputSize@LZfs@@QEAAIXZ ENDP				; LZfs::InputSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?OutSize@LZfs@@QEAAIXZ
_TEXT	SEGMENT
this$dead$ = 8
?OutSize@LZfs@@QEAAIXZ PROC				; LZfs::OutSize, COMDAT

; 102  : 		return u32(out_iterator-out_start);

	mov	rax, QWORD PTR fs+56
	sub	rax, QWORD PTR fs+40

; 103  : 	}

	ret	0
?OutSize@LZfs@@QEAAIXZ ENDP				; LZfs::OutSize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?OutPointer@LZfs@@QEAAPEAEXZ
_TEXT	SEGMENT
this$dead$ = 8
?OutPointer@LZfs@@QEAAPEAEXZ PROC			; LZfs::OutPointer, COMDAT

; 105  : 		return out_start;

	mov	rax, QWORD PTR fs+40

; 106  : 	}

	ret	0
?OutPointer@LZfs@@QEAAPEAEXZ ENDP			; LZfs::OutPointer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?GetBit@LZfs@@QEAAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?GetBit@LZfs@@QEAAHXZ PROC				; LZfs::GetBit, COMDAT

; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {

	mov	r9d, DWORD PTR fs+4
	mov	r10d, DWORD PTR fs
	cmp	r9d, 8
	ja	SHORT $LN2@GetBit
	mov	r11, QWORD PTR fs+24
	mov	rdx, QWORD PTR fs+32
$LL3@GetBit:

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	rdx, r11
	je	SHORT $LN13@GetBit

; 66   : 		return *in_iterator++;

	movzx	r8d, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR fs+32, rdx

; 118  : 			if ((int)(i = _getb()) < 0) i = 0;

	test	r8d, r8d
	jns	SHORT $LN1@GetBit
$LN13@GetBit:
	xor	r8d, r8d
$LN1@GetBit:

; 119  : 			getbuf |= i << (8 - getlen);

	mov	ecx, 8
	sub	ecx, r9d

; 120  : 			getlen += 8;

	add	r9d, 8
	shl	r8d, cl
	mov	DWORD PTR fs+4, r9d
	or	r10d, r8d
	mov	DWORD PTR fs, r10d
	cmp	r9d, 8
	jbe	SHORT $LL3@GetBit
$LN2@GetBit:

; 121  : 		}
; 122  : 		i = getbuf;

	mov	eax, r10d

; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;

	dec	r9d
	add	r10d, r10d

; 125  : 		return (int)((i & 0x8000) >> 15);

	shr	eax, 15
	mov	DWORD PTR fs, r10d
	mov	DWORD PTR fs+4, r9d
	and	eax, 1

; 126  : 	}

	ret	0
?GetBit@LZfs@@QEAAHXZ ENDP				; LZfs::GetBit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?GetByte@LZfs@@QEAAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?GetByte@LZfs@@QEAAHXZ PROC				; LZfs::GetByte, COMDAT

; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {

	mov	r9d, DWORD PTR fs+4
	mov	r10d, DWORD PTR fs
	cmp	r9d, 8
	ja	SHORT $LN2@GetByte
	mov	r11, QWORD PTR fs+24
	mov	rdx, QWORD PTR fs+32
$LL3@GetByte:

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	rdx, r11
	je	SHORT $LN13@GetByte

; 66   : 		return *in_iterator++;

	movzx	r8d, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR fs+32, rdx

; 133  : 			if ((int)(i = _getb()) < 0) i = 0;

	test	r8d, r8d
	jns	SHORT $LN1@GetByte
$LN13@GetByte:
	xor	r8d, r8d
$LN1@GetByte:

; 134  : 			getbuf |= i << (8 - getlen);

	mov	ecx, 8
	sub	ecx, r9d

; 135  : 			getlen += 8;

	add	r9d, 8
	shl	r8d, cl
	mov	DWORD PTR fs+4, r9d
	or	r10d, r8d
	mov	DWORD PTR fs, r10d
	cmp	r9d, 8
	jbe	SHORT $LL3@GetByte
$LN2@GetByte:

; 136  : 		}
; 137  : 		i = getbuf;

	mov	eax, r10d

; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;

	add	r9d, -8					; fffffff8H
	shl	r10d, 8

; 140  : 		return (int)((i & 0xff00) >> 8);

	shr	eax, 8
	mov	DWORD PTR fs, r10d
	mov	DWORD PTR fs+4, r9d
	movzx	eax, al

; 141  : 	}

	ret	0
?GetByte@LZfs@@QEAAHXZ ENDP				; LZfs::GetByte
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?PutCode@LZfs@@QEAAXHI@Z
_TEXT	SEGMENT
this$dead$ = 48
l$ = 56
c$ = 64
?PutCode@LZfs@@QEAAXHI@Z PROC				; LZfs::PutCode, COMDAT

; 144  : 	{

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 145  : 		putbuf |= c >> putlen;

	mov	ecx, DWORD PTR fs+12
	mov	edi, edx
	mov	edx, DWORD PTR fs+8
	mov	eax, r8d
	mov	ebx, r8d
	shr	eax, cl

; 146  : 		if ((putlen += l) >= 8) {

	add	ecx, edi
	or	edx, eax
	mov	DWORD PTR fs+12, ecx
	mov	DWORD PTR fs+8, edx
	cmp	ecx, 8
	jb	SHORT $LN1@PutCode

; 147  : 			_putb(putbuf >> 8);

	shr	edx, 8
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	eax, DWORD PTR fs+12
	add	eax, -8					; fffffff8H
	mov	DWORD PTR fs+12, eax
	cmp	eax, 8
	jb	SHORT $LN2@PutCode

; 149  : 				_putb(putbuf);

	mov	edx, DWORD PTR fs+8
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 150  : 				codesize += 2;
; 151  : 				putlen -= 8;

	mov	eax, DWORD PTR fs+12
	add	DWORD PTR ?codesize@@3IA, 2		; codesize
	add	eax, -8					; fffffff8H

; 152  : 				putbuf = c << (l - putlen);

	sub	edi, eax
	mov	DWORD PTR fs+12, eax
	movzx	ecx, dil
	shl	ebx, cl
	mov	DWORD PTR fs+8, ebx

; 156  : 			}
; 157  : 		}
; 158  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@PutCode:

; 153  : 			} else {
; 154  : 				putbuf <<= 8;

	shl	DWORD PTR fs+8, 8

; 155  : 				codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize
$LN1@PutCode:

; 156  : 			}
; 157  : 		}
; 158  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?PutCode@LZfs@@QEAAXHI@Z ENDP				; LZfs::PutCode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?PutFlush@LZfs@@QEAAXXZ
_TEXT	SEGMENT
?PutFlush@LZfs@@QEAAXXZ PROC				; LZfs::PutFlush, COMDAT

; 160  : 	{

$LN8:
	sub	rsp, 40					; 00000028H

; 161  : 		if (putlen) {
; 162  : 			_putb(putbuf >> 8);

	mov	edx, DWORD PTR fs+8
	shr	edx, 8
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 163  : 			codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize

; 164  : 		}
; 165  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?PutFlush@LZfs@@QEAAXXZ ENDP				; LZfs::PutFlush
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
;	COMDAT ?InitTree@@YAXXZ
_TEXT	SEGMENT
?InitTree@@YAXXZ PROC					; InitTree, COMDAT

; 171  :     int  i;
; 172  : 	
; 173  :     for (i = N + 1; i <= N + 256; i++)	        rson[i] = NIL;        /* root */

	mov	rdx, 17592186048512			; 0000100000001000H
	lea	rax, OFFSET FLAT:?rson@@3PAHA+16388
	mov	ecx, 16
	npad	10
$LL18@InitTree:
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], rdx
	mov	QWORD PTR [rax-32], rdx
	mov	QWORD PTR [rax-24], rdx
	mov	QWORD PTR [rax-16], rdx
	mov	QWORD PTR [rax-8], rdx
	dec	rcx
	jne	SHORT $LL18@InitTree

; 174  :     for (i = 0; i < N; i++)						dad[i] = NIL;         /* node */

	lea	rax, OFFSET FLAT:?dad@@3PAHA		; dad
	mov	ecx, 256				; 00000100H
	npad	12
$LL17@InitTree:
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], rdx
	mov	QWORD PTR [rax-32], rdx
	mov	QWORD PTR [rax-24], rdx
	mov	QWORD PTR [rax-16], rdx
	mov	QWORD PTR [rax-8], rdx
	dec	rcx
	jne	SHORT $LL17@InitTree

; 175  : }

	ret	0
?InitTree@@YAXXZ ENDP					; InitTree
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
r$ = 24
?InsertNode@@YAXH@Z PROC				; InsertNode

; 178  : {

$LN36:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	push	r15

; 179  :     int				i, p, cmp;
; 180  :     u8			*key;
; 181  :     unsigned		c;
; 182  : 	
; 183  :     cmp = 1;
; 184  :     key = &text_buf[r];
; 185  :     p = N + 1 + key[0];
; 186  :     rson[r] = lson[r] = NIL;
; 187  :     match_length = 0;

	mov	r9d, DWORD PTR ?match_position@@3HA	; match_position
	lea	r15, OFFSET FLAT:__ImageBase
	movsxd	rsi, ecx
	lea	r14, QWORD PTR [rsi*4]
	lea	rbp, QWORD PTR ?text_buf@@3PAEA[r15]
	mov	r8d, 1
	add	rbp, rsi
	mov	DWORD PTR ?lson@@3PAHA[r14+r15], 4096	; 00001000H
	mov	DWORD PTR ?rson@@3PAHA[r14+r15], 4096	; 00001000H
	movzx	r10d, BYTE PTR [rbp]
	add	r10d, 4097				; 00001001H
	xor	edi, edi
	mov	DWORD PTR ?match_length@@3HA, edi	; match_length
	npad	3
$LL19@InsertNode:

; 188  :     for ( ; ; ) {
; 189  :         if (cmp >= 0) {
; 190  :             if (rson[p] != NIL)

	movsxd	rax, r10d
	test	r8d, r8d
	js	SHORT $LN17@InsertNode
	mov	ecx, DWORD PTR ?rson@@3PAHA[r15+rax*4]
	cmp	ecx, 4096				; 00001000H
	jne	SHORT $LN32@InsertNode

; 191  :                 p = rson[p];
; 192  :             else {
; 193  :                 rson[p] = r;

	movsxd	rax, r10d
	mov	DWORD PTR ?rson@@3PAHA[r15+rax*4], esi

; 194  :                 dad[r] = p;
; 195  :                 return;

	jmp	$LN34@InsertNode
$LN17@InsertNode:

; 196  :             }
; 197  :         } else {
; 198  :             if (lson[p] != NIL)

	mov	ecx, DWORD PTR ?lson@@3PAHA[r15+rax*4]
	cmp	ecx, 4096				; 00001000H
	je	$LN13@InsertNode
$LN32@InsertNode:

; 199  :                 p = lson[p];

	mov	r10d, ecx
	movsxd	rcx, ecx

; 203  :                 return;
; 204  :             }
; 205  :         }
; 206  :         for (i = 1; i < F; i++)

	lea	rbx, QWORD PTR ?text_buf@@3PAEA[r15]
	sub	rcx, rbp
	mov	r11, rbp
	mov	edx, 1
	add	rbx, rcx
	neg	r11
	lea	rax, QWORD PTR [rbp+1]
	npad	2
$LL11@InsertNode:

; 207  :             if ((cmp = key[i] - text_buf[p + i]) != 0)

	movzx	ecx, BYTE PTR [rbx+rax]
	movzx	r8d, BYTE PTR [rax]
	sub	r8d, ecx
	jne	SHORT $LN24@InsertNode

; 203  :                 return;
; 204  :             }
; 205  :         }
; 206  :         for (i = 1; i < F; i++)

	inc	rax
	inc	edx
	lea	rcx, QWORD PTR [r11+rax]
	cmp	rcx, 60					; 0000003cH
	jl	SHORT $LL11@InsertNode
$LN24@InsertNode:

; 208  :                 break;
; 209  : 			if (i > THRESHOLD) {

	cmp	edx, 2
	jle	$LL19@InsertNode

; 210  : 				if (i > match_length) {

	cmp	edx, edi
	jle	$LN33@InsertNode

; 211  : 					match_position = ((r - p) & (N - 1)) - 1;

	mov	r9d, esi

; 212  : 					if ((match_length = i) >= F)

	mov	edi, edx
	mov	DWORD PTR ?match_length@@3HA, edx	; match_length
	sub	r9d, r10d
	and	r9d, 4095				; 00000fffH
	dec	r9d
	mov	DWORD PTR ?match_position@@3HA, r9d	; match_position
	cmp	edx, 60					; 0000003cH
	jl	$LN31@InsertNode

; 222  :     dad[r]  = dad[p];

	movsxd	rax, r10d
	lea	rcx, QWORD PTR [rax*4]
	mov	eax, DWORD PTR ?dad@@3PAHA[rcx+r15]
	mov	DWORD PTR ?dad@@3PAHA[r14+r15], eax

; 223  :     lson[r] = lson[p];

	mov	eax, DWORD PTR ?lson@@3PAHA[rcx+r15]
	mov	DWORD PTR ?lson@@3PAHA[r14+r15], eax

; 224  :     rson[r] = rson[p];

	mov	eax, DWORD PTR ?rson@@3PAHA[rcx+r15]
	mov	DWORD PTR ?rson@@3PAHA[r14+r15], eax

; 225  :     dad[lson[p]] = r;

	movsxd	rax, DWORD PTR ?lson@@3PAHA[rcx+r15]
	mov	DWORD PTR ?dad@@3PAHA[r15+rax*4], esi

; 226  :     dad[rson[p]] = r;

	movsxd	rax, DWORD PTR ?rson@@3PAHA[rcx+r15]
	mov	DWORD PTR ?dad@@3PAHA[r15+rax*4], esi

; 227  :     if (rson[dad[p]] == p)

	movsxd	rax, DWORD PTR ?dad@@3PAHA[rcx+r15]
	cmp	DWORD PTR ?rson@@3PAHA[r15+rax*4], r10d
	jne	SHORT $LN2@InsertNode

; 228  :         rson[dad[p]] = r;

	mov	DWORD PTR ?rson@@3PAHA[r15+rax*4], esi

; 231  :     dad[p] = NIL; /* remove p */

	mov	DWORD PTR ?dad@@3PAHA[rcx+r15], 4096	; 00001000H
	jmp	SHORT $LN20@InsertNode
$LN33@InsertNode:

; 213  : 						break;
; 214  : 				}
; 215  : 				if (i == match_length) {

	jne	$LL19@InsertNode
$LN31@InsertNode:

; 216  : 					if ((c = ((r - p) & (N-1)) - 1) < (unsigned)match_position) {

	mov	eax, esi
	sub	eax, r10d
	and	eax, 4095				; 00000fffH
	dec	eax
	cmp	eax, r9d
	jae	$LL19@InsertNode

; 217  : 						match_position = c;

	mov	r9d, eax
	mov	DWORD PTR ?match_position@@3HA, eax	; match_position

; 218  : 					}
; 219  : 				}
; 220  : 			}
; 221  :     }

	jmp	$LL19@InsertNode
$LN2@InsertNode:

; 229  :     else
; 230  :         lson[dad[p]] = r;

	mov	DWORD PTR ?lson@@3PAHA[r15+rax*4], esi

; 231  :     dad[p] = NIL; /* remove p */

	mov	DWORD PTR ?dad@@3PAHA[rcx+r15], 4096	; 00001000H
	jmp	SHORT $LN20@InsertNode
$LN13@InsertNode:

; 200  :             else {
; 201  :                 lson[p] = r;

	movsxd	rax, r10d
	mov	DWORD PTR ?lson@@3PAHA[r15+rax*4], esi
$LN34@InsertNode:

; 202  :                 dad[r] = p;

	mov	DWORD PTR ?dad@@3PAHA[r14+r15], r10d
$LN20@InsertNode:

; 232  : }

	mov	rbx, QWORD PTR [rsp+24]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	pop	r15
	pop	r14
	ret	0
?InsertNode@@YAXH@Z ENDP				; InsertNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
p$ = 16
?DeleteNode@@YAXH@Z PROC				; DeleteNode

; 235  : {

$LN20:
	mov	QWORD PTR [rsp+24], rdi
	push	r14

; 236  :     int  q;
; 237  : 	
; 238  :     if (dad[p] == NIL)	return;	/* not registered */

	lea	r14, OFFSET FLAT:__ImageBase
	movsxd	rdi, ecx
	lea	r9, QWORD PTR ?dad@@3PAHA[r14]
	lea	rdx, QWORD PTR [rdi*4]
	add	r9, rdx
	cmp	DWORD PTR [r9], 4096			; 00001000H
	je	$LN12@DeleteNode

; 239  :     if (rson[p] == NIL)

	lea	r11, QWORD PTR ?rson@@3PAHA[r14]
	add	r11, rdx
	mov	eax, DWORD PTR [r11]
	cmp	eax, 4096				; 00001000H
	jne	SHORT $LN10@DeleteNode

; 240  : 		q = lson[p];

	mov	eax, DWORD PTR ?lson@@3PAHA[rdx+r14]

; 241  :     else 

	jmp	$LN7@DeleteNode
$LN10@DeleteNode:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi

; 242  : 	{
; 243  : 		if (lson[p] == NIL)

	lea	rsi, QWORD PTR ?lson@@3PAHA[r14]
	add	rsi, rdx
	movsxd	rbx, DWORD PTR [rsi]
	cmp	ebx, 4096				; 00001000H
	je	$LN18@DeleteNode

; 244  : 		{
; 245  : 			q = rson[p];
; 246  : 		}
; 247  : 		else 
; 248  : 		{
; 249  : 			q = lson[p];
; 250  : 			if (rson[q] != NIL) 

	lea	r10, QWORD PTR [rbx*4]
	lea	rcx, QWORD PTR ?rson@@3PAHA[r14]
	mov	rax, rbx
	add	rcx, r10
	cmp	DWORD PTR [rcx], 4096			; 00001000H
	je	SHORT $LN6@DeleteNode
$LL5@DeleteNode:

; 251  : 			{
; 252  : 				do { q = rson[q]; } while (rson[q] != NIL);

	movsxd	rax, DWORD PTR [rcx]
	lea	rcx, QWORD PTR ?rson@@3PAHA[r14]
	cmp	DWORD PTR [rcx+rax*4], 4096		; 00001000H
	lea	rcx, QWORD PTR [rcx+rax*4]
	jne	SHORT $LL5@DeleteNode

; 253  : 				
; 254  : 				rson[dad[q]]	= lson[q];

	lea	r10, QWORD PTR [rax*4]
	movsxd	rdx, DWORD PTR ?lson@@3PAHA[r10+r14]
	movsxd	r8, DWORD PTR ?dad@@3PAHA[r10+r14]

; 255  : 				dad[lson[q]]	= dad[q];
; 256  : 				lson[q]			= lson[p];

	mov	DWORD PTR ?lson@@3PAHA[r10+r14], ebx

; 257  : 				dad[lson[p]]	= q;

	movsxd	rcx, DWORD PTR [rsi]
	mov	DWORD PTR ?dad@@3PAHA[r14+rdx*4], r8d
	mov	DWORD PTR ?rson@@3PAHA[r14+r8*4], edx
	mov	DWORD PTR ?dad@@3PAHA[r14+rcx*4], eax
$LN6@DeleteNode:

; 258  : 			}
; 259  : 			rson[q]			= rson[p];

	mov	ecx, DWORD PTR [r11]
	mov	DWORD PTR ?rson@@3PAHA[r10+r14], ecx

; 260  : 			dad[rson[p]]	= q;

	movsxd	rcx, DWORD PTR [r11]
	mov	DWORD PTR ?dad@@3PAHA[r14+rcx*4], eax
$LN18@DeleteNode:
	mov	rbx, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+24]
$LN7@DeleteNode:

; 261  : 		}
; 262  : 	}
; 263  : 	dad[q] = dad[p];

	mov	ecx, DWORD PTR [r9]
	movsxd	rdx, eax
	mov	DWORD PTR ?dad@@3PAHA[r14+rdx*4], ecx

; 264  : 	if (rson[dad[p]] == p)

	movsxd	rcx, DWORD PTR [r9]
	cmp	DWORD PTR ?rson@@3PAHA[r14+rcx*4], edi
	jne	SHORT $LN2@DeleteNode

; 265  : 		rson[dad[p]] = q;

	mov	DWORD PTR ?rson@@3PAHA[r14+rcx*4], eax

; 268  : 	dad[p] = NIL;

	mov	DWORD PTR [r9], 4096			; 00001000H

; 269  : }

	mov	rdi, QWORD PTR [rsp+32]
	pop	r14
	ret	0
$LN2@DeleteNode:

; 266  : 	else
; 267  : 		lson[dad[p]] = q;

	mov	DWORD PTR ?lson@@3PAHA[r14+rcx*4], eax

; 268  : 	dad[p] = NIL;

	mov	DWORD PTR [r9], 4096			; 00001000H
$LN12@DeleteNode:

; 269  : }

	mov	rdi, QWORD PTR [rsp+32]
	pop	r14
	ret	0
?DeleteNode@@YAXH@Z ENDP				; DeleteNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
?StartHuff@@YAXXZ PROC					; StartHuff

; 373  : {

$LN23:
	mov	QWORD PTR [rsp+8], rdi
	movdqa	xmm2, XMMWORD PTR __xmm@00000003000000020000000100000000
	movdqa	xmm3, XMMWORD PTR __xmm@00000001000000010000000100000001
	movdqa	xmm4, XMMWORD PTR __xmm@00000273000002730000027300000273

; 374  :     int i, j;
; 375  : 	
; 376  :     for (i = 0; i < N_CHAR; i++) {

	xor	edx, edx
	lea	r10, OFFSET FLAT:__ImageBase
	xor	ecx, ecx
	npad	8
$LL5@StartHuff:

; 377  :         freq[i]		= 1;
; 378  :         son	[i]		= i + T;

	movd	xmm1, edx
	lea	eax, DWORD PTR [rdx+4]
	movdqa	xmm0, xmm4
	add	edx, 8
	movdqu	XMMWORD PTR ?freq@@3PAIA[rcx+r10], xmm3
	movdqu	XMMWORD PTR ?freq@@3PAIA[rcx+r10+16], xmm3
	pshufd	xmm1, xmm1, 0
	paddd	xmm1, xmm2
	lea	rcx, QWORD PTR [rcx+32]
	paddd	xmm0, xmm1

; 379  :         prnt[i + T] = i;

	movdqu	XMMWORD PTR ?prnt@@3PAHA[rcx+r10+2476], xmm1
	movdqu	XMMWORD PTR ?son@@3PAHA[rcx+r10-32], xmm0
	movd	xmm1, eax
	pshufd	xmm1, xmm1, 0
	paddd	xmm1, xmm2
	movdqa	xmm0, xmm1
	movdqu	XMMWORD PTR ?prnt@@3PAHA[rcx+r10+2492], xmm1
	paddd	xmm0, xmm4
	movdqu	XMMWORD PTR ?son@@3PAHA[rcx+r10-16], xmm0
	cmp	edx, 312				; 00000138H
	jl	SHORT $LL5@StartHuff

; 374  :     int i, j;
; 375  : 	
; 376  :     for (i = 0; i < N_CHAR; i++) {

	mov	r8d, 314				; 0000013aH
	cmp	edx, r8d
	jge	SHORT $LN3@StartHuff
	movsxd	rax, edx
	mov	ecx, r8d
	lea	rdi, QWORD PTR ?freq@@3PAIA[r10]
	lea	r9, QWORD PTR [rax*4]
	mov	eax, 1
	add	rdi, r9
	sub	ecx, edx
	rep stosd
	npad	12
$LL12@StartHuff:
	lea	eax, DWORD PTR [rdx+627]

; 379  :         prnt[i + T] = i;

	mov	DWORD PTR ?prnt@@3PAHA[r9+r10+2508], edx
	inc	edx
	mov	DWORD PTR ?son@@3PAHA[r9+r10], eax
	lea	r9, QWORD PTR [r9+4]
	cmp	edx, r8d
	jl	SHORT $LL12@StartHuff
$LN3@StartHuff:

; 380  :     }
; 381  :     i = 0; j = N_CHAR;

	xor	edi, edi

; 382  :     while (j <= R) {

	xor	ecx, ecx
	xor	edx, edx
	npad	9
$LL2@StartHuff:

; 383  :         freq[j]		= freq[i] + freq[i + 1];

	mov	eax, DWORD PTR ?freq@@3PAIA[rcx+r10+4]

; 384  :         son[j]		= i;
; 385  :         prnt[i]		= prnt[i + 1] = j;

	mov	DWORD PTR ?prnt@@3PAHA[rcx+r10+4], r8d
	mov	DWORD PTR ?prnt@@3PAHA[rcx+r10], r8d
	add	eax, DWORD PTR ?freq@@3PAIA[rcx+r10]
	mov	DWORD PTR ?son@@3PAHA[rdx+r10+1256], edi

; 386  :         i += 2; j++;

	inc	r8d
	add	edi, 2
	mov	DWORD PTR ?freq@@3PAIA[rdx+r10+1256], eax
	lea	rdx, QWORD PTR [rdx+4]
	lea	rcx, QWORD PTR [rcx+8]
	cmp	r8d, 626				; 00000272H
	jle	SHORT $LL2@StartHuff

; 387  :     }
; 388  :     freq[T] = 0xffff;
; 389  :     prnt[R] = 0;
; 390  : }

	mov	rdi, QWORD PTR [rsp+8]
	mov	DWORD PTR ?freq@@3PAIA+2508, 65535	; 0000ffffH
	mov	DWORD PTR ?prnt@@3PAHA+2504, 0
	ret	0
?StartHuff@@YAXXZ ENDP					; StartHuff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
i$1$ = 96
tv622 = 104
tv626 = 112
?reconst@@YAXXZ PROC					; reconst

; 395  : {

$LN35:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 396  :     int			i, j, k;
; 397  :     unsigned	f, l;
; 398  : 	
; 399  :     /* collect leaf nodes in the first half of the table */
; 400  :     /* and replace the freq by (freq + 1) / 2. */
; 401  :     j = 0;
; 402  :     for (i = 0; i < T; i++) {

	xor	r14d, r14d
	mov	r9d, 627				; 00000273H
	lea	r12, OFFSET FLAT:?son@@3PAHA		; son
	mov	QWORD PTR tv626[rsp], r14
	mov	ecx, r14d
	mov	edx, r14d
	lea	r10, OFFSET FLAT:?freq@@3PAIA		; freq
	npad	10
$LL15@reconst:

; 403  :         if (son[i] >= T) {

	mov	r8d, DWORD PTR [rcx+r12]
	cmp	r8d, 627				; 00000273H
	jl	SHORT $LN14@reconst

; 404  :             freq[j] = (freq[i] + 1) / 2;

	mov	eax, DWORD PTR [rcx+r10]

; 405  :             son[j] = son[i];

	mov	DWORD PTR [rdx+r12], r8d
	inc	eax
	shr	eax, 1
	add	rdx, 4
	mov	DWORD PTR [rdx+r10-4], eax
$LN14@reconst:

; 396  :     int			i, j, k;
; 397  :     unsigned	f, l;
; 398  : 	
; 399  :     /* collect leaf nodes in the first half of the table */
; 400  :     /* and replace the freq by (freq + 1) / 2. */
; 401  :     j = 0;
; 402  :     for (i = 0; i < T; i++) {

	add	rcx, 4
	dec	r9
	jne	SHORT $LL15@reconst

; 406  :             j++;
; 407  :         }
; 408  :     }
; 409  :     /* begin constructing tree by connecting sons */
; 410  :     for (i = 0, j = N_CHAR; j < T; i += 2, j++) {

	mov	edx, 314				; 0000013aH
	mov	DWORD PTR i$1$[rsp], r14d
	mov	r14, r10
	mov	QWORD PTR tv622[rsp], rdx
	mov	r13d, edx
$LL11@reconst:

; 411  :         k = i + 1;
; 412  :         f = freq[j] = freq[i] + freq[k];

	mov	r15d, DWORD PTR [r14+4]

; 413  :         for (k = j - 1; f < freq[k]; k--);

	lea	ecx, DWORD PTR [rdx-1]
	lea	rbx, QWORD PTR [r13-1]
	add	r15d, DWORD PTR [r14]
	mov	DWORD PTR [r10+r13*4], r15d
	cmp	r15d, DWORD PTR [r10+r13*4-4]
	jae	SHORT $LN6@reconst
	npad	7
$LL8@reconst:
	dec	rbx
	dec	ecx
	cmp	r15d, DWORD PTR [r10+rbx*4]
	jb	SHORT $LL8@reconst
$LN6@reconst:

; 414  :         k++;

	inc	ecx

; 415  :         l = (j - k) * sizeof(unsigned);

	mov	ebp, edx

; 416  :         memmove	(&freq[k + 1], &freq[k], l);

	movsxd	rax, ecx
	sub	ebp, ecx
	lea	rsi, QWORD PTR [rax*4]
	lea	eax, DWORD PTR [rcx+1]
	shl	ebp, 2
	movsxd	rcx, eax
	lea	rdx, QWORD PTR [rsi+r10]
	mov	r8d, ebp
	lea	rdi, QWORD PTR [rcx*4]
	lea	rcx, QWORD PTR [rdi+r10]
	call	QWORD PTR __imp_memmove

; 417  :         freq[k] = f;

	lea	rax, OFFSET FLAT:?freq@@3PAIA		; freq

; 418  :         memmove	(&son[k + 1], &son[k], l);

	lea	rdx, QWORD PTR [rsi+r12]
	lea	rcx, QWORD PTR [rdi+r12]
	mov	r8d, ebp
	mov	DWORD PTR [rax+rbx*4+4], r15d
	call	QWORD PTR __imp_memmove

; 419  :         son[k] = i;

	mov	r8d, DWORD PTR i$1$[rsp]
	mov	rdx, QWORD PTR tv622[rsp]
	inc	edx
	mov	DWORD PTR [r12+rbx*4+4], r8d
	add	r8d, 2
	inc	r13
	add	r14, 8
	lea	r10, OFFSET FLAT:?freq@@3PAIA		; freq
	mov	DWORD PTR i$1$[rsp], r8d
	mov	QWORD PTR tv622[rsp], rdx
	cmp	r13, 627				; 00000273H
	jl	$LL11@reconst

; 420  :     }
; 421  :     /* connect prnt */
; 422  :     for (i = 0; i < T; i++) {

	mov	r14, QWORD PTR tv626[rsp]
	lea	rcx, OFFSET FLAT:?prnt@@3PAHA		; prnt
$LL5@reconst:

; 423  :         if ((k = son[i]) >= T) {

	movsxd	rax, DWORD PTR [r12]

; 424  :             prnt[k] = i;

	mov	DWORD PTR [rcx+rax*4], r14d
	cmp	eax, 627				; 00000273H
	jge	SHORT $LN4@reconst

; 425  :         } else {
; 426  :             prnt[k] = prnt[k + 1] = i;

	mov	DWORD PTR [rcx+rax*4+4], r14d
$LN4@reconst:

; 420  :     }
; 421  :     /* connect prnt */
; 422  :     for (i = 0; i < T; i++) {

	inc	r14d
	add	r12, 4
	cmp	r14d, 627				; 00000273H
	jl	SHORT $LL5@reconst

; 427  :         }
; 428  :     }
; 429  : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?reconst@@YAXXZ ENDP					; reconst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
c$ = 48
?update@@YAXH@Z PROC					; update

; 434  : {

$LN19:
	push	rbx
	sub	rsp, 32					; 00000020H

; 435  :     int i, j, k, l;
; 436  : 	
; 437  :     if (freq[R] == MAX_FREQ) {

	cmp	DWORD PTR ?freq@@3PAIA+2504, 16384	; 00004000H
	movsxd	rbx, ecx
	jne	SHORT $LN9@update

; 438  :         reconst();

	call	?reconst@@YAXXZ				; reconst
$LN9@update:

; 439  :     }
; 440  :     c = prnt[c + T];

	mov	rax, rbx
	lea	rbx, OFFSET FLAT:__ImageBase
	mov	edx, DWORD PTR ?prnt@@3PAHA[rbx+rax*4+2508]
	npad	5
$LL8@update:

; 441  :     do {
; 442  :         k = ++freq[c];

	movsxd	rax, edx

; 443  : 		
; 444  :         /* if the order is disturbed, exchange nodes */
; 445  :         if ((unsigned)k > freq[l = c + 1]) {

	lea	ecx, DWORD PTR [rdx+1]
	lea	r10, QWORD PTR [rax*4]
	movsxd	rax, ecx
	inc	DWORD PTR ?freq@@3PAIA[r10+rbx]
	mov	r8d, DWORD PTR ?freq@@3PAIA[r10+rbx]
	lea	rax, QWORD PTR ?freq@@3PAIA[rax*4]
	add	rax, rbx
	cmp	r8d, DWORD PTR [rax]
	jbe	$LN7@update
$LL4@update:

; 446  :             while ((unsigned)k > freq[++l]);

	lea	rax, QWORD PTR [rax+4]
	inc	ecx
	cmp	r8d, DWORD PTR [rax]
	ja	SHORT $LL4@update

; 447  :             l--;
; 448  :             freq[c] = freq[l];
; 449  :             freq[l] = k;
; 450  : 			
; 451  :             i = son[c];

	movsxd	r9, DWORD PTR ?son@@3PAHA[r10+rbx]
	dec	ecx
	movsxd	rax, ecx

; 452  :             prnt[i] = l;

	mov	DWORD PTR ?prnt@@3PAHA[rbx+r9*4], ecx
	lea	r11, QWORD PTR [rax*4]
	mov	eax, DWORD PTR ?freq@@3PAIA[r11+rbx]
	mov	DWORD PTR ?freq@@3PAIA[r10+rbx], eax
	mov	DWORD PTR ?freq@@3PAIA[r11+rbx], r8d

; 453  :             if (i < T) prnt[i + 1] = l;

	cmp	r9d, 627				; 00000273H
	jge	SHORT $LN2@update
	mov	DWORD PTR ?prnt@@3PAHA[rbx+r9*4+4], ecx
$LN2@update:

; 454  : 			
; 455  :             j = son[l];

	movsxd	r8, DWORD PTR ?son@@3PAHA[r11+rbx]

; 456  :             son[l] = i;

	mov	DWORD PTR ?son@@3PAHA[r11+rbx], r9d

; 457  : 			
; 458  :             prnt[j] = c;

	mov	DWORD PTR ?prnt@@3PAHA[rbx+r8*4], edx

; 459  :             if (j < T) prnt[j + 1] = c;

	cmp	r8d, 627				; 00000273H
	jge	SHORT $LN1@update
	mov	DWORD PTR ?prnt@@3PAHA[rbx+r8*4+4], edx
$LN1@update:

; 460  :             son[c] = j;

	mov	DWORD PTR ?son@@3PAHA[r10+rbx], r8d

; 461  : 			
; 462  :             c = l;

	mov	edx, ecx
$LN7@update:

; 463  :         }
; 464  :     } while ((c = prnt[c]) != 0); /* repeat up to root */

	movsxd	rax, edx
	mov	edx, DWORD PTR ?prnt@@3PAHA[rbx+rax*4]
	test	edx, edx
	jne	$LL8@update

; 465  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?update@@YAXH@Z ENDP					; update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
c$ = 48
?EncodeChar@@YAXI@Z PROC				; EncodeChar

; 468  : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 469  :     unsigned i;
; 470  :     int j, k;
; 471  : 	
; 472  :     i = 0;
; 473  :     j = 0;
; 474  :     k = prnt[c + T];

	lea	eax, DWORD PTR [rcx+627]
	mov	esi, ecx
	lea	rcx, OFFSET FLAT:?prnt@@3PAHA		; prnt
	mov	eax, DWORD PTR [rcx+rax*4]
	xor	ebx, ebx
	mov	edi, ebx
$LL4@EncodeChar:

; 475  : 	
; 476  :     /* travel from leaf to root */
; 477  :     do {
; 478  :         i >>= 1;

	shr	ebx, 1

; 479  : 		
; 480  :         /* if node's address is odd-numbered, choose bigger brother node */
; 481  :         if (k & 1) i += 0x8000;

	test	al, 1
	je	SHORT $LN1@EncodeChar
	add	ebx, 32768				; 00008000H
$LN1@EncodeChar:

; 482  : 		
; 483  :         j++;
; 484  : 		k = prnt[k];

	cdqe
	inc	edi
	mov	eax, DWORD PTR [rcx+rax*4]

; 485  :     } while (k != R);

	cmp	eax, 626				; 00000272H
	jne	SHORT $LL4@EncodeChar

; 486  :     fs.PutCode(j, i);

	mov	r8d, ebx
	mov	edx, edi
	call	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode

; 487  :     code = i;
; 488  :     len = j;
; 489  :     update(c);

	mov	ecx, esi
	mov	DWORD PTR ?code@@3IA, ebx		; code
	mov	DWORD PTR ?len@@3IA, edi		; len

; 490  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 487  :     code = i;
; 488  :     len = j;
; 489  :     update(c);

	jmp	?update@@YAXH@Z				; update
?EncodeChar@@YAXI@Z ENDP				; EncodeChar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
c$dead$ = 48
?EncodePosition@@YAXI@Z PROC				; EncodePosition

; 493  : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, DWORD PTR ?match_position@@3HA	; match_position

; 494  :     unsigned i;
; 495  : 	
; 496  :     /* output upper 6 bits by table lookup */
; 497  :     i = c >> 6;
; 498  :     fs.PutCode(p_len[i], (unsigned)p_code[i] << 8);

	lea	rax, OFFSET FLAT:__ImageBase
	mov	ecx, ebx
	shr	ecx, 6
	movzx	r8d, BYTE PTR ?p_code@@3PAEA[rcx+rax]
	movzx	edx, BYTE PTR ?p_len@@3PAEA[rcx+rax]
	shl	r8d, 8
	call	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode

; 499  : 	
; 500  :     /* output lower 6 bits verbatim */
; 501  :     fs.PutCode(6, (c & 0x3f) << 10);

	and	ebx, 63					; 0000003fH
	mov	edx, 6
	shl	ebx, 10
	mov	r8d, ebx

; 502  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 499  : 	
; 500  :     /* output lower 6 bits verbatim */
; 501  :     fs.PutCode(6, (c & 0x3f) << 10);

	jmp	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode
?EncodePosition@@YAXI@Z ENDP				; EncodePosition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
?DecodeChar@@YAHXZ PROC					; DecodeChar

; 505  : {

$LN23:
	push	rbx
	sub	rsp, 32					; 00000020H

; 506  :     unsigned c;
; 507  : 	
; 508  :     c = son[R];

	mov	ebx, DWORD PTR ?son@@3PAHA+2504

; 509  : 	
; 510  :     /* travel from root to leaf, */
; 511  :     /* choosing the smaller child node (son[]) if the read bit is 0, */
; 512  :     /* the bigger (son[]+1} if 1 */
; 513  :     while (c < T) {

	cmp	ebx, 627				; 00000273H
	jae	$LN1@DecodeChar
	mov	r10, QWORD PTR fs+24
	mov	rdx, QWORD PTR fs+32
	mov	r8d, DWORD PTR fs+4
	mov	r9d, DWORD PTR fs
	lea	r11, OFFSET FLAT:?son@@3PAHA		; son
	npad	5
$LL2@DecodeChar:

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {
; 70   : 			u32	out_size= u32(out_end-out_start);
; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);
; 72   : 			out_iterator= out_start+out_size;
; 73   : 			out_end		= out_iterator+1024;
; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);
; 76   : 	}
; 77   : 	
; 78   : 	LZfs() {
; 79   : 		in_start	= in_end	= in_iterator = 0;
; 80   : 		out_start	= out_end	= out_iterator = 0;
; 81   : 	}
; 82   : 	
; 83   : 	IC void		Init_Input(u8* _start, u8* _end) {
; 84   : 		// input
; 85   : 		in_start	= _start;
; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;
; 88   : 		
; 89   : 		// bitwise input/output
; 90   : 		getbuf = getlen = putbuf = putlen = 0;
; 91   : 	}
; 92   : 	IC void		Init_Output(int _rsize) {
; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);
; 95   : 		out_end		= out_start + _rsize;
; 96   : 		out_iterator= out_start;
; 97   : 	}
; 98   : 	IC u32		InputSize	() {
; 99   : 		return u32(in_end-in_start);
; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);
; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {

	cmp	r8d, 8
	ja	SHORT $LN6@DecodeChar
$LL7@DecodeChar:

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	rdx, r10
	je	SHORT $LN21@DecodeChar

; 66   : 		return *in_iterator++;

	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR fs+32, rdx

; 118  : 			if ((int)(i = _getb()) < 0) i = 0;

	test	eax, eax
	jns	SHORT $LN5@DecodeChar
$LN21@DecodeChar:
	xor	eax, eax
$LN5@DecodeChar:

; 119  : 			getbuf |= i << (8 - getlen);

	mov	ecx, 8
	sub	ecx, r8d

; 120  : 			getlen += 8;

	add	r8d, 8
	shl	eax, cl
	mov	DWORD PTR fs+4, r8d
	or	r9d, eax
	mov	DWORD PTR fs, r9d
	cmp	r8d, 8
	jbe	SHORT $LL7@DecodeChar
$LN6@DecodeChar:

; 121  : 		}
; 122  : 		i = getbuf;

	mov	eax, r9d

; 124  : 		getlen--;

	dec	r8d
	add	r9d, r9d

; 515  :         c = son[c];

	shr	eax, 15

; 123  : 		getbuf <<= 1;

	mov	DWORD PTR fs, r9d

; 124  : 		getlen--;

	mov	DWORD PTR fs+4, r8d

; 125  : 		return (int)((i & 0x8000) >> 15);

	and	eax, 1

; 514  :         c += fs.GetBit();

	add	eax, ebx

; 515  :         c = son[c];

	mov	ebx, DWORD PTR [r11+rax*4]
	cmp	ebx, 627				; 00000273H
	jb	SHORT $LL2@DecodeChar
$LN1@DecodeChar:

; 516  :     }
; 517  :     c -= T;

	add	ebx, -627				; fffffd8dH

; 518  :     update(c);

	mov	ecx, ebx
	call	?update@@YAXH@Z				; update

; 519  :     return (int)c;

	mov	eax, ebx

; 520  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?DecodeChar@@YAHXZ ENDP					; DecodeChar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
?DecodePosition@@YAHXZ PROC				; DecodePosition

; 523  : {

$LN24:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 524  :     unsigned i, j, c;
; 525  : 	
; 526  :     /* recover upper 6 bits from table */
; 527  :     i = fs.GetByte();

	call	?GetByte@LZfs@@QEAAHXZ			; LZfs::GetByte
	mov	r11d, eax

; 528  :     c = (unsigned)d_code[i] << 6;

	lea	rax, OFFSET FLAT:__ImageBase
	movzx	edi, BYTE PTR ?d_code@@3PAEA[r11+rax]

; 529  :     j = d_len[i];

	movzx	ebx, BYTE PTR ?d_len@@3PAEA[r11+rax]
	shl	edi, 6

; 530  : 	
; 531  :     /* read lower 6 bits verbatim */
; 532  :     j -= 2;

	sub	ebx, 2

; 533  :     while (j--) {

	je	$LN16@DecodePosi
	mov	r10, QWORD PTR fs+24
	mov	rdx, QWORD PTR fs+32
	mov	r8d, DWORD PTR fs+4
	mov	r9d, DWORD PTR fs
$LL2@DecodePosi:
	dec	ebx

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {
; 70   : 			u32	out_size= u32(out_end-out_start);
; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);
; 72   : 			out_iterator= out_start+out_size;
; 73   : 			out_end		= out_iterator+1024;
; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);
; 76   : 	}
; 77   : 	
; 78   : 	LZfs() {
; 79   : 		in_start	= in_end	= in_iterator = 0;
; 80   : 		out_start	= out_end	= out_iterator = 0;
; 81   : 	}
; 82   : 	
; 83   : 	IC void		Init_Input(u8* _start, u8* _end) {
; 84   : 		// input
; 85   : 		in_start	= _start;
; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;
; 88   : 		
; 89   : 		// bitwise input/output
; 90   : 		getbuf = getlen = putbuf = putlen = 0;
; 91   : 	}
; 92   : 	IC void		Init_Output(int _rsize) {
; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);
; 95   : 		out_end		= out_start + _rsize;
; 96   : 		out_iterator= out_start;
; 97   : 	}
; 98   : 	IC u32		InputSize	() {
; 99   : 		return u32(in_end-in_start);
; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);
; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {

	cmp	r8d, 8
	ja	SHORT $LN6@DecodePosi
	npad	5
$LL7@DecodePosi:

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	rdx, r10
	je	SHORT $LN22@DecodePosi

; 66   : 		return *in_iterator++;

	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR fs+32, rdx

; 118  : 			if ((int)(i = _getb()) < 0) i = 0;

	test	eax, eax
	jns	SHORT $LN5@DecodePosi
$LN22@DecodePosi:
	xor	eax, eax
$LN5@DecodePosi:

; 119  : 			getbuf |= i << (8 - getlen);

	mov	ecx, 8
	sub	ecx, r8d

; 120  : 			getlen += 8;

	add	r8d, 8
	shl	eax, cl
	mov	DWORD PTR fs+4, r8d
	or	r9d, eax
	mov	DWORD PTR fs, r9d
	cmp	r8d, 8
	jbe	SHORT $LL7@DecodePosi
$LN6@DecodePosi:

; 121  : 		}
; 122  : 		i = getbuf;

	mov	eax, r9d

; 124  : 		getlen--;

	dec	r8d
	add	r9d, r9d

; 534  :         i = (i << 1) + fs.GetBit();

	shr	eax, 15

; 123  : 		getbuf <<= 1;

	mov	DWORD PTR fs, r9d

; 124  : 		getlen--;

	mov	DWORD PTR fs+4, r8d

; 125  : 		return (int)((i & 0x8000) >> 15);

	and	eax, 1

; 534  :         i = (i << 1) + fs.GetBit();

	lea	r11d, DWORD PTR [rax+r11*2]
	test	ebx, ebx
	jne	SHORT $LL2@DecodePosi
$LN16@DecodePosi:

; 535  :     }
; 536  :     return (int)(c | (i & 0x3f));
; 537  : }

	mov	rbx, QWORD PTR [rsp+48]
	and	r11d, 63				; 0000003fH
	or	r11d, edi
	mov	eax, r11d
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?DecodePosition@@YAHXZ ENDP				; DecodePosition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
fs$24$ = 96
len$1$ = 104
last_match_length$1$ = 112
?Encode@@YAXXZ PROC					; Encode

; 541  : {

$LN176:
	push	rbx
	sub	rsp, 80					; 00000050H

; 99   : 		return u32(in_end-in_start);

	mov	eax, DWORD PTR fs+24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 110  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 99   : 		return u32(in_end-in_start);

	sub	eax, DWORD PTR fs+16

; 76   : 	}
; 77   : 	
; 78   : 	LZfs() {
; 79   : 		in_start	= in_end	= in_iterator = 0;
; 80   : 		out_start	= out_end	= out_iterator = 0;
; 81   : 	}
; 82   : 	
; 83   : 	IC void		Init_Input(u8* _start, u8* _end) {
; 84   : 		// input
; 85   : 		in_start	= _start;
; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;
; 88   : 		
; 89   : 		// bitwise input/output
; 90   : 		getbuf = getlen = putbuf = putlen = 0;
; 91   : 	}
; 92   : 	IC void		Init_Output(int _rsize) {
; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);

	movsxd	rbx, eax

; 542  :     int  i, c, len, r, s, last_match_length;
; 543  : 	
; 544  :     textsize = fs.InputSize();

	mov	DWORD PTR ?textsize@@3IA, eax		; textsize
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 110  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	mov	rdx, rbx
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 546  : 	fs._putb((textsize & 0xff));

	movzx	edx, BYTE PTR ?textsize@@3IA

; 95   : 		out_end		= out_start + _rsize;

	lea	rcx, QWORD PTR [rbx+rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 110  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 96   : 		out_iterator= out_start;

	mov	QWORD PTR fs+56, rax
	mov	QWORD PTR fs+48, rcx

; 546  : 	fs._putb((textsize & 0xff));

	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 547  : 	fs._putb((textsize & 0xff00) >> 8);

	movzx	edx, BYTE PTR ?textsize@@3IA+1
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 548  : 	fs._putb((textsize & 0xff0000L) >> 16);

	movzx	edx, BYTE PTR ?textsize@@3IA+2
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 549  : 	fs._putb((textsize & 0xff000000L) >> 24);

	movzx	edx, BYTE PTR ?textsize@@3IA+3
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 550  :     if (textsize == 0)

	cmp	DWORD PTR ?textsize@@3IA, 0		; textsize
	je	$LN24@Encode

; 551  :         return;
; 552  :     textsize = 0;           /* rewind and re-read */
; 553  :     StartHuff();

	mov	QWORD PTR [rsp+120], rbp
	mov	QWORD PTR [rsp+72], rsi
	mov	QWORD PTR [rsp+64], rdi
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], r13
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15
	call	?StartHuff@@YAXXZ			; StartHuff

; 164  : 		}
; 165  : 	}
; 166  : };
; 167  : static LZfs fs;
; 168  : //************************** Internal FS
; 169  : IC void InitTree(void)  /* initialize trees */
; 170  : {
; 171  :     int  i;
; 172  : 	
; 173  :     for (i = N + 1; i <= N + 256; i++)	        rson[i] = NIL;        /* root */

	mov	r11, 17592186048512			; 0000100000001000H
	lea	rax, OFFSET FLAT:?rson@@3PAHA+16388
	mov	ecx, 16
	npad	2
$LL169@Encode:
	mov	QWORD PTR [rax], r11
	mov	QWORD PTR [rax+8], r11
	mov	QWORD PTR [rax+16], r11
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r11
	mov	QWORD PTR [rax-32], r11
	mov	QWORD PTR [rax-24], r11
	mov	QWORD PTR [rax-16], r11
	mov	QWORD PTR [rax-8], r11
	dec	rcx
	jne	SHORT $LL169@Encode

; 174  :     for (i = 0; i < N; i++)						dad[i] = NIL;         /* node */

	lea	rax, OFFSET FLAT:?dad@@3PAHA		; dad
	mov	ecx, 256				; 00000100H
	npad	12
$LL168@Encode:
	mov	QWORD PTR [rax], r11
	mov	QWORD PTR [rax+8], r11
	mov	QWORD PTR [rax+16], r11
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r11
	mov	QWORD PTR [rax-32], r11
	mov	QWORD PTR [rax-24], r11
	mov	QWORD PTR [rax-16], r11
	mov	QWORD PTR [rax-8], r11
	dec	rcx
	jne	SHORT $LL168@Encode

; 554  :     InitTree();
; 555  :     s = 0;

	lea	r15, OFFSET FLAT:?text_buf@@3PAEA	; text_buf
	xor	esi, esi

; 556  :     r = N - F;
; 557  :     for (i = s; i < r; i++)
; 558  :         text_buf[i] = 0x20;

	mov	rdx, 2314885530818453536		; 2020202020202020H
	mov	rax, r15
	mov	r14d, 4036				; 00000fc4H
	lea	ecx, QWORD PTR [rsi+63]
	npad	9
$LL167@Encode:
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], rdx
	mov	QWORD PTR [rax-32], rdx
	mov	QWORD PTR [rax-24], rdx
	mov	QWORD PTR [rax-16], rdx
	mov	QWORD PTR [rax-8], rdx
	dec	rcx
	jne	SHORT $LL167@Encode

; 559  :     for (len = 0; len < F && (c = fs._getb()) != EOF; len++)

	mov	r8, QWORD PTR fs+24
	mov	DWORD PTR [rax], edx
	mov	rax, QWORD PTR fs+32
	xor	r13d, r13d
	npad	5
$LL19@Encode:

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	rax, r8
	je	SHORT $LN165@Encode

; 66   : 		return *in_iterator++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax

; 559  :     for (len = 0; len < F && (c = fs._getb()) != EOF; len++)

	cmp	edx, -1
	je	SHORT $LN165@Encode

; 560  :         text_buf[r + len] = (unsigned char)c;

	mov	BYTE PTR [rcx+r15+4036], dl
	inc	rcx
	inc	r13d
	cmp	rcx, 60					; 0000003cH
	jl	SHORT $LL19@Encode
$LN165@Encode:
	mov	DWORD PTR len$1$[rsp], r13d

; 561  :     textsize = len;

	mov	DWORD PTR ?textsize@@3IA, r13d		; textsize
	mov	ebx, 4035				; 00000fc3H
	npad	4
$LL16@Encode:

; 562  :     for (i = 1; i <= F; i++)
; 563  :         InsertNode(r - i);

	mov	ecx, ebx
	call	?InsertNode@@YAXH@Z			; InsertNode
	dec	ebx
	cmp	ebx, 3976				; 00000f88H
	jge	SHORT $LL16@Encode

; 564  :     InsertNode(r);

	mov	ecx, r14d
	call	?InsertNode@@YAXH@Z			; InsertNode
	mov	rdi, QWORD PTR fs+56
	mov	ebp, DWORD PTR fs+12
	mov	ebx, DWORD PTR fs+8
	lea	rdx, OFFSET FLAT:__ImageBase
$LL13@Encode:

; 565  :     do {
; 566  :         if (match_length > len)

	mov	eax, DWORD PTR ?match_length@@3HA	; match_length
	cmp	eax, r13d
	cmovg	eax, r13d
	mov	DWORD PTR ?match_length@@3HA, eax	; match_length

; 567  :             match_length = len;
; 568  :         if (match_length <= THRESHOLD) {

	cmp	eax, 2
	jg	$LN9@Encode

; 569  :             match_length = 1;
; 570  : 			// textsize==56158    - FATAL :(
; 571  :             EncodeChar(text_buf[r]);

	movsxd	rax, r14d
	mov	DWORD PTR ?match_length@@3HA, 1		; match_length
	movzx	r13d, BYTE PTR [rax+r15]

; 175  : }
; 176  : 
; 177  : void InsertNode(int r)  /* insert to tree */
; 178  : {
; 179  :     int				i, p, cmp;
; 180  :     u8			*key;
; 181  :     unsigned		c;
; 182  : 	
; 183  :     cmp = 1;
; 184  :     key = &text_buf[r];
; 185  :     p = N + 1 + key[0];
; 186  :     rson[r] = lson[r] = NIL;
; 187  :     match_length = 0;
; 188  :     for ( ; ; ) {
; 189  :         if (cmp >= 0) {
; 190  :             if (rson[p] != NIL)
; 191  :                 p = rson[p];
; 192  :             else {
; 193  :                 rson[p] = r;
; 194  :                 dad[r] = p;
; 195  :                 return;
; 196  :             }
; 197  :         } else {
; 198  :             if (lson[p] != NIL)
; 199  :                 p = lson[p];
; 200  :             else {
; 201  :                 lson[p] = r;
; 202  :                 dad[r] = p;
; 203  :                 return;
; 204  :             }
; 205  :         }
; 206  :         for (i = 1; i < F; i++)
; 207  :             if ((cmp = key[i] - text_buf[p + i]) != 0)
; 208  :                 break;
; 209  : 			if (i > THRESHOLD) {
; 210  : 				if (i > match_length) {
; 211  : 					match_position = ((r - p) & (N - 1)) - 1;
; 212  : 					if ((match_length = i) >= F)
; 213  : 						break;
; 214  : 				}
; 215  : 				if (i == match_length) {
; 216  : 					if ((c = ((r - p) & (N-1)) - 1) < (unsigned)match_position) {
; 217  : 						match_position = c;
; 218  : 					}
; 219  : 				}
; 220  : 			}
; 221  :     }
; 222  :     dad[r]  = dad[p];
; 223  :     lson[r] = lson[p];
; 224  :     rson[r] = rson[p];
; 225  :     dad[lson[p]] = r;
; 226  :     dad[rson[p]] = r;
; 227  :     if (rson[dad[p]] == p)
; 228  :         rson[dad[p]] = r;
; 229  :     else
; 230  :         lson[dad[p]] = r;
; 231  :     dad[p] = NIL; /* remove p */
; 232  : }
; 233  : 
; 234  : void DeleteNode(int p)  /* remove from tree */
; 235  : {
; 236  :     int  q;
; 237  : 	
; 238  :     if (dad[p] == NIL)	return;	/* not registered */
; 239  :     if (rson[p] == NIL)
; 240  : 		q = lson[p];
; 241  :     else 
; 242  : 	{
; 243  : 		if (lson[p] == NIL)
; 244  : 		{
; 245  : 			q = rson[p];
; 246  : 		}
; 247  : 		else 
; 248  : 		{
; 249  : 			q = lson[p];
; 250  : 			if (rson[q] != NIL) 
; 251  : 			{
; 252  : 				do { q = rson[q]; } while (rson[q] != NIL);
; 253  : 				
; 254  : 				rson[dad[q]]	= lson[q];
; 255  : 				dad[lson[q]]	= dad[q];
; 256  : 				lson[q]			= lson[p];
; 257  : 				dad[lson[p]]	= q;
; 258  : 			}
; 259  : 			rson[q]			= rson[p];
; 260  : 			dad[rson[p]]	= q;
; 261  : 		}
; 262  : 	}
; 263  : 	dad[q] = dad[p];
; 264  : 	if (rson[dad[p]] == p)
; 265  : 		rson[dad[p]] = q;
; 266  : 	else
; 267  : 		lson[dad[p]] = q;
; 268  : 	dad[p] = NIL;
; 269  : }
; 270  : 
; 271  : /* Huffman coding */
; 272  : 
; 273  : 
; 274  : /* table for encoding and decoding the upper 6 bits of position */
; 275  : /* for encoding */
; 276  : u8 p_len[64] = {
; 277  :     0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
; 278  : 	0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
; 279  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 280  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 281  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 282  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 283  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 284  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
; 285  : };
; 286  : 
; 287  : u8 p_code[64] = {
; 288  :     0x00, 0x20, 0x30, 0x40, 0x50, 0x58, 0x60, 0x68,
; 289  : 	0x70, 0x78, 0x80, 0x88, 0x90, 0x94, 0x98, 0x9C,
; 290  : 	0xA0, 0xA4, 0xA8, 0xAC, 0xB0, 0xB4, 0xB8, 0xBC,
; 291  : 	0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,
; 292  : 	0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,
; 293  : 	0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE,
; 294  : 	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
; 295  : 	0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
; 296  : };
; 297  : 
; 298  : /* for decoding */
; 299  : u8 d_code[256] = {
; 300  :     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 301  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 302  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 303  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 304  : 	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
; 305  : 	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
; 306  : 	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
; 307  : 	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
; 308  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 309  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 310  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 311  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 312  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 313  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 314  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 315  : 	0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
; 316  : 	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
; 317  : 	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
; 318  : 	0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
; 319  : 	0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
; 320  : 	0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
; 321  : 	0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
; 322  : 	0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
; 323  : 	0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
; 324  : 	0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,
; 325  : 	0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,
; 326  : 	0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,
; 327  : 	0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,
; 328  : 	0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,
; 329  : 	0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,
; 330  : 	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
; 331  : 	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
; 332  : };
; 333  : 
; 334  : u8 d_len[256] = {
; 335  :     0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 336  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 337  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 338  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 339  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 340  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 341  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 342  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 343  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 344  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 345  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 346  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 347  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 348  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 349  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 350  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 351  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 352  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 353  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 354  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 355  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 356  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 357  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 358  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 359  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 360  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 361  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 362  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 363  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 364  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 365  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 366  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 367  : };
; 368  : 
; 369  : 
; 370  : /* initialization of tree */
; 371  : 
; 372  : void StartHuff(void)
; 373  : {
; 374  :     int i, j;
; 375  : 	
; 376  :     for (i = 0; i < N_CHAR; i++) {
; 377  :         freq[i]		= 1;
; 378  :         son	[i]		= i + T;
; 379  :         prnt[i + T] = i;
; 380  :     }
; 381  :     i = 0; j = N_CHAR;
; 382  :     while (j <= R) {
; 383  :         freq[j]		= freq[i] + freq[i + 1];
; 384  :         son[j]		= i;
; 385  :         prnt[i]		= prnt[i + 1] = j;
; 386  :         i += 2; j++;
; 387  :     }
; 388  :     freq[T] = 0xffff;
; 389  :     prnt[R] = 0;
; 390  : }
; 391  : 
; 392  : 
; 393  : /* reconstruction of tree */
; 394  : void reconst(void)
; 395  : {
; 396  :     int			i, j, k;
; 397  :     unsigned	f, l;
; 398  : 	
; 399  :     /* collect leaf nodes in the first half of the table */
; 400  :     /* and replace the freq by (freq + 1) / 2. */
; 401  :     j = 0;
; 402  :     for (i = 0; i < T; i++) {
; 403  :         if (son[i] >= T) {
; 404  :             freq[j] = (freq[i] + 1) / 2;
; 405  :             son[j] = son[i];
; 406  :             j++;
; 407  :         }
; 408  :     }
; 409  :     /* begin constructing tree by connecting sons */
; 410  :     for (i = 0, j = N_CHAR; j < T; i += 2, j++) {
; 411  :         k = i + 1;
; 412  :         f = freq[j] = freq[i] + freq[k];
; 413  :         for (k = j - 1; f < freq[k]; k--);
; 414  :         k++;
; 415  :         l = (j - k) * sizeof(unsigned);
; 416  :         memmove	(&freq[k + 1], &freq[k], l);
; 417  :         freq[k] = f;
; 418  :         memmove	(&son[k + 1], &son[k], l);
; 419  :         son[k] = i;
; 420  :     }
; 421  :     /* connect prnt */
; 422  :     for (i = 0; i < T; i++) {
; 423  :         if ((k = son[i]) >= T) {
; 424  :             prnt[k] = i;
; 425  :         } else {
; 426  :             prnt[k] = prnt[k + 1] = i;
; 427  :         }
; 428  :     }
; 429  : }
; 430  : 
; 431  : 
; 432  : /* increment frequency of given code by one, and update tree */
; 433  : void update(int c)
; 434  : {
; 435  :     int i, j, k, l;
; 436  : 	
; 437  :     if (freq[R] == MAX_FREQ) {
; 438  :         reconst();
; 439  :     }
; 440  :     c = prnt[c + T];
; 441  :     do {
; 442  :         k = ++freq[c];
; 443  : 		
; 444  :         /* if the order is disturbed, exchange nodes */
; 445  :         if ((unsigned)k > freq[l = c + 1]) {
; 446  :             while ((unsigned)k > freq[++l]);
; 447  :             l--;
; 448  :             freq[c] = freq[l];
; 449  :             freq[l] = k;
; 450  : 			
; 451  :             i = son[c];
; 452  :             prnt[i] = l;
; 453  :             if (i < T) prnt[i + 1] = l;
; 454  : 			
; 455  :             j = son[l];
; 456  :             son[l] = i;
; 457  : 			
; 458  :             prnt[j] = c;
; 459  :             if (j < T) prnt[j + 1] = c;
; 460  :             son[c] = j;
; 461  : 			
; 462  :             c = l;
; 463  :         }
; 464  :     } while ((c = prnt[c]) != 0); /* repeat up to root */
; 465  : }
; 466  : 
; 467  : void EncodeChar(unsigned c)
; 468  : {
; 469  :     unsigned i;
; 470  :     int j, k;
; 471  : 	
; 472  :     i = 0;

	xor	r15d, r15d

; 473  :     j = 0;

	xor	r12d, r12d

; 474  :     k = prnt[c + T];

	lea	eax, DWORD PTR [r13+627]
	mov	eax, DWORD PTR ?prnt@@3PAHA[rdx+rax*4]
$LL46@Encode:

; 475  : 	
; 476  :     /* travel from leaf to root */
; 477  :     do {
; 478  :         i >>= 1;

	shr	r15d, 1

; 479  : 		
; 480  :         /* if node's address is odd-numbered, choose bigger brother node */
; 481  :         if (k & 1) i += 0x8000;

	test	al, 1
	je	SHORT $LN43@Encode
	add	r15d, 32768				; 00008000H
$LN43@Encode:

; 482  : 		
; 483  :         j++;
; 484  : 		k = prnt[k];

	cdqe
	inc	r12d
	mov	eax, DWORD PTR ?prnt@@3PAHA[rdx+rax*4]

; 485  :     } while (k != R);

	cmp	eax, 626				; 00000272H
	jne	SHORT $LL46@Encode

; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);
; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {
; 118  : 			if ((int)(i = _getb()) < 0) i = 0;
; 119  : 			getbuf |= i << (8 - getlen);
; 120  : 			getlen += 8;
; 121  : 		}
; 122  : 		i = getbuf;
; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;
; 125  : 		return (int)((i & 0x8000) >> 15);
; 126  : 	}
; 127  : 	
; 128  : 	IC int		GetByte(void)   /* get one byte */
; 129  : 	{
; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {
; 133  : 			if ((int)(i = _getb()) < 0) i = 0;
; 134  : 			getbuf |= i << (8 - getlen);
; 135  : 			getlen += 8;
; 136  : 		}
; 137  : 		i = getbuf;
; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;
; 140  : 		return (int)((i & 0xff00) >> 8);
; 141  : 	}
; 142  : 	
; 143  : 	IC void		PutCode(int l, unsigned c)     /* output c bits of code */
; 144  : 	{
; 145  : 		putbuf |= c >> putlen;

	mov	ecx, ebp

; 146  : 		if ((putlen += l) >= 8) {

	add	ebp, r12d
	mov	eax, r15d
	shr	eax, cl
	mov	DWORD PTR fs+12, ebp
	or	ebx, eax
	mov	DWORD PTR fs+8, ebx
	cmp	ebp, 8
	jb	$LN49@Encode

; 147  : 			_putb(putbuf >> 8);

	shr	ebx, 8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rdi, QWORD PTR fs+48
	jne	SHORT $LN54@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	edi, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	edi, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rdi+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	add	rdi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rdi+1024]
	mov	QWORD PTR fs+56, rdi
	mov	QWORD PTR fs+48, rax
$LN54@Encode:

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rdi], bl

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	eax, DWORD PTR fs+12

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	rcx, QWORD PTR fs+56

; 148  : 			if ((putlen -= 8) >= 8) {

	add	eax, -8					; fffffff8H

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	rcx
	mov	QWORD PTR fs+56, rcx

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	DWORD PTR fs+12, eax
	cmp	eax, 8
	jb	$LN50@Encode

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rcx, QWORD PTR fs+48

; 149  : 				_putb(putbuf);

	mov	edi, DWORD PTR fs+8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	jne	SHORT $LN59@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	ebx, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	ebx, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rbx+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	ecx, ebx
	add	rcx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+56, rcx
	mov	QWORD PTR fs+48, rax
$LN59@Encode:

; 150  : 				codesize += 2;

	add	DWORD PTR ?codesize@@3IA, 2		; codesize

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rcx], dil

; 151  : 				putlen -= 8;

	mov	ecx, DWORD PTR fs+12

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	QWORD PTR fs+56

; 151  : 				putlen -= 8;

	add	ecx, -8					; fffffff8H

; 152  : 				putbuf = c << (l - putlen);

	mov	eax, r12d
	sub	eax, ecx
	mov	DWORD PTR fs+12, ecx
	movzx	ecx, al
	mov	eax, r15d
	shl	eax, cl
	mov	DWORD PTR fs+8, eax

; 153  : 			} else {

	jmp	SHORT $LN49@Encode
$LN50@Encode:

; 154  : 				putbuf <<= 8;

	shl	DWORD PTR fs+8, 8

; 155  : 				codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize
$LN49@Encode:

; 486  :     fs.PutCode(j, i);
; 487  :     code = i;
; 488  :     len = j;
; 489  :     update(c);

	mov	ecx, r13d
	mov	DWORD PTR ?code@@3IA, r15d		; code
	mov	DWORD PTR ?len@@3IA, r12d		; len
	call	?update@@YAXH@Z				; update

; 572  :         } else {

	mov	ebp, DWORD PTR fs+12
	mov	rdi, QWORD PTR fs+56
	mov	ebx, DWORD PTR fs+8
	mov	DWORD PTR fs$24$[rsp], ebp
	jmp	$LN102@Encode
$LN9@Encode:

; 573  :             EncodeChar(255 - THRESHOLD + match_length);

	lea	r13d, DWORD PTR [rax+253]

; 175  : }
; 176  : 
; 177  : void InsertNode(int r)  /* insert to tree */
; 178  : {
; 179  :     int				i, p, cmp;
; 180  :     u8			*key;
; 181  :     unsigned		c;
; 182  : 	
; 183  :     cmp = 1;
; 184  :     key = &text_buf[r];
; 185  :     p = N + 1 + key[0];
; 186  :     rson[r] = lson[r] = NIL;
; 187  :     match_length = 0;
; 188  :     for ( ; ; ) {
; 189  :         if (cmp >= 0) {
; 190  :             if (rson[p] != NIL)
; 191  :                 p = rson[p];
; 192  :             else {
; 193  :                 rson[p] = r;
; 194  :                 dad[r] = p;
; 195  :                 return;
; 196  :             }
; 197  :         } else {
; 198  :             if (lson[p] != NIL)
; 199  :                 p = lson[p];
; 200  :             else {
; 201  :                 lson[p] = r;
; 202  :                 dad[r] = p;
; 203  :                 return;
; 204  :             }
; 205  :         }
; 206  :         for (i = 1; i < F; i++)
; 207  :             if ((cmp = key[i] - text_buf[p + i]) != 0)
; 208  :                 break;
; 209  : 			if (i > THRESHOLD) {
; 210  : 				if (i > match_length) {
; 211  : 					match_position = ((r - p) & (N - 1)) - 1;
; 212  : 					if ((match_length = i) >= F)
; 213  : 						break;
; 214  : 				}
; 215  : 				if (i == match_length) {
; 216  : 					if ((c = ((r - p) & (N-1)) - 1) < (unsigned)match_position) {
; 217  : 						match_position = c;
; 218  : 					}
; 219  : 				}
; 220  : 			}
; 221  :     }
; 222  :     dad[r]  = dad[p];
; 223  :     lson[r] = lson[p];
; 224  :     rson[r] = rson[p];
; 225  :     dad[lson[p]] = r;
; 226  :     dad[rson[p]] = r;
; 227  :     if (rson[dad[p]] == p)
; 228  :         rson[dad[p]] = r;
; 229  :     else
; 230  :         lson[dad[p]] = r;
; 231  :     dad[p] = NIL; /* remove p */
; 232  : }
; 233  : 
; 234  : void DeleteNode(int p)  /* remove from tree */
; 235  : {
; 236  :     int  q;
; 237  : 	
; 238  :     if (dad[p] == NIL)	return;	/* not registered */
; 239  :     if (rson[p] == NIL)
; 240  : 		q = lson[p];
; 241  :     else 
; 242  : 	{
; 243  : 		if (lson[p] == NIL)
; 244  : 		{
; 245  : 			q = rson[p];
; 246  : 		}
; 247  : 		else 
; 248  : 		{
; 249  : 			q = lson[p];
; 250  : 			if (rson[q] != NIL) 
; 251  : 			{
; 252  : 				do { q = rson[q]; } while (rson[q] != NIL);
; 253  : 				
; 254  : 				rson[dad[q]]	= lson[q];
; 255  : 				dad[lson[q]]	= dad[q];
; 256  : 				lson[q]			= lson[p];
; 257  : 				dad[lson[p]]	= q;
; 258  : 			}
; 259  : 			rson[q]			= rson[p];
; 260  : 			dad[rson[p]]	= q;
; 261  : 		}
; 262  : 	}
; 263  : 	dad[q] = dad[p];
; 264  : 	if (rson[dad[p]] == p)
; 265  : 		rson[dad[p]] = q;
; 266  : 	else
; 267  : 		lson[dad[p]] = q;
; 268  : 	dad[p] = NIL;
; 269  : }
; 270  : 
; 271  : /* Huffman coding */
; 272  : 
; 273  : 
; 274  : /* table for encoding and decoding the upper 6 bits of position */
; 275  : /* for encoding */
; 276  : u8 p_len[64] = {
; 277  :     0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
; 278  : 	0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
; 279  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 280  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 281  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 282  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 283  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 284  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
; 285  : };
; 286  : 
; 287  : u8 p_code[64] = {
; 288  :     0x00, 0x20, 0x30, 0x40, 0x50, 0x58, 0x60, 0x68,
; 289  : 	0x70, 0x78, 0x80, 0x88, 0x90, 0x94, 0x98, 0x9C,
; 290  : 	0xA0, 0xA4, 0xA8, 0xAC, 0xB0, 0xB4, 0xB8, 0xBC,
; 291  : 	0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,
; 292  : 	0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,
; 293  : 	0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE,
; 294  : 	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
; 295  : 	0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
; 296  : };
; 297  : 
; 298  : /* for decoding */
; 299  : u8 d_code[256] = {
; 300  :     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 301  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 302  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 303  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 304  : 	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
; 305  : 	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
; 306  : 	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
; 307  : 	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
; 308  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 309  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 310  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 311  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 312  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 313  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 314  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 315  : 	0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
; 316  : 	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
; 317  : 	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
; 318  : 	0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
; 319  : 	0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
; 320  : 	0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
; 321  : 	0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
; 322  : 	0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
; 323  : 	0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
; 324  : 	0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,
; 325  : 	0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,
; 326  : 	0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,
; 327  : 	0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,
; 328  : 	0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,
; 329  : 	0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,
; 330  : 	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
; 331  : 	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
; 332  : };
; 333  : 
; 334  : u8 d_len[256] = {
; 335  :     0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 336  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 337  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 338  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 339  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 340  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 341  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 342  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 343  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 344  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 345  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 346  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 347  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 348  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 349  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 350  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 351  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 352  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 353  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 354  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 355  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 356  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 357  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 358  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 359  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 360  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 361  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 362  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 363  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 364  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 365  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 366  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 367  : };
; 368  : 
; 369  : 
; 370  : /* initialization of tree */
; 371  : 
; 372  : void StartHuff(void)
; 373  : {
; 374  :     int i, j;
; 375  : 	
; 376  :     for (i = 0; i < N_CHAR; i++) {
; 377  :         freq[i]		= 1;
; 378  :         son	[i]		= i + T;
; 379  :         prnt[i + T] = i;
; 380  :     }
; 381  :     i = 0; j = N_CHAR;
; 382  :     while (j <= R) {
; 383  :         freq[j]		= freq[i] + freq[i + 1];
; 384  :         son[j]		= i;
; 385  :         prnt[i]		= prnt[i + 1] = j;
; 386  :         i += 2; j++;
; 387  :     }
; 388  :     freq[T] = 0xffff;
; 389  :     prnt[R] = 0;
; 390  : }
; 391  : 
; 392  : 
; 393  : /* reconstruction of tree */
; 394  : void reconst(void)
; 395  : {
; 396  :     int			i, j, k;
; 397  :     unsigned	f, l;
; 398  : 	
; 399  :     /* collect leaf nodes in the first half of the table */
; 400  :     /* and replace the freq by (freq + 1) / 2. */
; 401  :     j = 0;
; 402  :     for (i = 0; i < T; i++) {
; 403  :         if (son[i] >= T) {
; 404  :             freq[j] = (freq[i] + 1) / 2;
; 405  :             son[j] = son[i];
; 406  :             j++;
; 407  :         }
; 408  :     }
; 409  :     /* begin constructing tree by connecting sons */
; 410  :     for (i = 0, j = N_CHAR; j < T; i += 2, j++) {
; 411  :         k = i + 1;
; 412  :         f = freq[j] = freq[i] + freq[k];
; 413  :         for (k = j - 1; f < freq[k]; k--);
; 414  :         k++;
; 415  :         l = (j - k) * sizeof(unsigned);
; 416  :         memmove	(&freq[k + 1], &freq[k], l);
; 417  :         freq[k] = f;
; 418  :         memmove	(&son[k + 1], &son[k], l);
; 419  :         son[k] = i;
; 420  :     }
; 421  :     /* connect prnt */
; 422  :     for (i = 0; i < T; i++) {
; 423  :         if ((k = son[i]) >= T) {
; 424  :             prnt[k] = i;
; 425  :         } else {
; 426  :             prnt[k] = prnt[k + 1] = i;
; 427  :         }
; 428  :     }
; 429  : }
; 430  : 
; 431  : 
; 432  : /* increment frequency of given code by one, and update tree */
; 433  : void update(int c)
; 434  : {
; 435  :     int i, j, k, l;
; 436  : 	
; 437  :     if (freq[R] == MAX_FREQ) {
; 438  :         reconst();
; 439  :     }
; 440  :     c = prnt[c + T];
; 441  :     do {
; 442  :         k = ++freq[c];
; 443  : 		
; 444  :         /* if the order is disturbed, exchange nodes */
; 445  :         if ((unsigned)k > freq[l = c + 1]) {
; 446  :             while ((unsigned)k > freq[++l]);
; 447  :             l--;
; 448  :             freq[c] = freq[l];
; 449  :             freq[l] = k;
; 450  : 			
; 451  :             i = son[c];
; 452  :             prnt[i] = l;
; 453  :             if (i < T) prnt[i + 1] = l;
; 454  : 			
; 455  :             j = son[l];
; 456  :             son[l] = i;
; 457  : 			
; 458  :             prnt[j] = c;
; 459  :             if (j < T) prnt[j + 1] = c;
; 460  :             son[c] = j;
; 461  : 			
; 462  :             c = l;
; 463  :         }
; 464  :     } while ((c = prnt[c]) != 0); /* repeat up to root */
; 465  : }
; 466  : 
; 467  : void EncodeChar(unsigned c)
; 468  : {
; 469  :     unsigned i;
; 470  :     int j, k;
; 471  : 	
; 472  :     i = 0;

	xor	r15d, r15d

; 473  :     j = 0;

	xor	r12d, r12d

; 474  :     k = prnt[c + T];

	lea	eax, DWORD PTR [r13+627]
	mov	eax, DWORD PTR ?prnt@@3PAHA[rdx+rax*4]
$LL67@Encode:

; 475  : 	
; 476  :     /* travel from leaf to root */
; 477  :     do {
; 478  :         i >>= 1;

	shr	r15d, 1

; 479  : 		
; 480  :         /* if node's address is odd-numbered, choose bigger brother node */
; 481  :         if (k & 1) i += 0x8000;

	test	al, 1
	je	SHORT $LN64@Encode
	add	r15d, 32768				; 00008000H
$LN64@Encode:

; 482  : 		
; 483  :         j++;
; 484  : 		k = prnt[k];

	cdqe
	inc	r12d
	mov	eax, DWORD PTR ?prnt@@3PAHA[rdx+rax*4]

; 485  :     } while (k != R);

	cmp	eax, 626				; 00000272H
	jne	SHORT $LL67@Encode

; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);
; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {
; 118  : 			if ((int)(i = _getb()) < 0) i = 0;
; 119  : 			getbuf |= i << (8 - getlen);
; 120  : 			getlen += 8;
; 121  : 		}
; 122  : 		i = getbuf;
; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;
; 125  : 		return (int)((i & 0x8000) >> 15);
; 126  : 	}
; 127  : 	
; 128  : 	IC int		GetByte(void)   /* get one byte */
; 129  : 	{
; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {
; 133  : 			if ((int)(i = _getb()) < 0) i = 0;
; 134  : 			getbuf |= i << (8 - getlen);
; 135  : 			getlen += 8;
; 136  : 		}
; 137  : 		i = getbuf;
; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;
; 140  : 		return (int)((i & 0xff00) >> 8);
; 141  : 	}
; 142  : 	
; 143  : 	IC void		PutCode(int l, unsigned c)     /* output c bits of code */
; 144  : 	{
; 145  : 		putbuf |= c >> putlen;

	mov	ecx, ebp

; 146  : 		if ((putlen += l) >= 8) {

	add	ebp, r12d
	mov	eax, r15d
	shr	eax, cl
	mov	DWORD PTR fs+12, ebp
	or	ebx, eax
	mov	DWORD PTR fs+8, ebx
	cmp	ebp, 8
	jb	$LN70@Encode

; 147  : 			_putb(putbuf >> 8);

	shr	ebx, 8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rdi, QWORD PTR fs+48
	jne	SHORT $LN75@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	edi, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	edi, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rdi+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	add	rdi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rdi+1024]
	mov	QWORD PTR fs+56, rdi
	mov	QWORD PTR fs+48, rax
$LN75@Encode:

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rdi], bl

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	eax, DWORD PTR fs+12

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	rcx, QWORD PTR fs+56

; 148  : 			if ((putlen -= 8) >= 8) {

	add	eax, -8					; fffffff8H

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	rcx
	mov	QWORD PTR fs+56, rcx

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	DWORD PTR fs+12, eax
	cmp	eax, 8
	jb	$LN71@Encode

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rcx, QWORD PTR fs+48

; 149  : 				_putb(putbuf);

	mov	edi, DWORD PTR fs+8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	jne	SHORT $LN80@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	ebx, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	ebx, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rbx+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	ecx, ebx
	add	rcx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+56, rcx
	mov	QWORD PTR fs+48, rax
$LN80@Encode:

; 150  : 				codesize += 2;

	add	DWORD PTR ?codesize@@3IA, 2		; codesize

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rcx], dil

; 151  : 				putlen -= 8;

	mov	ecx, DWORD PTR fs+12

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	QWORD PTR fs+56

; 151  : 				putlen -= 8;

	add	ecx, -8					; fffffff8H

; 152  : 				putbuf = c << (l - putlen);

	mov	eax, r12d
	sub	eax, ecx
	mov	DWORD PTR fs+12, ecx
	movzx	ecx, al
	mov	eax, r15d
	shl	eax, cl
	mov	DWORD PTR fs+8, eax

; 153  : 			} else {

	jmp	SHORT $LN70@Encode
$LN71@Encode:

; 154  : 				putbuf <<= 8;

	shl	DWORD PTR fs+8, 8

; 155  : 				codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize
$LN70@Encode:

; 486  :     fs.PutCode(j, i);
; 487  :     code = i;
; 488  :     len = j;
; 489  :     update(c);

	mov	ecx, r13d
	mov	DWORD PTR ?code@@3IA, r15d		; code
	mov	DWORD PTR ?len@@3IA, r12d		; len
	call	?update@@YAXH@Z				; update

; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);
; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {
; 118  : 			if ((int)(i = _getb()) < 0) i = 0;
; 119  : 			getbuf |= i << (8 - getlen);
; 120  : 			getlen += 8;
; 121  : 		}
; 122  : 		i = getbuf;
; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;
; 125  : 		return (int)((i & 0x8000) >> 15);
; 126  : 	}
; 127  : 	
; 128  : 	IC int		GetByte(void)   /* get one byte */
; 129  : 	{
; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {
; 133  : 			if ((int)(i = _getb()) < 0) i = 0;
; 134  : 			getbuf |= i << (8 - getlen);
; 135  : 			getlen += 8;
; 136  : 		}
; 137  : 		i = getbuf;
; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;
; 140  : 		return (int)((i & 0xff00) >> 8);
; 141  : 	}
; 142  : 	
; 143  : 	IC void		PutCode(int l, unsigned c)     /* output c bits of code */
; 144  : 	{
; 145  : 		putbuf |= c >> putlen;

	mov	ebp, DWORD PTR fs+12
	mov	ebx, DWORD PTR fs+8

; 574  :             EncodePosition(match_position);

	mov	r15d, DWORD PTR ?match_position@@3HA	; match_position

; 490  : }
; 491  : 
; 492  : void EncodePosition(unsigned c)
; 493  : {
; 494  :     unsigned i;
; 495  : 	
; 496  :     /* output upper 6 bits by table lookup */
; 497  :     i = c >> 6;
; 498  :     fs.PutCode(p_len[i], (unsigned)p_code[i] << 8);

	lea	rax, OFFSET FLAT:__ImageBase
	mov	ecx, r15d
	shr	ecx, 6
	movzx	r13d, BYTE PTR ?p_code@@3PAEA[rcx+rax]
	movzx	r12d, BYTE PTR ?p_len@@3PAEA[rcx+rax]

; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);
; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {
; 118  : 			if ((int)(i = _getb()) < 0) i = 0;
; 119  : 			getbuf |= i << (8 - getlen);
; 120  : 			getlen += 8;
; 121  : 		}
; 122  : 		i = getbuf;
; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;
; 125  : 		return (int)((i & 0x8000) >> 15);
; 126  : 	}
; 127  : 	
; 128  : 	IC int		GetByte(void)   /* get one byte */
; 129  : 	{
; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {
; 133  : 			if ((int)(i = _getb()) < 0) i = 0;
; 134  : 			getbuf |= i << (8 - getlen);
; 135  : 			getlen += 8;
; 136  : 		}
; 137  : 		i = getbuf;
; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;
; 140  : 		return (int)((i & 0xff00) >> 8);
; 141  : 	}
; 142  : 	
; 143  : 	IC void		PutCode(int l, unsigned c)     /* output c bits of code */
; 144  : 	{
; 145  : 		putbuf |= c >> putlen;

	mov	ecx, ebp

; 490  : }
; 491  : 
; 492  : void EncodePosition(unsigned c)
; 493  : {
; 494  :     unsigned i;
; 495  : 	
; 496  :     /* output upper 6 bits by table lookup */
; 497  :     i = c >> 6;
; 498  :     fs.PutCode(p_len[i], (unsigned)p_code[i] << 8);

	shl	r13d, 8

; 146  : 		if ((putlen += l) >= 8) {

	add	ebp, r12d
	mov	eax, r13d
	mov	DWORD PTR fs+12, ebp
	shr	eax, cl
	or	ebx, eax
	mov	DWORD PTR fs+8, ebx
	cmp	ebp, 8
	jb	$LN170@Encode

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	mov	rcx, QWORD PTR fs+56

; 147  : 			_putb(putbuf >> 8);

	shr	ebx, 8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rcx, QWORD PTR fs+48
	jne	SHORT $LN92@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	edi, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	edi, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rdi+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	ecx, edi
	add	rcx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+56, rcx
	mov	QWORD PTR fs+48, rax
$LN92@Encode:

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rcx], bl

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	ebp, DWORD PTR fs+12

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	rdi, QWORD PTR fs+56

; 148  : 			if ((putlen -= 8) >= 8) {

	add	ebp, -8					; fffffff8H

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	rdi
	mov	QWORD PTR fs+56, rdi

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	DWORD PTR fs+12, ebp
	cmp	ebp, 8
	jb	$LN88@Encode

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rdi, QWORD PTR fs+48

; 149  : 				_putb(putbuf);

	mov	ebp, DWORD PTR fs+8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	jne	SHORT $LN97@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	ebx, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	ebx, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rbx+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	edi, ebx
	add	rdi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rdi+1024]
	mov	QWORD PTR fs+56, rdi
	mov	QWORD PTR fs+48, rax
$LN97@Encode:

; 150  : 				codesize += 2;

	add	DWORD PTR ?codesize@@3IA, 2		; codesize

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rdi], bpl
	mov	rdi, QWORD PTR fs+56

; 151  : 				putlen -= 8;

	mov	ebp, DWORD PTR fs+12

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	rdi

; 152  : 				putbuf = c << (l - putlen);

	mov	ebx, r13d
	add	ebp, -8					; fffffff8H

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	QWORD PTR fs+56, rdi

; 152  : 				putbuf = c << (l - putlen);

	sub	r12d, ebp
	movzx	ecx, r12b
	shl	ebx, cl

; 153  : 			} else {

	jmp	SHORT $LN87@Encode
$LN88@Encode:

; 154  : 				putbuf <<= 8;

	mov	ebx, DWORD PTR fs+8
	shl	ebx, 8

; 155  : 				codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize
	jmp	SHORT $LN87@Encode
$LN170@Encode:
	mov	rdi, QWORD PTR fs+56
$LN87@Encode:

; 499  : 	
; 500  :     /* output lower 6 bits verbatim */
; 501  :     fs.PutCode(6, (c & 0x3f) << 10);

	and	r15d, 63				; 0000003fH

; 100  : 	}
; 101  : 	IC u32		OutSize		() {
; 102  : 		return u32(out_iterator-out_start);
; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {
; 118  : 			if ((int)(i = _getb()) < 0) i = 0;
; 119  : 			getbuf |= i << (8 - getlen);
; 120  : 			getlen += 8;
; 121  : 		}
; 122  : 		i = getbuf;
; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;
; 125  : 		return (int)((i & 0x8000) >> 15);
; 126  : 	}
; 127  : 	
; 128  : 	IC int		GetByte(void)   /* get one byte */
; 129  : 	{
; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {
; 133  : 			if ((int)(i = _getb()) < 0) i = 0;
; 134  : 			getbuf |= i << (8 - getlen);
; 135  : 			getlen += 8;
; 136  : 		}
; 137  : 		i = getbuf;
; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;
; 140  : 		return (int)((i & 0xff00) >> 8);
; 141  : 	}
; 142  : 	
; 143  : 	IC void		PutCode(int l, unsigned c)     /* output c bits of code */
; 144  : 	{
; 145  : 		putbuf |= c >> putlen;

	mov	ecx, ebp

; 146  : 		if ((putlen += l) >= 8) {

	add	ebp, 6

; 499  : 	
; 500  :     /* output lower 6 bits verbatim */
; 501  :     fs.PutCode(6, (c & 0x3f) << 10);

	shl	r15d, 10

; 146  : 		if ((putlen += l) >= 8) {

	mov	DWORD PTR fs$24$[rsp], ebp
	mov	DWORD PTR fs+12, ebp
	mov	eax, r15d
	shr	eax, cl
	or	ebx, eax
	mov	DWORD PTR fs+8, ebx
	cmp	ebp, 8
	jb	$LN102@Encode

; 147  : 			_putb(putbuf >> 8);

	shr	ebx, 8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rdi, QWORD PTR fs+48
	jne	SHORT $LN107@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	edi, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	edi, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rdi+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	add	rdi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rdi+1024]
	mov	QWORD PTR fs+56, rdi
	mov	QWORD PTR fs+48, rax
$LN107@Encode:

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rdi], bl

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	ebp, DWORD PTR fs+12

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	rdi, QWORD PTR fs+56

; 148  : 			if ((putlen -= 8) >= 8) {

	add	ebp, -8					; fffffff8H

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	rdi
	mov	QWORD PTR fs+56, rdi

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	DWORD PTR fs$24$[rsp], ebp
	mov	DWORD PTR fs+12, ebp
	cmp	ebp, 8
	jb	$LN103@Encode

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rdi, QWORD PTR fs+48

; 149  : 				_putb(putbuf);

	mov	ebp, DWORD PTR fs+8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	jne	SHORT $LN112@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	ebx, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	ebx, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rbx+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	edi, ebx
	add	rdi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rdi+1024]
	mov	QWORD PTR fs+56, rdi
	mov	QWORD PTR fs+48, rax
$LN112@Encode:

; 150  : 				codesize += 2;

	add	DWORD PTR ?codesize@@3IA, 2		; codesize

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rdi], bpl

; 151  : 				putlen -= 8;

	mov	ebp, DWORD PTR fs+12

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	rdi, QWORD PTR fs+56

; 151  : 				putlen -= 8;

	add	ebp, -8					; fffffff8H

; 152  : 				putbuf = c << (l - putlen);

	mov	ecx, 6

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	rdi

; 152  : 				putbuf = c << (l - putlen);

	sub	ecx, ebp
	mov	ebx, r15d
	mov	DWORD PTR fs$24$[rsp], ebp
	mov	DWORD PTR fs+12, ebp
	shl	ebx, cl

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	QWORD PTR fs+56, rdi

; 153  : 			} else {

	jmp	SHORT $LN174@Encode
$LN103@Encode:

; 154  : 				putbuf <<= 8;

	mov	ebx, DWORD PTR fs+8
	shl	ebx, 8

; 155  : 				codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize
$LN174@Encode:

; 154  : 				putbuf <<= 8;

	mov	DWORD PTR fs+8, ebx
$LN102@Encode:

; 575  :         }
; 576  :         last_match_length = match_length;

	mov	eax, DWORD PTR ?match_length@@3HA	; match_length

; 577  :         for (i = 0; i < last_match_length &&

	xor	r13d, r13d
	mov	DWORD PTR last_match_length$1$[rsp], eax

; 578  : 			(c = fs._getb()) != EOF; i++) {

	test	eax, eax
	jle	SHORT $LN171@Encode
	mov	r15, QWORD PTR fs+32
	lea	rbp, OFFSET FLAT:?text_buf@@3PAEA	; text_buf
$LL7@Encode:

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	r15, QWORD PTR fs+24
	je	SHORT $LN172@Encode

; 66   : 		return *in_iterator++;

	movzx	r12d, BYTE PTR [r15]
	inc	r15
	mov	QWORD PTR fs+32, r15

; 578  : 			(c = fs._getb()) != EOF; i++) {

	cmp	r12d, -1
	je	SHORT $LN172@Encode

; 579  :             DeleteNode(s);

	mov	ecx, esi
	call	?DeleteNode@@YAXH@Z			; DeleteNode

; 580  :             text_buf[s] = (unsigned char)c;

	movsxd	rax, esi
	mov	BYTE PTR [rax+rbp], r12b

; 581  :             if (s < F - 1)

	cmp	esi, 59					; 0000003bH
	jge	SHORT $LN4@Encode

; 582  :                 text_buf[s + N] = (unsigned char)c;

	mov	BYTE PTR [rax+rbp+4096], r12b
$LN4@Encode:

; 583  :             s = (s + 1) & (N - 1);

	inc	esi
	and	esi, 4095				; 00000fffH

; 584  :             r = (r + 1) & (N - 1);

	inc	r14d
	and	r14d, 4095				; 00000fffH

; 585  :             InsertNode(r);

	mov	ecx, r14d
	call	?InsertNode@@YAXH@Z			; InsertNode
	mov	eax, DWORD PTR last_match_length$1$[rsp]
	inc	r13d
	cmp	r13d, eax
	jl	SHORT $LL7@Encode
$LN172@Encode:
	mov	ebp, DWORD PTR fs$24$[rsp]
$LN171@Encode:

; 586  :         }
; 587  : 		textsize += i;

	mov	r12d, DWORD PTR ?textsize@@3IA		; textsize
	add	r12d, r13d
	mov	DWORD PTR ?textsize@@3IA, r12d		; textsize

; 588  :         while (i++ < last_match_length) {

	cmp	r13d, eax
	jge	SHORT $LN173@Encode

; 586  :         }
; 587  : 		textsize += i;

	sub	eax, r13d
	mov	r13d, DWORD PTR len$1$[rsp]
	mov	r15d, eax
$LL3@Encode:

; 589  :             DeleteNode(s);

	mov	ecx, esi
	call	?DeleteNode@@YAXH@Z			; DeleteNode

; 590  :             s = (s + 1) & (N - 1);

	inc	esi
	and	esi, 4095				; 00000fffH

; 591  :             r = (r + 1) & (N - 1);

	inc	r14d
	and	r14d, 4095				; 00000fffH

; 592  :             if (--len) InsertNode(r);

	dec	r13d
	je	SHORT $LN1@Encode
	mov	ecx, r14d
	call	?InsertNode@@YAXH@Z			; InsertNode
$LN1@Encode:

; 588  :         while (i++ < last_match_length) {

	dec	r15
	jne	SHORT $LL3@Encode
	mov	DWORD PTR len$1$[rsp], r13d
	jmp	SHORT $LN144@Encode
$LN173@Encode:
	mov	r13d, DWORD PTR len$1$[rsp]
$LN144@Encode:

; 593  :         }
; 594  :     } while (len > 0);

	lea	rdx, OFFSET FLAT:__ImageBase
	lea	r15, OFFSET FLAT:?text_buf@@3PAEA	; text_buf
	test	r13d, r13d
	jg	$LL13@Encode
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+72]

; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 	IC void		PutFlush()
; 160  : 	{
; 161  : 		if (putlen) {

	test	ebp, ebp
	mov	rbp, QWORD PTR [rsp+120]
	je	SHORT $LN120@Encode

; 162  : 			_putb(putbuf >> 8);

	shr	ebx, 8

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rdi, QWORD PTR fs+48
	jne	SHORT $LN123@Encode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	edi, DWORD PTR fs+48
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	edi, DWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rdi+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	mov	r12d, DWORD PTR ?textsize@@3IA		; textsize
	add	rdi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rdi+1024]
	mov	QWORD PTR fs+56, rdi
	mov	QWORD PTR fs+48, rax
$LN123@Encode:

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rdi], bl
	inc	QWORD PTR fs+56

; 163  : 			codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize
$LN120@Encode:
	mov	rdi, QWORD PTR [rsp+64]

; 595  :     fs.PutFlush();
; 596  : 	tim_size = textsize;

	mov	DWORD PTR ?tim_size@@3IA, r12d		; tim_size
	mov	r12, QWORD PTR [rsp+56]
$LN24@Encode:

; 597  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?Encode@@YAXXZ ENDP					; Encode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
_TEXT	SEGMENT
?Decode@@YAXXZ PROC					; Decode

; 600  : {

$LN53:
	sub	rsp, 56					; 00000038H

; 65   : 		if (in_iterator==in_end) return EOF;

	mov	rax, QWORD PTR fs+32
	mov	r8, QWORD PTR fs+24
	or	edx, -1
	cmp	rax, r8
	jne	SHORT $LN14@Decode
	mov	r9d, edx
	jmp	SHORT $LN15@Decode
$LN14@Decode:

; 66   : 		return *in_iterator++;

	movzx	r9d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
$LN15@Decode:

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	rax, r8
	jne	SHORT $LN17@Decode
	mov	ecx, edx
	jmp	SHORT $LN18@Decode
$LN17@Decode:

; 66   : 		return *in_iterator++;

	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
$LN18@Decode:

; 601  :     int  i, j, k, r, c;
; 602  :     unsigned int  count;
; 603  : 	
; 604  :     textsize =  (fs._getb());
; 605  :     textsize |= (fs._getb() << 8);

	shl	ecx, 8
	or	ecx, r9d

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	rax, r8
	jne	SHORT $LN20@Decode
	mov	r9d, edx
	jmp	SHORT $LN21@Decode
$LN20@Decode:

; 66   : 		return *in_iterator++;

	movzx	r9d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
$LN21@Decode:

; 606  :     textsize |= (fs._getb() << 16);

	shl	r9d, 16
	or	ecx, r9d

; 65   : 		if (in_iterator==in_end) return EOF;

	cmp	rax, r8
	je	SHORT $LN24@Decode

; 66   : 		return *in_iterator++;

	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
$LN24@Decode:

; 607  :     textsize |= (fs._getb() << 24);

	shl	edx, 24
	or	ecx, edx
	mov	DWORD PTR ?textsize@@3IA, ecx		; textsize

; 608  :     if (textsize == 0) return;

	je	$LN12@Decode
	mov	QWORD PTR [rsp+64], rbx

; 76   : 	}
; 77   : 	
; 78   : 	LZfs() {
; 79   : 		in_start	= in_end	= in_iterator = 0;
; 80   : 		out_start	= out_end	= out_iterator = 0;
; 81   : 	}
; 82   : 	
; 83   : 	IC void		Init_Input(u8* _start, u8* _end) {
; 84   : 		// input
; 85   : 		in_start	= _start;
; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;
; 88   : 		
; 89   : 		// bitwise input/output
; 90   : 		getbuf = getlen = putbuf = putlen = 0;
; 91   : 	}
; 92   : 	IC void		Init_Output(int _rsize) {
; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);

	movsxd	rbx, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 110  : 	IC void*	xr_malloc	(size_t size)			{	return	Memory.mem_alloc(size);					}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	rdx, rbx
	mov	QWORD PTR [rsp+48], r12
	mov	QWORD PTR [rsp+32], r15
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 96   : 		out_iterator= out_start;

	mov	QWORD PTR fs+56, rax
	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR fs+48, rcx

; 609  : 	
; 610  : 	fs.Init_Output(textsize);
; 611  : 	
; 612  :     StartHuff();

	call	?StartHuff@@YAXXZ			; StartHuff

; 613  :     for (i = 0; i < N - F; i++)
; 614  :         text_buf[i] = 0x20;

	lea	r12, OFFSET FLAT:?text_buf@@3PAEA	; text_buf
	mov	rax, r12
	mov	r11, 2314885530818453536		; 2020202020202020H
	mov	ecx, 63					; 0000003fH
	npad	13
$LL51@Decode:
	mov	QWORD PTR [rax], r11
	mov	QWORD PTR [rax+8], r11
	mov	QWORD PTR [rax+16], r11
	lea	rax, QWORD PTR [rax+64]
	mov	QWORD PTR [rax-40], r11
	mov	QWORD PTR [rax-32], r11
	mov	QWORD PTR [rax-24], r11
	mov	QWORD PTR [rax-16], r11
	mov	QWORD PTR [rax-8], r11
	dec	rcx
	jne	SHORT $LL51@Decode

; 615  :     r = N - F;
; 616  :     for (count = 0; count < textsize; ) {

	xor	r15d, r15d
	mov	DWORD PTR [rax], r11d
	mov	ebx, 4036				; 00000fc4H
	cmp	DWORD PTR ?textsize@@3IA, r15d		; textsize
	jbe	$LN6@Decode
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+40], r14
$LL7@Decode:

; 617  :         c = DecodeChar();

	call	?DecodeChar@@YAHXZ			; DecodeChar
	mov	edi, eax

; 618  :         if (c < 256) {

	cmp	eax, 256				; 00000100H
	jge	SHORT $LN5@Decode

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	mov	rcx, QWORD PTR fs+56
	mov	rsi, QWORD PTR fs+48
	cmp	rcx, rsi
	jne	SHORT $LN30@Decode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	rdx, QWORD PTR fs+40
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	esi, edx

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rsi+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	ecx, esi
	add	rcx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+56, rcx
	mov	QWORD PTR fs+48, rax
$LN30@Decode:

; 619  :             fs._putb(c);
; 620  :             text_buf[r++] = (unsigned char)c;

	movsxd	rax, ebx

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rcx], dil
	inc	QWORD PTR fs+56

; 619  :             fs._putb(c);
; 620  :             text_buf[r++] = (unsigned char)c;

	inc	ebx
	mov	BYTE PTR [rax+r12], dil

; 621  :             r &= (N - 1);

	and	ebx, 4095				; 00000fffH

; 622  :             count++;

	inc	r15d

; 623  :         } else {

	jmp	$LN1@Decode
$LN5@Decode:

; 624  :             i = (r - DecodePosition() - 1) & (N - 1);

	call	?DecodePosition@@YAHXZ			; DecodePosition
	mov	ecx, ebx

; 625  :             j = c - 255 + THRESHOLD;

	add	edi, -253				; ffffffffffffff03H
	sub	ecx, eax
	dec	ecx
	and	ecx, 4095				; 00000fffH

; 626  :             for (k = 0; k < j; k++) {

	test	edi, edi
	jle	$LN1@Decode
	mov	rax, QWORD PTR fs+56
	movsxd	rsi, ecx
	mov	r14d, edi
	add	r15d, edi
	npad	14
$LL3@Decode:

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	mov	rdi, QWORD PTR fs+48

; 627  :                 c = text_buf[(i + k) & (N - 1)];

	mov	rcx, rsi
	and	ecx, 4095				; 00000fffH
	movzx	ebp, BYTE PTR [rcx+r12]

; 67   : 	}
; 68   : 	IC void		_putb(int c) {
; 69   : 		if (out_iterator==out_end) {

	cmp	rax, rdi
	jne	SHORT $LN35@Decode

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	rdx, QWORD PTR fs+40
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 70   : 			u32	out_size= u32(out_end-out_start);

	sub	edi, edx

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	r8d, DWORD PTR [rdi+1024]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
	mov	rcx, rax
	mov	QWORD PTR fs+40, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 72   : 			out_iterator= out_start+out_size;

	mov	eax, edi
	add	rax, rcx
	mov	QWORD PTR fs+56, rax

; 73   : 			out_end		= out_iterator+1024;

	lea	rcx, QWORD PTR [rax+1024]
	mov	QWORD PTR fs+48, rcx
$LN35@Decode:

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rax], bpl
	mov	rax, QWORD PTR fs+56

; 628  :                 fs._putb(c);
; 629  :                 text_buf[r++] = (unsigned char)c;

	movsxd	rcx, ebx

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	inc	rax

; 628  :                 fs._putb(c);
; 629  :                 text_buf[r++] = (unsigned char)c;

	inc	ebx
	inc	rsi

; 630  :                 r &= (N - 1);

	and	ebx, 4095				; 00000fffH

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	QWORD PTR fs+56, rax

; 628  :                 fs._putb(c);
; 629  :                 text_buf[r++] = (unsigned char)c;

	mov	BYTE PTR [rcx+r12], bpl
	dec	r14
	jne	$LL3@Decode
$LN1@Decode:

; 615  :     r = N - F;
; 616  :     for (count = 0; count < textsize; ) {

	cmp	r15d, DWORD PTR ?textsize@@3IA		; textsize
	jb	$LL7@Decode
	mov	r14, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
$LN6@Decode:
	mov	r12, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+64]

; 631  :                 count++;
; 632  :             }
; 633  :         }
; 634  :     }
; 635  : 	tim_size = count;

	mov	DWORD PTR ?tim_size@@3IA, r15d		; tim_size
	mov	r15, QWORD PTR [rsp+32]
$LN12@Decode:

; 636  : }

	add	rsp, 56					; 00000038H
	ret	0
?Decode@@YAXXZ ENDP					; Decode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ?xr_realloc@@YAPEAXPEAX_K@Z
_TEXT	SEGMENT
P$ = 8
size$ = 16
?xr_realloc@@YAPEAXPEAX_K@Z PROC			; xr_realloc, COMDAT

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	r8, rdx
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	jmp	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
?xr_realloc@@YAPEAXPEAX_K@Z ENDP			; xr_realloc
_TEXT	ENDS
END
