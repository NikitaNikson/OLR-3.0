; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?PutCode@LZfs@@QEAAXHI@Z			; LZfs::PutCode
PUBLIC	?GetBit@LZfs@@QEAAHXZ				; LZfs::GetBit
PUBLIC	?GetByte@LZfs@@QEAAHXZ				; LZfs::GetByte
PUBLIC	?InputSize@LZfs@@QEAAIXZ			; LZfs::InputSize
PUBLIC	?PutFlush@LZfs@@QEAAXXZ				; LZfs::PutFlush
PUBLIC	?InitTree@@YAXXZ				; InitTree
PUBLIC	?_getb@LZfs@@QEAAHXZ				; LZfs::_getb
PUBLIC	?xr_realloc@@YAPEAXPEAX_K@Z			; xr_realloc
PUBLIC	?_putb@LZfs@@QEAAXH@Z				; LZfs::_putb
PUBLIC	?Init_Output@LZfs@@QEAAXH@Z			; LZfs::Init_Output
PUBLIC	?OutRelease@LZfs@@QEAAXXZ			; LZfs::OutRelease
PUBLIC	?Init_Input@LZfs@@QEAAXPEAE0@Z			; LZfs::Init_Input
PUBLIC	?OutSize@LZfs@@QEAAIXZ				; LZfs::OutSize
PUBLIC	?OutPointer@LZfs@@QEAAPEAEXZ			; LZfs::OutPointer
PUBLIC	??0LZfs@@QEAA@XZ				; LZfs::LZfs
PUBLIC	?text_buf@@3PAEA				; text_buf
PUBLIC	?match_position@@3HA				; match_position
PUBLIC	?match_length@@3HA				; match_length
PUBLIC	?lson@@3PAHA					; lson
PUBLIC	?rson@@3PAHA					; rson
PUBLIC	?dad@@3PAHA					; dad
PUBLIC	?code@@3IA					; code
PUBLIC	?len@@3IA					; len
PUBLIC	?freq@@3PAIA					; freq
PUBLIC	?prnt@@3PAHA					; prnt
PUBLIC	?son@@3PAHA					; son
PUBLIC	?textsize@@3IA					; textsize
PUBLIC	?codesize@@3IA					; codesize
PUBLIC	?wterr@@3PADA					; wterr
PUBLIC	?tim_size@@3IA					; tim_size
PUBLIC	?p_len@@3PAEA					; p_len
PUBLIC	?p_code@@3PAEA					; p_code
PUBLIC	?d_code@@3PAEA					; d_code
PUBLIC	?d_len@@3PAEA					; d_len
?text_buf@@3PAEA DB 0103cH DUP (?)			; text_buf
?match_position@@3HA DD 01H DUP (?)			; match_position
?match_length@@3HA DD 01H DUP (?)			; match_length
?lson@@3PAHA DD	01001H DUP (?)				; lson
?rson@@3PAHA DD	01101H DUP (?)				; rson
?dad@@3PAHA DD	01001H DUP (?)				; dad
?code@@3IA DD	01H DUP (?)				; code
?len@@3IA DD	01H DUP (?)				; len
?freq@@3PAIA DD	0274H DUP (?)				; freq
?prnt@@3PAHA DD	03aeH DUP (?)				; prnt
?son@@3PAHA DD	0273H DUP (?)				; son
?textsize@@3IA DD 01H DUP (?)				; textsize
?codesize@@3IA DD 01H DUP (?)				; codesize
?tim_size@@3IA DD 01H DUP (?)				; tim_size
?wterr@@3PADA DB 'Can''t write.', 00H			; wterr
	ORG $+3
?p_len@@3PAEA DB 03H					; p_len
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
?p_code@@3PAEA DB 00H					; p_code
	DB	020H
	DB	030H
	DB	040H
	DB	050H
	DB	058H
	DB	060H
	DB	068H
	DB	070H
	DB	078H
	DB	080H
	DB	088H
	DB	090H
	DB	094H
	DB	098H
	DB	09cH
	DB	0a0H
	DB	0a4H
	DB	0a8H
	DB	0acH
	DB	0b0H
	DB	0b4H
	DB	0b8H
	DB	0bcH
	DB	0c0H
	DB	0c2H
	DB	0c4H
	DB	0c6H
	DB	0c8H
	DB	0caH
	DB	0ccH
	DB	0ceH
	DB	0d0H
	DB	0d2H
	DB	0d4H
	DB	0d6H
	DB	0d8H
	DB	0daH
	DB	0dcH
	DB	0deH
	DB	0e0H
	DB	0e2H
	DB	0e4H
	DB	0e6H
	DB	0e8H
	DB	0eaH
	DB	0ecH
	DB	0eeH
	DB	0f0H
	DB	0f1H
	DB	0f2H
	DB	0f3H
	DB	0f4H
	DB	0f5H
	DB	0f6H
	DB	0f7H
	DB	0f8H
	DB	0f9H
	DB	0faH
	DB	0fbH
	DB	0fcH
	DB	0fdH
	DB	0feH
	DB	0ffH
?d_code@@3PAEA DB 00H					; d_code
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01bH
	DB	01bH
	DB	01cH
	DB	01cH
	DB	01dH
	DB	01dH
	DB	01eH
	DB	01eH
	DB	01fH
	DB	01fH
	DB	020H
	DB	020H
	DB	021H
	DB	021H
	DB	022H
	DB	022H
	DB	023H
	DB	023H
	DB	024H
	DB	024H
	DB	025H
	DB	025H
	DB	026H
	DB	026H
	DB	027H
	DB	027H
	DB	028H
	DB	028H
	DB	029H
	DB	029H
	DB	02aH
	DB	02aH
	DB	02bH
	DB	02bH
	DB	02cH
	DB	02cH
	DB	02dH
	DB	02dH
	DB	02eH
	DB	02eH
	DB	02fH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
?d_len@@3PAEA DB 03H					; d_len
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
PUBLIC	?reconst@@YAXXZ					; reconst
pdata	SEGMENT
$pdata$?reconst@@YAXXZ DD imagerel $LN26
	DD	imagerel $LN26+361
	DD	imagerel $unwind$?reconst@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?reconst@@YAXXZ DD 0a1401H
	DD	0f3414H
	DD	0f0103214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
xdata	ENDS
_TEXT	SEGMENT
i$1$ = 96
tv570 = 104
tv574 = 112
?reconst@@YAXXZ PROC					; reconst

; 395  : {

$LN26:
	mov	QWORD PTR [rsp+32], rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 396  :     int			i, j, k;
; 397  :     unsigned	f, l;
; 398  : 	
; 399  :     /* collect leaf nodes in the first half of the table */
; 400  :     /* and replace the freq by (freq + 1) / 2. */
; 401  :     j = 0;
; 402  :     for (i = 0; i < T; i++) {

	xor	r12d, r12d
	mov	r9d, 627				; 00000273H
	lea	r14, OFFSET FLAT:?son@@3PAHA		; son
	mov	QWORD PTR tv574[rsp], r12
	mov	ecx, r12d
	mov	edx, r12d
	lea	r10, OFFSET FLAT:?freq@@3PAIA		; freq
	npad	10
$LL15@reconst:

; 403  :         if (son[i] >= T) {

	mov	r8d, DWORD PTR [rcx+r14]
	cmp	r8d, 627				; 00000273H
	jl	SHORT $LN14@reconst

; 404  :             freq[j] = (freq[i] + 1) / 2;

	mov	eax, DWORD PTR [rcx+r10]

; 405  :             son[j] = son[i];

	mov	DWORD PTR [rdx+r14], r8d
	inc	eax
	shr	eax, 1
	add	rdx, 4
	mov	DWORD PTR [rdx+r10-4], eax
$LN14@reconst:

; 396  :     int			i, j, k;
; 397  :     unsigned	f, l;
; 398  : 	
; 399  :     /* collect leaf nodes in the first half of the table */
; 400  :     /* and replace the freq by (freq + 1) / 2. */
; 401  :     j = 0;
; 402  :     for (i = 0; i < T; i++) {

	add	rcx, 4
	dec	r9
	jne	SHORT $LL15@reconst

; 406  :             j++;
; 407  :         }
; 408  :     }
; 409  :     /* begin constructing tree by connecting sons */
; 410  :     for (i = 0, j = N_CHAR; j < T; i += 2, j++) {

	mov	edx, 314				; 0000013aH
	mov	DWORD PTR i$1$[rsp], r12d
	mov	r12, r10
	mov	QWORD PTR tv570[rsp], rdx
	mov	r15d, edx
$LL11@reconst:

; 411  :         k = i + 1;
; 412  :         f = freq[j] = freq[i] + freq[k];

	mov	r13d, DWORD PTR [r12+4]

; 413  :         for (k = j - 1; f < freq[k]; k--);

	lea	ecx, DWORD PTR [rdx-1]
	lea	rbp, QWORD PTR [r15-1]
	add	r13d, DWORD PTR [r12]
	mov	DWORD PTR [r10+r15*4], r13d
	cmp	r13d, DWORD PTR [r10+r15*4-4]
	jae	SHORT $LN6@reconst
	npad	5
$LL8@reconst:
	dec	rbp
	dec	ecx
	cmp	r13d, DWORD PTR [r10+rbp*4]
	jb	SHORT $LL8@reconst
$LN6@reconst:

; 414  :         k++;

	inc	ecx

; 415  :         l = (j - k) * sizeof(unsigned);

	mov	esi, edx
	sub	esi, ecx

; 416  :         memmove	(&freq[k + 1], &freq[k], l);

	lea	eax, DWORD PTR [rcx+1]
	movsxd	rdi, ecx
	movsxd	rbx, eax
	shl	esi, 2
	lea	rdx, QWORD PTR [r10+rdi*4]
	lea	rcx, QWORD PTR [r10+rbx*4]
	mov	r8d, esi
	call	QWORD PTR __imp_memmove

; 417  :         freq[k] = f;

	lea	rax, OFFSET FLAT:?freq@@3PAIA		; freq

; 418  :         memmove	(&son[k + 1], &son[k], l);

	lea	rdx, QWORD PTR [r14+rdi*4]
	lea	rcx, QWORD PTR [r14+rbx*4]
	mov	r8d, esi
	mov	DWORD PTR [rax+rbp*4+4], r13d
	call	QWORD PTR __imp_memmove

; 419  :         son[k] = i;

	mov	r8d, DWORD PTR i$1$[rsp]
	mov	rdx, QWORD PTR tv570[rsp]
	inc	edx
	mov	DWORD PTR [r14+rbp*4+4], r8d
	add	r8d, 2
	inc	r15
	add	r12, 8
	lea	r10, OFFSET FLAT:?freq@@3PAIA		; freq
	mov	DWORD PTR i$1$[rsp], r8d
	mov	QWORD PTR tv570[rsp], rdx
	cmp	r15, 627				; 00000273H
	jl	$LL11@reconst

; 420  :     }
; 421  :     /* connect prnt */
; 422  :     for (i = 0; i < T; i++) {

	mov	r12, QWORD PTR tv574[rsp]
	lea	rcx, OFFSET FLAT:?prnt@@3PAHA		; prnt
$LL5@reconst:

; 423  :         if ((k = son[i]) >= T) {

	movsxd	rax, DWORD PTR [r14]

; 424  :             prnt[k] = i;

	mov	DWORD PTR [rcx+rax*4], r12d
	cmp	eax, 627				; 00000273H

; 425  :         } else {

	jge	SHORT $LN4@reconst

; 426  :             prnt[k] = prnt[k + 1] = i;

	mov	DWORD PTR [rcx+rax*4+4], r12d
$LN4@reconst:

; 420  :     }
; 421  :     /* connect prnt */
; 422  :     for (i = 0; i < T; i++) {

	inc	r12d
	add	r14, 4
	cmp	r12d, 627				; 00000273H
	jl	SHORT $LL5@reconst

; 427  :         }
; 428  :     }
; 429  : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?reconst@@YAXXZ ENDP					; reconst
_TEXT	ENDS
PUBLIC	?StartHuff@@YAXXZ				; StartHuff
EXTRN	__ImageBase:BYTE
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?StartHuff@@YAXXZ PROC					; StartHuff

; 374  :     int i, j;
; 375  : 	
; 376  :     for (i = 0; i < N_CHAR; i++) {
; 377  :         freq[i]		= 1;

	lea	r11, OFFSET FLAT:?freq@@3PAIA		; freq
	xor	ecx, ecx
	mov	r8, 4294967297				; 0000000100000001H
	mov	rax, r11
	lea	edx, QWORD PTR [rcx+19]
	npad	7
$LL12@StartHuff:
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	add	rax, 64					; 00000040H
	dec	rdx
	mov	QWORD PTR [rax-40], r8
	mov	QWORD PTR [rax-32], r8
	mov	QWORD PTR [rax-24], r8
	mov	QWORD PTR [rax-16], r8
	mov	QWORD PTR [rax-8], r8
	jne	SHORT $LL12@StartHuff
	mov	QWORD PTR [rax], r8
	mov	QWORD PTR [rax+8], r8
	mov	QWORD PTR [rax+16], r8
	mov	QWORD PTR [rax+24], r8
	mov	QWORD PTR [rax+32], r8
	lea	r10, OFFSET FLAT:__ImageBase
	mov	r8d, 314				; 0000013aH
	npad	8
$LL5@StartHuff:

; 378  :         son	[i]		= i + T;

	lea	eax, DWORD PTR [rcx+627]

; 379  :         prnt[i + T] = i;

	mov	DWORD PTR ?prnt@@3PAHA[rdx+r10+2508], ecx
	inc	ecx
	mov	DWORD PTR ?son@@3PAHA[rdx+r10], eax
	add	rdx, 4
	cmp	ecx, r8d
	jl	SHORT $LL5@StartHuff

; 380  :     }
; 381  :     i = 0; j = N_CHAR;

	xor	r9d, r9d

; 382  :     while (j <= R) {

	xor	ecx, ecx
	xor	edx, edx
	npad	8
$LL2@StartHuff:

; 383  :         freq[j]		= freq[i] + freq[i + 1];

	mov	eax, DWORD PTR [rcx+r11+4]

; 384  :         son[j]		= i;
; 385  :         prnt[i]		= prnt[i + 1] = j;

	mov	DWORD PTR ?prnt@@3PAHA[rcx+r10+4], r8d
	mov	DWORD PTR ?prnt@@3PAHA[rcx+r10], r8d
	add	eax, DWORD PTR [rcx+r11]
	mov	DWORD PTR ?son@@3PAHA[rdx+r10+1256], r9d

; 386  :         i += 2; j++;

	inc	r8d
	mov	DWORD PTR [rdx+r11+1256], eax
	add	rdx, 4
	add	r9d, 2
	add	rcx, 8
	cmp	r8d, 626				; 00000272H
	jle	SHORT $LL2@StartHuff

; 387  :     }
; 388  :     freq[T] = 0xffff;

	mov	DWORD PTR ?freq@@3PAIA+2508, 65535	; 0000ffffH

; 389  :     prnt[R] = 0;

	mov	DWORD PTR ?prnt@@3PAHA+2504, 0

; 390  : }

	ret	0
?StartHuff@@YAXXZ ENDP					; StartHuff
_TEXT	ENDS
PUBLIC	?DeleteNode@@YAXH@Z				; DeleteNode
pdata	SEGMENT
$pdata$?DeleteNode@@YAXH@Z DD imagerel $LN15
	DD	imagerel $LN15+320
	DD	imagerel $unwind$?DeleteNode@@YAXH@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?DeleteNode@@YAXH@Z DD 040a01H
	DD	02740aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
p$ = 8
?DeleteNode@@YAXH@Z PROC				; DeleteNode

; 235  : {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi

; 236  :     int  q;
; 237  : 	
; 238  :     if (dad[p] == NIL)	return;	/* not registered */

	lea	rdi, OFFSET FLAT:__ImageBase
	movsxd	rbx, ecx
	cmp	DWORD PTR ?dad@@3PAHA[rdi+rbx*4], 4096	; 00001000H
	je	$LN12@DeleteNode

; 239  :     if (rson[p] == NIL)

	mov	r8d, DWORD PTR ?rson@@3PAHA[rdi+rbx*4]
	cmp	r8d, 4096				; 00001000H
	jne	SHORT $LN10@DeleteNode

; 240  : 		q = lson[p];

	mov	r8d, DWORD PTR ?lson@@3PAHA[rdi+rbx*4]

; 241  :     else 

	jmp	$LN7@DeleteNode
$LN10@DeleteNode:

; 242  : 	{
; 243  : 		if (lson[p] == NIL)

	movsxd	r11, DWORD PTR ?lson@@3PAHA[rdi+rbx*4]
	cmp	r11d, 4096				; 00001000H
	je	$LN7@DeleteNode

; 244  : 		{
; 245  : 			q = rson[p];
; 246  : 		}
; 247  : 		else 
; 248  : 		{
; 249  : 			q = lson[p];
; 250  : 			if (rson[q] != NIL) 

	lea	r10, QWORD PTR [r11*4]
	mov	r8, r11
	cmp	DWORD PTR ?rson@@3PAHA[r10+rdi], 4096	; 00001000H
	lea	rax, QWORD PTR ?rson@@3PAHA[r10+rdi]
	je	SHORT $LN6@DeleteNode
	npad	7
$LL5@DeleteNode:

; 251  : 			{
; 252  : 				do { q = rson[q]; } while (rson[q] != NIL);

	movsxd	r8, DWORD PTR [rax]
	cmp	DWORD PTR ?rson@@3PAHA[rdi+r8*4], 4096	; 00001000H
	lea	rax, QWORD PTR ?rson@@3PAHA[rdi+r8*4]
	jne	SHORT $LL5@DeleteNode

; 253  : 				
; 254  : 				rson[dad[q]]	= lson[q];

	lea	r10, QWORD PTR [r8*4]
	movsxd	rcx, DWORD PTR ?lson@@3PAHA[r10+rdi]
	movsxd	rdx, DWORD PTR ?dad@@3PAHA[r10+rdi]

; 255  : 				dad[lson[q]]	= dad[q];
; 256  : 				lson[q]			= lson[p];

	mov	DWORD PTR ?lson@@3PAHA[r10+rdi], r11d

; 257  : 				dad[lson[p]]	= q;

	movsxd	rax, DWORD PTR ?lson@@3PAHA[rdi+rbx*4]
	mov	DWORD PTR ?dad@@3PAHA[rdi+rcx*4], edx
	mov	DWORD PTR ?rson@@3PAHA[rdi+rdx*4], ecx
	mov	DWORD PTR ?dad@@3PAHA[rdi+rax*4], r8d
$LN6@DeleteNode:

; 258  : 			}
; 259  : 			rson[q]			= rson[p];

	mov	eax, DWORD PTR ?rson@@3PAHA[rdi+rbx*4]
	mov	DWORD PTR ?rson@@3PAHA[r10+rdi], eax

; 260  : 			dad[rson[p]]	= q;

	movsxd	rax, DWORD PTR ?rson@@3PAHA[rdi+rbx*4]
	mov	DWORD PTR ?dad@@3PAHA[rdi+rax*4], r8d
$LN7@DeleteNode:

; 261  : 		}
; 262  : 	}
; 263  : 	dad[q] = dad[p];

	mov	eax, DWORD PTR ?dad@@3PAHA[rdi+rbx*4]
	movsxd	rcx, r8d
	mov	DWORD PTR ?dad@@3PAHA[rdi+rcx*4], eax

; 264  : 	if (rson[dad[p]] == p)

	movsxd	rax, DWORD PTR ?dad@@3PAHA[rdi+rbx*4]
	cmp	DWORD PTR ?rson@@3PAHA[rdi+rax*4], ebx
	jne	SHORT $LN2@DeleteNode

; 265  : 		rson[dad[p]] = q;

	mov	DWORD PTR ?rson@@3PAHA[rdi+rax*4], r8d

; 266  : 	else

	jmp	SHORT $LN1@DeleteNode
$LN2@DeleteNode:

; 267  : 		lson[dad[p]] = q;

	mov	DWORD PTR ?lson@@3PAHA[rdi+rax*4], r8d
$LN1@DeleteNode:

; 268  : 	dad[p] = NIL;

	mov	DWORD PTR ?dad@@3PAHA[rdi+rbx*4], 4096	; 00001000H
$LN12@DeleteNode:

; 269  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
?DeleteNode@@YAXH@Z ENDP				; DeleteNode
_TEXT	ENDS
PUBLIC	?InsertNode@@YAXH@Z				; InsertNode
pdata	SEGMENT
$pdata$?InsertNode@@YAXH@Z DD imagerel $LN31
	DD	imagerel $LN31+506
	DD	imagerel $unwind$?InsertNode@@YAXH@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?InsertNode@@YAXH@Z DD 0a1801H
	DD	067418H
	DD	056418H
	DD	045418H
	DD	033418H
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
r$ = 24
?InsertNode@@YAXH@Z PROC				; InsertNode

; 178  : {

$LN31:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r13

; 179  :     int				i, p, cmp;
; 180  :     u8			*key;
; 181  :     unsigned		c;
; 182  : 	
; 183  :     cmp = 1;
; 184  :     key = &text_buf[r];
; 185  :     p = N + 1 + key[0];
; 186  :     rson[r] = lson[r] = NIL;
; 187  :     match_length = 0;

	mov	r9d, DWORD PTR ?match_position@@3HA	; match_position
	lea	r13, OFFSET FLAT:__ImageBase
	movsxd	rsi, ecx
	movzx	r10d, BYTE PTR ?text_buf@@3PAEA[rsi+r13]
	lea	rbp, QWORD PTR ?text_buf@@3PAEA[rsi+r13]
	mov	r8d, 1
	add	r10d, 4097				; 00001001H
	xor	edi, edi
	mov	DWORD PTR ?lson@@3PAHA[r13+rsi*4], 4096	; 00001000H
	mov	DWORD PTR ?match_length@@3HA, edi	; match_length
	mov	DWORD PTR ?rson@@3PAHA[r13+rsi*4], 4096	; 00001000H
$LL19@InsertNode:

; 188  :     for ( ; ; ) {
; 189  :         if (cmp >= 0) {
; 190  :             if (rson[p] != NIL)

	movsxd	rax, r10d
	test	r8d, r8d
	js	SHORT $LN17@InsertNode
	mov	ecx, DWORD PTR ?rson@@3PAHA[r13+rax*4]
	cmp	ecx, 4096				; 00001000H
	jne	SHORT $LN28@InsertNode

; 191  :                 p = rson[p];
; 192  :             else {
; 193  :                 rson[p] = r;

	movsxd	rax, r10d
	mov	DWORD PTR ?rson@@3PAHA[r13+rax*4], esi

; 194  :                 dad[r] = p;
; 195  :                 return;

	jmp	$LN30@InsertNode
$LN17@InsertNode:

; 196  :             }
; 197  :         } else {
; 198  :             if (lson[p] != NIL)

	mov	ecx, DWORD PTR ?lson@@3PAHA[r13+rax*4]
	cmp	ecx, 4096				; 00001000H
	je	$LN13@InsertNode
$LN28@InsertNode:

; 203  :                 return;
; 204  :             }
; 205  :         }
; 206  :         for (i = 1; i < F; i++)

	movsxd	rax, ecx
	mov	r11, rbp
	mov	r10d, ecx
	sub	rax, rbp
	mov	edx, 1
	lea	rcx, QWORD PTR [rbp+1]
	lea	rbx, QWORD PTR ?text_buf@@3PAEA[rax+r13]
	neg	r11
$LL11@InsertNode:

; 207  :             if ((cmp = key[i] - text_buf[p + i]) != 0)

	movzx	eax, BYTE PTR [rbx+rcx]
	movzx	r8d, BYTE PTR [rcx]
	sub	r8d, eax
	jne	SHORT $LN24@InsertNode

; 203  :                 return;
; 204  :             }
; 205  :         }
; 206  :         for (i = 1; i < F; i++)

	inc	rcx
	inc	edx
	lea	rax, QWORD PTR [r11+rcx]
	cmp	rax, 60					; 0000003cH
	jl	SHORT $LL11@InsertNode
$LN24@InsertNode:

; 208  :                 break;
; 209  : 			if (i > THRESHOLD) {

	cmp	edx, 2
	jle	SHORT $LL19@InsertNode

; 210  : 				if (i > match_length) {

	cmp	edx, edi
	jle	$LN29@InsertNode

; 211  : 					match_position = ((r - p) & (N - 1)) - 1;

	mov	r9d, esi

; 212  : 					if ((match_length = i) >= F)

	mov	edi, edx
	mov	DWORD PTR ?match_length@@3HA, edx	; match_length
	sub	r9d, r10d
	and	r9d, 4095				; 00000fffH
	dec	r9d
	mov	DWORD PTR ?match_position@@3HA, r9d	; match_position
	cmp	edx, 60					; 0000003cH
	jl	$LN27@InsertNode

; 222  :     dad[r]  = dad[p];

	movsxd	rcx, r10d
	mov	eax, DWORD PTR ?dad@@3PAHA[r13+rcx*4]
	mov	DWORD PTR ?dad@@3PAHA[r13+rsi*4], eax

; 223  :     lson[r] = lson[p];

	mov	eax, DWORD PTR ?lson@@3PAHA[r13+rcx*4]
	mov	DWORD PTR ?lson@@3PAHA[r13+rsi*4], eax

; 224  :     rson[r] = rson[p];

	mov	eax, DWORD PTR ?rson@@3PAHA[r13+rcx*4]
	mov	DWORD PTR ?rson@@3PAHA[r13+rsi*4], eax

; 225  :     dad[lson[p]] = r;

	movsxd	rax, DWORD PTR ?lson@@3PAHA[r13+rcx*4]
	mov	DWORD PTR ?dad@@3PAHA[r13+rax*4], esi

; 226  :     dad[rson[p]] = r;

	movsxd	rax, DWORD PTR ?rson@@3PAHA[r13+rcx*4]
	mov	DWORD PTR ?dad@@3PAHA[r13+rax*4], esi

; 227  :     if (rson[dad[p]] == p)

	movsxd	rax, DWORD PTR ?dad@@3PAHA[r13+rcx*4]
	cmp	DWORD PTR ?rson@@3PAHA[r13+rax*4], r10d
	jne	SHORT $LN2@InsertNode

; 228  :         rson[dad[p]] = r;

	mov	DWORD PTR ?rson@@3PAHA[r13+rax*4], esi

; 231  :     dad[p] = NIL; /* remove p */

	mov	DWORD PTR ?dad@@3PAHA[r13+rcx*4], 4096	; 00001000H
	jmp	SHORT $LN20@InsertNode
$LN29@InsertNode:

; 213  : 						break;
; 214  : 				}
; 215  : 				if (i == match_length) {

	jne	$LL19@InsertNode
$LN27@InsertNode:

; 216  : 					if ((c = ((r - p) & (N-1)) - 1) < (unsigned)match_position) {

	mov	eax, esi
	sub	eax, r10d
	and	eax, 4095				; 00000fffH
	dec	eax
	cmp	eax, r9d
	jae	$LL19@InsertNode

; 217  : 						match_position = c;

	mov	r9d, eax
	mov	DWORD PTR ?match_position@@3HA, eax	; match_position

; 218  : 					}
; 219  : 				}
; 220  : 			}
; 221  :     }

	jmp	$LL19@InsertNode
$LN2@InsertNode:

; 229  :     else
; 230  :         lson[dad[p]] = r;

	mov	DWORD PTR ?lson@@3PAHA[r13+rax*4], esi

; 231  :     dad[p] = NIL; /* remove p */

	mov	DWORD PTR ?dad@@3PAHA[r13+rcx*4], 4096	; 00001000H
	jmp	SHORT $LN20@InsertNode
$LN13@InsertNode:

; 199  :                 p = lson[p];
; 200  :             else {
; 201  :                 lson[p] = r;

	movsxd	rax, r10d
	mov	DWORD PTR ?lson@@3PAHA[r13+rax*4], esi
$LN30@InsertNode:

; 202  :                 dad[r] = p;

	mov	DWORD PTR ?dad@@3PAHA[r13+rsi*4], r10d
$LN20@InsertNode:

; 232  : }

	mov	rbx, QWORD PTR [rsp+24]
	mov	rbp, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+40]
	mov	rdi, QWORD PTR [rsp+48]
	pop	r13
	pop	r12
	ret	0
?InsertNode@@YAXH@Z ENDP				; InsertNode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?InitTree@@YAXXZ
_TEXT	SEGMENT
?InitTree@@YAXXZ PROC					; InitTree, COMDAT

; 171  :     int  i;
; 172  : 	
; 173  :     for (i = N + 1; i <= N + 256; i++)	        rson[i] = NIL;        /* root */

	lea	rax, OFFSET FLAT:?rson@@3PAHA+16388
	mov	ecx, 32					; 00000020H
	npad	4
$LL14@InitTree:
	mov	DWORD PTR [rax], 4096			; 00001000H
	mov	DWORD PTR [rax+4], 4096			; 00001000H
	mov	DWORD PTR [rax+8], 4096			; 00001000H
	add	rax, 32					; 00000020H
	dec	rcx
	mov	DWORD PTR [rax-20], 4096		; 00001000H
	mov	DWORD PTR [rax-16], 4096		; 00001000H
	mov	DWORD PTR [rax-12], 4096		; 00001000H
	mov	DWORD PTR [rax-8], 4096			; 00001000H
	mov	DWORD PTR [rax-4], 4096			; 00001000H
	jne	SHORT $LL14@InitTree

; 174  :     for (i = 0; i < N; i++)						dad[i] = NIL;         /* node */

	mov	rdx, 17592186048512			; 0000100000001000H
	lea	rax, OFFSET FLAT:?dad@@3PAHA		; dad
	mov	ecx, 256				; 00000100H
	npad	10
$LL13@InitTree:
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
	add	rax, 64					; 00000040H
	dec	rcx
	mov	QWORD PTR [rax-40], rdx
	mov	QWORD PTR [rax-32], rdx
	mov	QWORD PTR [rax-24], rdx
	mov	QWORD PTR [rax-16], rdx
	mov	QWORD PTR [rax-8], rdx
	jne	SHORT $LL13@InitTree

; 175  : }

	fatret	0
?InitTree@@YAXXZ ENDP					; InitTree
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?OutPointer@LZfs@@QEAAPEAEXZ
_TEXT	SEGMENT
?OutPointer@LZfs@@QEAAPEAEXZ PROC			; LZfs::OutPointer, COMDAT

; 105  : 		return out_start;

	mov	rax, QWORD PTR fs+40

; 106  : 	}

	ret	0
?OutPointer@LZfs@@QEAAPEAEXZ ENDP			; LZfs::OutPointer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?OutSize@LZfs@@QEAAIXZ
_TEXT	SEGMENT
?OutSize@LZfs@@QEAAIXZ PROC				; LZfs::OutSize, COMDAT

; 102  : 		return u32(out_iterator-out_start);

	mov	rax, QWORD PTR fs+56
	sub	rax, QWORD PTR fs+40

; 103  : 	}

	ret	0
?OutSize@LZfs@@QEAAIXZ ENDP				; LZfs::OutSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?InputSize@LZfs@@QEAAIXZ
_TEXT	SEGMENT
?InputSize@LZfs@@QEAAIXZ PROC				; LZfs::InputSize, COMDAT

; 99   : 		return u32(in_end-in_start);

	mov	rax, QWORD PTR fs+24
	sub	rax, QWORD PTR fs+16

; 100  : 	}

	ret	0
?InputSize@LZfs@@QEAAIXZ ENDP				; LZfs::InputSize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init_Input@LZfs@@QEAAXPEAE0@Z
_TEXT	SEGMENT
_start$ = 8
_end$ = 16
?Init_Input@LZfs@@QEAAXPEAE0@Z PROC			; LZfs::Init_Input, COMDAT

; 84   : 		// input
; 85   : 		in_start	= _start;
; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;
; 88   : 		
; 89   : 		// bitwise input/output
; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	xor	eax, eax
	mov	QWORD PTR fs+16, rcx
	mov	QWORD PTR fs+24, rdx
	mov	QWORD PTR fs+8, rax
	mov	QWORD PTR fs, rax
	mov	QWORD PTR fs+32, rcx

; 91   : 	}

	ret	0
?Init_Input@LZfs@@QEAAXPEAE0@Z ENDP			; LZfs::Init_Input
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0LZfs@@QEAA@XZ
_TEXT	SEGMENT
??0LZfs@@QEAA@XZ PROC					; LZfs::LZfs, COMDAT

; 79   : 		in_start	= in_end	= in_iterator = 0;

	xor	eax, eax
	mov	QWORD PTR fs+32, rax
	mov	QWORD PTR fs+24, rax
	mov	QWORD PTR fs+16, rax

; 80   : 		out_start	= out_end	= out_iterator = 0;

	mov	QWORD PTR fs+56, rax
	mov	QWORD PTR fs+48, rax
	mov	QWORD PTR fs+40, rax

; 81   : 	}

	lea	rax, OFFSET FLAT:fs
	ret	0
??0LZfs@@QEAA@XZ ENDP					; LZfs::LZfs
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_getb@LZfs@@QEAAHXZ
_TEXT	SEGMENT
?_getb@LZfs@@QEAAHXZ PROC				; LZfs::_getb, COMDAT

; 65   : 		if (in_iterator==in_end) return EOF;

	mov	rcx, QWORD PTR fs+32
	cmp	rcx, QWORD PTR fs+24
	jne	SHORT $LN1@getb
	or	eax, -1

; 67   : 	}

	ret	0
$LN1@getb:

; 66   : 		return *in_iterator++;

	movzx	eax, BYTE PTR [rcx]
	inc	rcx
	mov	QWORD PTR fs+32, rcx

; 67   : 	}

	ret	0
?_getb@LZfs@@QEAAHXZ ENDP				; LZfs::_getb
PUBLIC	?update@@YAXH@Z					; update
pdata	SEGMENT
$pdata$?update@@YAXH@Z DD imagerel $LN14
	DD	imagerel $LN14+245
	DD	imagerel $unwind$?update@@YAXH@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?update@@YAXH@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
c$ = 48
?update@@YAXH@Z PROC					; update

; 434  : {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H

; 435  :     int i, j, k, l;
; 436  : 	
; 437  :     if (freq[R] == MAX_FREQ) {

	cmp	DWORD PTR ?freq@@3PAIA+2504, 16384	; 00004000H
	movsxd	rbx, ecx
	jne	SHORT $LN9@update@2

; 438  :         reconst();

	call	?reconst@@YAXXZ				; reconst
$LN9@update@2:

; 439  :     }
; 440  :     c = prnt[c + T];

	lea	r11, OFFSET FLAT:__ImageBase
	mov	r8d, DWORD PTR ?prnt@@3PAHA[r11+rbx*4+2508]
	npad	7
$LL8@update@2:

; 441  :     do {
; 442  :         k = ++freq[c];

	movsxd	r10, r8d

; 443  : 		
; 444  :         /* if the order is disturbed, exchange nodes */
; 445  :         if ((unsigned)k > freq[l = c + 1]) {

	lea	edx, DWORD PTR [r8+1]
	inc	DWORD PTR ?freq@@3PAIA[r11+r10*4]
	mov	r9d, DWORD PTR ?freq@@3PAIA[r11+r10*4]
	movsxd	rax, edx
	cmp	r9d, DWORD PTR ?freq@@3PAIA[r11+rax*4]
	lea	rcx, QWORD PTR ?freq@@3PAIA[r11+rax*4]
	jbe	SHORT $LN7@update@2
	npad	4
$LL4@update@2:

; 446  :             while ((unsigned)k > freq[++l]);

	add	rcx, 4
	inc	edx
	cmp	r9d, DWORD PTR [rcx]
	ja	SHORT $LL4@update@2

; 447  :             l--;

	dec	edx

; 448  :             freq[c] = freq[l];

	movsxd	rcx, edx
	mov	eax, DWORD PTR ?freq@@3PAIA[r11+rcx*4]
	mov	DWORD PTR ?freq@@3PAIA[r11+r10*4], eax

; 449  :             freq[l] = k;

	mov	DWORD PTR ?freq@@3PAIA[r11+rcx*4], r9d

; 450  : 			
; 451  :             i = son[c];

	movsxd	r9, DWORD PTR ?son@@3PAHA[r11+r10*4]

; 452  :             prnt[i] = l;

	mov	DWORD PTR ?prnt@@3PAHA[r11+r9*4], edx

; 453  :             if (i < T) prnt[i + 1] = l;

	cmp	r9d, 627				; 00000273H
	jge	SHORT $LN2@update@2
	mov	DWORD PTR ?prnt@@3PAHA[r11+r9*4+4], edx
$LN2@update@2:

; 454  : 			
; 455  :             j = son[l];

	movsxd	rax, DWORD PTR ?son@@3PAHA[r11+rcx*4]

; 456  :             son[l] = i;

	mov	DWORD PTR ?son@@3PAHA[r11+rcx*4], r9d

; 457  : 			
; 458  :             prnt[j] = c;

	mov	DWORD PTR ?prnt@@3PAHA[r11+rax*4], r8d

; 459  :             if (j < T) prnt[j + 1] = c;

	cmp	eax, 627				; 00000273H
	jge	SHORT $LN1@update@2
	mov	DWORD PTR ?prnt@@3PAHA[r11+rax*4+4], r8d
$LN1@update@2:

; 460  :             son[c] = j;

	mov	DWORD PTR ?son@@3PAHA[r11+r10*4], eax

; 461  : 			
; 462  :             c = l;

	mov	r8d, edx
$LN7@update@2:

; 463  :         }
; 464  :     } while ((c = prnt[c]) != 0); /* repeat up to root */

	movsxd	rax, r8d
	mov	r8d, DWORD PTR ?prnt@@3PAHA[r11+rax*4]
	test	r8d, r8d
	jne	$LL8@update@2

; 465  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?update@@YAXH@Z ENDP					; update
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetByte@LZfs@@QEAAHXZ DD imagerel $LN12
	DD	imagerel $LN12+38
	DD	imagerel $unwind$?GetByte@LZfs@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetByte@LZfs@@QEAAHXZ DD imagerel $LN12+38
	DD	imagerel $LN12+122
	DD	imagerel $chain$0$?GetByte@LZfs@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetByte@LZfs@@QEAAHXZ DD imagerel $LN12+122
	DD	imagerel $LN12+158
	DD	imagerel $chain$1$?GetByte@LZfs@@QEAAHXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetByte@LZfs@@QEAAHXZ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+38
	DD	imagerel $unwind$?GetByte@LZfs@@QEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetByte@LZfs@@QEAAHXZ DD 020421H
	DD	03404H
	DD	imagerel $LN12
	DD	imagerel $LN12+38
	DD	imagerel $unwind$?GetByte@LZfs@@QEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetByte@LZfs@@QEAAHXZ DD 010401H
	DD	0204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?GetByte@LZfs@@QEAAHXZ
_TEXT	SEGMENT
?GetByte@LZfs@@QEAAHXZ PROC				; LZfs::GetByte, COMDAT

; 129  : 	{

$LN12:
	sub	rsp, 8

; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {

	mov	r9d, DWORD PTR fs+4
	mov	r10d, DWORD PTR fs
	cmp	r9d, 8
	ja	SHORT $LN2@GetByte
	mov	r11, QWORD PTR fs+24
	mov	rdx, QWORD PTR fs+32
	mov	QWORD PTR [rsp], rbx
	xor	ebx, ebx
	npad	4
$LL3@GetByte:

; 133  : 			if ((int)(i = _getb()) < 0) i = 0;

	cmp	rdx, r11
	jne	SHORT $LN6@GetByte
	or	r8d, -1
	jmp	SHORT $LN7@GetByte
$LN6@GetByte:
	movzx	r8d, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR fs+32, rdx
$LN7@GetByte:
	test	r8d, r8d

; 134  : 			getbuf |= i << (8 - getlen);

	mov	ecx, 8
	cmovs	r8d, ebx
	sub	ecx, r9d

; 135  : 			getlen += 8;

	add	r9d, 8
	shl	r8d, cl
	mov	DWORD PTR fs+4, r9d
	or	r10d, r8d
	mov	DWORD PTR fs, r10d
	cmp	r9d, 8
	jbe	SHORT $LL3@GetByte
	mov	rbx, QWORD PTR [rsp]
$LN2@GetByte:

; 136  : 		}
; 137  : 		i = getbuf;

	mov	eax, r10d

; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;

	add	r9d, -8					; fffffff8H
	shl	r10d, 8

; 140  : 		return (int)((i & 0xff00) >> 8);

	shr	eax, 8
	mov	DWORD PTR fs, r10d
	mov	DWORD PTR fs+4, r9d
	movzx	eax, al

; 141  : 	}

	add	rsp, 8
	ret	0
?GetByte@LZfs@@QEAAHXZ ENDP				; LZfs::GetByte
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetBit@LZfs@@QEAAHXZ DD imagerel $LN12
	DD	imagerel $LN12+38
	DD	imagerel $unwind$?GetBit@LZfs@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?GetBit@LZfs@@QEAAHXZ DD imagerel $LN12+38
	DD	imagerel $LN12+122
	DD	imagerel $chain$0$?GetBit@LZfs@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?GetBit@LZfs@@QEAAHXZ DD imagerel $LN12+122
	DD	imagerel $LN12+156
	DD	imagerel $chain$1$?GetBit@LZfs@@QEAAHXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?GetBit@LZfs@@QEAAHXZ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+38
	DD	imagerel $unwind$?GetBit@LZfs@@QEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?GetBit@LZfs@@QEAAHXZ DD 020421H
	DD	03404H
	DD	imagerel $LN12
	DD	imagerel $LN12+38
	DD	imagerel $unwind$?GetBit@LZfs@@QEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetBit@LZfs@@QEAAHXZ DD 010401H
	DD	0204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?GetBit@LZfs@@QEAAHXZ
_TEXT	SEGMENT
?GetBit@LZfs@@QEAAHXZ PROC				; LZfs::GetBit, COMDAT

; 114  : 	{

$LN12:
	sub	rsp, 8

; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {

	mov	r9d, DWORD PTR fs+4
	mov	r10d, DWORD PTR fs
	cmp	r9d, 8
	ja	SHORT $LN2@GetBit
	mov	r11, QWORD PTR fs+24
	mov	rdx, QWORD PTR fs+32
	mov	QWORD PTR [rsp], rbx
	xor	ebx, ebx
	npad	4
$LL3@GetBit:

; 118  : 			if ((int)(i = _getb()) < 0) i = 0;

	cmp	rdx, r11
	jne	SHORT $LN6@GetBit
	or	r8d, -1
	jmp	SHORT $LN7@GetBit
$LN6@GetBit:
	movzx	r8d, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR fs+32, rdx
$LN7@GetBit:
	test	r8d, r8d

; 119  : 			getbuf |= i << (8 - getlen);

	mov	ecx, 8
	cmovs	r8d, ebx
	sub	ecx, r9d

; 120  : 			getlen += 8;

	add	r9d, 8
	shl	r8d, cl
	mov	DWORD PTR fs+4, r9d
	or	r10d, r8d
	mov	DWORD PTR fs, r10d
	cmp	r9d, 8
	jbe	SHORT $LL3@GetBit
	mov	rbx, QWORD PTR [rsp]
$LN2@GetBit:

; 121  : 		}
; 122  : 		i = getbuf;

	mov	eax, r10d

; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;

	dec	r9d
	add	r10d, r10d

; 125  : 		return (int)((i & 0x8000) >> 15);

	shr	eax, 15
	mov	DWORD PTR fs, r10d
	mov	DWORD PTR fs+4, r9d
	and	eax, 1

; 126  : 	}

	add	rsp, 8
	ret	0
?GetBit@LZfs@@QEAAHXZ ENDP				; LZfs::GetBit
PUBLIC	?DecodePosition@@YAHXZ				; DecodePosition
pdata	SEGMENT
$pdata$?DecodePosition@@YAHXZ DD imagerel $LN8
	DD	imagerel $LN8+88
	DD	imagerel $unwind$?DecodePosition@@YAHXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?DecodePosition@@YAHXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
?DecodePosition@@YAHXZ PROC				; DecodePosition

; 523  : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 524  :     unsigned i, j, c;
; 525  : 	
; 526  :     /* recover upper 6 bits from table */
; 527  :     i = fs.GetByte();

	call	?GetByte@LZfs@@QEAAHXZ			; LZfs::GetByte
	mov	ebx, eax

; 528  :     c = (unsigned)d_code[i] << 6;

	lea	rax, OFFSET FLAT:__ImageBase
	movzx	esi, BYTE PTR ?d_code@@3PAEA[rbx+rax]

; 529  :     j = d_len[i];
; 530  : 	
; 531  :     /* read lower 6 bits verbatim */
; 532  :     j -= 2;

	movzx	edi, BYTE PTR ?d_len@@3PAEA[rbx+rax]
	shl	esi, 6
	sub	edi, 2

; 533  :     while (j--) {

	je	SHORT $LN6@DecodePosi
$LL2@DecodePosi:

; 534  :         i = (i << 1) + fs.GetBit();

	call	?GetBit@LZfs@@QEAAHXZ			; LZfs::GetBit
	dec	edi
	lea	ebx, DWORD PTR [rax+rbx*2]
	jne	SHORT $LL2@DecodePosi
$LN6@DecodePosi:

; 535  :     }
; 536  :     return (int)(c | (i & 0x3f));

	and	ebx, 63					; 0000003fH
	or	ebx, esi

; 537  : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?DecodePosition@@YAHXZ ENDP				; DecodePosition
_TEXT	ENDS
PUBLIC	?DecodeChar@@YAHXZ				; DecodeChar
pdata	SEGMENT
$pdata$?DecodeChar@@YAHXZ DD imagerel $LN7
	DD	imagerel $LN7+20
	DD	imagerel $unwind$?DecodeChar@@YAHXZ
$pdata$0$?DecodeChar@@YAHXZ DD imagerel $LN7+20
	DD	imagerel $LN7+55
	DD	imagerel $chain$0$?DecodeChar@@YAHXZ
$pdata$1$?DecodeChar@@YAHXZ DD imagerel $LN7+55
	DD	imagerel $LN7+76
	DD	imagerel $chain$1$?DecodeChar@@YAHXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?DecodeChar@@YAHXZ DD 020601H
	DD	030023206H
$chain$0$?DecodeChar@@YAHXZ DD 020521H
	DD	067405H
	DD	imagerel $LN7
	DD	imagerel $LN7+20
	DD	imagerel $unwind$?DecodeChar@@YAHXZ
$chain$1$?DecodeChar@@YAHXZ DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+20
	DD	imagerel $unwind$?DecodeChar@@YAHXZ
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
?DecodeChar@@YAHXZ PROC					; DecodeChar

; 505  : {

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H

; 506  :     unsigned c;
; 507  : 	
; 508  :     c = son[R];

	mov	ebx, DWORD PTR ?son@@3PAHA+2504

; 509  : 	
; 510  :     /* travel from root to leaf, */
; 511  :     /* choosing the smaller child node (son[]) if the read bit is 0, */
; 512  :     /* the bigger (son[]+1} if 1 */
; 513  :     while (c < T) {

	cmp	ebx, 627				; 00000273H
	jae	SHORT $LN1@DecodeChar
	mov	QWORD PTR [rsp+48], rdi
	lea	rdi, OFFSET FLAT:?son@@3PAHA		; son
$LL2@DecodeChar:

; 514  :         c += fs.GetBit();

	call	?GetBit@LZfs@@QEAAHXZ			; LZfs::GetBit
	add	ebx, eax

; 515  :         c = son[c];

	mov	ebx, DWORD PTR [rdi+rbx*4]
	cmp	ebx, 627				; 00000273H
	jb	SHORT $LL2@DecodeChar
	mov	rdi, QWORD PTR [rsp+48]
$LN1@DecodeChar:

; 516  :     }
; 517  :     c -= T;

	add	ebx, -627				; fffffd8dH

; 518  :     update(c);

	mov	ecx, ebx
	call	?update@@YAXH@Z				; update

; 519  :     return (int)c;

	mov	eax, ebx

; 520  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?DecodeChar@@YAHXZ ENDP					; DecodeChar
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ?xr_realloc@@YAPEAXPEAX_K@Z
_TEXT	SEGMENT
P$ = 8
size$ = 16
?xr_realloc@@YAPEAXPEAX_K@Z PROC			; xr_realloc, COMDAT

; 111  : 	IC void*	xr_realloc	(void* P, size_t size)	{	return Memory.mem_realloc(P,size);				}

	mov	r8, rdx
	mov	rdx, rcx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	jmp	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
?xr_realloc@@YAPEAXPEAX_K@Z ENDP			; xr_realloc
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Init_Output@LZfs@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$?Init_Output@LZfs@@QEAAXH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Init_Output@LZfs@@QEAAXH@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
xdata	ENDS
;	COMDAT ?Init_Output@LZfs@@QEAAXH@Z
_TEXT	SEGMENT
_rsize$ = 48
?Init_Output@LZfs@@QEAAXH@Z PROC			; LZfs::Init_Output, COMDAT

; 92   : 	IC void		Init_Output(int _rsize) {

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H

; 93   : 		// output
; 94   : 		out_start	= (u8*)xr_malloc(_rsize);

	movsxd	rbx, ecx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	rdx, rbx
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	QWORD PTR fs+40, rax

; 95   : 		out_end		= out_start + _rsize;
; 96   : 		out_iterator= out_start;

	mov	QWORD PTR fs+56, rax
	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR fs+48, rcx

; 97   : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?Init_Output@LZfs@@QEAAXH@Z ENDP			; LZfs::Init_Output
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
pdata	SEGMENT
$pdata$?_putb@LZfs@@QEAAXH@Z DD imagerel $LN8
	DD	imagerel $LN8+133
	DD	imagerel $unwind$?_putb@LZfs@@QEAAXH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_putb@LZfs@@QEAAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
xdata	ENDS
;	COMDAT ?_putb@LZfs@@QEAAXH@Z
_TEXT	SEGMENT
c$ = 48
?_putb@LZfs@@QEAAXH@Z PROC				; LZfs::_putb, COMDAT

; 68   : 	IC void		_putb(int c) {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 69   : 		if (out_iterator==out_end) {

	mov	rax, QWORD PTR fs+56
	mov	rbx, QWORD PTR fs+48
	mov	edi, ecx
	cmp	rax, rbx
	jne	SHORT $LN6@putb

; 70   : 			u32	out_size= u32(out_end-out_start);

	mov	rdx, QWORD PTR fs+40

; 71   : 			out_start	= (u8*) xr_realloc(out_start,out_size+1024);

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	sub	ebx, edx
	lea	r8d, DWORD PTR [rbx+1024]
	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc

; 72   : 			out_iterator= out_start+out_size;

	mov	ecx, ebx
	add	rcx, rax
	mov	QWORD PTR fs+40, rax
	mov	QWORD PTR fs+56, rcx

; 73   : 			out_end		= out_iterator+1024;

	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+48, rax

; 74   : 		}
; 75   : 		*out_iterator++ = u8(c&0xFF);

	mov	BYTE PTR [rcx], dil
	inc	QWORD PTR fs+56

; 76   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@putb:
	mov	rbx, QWORD PTR [rsp+48]
	mov	BYTE PTR [rax], cl
	inc	QWORD PTR fs+56
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_putb@LZfs@@QEAAXH@Z ENDP				; LZfs::_putb
PUBLIC	?Decode@@YAXXZ					; Decode
pdata	SEGMENT
$pdata$?Decode@@YAXXZ DD imagerel $LN58
	DD	imagerel $LN58+139
	DD	imagerel $unwind$?Decode@@YAXXZ
$pdata$3$?Decode@@YAXXZ DD imagerel $LN58+139
	DD	imagerel $LN58+248
	DD	imagerel $chain$3$?Decode@@YAXXZ
$pdata$7$?Decode@@YAXXZ DD imagerel $LN58+248
	DD	imagerel $LN58+726
	DD	imagerel $chain$7$?Decode@@YAXXZ
$pdata$8$?Decode@@YAXXZ DD imagerel $LN58+726
	DD	imagerel $LN58+753
	DD	imagerel $chain$8$?Decode@@YAXXZ
$pdata$9$?Decode@@YAXXZ DD imagerel $LN58+753
	DD	imagerel $LN58+758
	DD	imagerel $chain$9$?Decode@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?Decode@@YAXXZ DD 010401H
	DD	08204H
$chain$3$?Decode@@YAXXZ DD 082121H
	DD	05e421H
	DD	06d41cH
	DD	0b540dH
	DD	0a3405H
	DD	imagerel $LN58
	DD	imagerel $LN58+139
	DD	imagerel $unwind$?Decode@@YAXXZ
$chain$7$?Decode@@YAXXZ DD 081421H
	DD	04f414H
	DD	07c40fH
	DD	08740aH
	DD	0c6405H
	DD	imagerel $LN58+139
	DD	imagerel $LN58+248
	DD	imagerel $chain$3$?Decode@@YAXXZ
$chain$8$?Decode@@YAXXZ DD 021H
	DD	imagerel $LN58+139
	DD	imagerel $LN58+248
	DD	imagerel $chain$3$?Decode@@YAXXZ
$chain$9$?Decode@@YAXXZ DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+139
	DD	imagerel $unwind$?Decode@@YAXXZ
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
?Decode@@YAXXZ PROC					; Decode

; 600  : {

$LN58:
	sub	rsp, 72					; 00000048H

; 601  :     int  i, j, k, r, c;
; 602  :     unsigned int  count;
; 603  : 	
; 604  :     textsize =  (fs._getb());

	mov	rax, QWORD PTR fs+32
	mov	r8, QWORD PTR fs+24
	or	edx, -1
	cmp	rax, r8
	jne	SHORT $LN14@Decode
	mov	r9d, edx
	jmp	SHORT $LN15@Decode
$LN14@Decode:
	movzx	r9d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
$LN15@Decode:

; 605  :     textsize |= (fs._getb() << 8);

	cmp	rax, r8
	jne	SHORT $LN17@Decode
	mov	ecx, edx
	jmp	SHORT $LN18@Decode
$LN17@Decode:
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
$LN18@Decode:
	shl	ecx, 8
	or	ecx, r9d

; 606  :     textsize |= (fs._getb() << 16);

	cmp	rax, r8
	jne	SHORT $LN20@Decode
	mov	r9d, edx
	jmp	SHORT $LN21@Decode
$LN20@Decode:
	movzx	r9d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
$LN21@Decode:
	shl	r9d, 16
	or	ecx, r9d

; 607  :     textsize |= (fs._getb() << 24);

	cmp	rax, r8
	je	SHORT $LN24@Decode
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
$LN24@Decode:
	shl	edx, 24
	or	ecx, edx
	mov	DWORD PTR ?textsize@@3IA, ecx		; textsize

; 608  :     if (textsize == 0) return;

	je	$LN12@Decode

; 609  : 	
; 610  : 	fs.Init_Output(textsize);

	mov	QWORD PTR [rsp+80], rbx
	movsxd	rbx, ecx
	mov	QWORD PTR [rsp+88], rbp
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	rdx, rbx
	mov	QWORD PTR [rsp+48], r13
	mov	QWORD PTR [rsp+40], r14
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR fs+40, rax
	mov	QWORD PTR fs+56, rax
	mov	QWORD PTR fs+48, rcx

; 611  : 	
; 612  :     StartHuff();

	call	?StartHuff@@YAXXZ			; StartHuff

; 613  :     for (i = 0; i < N - F; i++)
; 614  :         text_buf[i] = 0x20;

	lea	r14, OFFSET FLAT:?text_buf@@3PAEA	; text_buf
	mov	ebp, 4036				; 00000fc4H
	mov	rcx, r14
	mov	dl, 32					; 00000020H
	mov	r8d, ebp
	call	memset

; 615  :     r = N - F;
; 616  :     for (count = 0; count < textsize; ) {

	xor	r13d, r13d
	cmp	DWORD PTR ?textsize@@3IA, r13d		; textsize
	jbe	$LN6@Decode
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+64], rdi
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+32], r15
	lea	r15, OFFSET FLAT:__ImageBase
	npad	13
$LL7@Decode:

; 617  :         c = DecodeChar();

	mov	ebx, DWORD PTR ?son@@3PAHA+2504
	cmp	ebx, 627				; 00000273H
	jae	SHORT $LN30@Decode
	npad	2
$LL31@Decode:
	call	?GetBit@LZfs@@QEAAHXZ			; LZfs::GetBit
	add	ebx, eax
	mov	ebx, DWORD PTR ?son@@3PAHA[r15+rbx*4]
	cmp	ebx, 627				; 00000273H
	jb	SHORT $LL31@Decode
$LN30@Decode:
	add	ebx, -627				; fffffd8dH
	mov	ecx, ebx
	call	?update@@YAXH@Z				; update

; 618  :         if (c < 256) {

	cmp	ebx, 256				; 00000100H
	jge	SHORT $LN5@Decode

; 619  :             fs._putb(c);

	mov	rcx, QWORD PTR fs+56
	mov	rdi, QWORD PTR fs+48
	cmp	rcx, rdi
	jne	SHORT $LN34@Decode
	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	sub	edi, edx
	lea	r8d, DWORD PTR [rdi+1024]
	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
	mov	ecx, edi
	add	rcx, rax
	mov	QWORD PTR fs+40, rax
	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+56, rcx
	mov	QWORD PTR fs+48, rax
$LN34@Decode:

; 620  :             text_buf[r++] = (unsigned char)c;

	movsxd	rax, ebp
	inc	ebp
	mov	BYTE PTR [rcx], bl
	inc	QWORD PTR fs+56

; 621  :             r &= (N - 1);

	and	ebp, 4095				; 00000fffH

; 622  :             count++;

	inc	r13d
	mov	BYTE PTR [rax+r14], bl

; 623  :         } else {

	jmp	$LN1@Decode
$LN5@Decode:

; 624  :             i = (r - DecodePosition() - 1) & (N - 1);

	call	?GetByte@LZfs@@QEAAHXZ			; LZfs::GetByte
	mov	esi, eax
	movzx	r12d, BYTE PTR ?d_code@@3PAEA[rsi+r15]
	movzx	edi, BYTE PTR ?d_len@@3PAEA[rsi+r15]
	shl	r12d, 6
	sub	edi, 2
	je	SHORT $LN55@Decode
	npad	2
$LL40@Decode:
	call	?GetBit@LZfs@@QEAAHXZ			; LZfs::GetBit
	dec	edi
	lea	esi, DWORD PTR [rax+rsi*2]
	jne	SHORT $LL40@Decode
$LN55@Decode:
	and	esi, 63					; 0000003fH
	mov	eax, ebp

; 625  :             j = c - 255 + THRESHOLD;

	lea	ecx, DWORD PTR [rbx-253]
	or	esi, r12d
	sub	eax, esi
	dec	eax
	and	eax, 4095				; 00000fffH

; 626  :             for (k = 0; k < j; k++) {

	test	ecx, ecx
	jle	$LN1@Decode
	mov	r12d, ecx
	add	r13d, ecx
	mov	rcx, QWORD PTR fs+56
	movsxd	rbx, eax
	npad	5
$LL3@Decode:

; 627  :                 c = text_buf[(i + k) & (N - 1)];
; 628  :                 fs._putb(c);

	mov	rdi, QWORD PTR fs+48
	mov	rax, rbx
	and	eax, 4095				; 00000fffH
	movzx	esi, BYTE PTR [rax+r14]
	cmp	rcx, rdi
	jne	SHORT $LN43@Decode
	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	sub	edi, edx
	lea	r8d, DWORD PTR [rdi+1024]
	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
	mov	ecx, edi
	add	rcx, rax
	mov	QWORD PTR fs+40, rax
	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+56, rcx
	mov	QWORD PTR fs+48, rax
$LN43@Decode:
	mov	BYTE PTR [rcx], sil
	mov	rcx, QWORD PTR fs+56

; 629  :                 text_buf[r++] = (unsigned char)c;

	movsxd	rax, ebp
	inc	ebp
	inc	rcx
	inc	rbx

; 630  :                 r &= (N - 1);

	and	ebp, 4095				; 00000fffH
	dec	r12
	mov	QWORD PTR fs+56, rcx
	mov	BYTE PTR [rax+r14], sil
	jne	$LL3@Decode
$LN1@Decode:

; 615  :     r = N - F;
; 616  :     for (count = 0; count < textsize; ) {

	cmp	r13d, DWORD PTR ?textsize@@3IA		; textsize
	jb	$LL7@Decode
	mov	r15, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+96]
$LN6@Decode:
	mov	r14, QWORD PTR [rsp+40]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]

; 631  :                 count++;
; 632  :             }
; 633  :         }
; 634  :     }
; 635  : 	tim_size = count;

	mov	DWORD PTR ?tim_size@@3IA, r13d		; tim_size
	mov	r13, QWORD PTR [rsp+48]
$LN12@Decode:

; 636  : }

	add	rsp, 72					; 00000048H
	ret	0
?Decode@@YAXXZ ENDP					; Decode
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PutFlush@LZfs@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+29
	DD	imagerel $unwind$?PutFlush@LZfs@@QEAAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PutFlush@LZfs@@QEAAXXZ DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?PutFlush@LZfs@@QEAAXXZ
_TEXT	SEGMENT
?PutFlush@LZfs@@QEAAXXZ PROC				; LZfs::PutFlush, COMDAT

; 160  : 	{

$LN7:
	sub	rsp, 40					; 00000028H

; 161  : 		if (putlen) {
; 162  : 			_putb(putbuf >> 8);

	mov	ecx, DWORD PTR fs+8
	shr	ecx, 8
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 163  : 			codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize

; 164  : 		}
; 165  : 	}

	add	rsp, 40					; 00000028H
	ret	0
?PutFlush@LZfs@@QEAAXXZ ENDP				; LZfs::PutFlush
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?PutCode@LZfs@@QEAAXHI@Z DD imagerel $LN6
	DD	imagerel $LN6+172
	DD	imagerel $unwind$?PutCode@LZfs@@QEAAXHI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?PutCode@LZfs@@QEAAXHI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?PutCode@LZfs@@QEAAXHI@Z
_TEXT	SEGMENT
l$ = 48
c$ = 56
?PutCode@LZfs@@QEAAXHI@Z PROC				; LZfs::PutCode, COMDAT

; 144  : 	{

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 145  : 		putbuf |= c >> putlen;

	mov	r8d, DWORD PTR fs+8
	mov	edi, ecx
	mov	ecx, DWORD PTR fs+12
	mov	eax, edx
	mov	ebx, edx
	shr	eax, cl

; 146  : 		if ((putlen += l) >= 8) {

	add	ecx, edi
	or	r8d, eax
	mov	DWORD PTR fs+12, ecx
	mov	DWORD PTR fs+8, r8d
	cmp	ecx, 8
	jb	SHORT $LN1@PutCode

; 147  : 			_putb(putbuf >> 8);

	shr	r8d, 8
	mov	ecx, r8d
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 148  : 			if ((putlen -= 8) >= 8) {

	mov	r11d, DWORD PTR fs+12
	add	r11d, -8				; fffffff8H
	mov	DWORD PTR fs+12, r11d
	cmp	r11d, 8
	jb	SHORT $LN2@PutCode

; 149  : 				_putb(putbuf);

	mov	ecx, DWORD PTR fs+8
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 150  : 				codesize += 2;
; 151  : 				putlen -= 8;

	mov	eax, DWORD PTR fs+12
	add	DWORD PTR ?codesize@@3IA, 2		; codesize
	add	eax, -8					; fffffff8H

; 152  : 				putbuf = c << (l - putlen);

	sub	edi, eax
	mov	DWORD PTR fs+12, eax
	movzx	ecx, dil
	shl	ebx, cl
	mov	DWORD PTR fs+8, ebx

; 156  : 			}
; 157  : 		}
; 158  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@PutCode:

; 153  : 			} else {
; 154  : 				putbuf <<= 8;

	shl	DWORD PTR fs+8, 8

; 155  : 				codesize++;

	inc	DWORD PTR ?codesize@@3IA		; codesize
$LN1@PutCode:

; 156  : 			}
; 157  : 		}
; 158  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?PutCode@LZfs@@QEAAXHI@Z ENDP				; LZfs::PutCode
PUBLIC	?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z		; _decompressLZ
pdata	SEGMENT
$pdata$?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+96
	DD	imagerel $unwind$?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
dest$ = 48
dest_sz$ = 56
src$ = 64
src_sz$ = 72
?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z PROC		; _decompressLZ

; 662  : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 663  : 	u8*	start = (u8*) src;
; 664  : 	fs.Init_Input(start,start+src_sz);

	mov	eax, r9d
	mov	rdi, rdx
	mov	rbx, rcx
	add	rax, r8
	mov	QWORD PTR fs+16, r8
	mov	QWORD PTR fs+32, r8
	mov	QWORD PTR fs+24, rax
	xor	eax, eax
	mov	QWORD PTR fs+8, rax
	mov	QWORD PTR fs, rax

; 665  :     Decode();

	call	?Decode@@YAXXZ				; Decode

; 666  : 	*dest		= fs.OutPointer();

	mov	r11, QWORD PTR fs+40

; 667  : 	*dest_sz	= fs.OutSize();

	mov	eax, DWORD PTR fs+56
	sub	eax, r11d
	mov	QWORD PTR [rbx], r11

; 668  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi], eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_decompressLZ@@YAXPEAPEAEPEAIPEAXI@Z ENDP		; _decompressLZ
_TEXT	ENDS
PUBLIC	?EncodePosition@@YAXI@Z				; EncodePosition
pdata	SEGMENT
$pdata$?EncodePosition@@YAXI@Z DD imagerel $LN3
	DD	imagerel $LN3+71
	DD	imagerel $unwind$?EncodePosition@@YAXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?EncodePosition@@YAXI@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
?EncodePosition@@YAXI@Z PROC				; EncodePosition

; 493  : {

$LN3:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	ebx, DWORD PTR ?match_position@@3HA	; match_position

; 494  :     unsigned i;
; 495  : 	
; 496  :     /* output upper 6 bits by table lookup */
; 497  :     i = c >> 6;
; 498  :     fs.PutCode(p_len[i], (unsigned)p_code[i] << 8);

	lea	rax, OFFSET FLAT:__ImageBase
	mov	ecx, ebx
	shr	ecx, 6
	movzx	edx, BYTE PTR ?p_code@@3PAEA[rcx+rax]
	movzx	ecx, BYTE PTR ?p_len@@3PAEA[rcx+rax]
	shl	edx, 8
	call	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode

; 499  : 	
; 500  :     /* output lower 6 bits verbatim */
; 501  :     fs.PutCode(6, (c & 0x3f) << 10);

	and	ebx, 63					; 0000003fH
	mov	ecx, 6
	shl	ebx, 10
	mov	edx, ebx

; 502  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode
?EncodePosition@@YAXI@Z ENDP				; EncodePosition
_TEXT	ENDS
PUBLIC	?EncodeChar@@YAXI@Z				; EncodeChar
pdata	SEGMENT
$pdata$?EncodeChar@@YAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+106
	DD	imagerel $unwind$?EncodeChar@@YAXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?EncodeChar@@YAXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
c$ = 48
?EncodeChar@@YAXI@Z PROC				; EncodeChar

; 468  : {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 469  :     unsigned i;
; 470  :     int j, k;
; 471  : 	
; 472  :     i = 0;
; 473  :     j = 0;
; 474  :     k = prnt[c + T];

	lea	eax, DWORD PTR [rcx+627]
	mov	esi, ecx
	lea	rcx, OFFSET FLAT:?prnt@@3PAHA		; prnt
	mov	eax, DWORD PTR [rcx+rax*4]
	xor	ebx, ebx
	mov	edi, ebx
$LL4@EncodeChar:

; 475  : 	
; 476  :     /* travel from leaf to root */
; 477  :     do {
; 478  :         i >>= 1;

	shr	ebx, 1

; 479  : 		
; 480  :         /* if node's address is odd-numbered, choose bigger brother node */
; 481  :         if (k & 1) i += 0x8000;

	test	al, 1
	je	SHORT $LN1@EncodeChar
	add	ebx, 32768				; 00008000H
$LN1@EncodeChar:

; 482  : 		
; 483  :         j++;
; 484  : 		k = prnt[k];

	cdqe
	inc	edi
	mov	eax, DWORD PTR [rcx+rax*4]

; 485  :     } while (k != R);

	cmp	eax, 626				; 00000272H
	jne	SHORT $LL4@EncodeChar

; 486  :     fs.PutCode(j, i);

	mov	edx, ebx
	mov	ecx, edi
	call	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode

; 487  :     code = i;
; 488  :     len = j;
; 489  :     update(c);

	mov	ecx, esi
	mov	DWORD PTR ?code@@3IA, ebx		; code
	mov	DWORD PTR ?len@@3IA, edi		; len

; 490  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	?update@@YAXH@Z				; update
?EncodeChar@@YAXI@Z ENDP				; EncodeChar
PUBLIC	?Encode@@YAXXZ					; Encode
pdata	SEGMENT
$pdata$?Encode@@YAXXZ DD imagerel $LN110
	DD	imagerel $LN110+128
	DD	imagerel $unwind$?Encode@@YAXXZ
$pdata$6$?Encode@@YAXXZ DD imagerel $LN110+128
	DD	imagerel $LN110+1394
	DD	imagerel $chain$6$?Encode@@YAXXZ
$pdata$7$?Encode@@YAXXZ DD imagerel $LN110+1394
	DD	imagerel $LN110+1516
	DD	imagerel $chain$7$?Encode@@YAXXZ
$pdata$8$?Encode@@YAXXZ DD imagerel $LN110+1516
	DD	imagerel $LN110+1522
	DD	imagerel $chain$8$?Encode@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?Encode@@YAXXZ DD 020601H
	DD	030027206H
$chain$6$?Encode@@YAXXZ DD 0e2321H
	DD	04f423H
	DD	05e41eH
	DD	06d419H
	DD	07c414H
	DD	0d740fH
	DD	0c640aH
	DD	0b5405H
	DD	imagerel $LN110
	DD	imagerel $LN110+128
	DD	imagerel $unwind$?Encode@@YAXXZ
$chain$7$?Encode@@YAXXZ DD 040021H
	DD	06d400H
	DD	0c6400H
	DD	imagerel $LN110
	DD	imagerel $LN110+128
	DD	imagerel $unwind$?Encode@@YAXXZ
$chain$8$?Encode@@YAXXZ DD 021H
	DD	imagerel $LN110
	DD	imagerel $LN110+128
	DD	imagerel $unwind$?Encode@@YAXXZ
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
len$1$ = 80
?Encode@@YAXXZ PROC					; Encode

; 541  : {

$LN110:
	push	rbx
	sub	rsp, 64					; 00000040H

; 542  :     int  i, c, len, r, s, last_match_length;
; 543  : 	
; 544  :     textsize = fs.InputSize();

	mov	eax, DWORD PTR fs+24

; 545  : 	fs.Init_Output(textsize);

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	sub	eax, DWORD PTR fs+16
	movsxd	rbx, eax
	mov	DWORD PTR ?textsize@@3IA, eax		; textsize
	mov	rdx, rbx
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	QWORD PTR fs+40, rax
	mov	QWORD PTR fs+56, rax
	lea	rcx, QWORD PTR [rbx+rax]
	mov	QWORD PTR fs+48, rcx

; 546  : 	fs._putb((textsize & 0xff));

	movzx	ecx, BYTE PTR ?textsize@@3IA
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 547  : 	fs._putb((textsize & 0xff00) >> 8);

	movzx	ecx, BYTE PTR ?textsize@@3IA+1
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 548  : 	fs._putb((textsize & 0xff0000L) >> 16);

	movzx	ecx, BYTE PTR ?textsize@@3IA+2
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 549  : 	fs._putb((textsize & 0xff000000L) >> 24);

	movzx	ecx, BYTE PTR ?textsize@@3IA+3
	call	?_putb@LZfs@@QEAAXH@Z			; LZfs::_putb

; 550  :     if (textsize == 0)

	cmp	DWORD PTR ?textsize@@3IA, 0		; textsize
	je	$LN24@Encode

; 551  :         return;
; 552  :     textsize = 0;           /* rewind and re-read */
; 553  :     StartHuff();

	mov	QWORD PTR [rsp+88], rbp
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	QWORD PTR [rsp+56], r12
	mov	QWORD PTR [rsp+48], r13
	mov	QWORD PTR [rsp+40], r14
	mov	QWORD PTR [rsp+32], r15
	call	?StartHuff@@YAXXZ			; StartHuff

; 554  :     InitTree();

	lea	rax, OFFSET FLAT:?rson@@3PAHA+16388
	mov	ecx, 32					; 00000020H
	npad	12
$LL103@Encode:
	mov	DWORD PTR [rax], 4096			; 00001000H
	mov	DWORD PTR [rax+4], 4096			; 00001000H
	mov	DWORD PTR [rax+8], 4096			; 00001000H
	add	rax, 32					; 00000020H
	dec	rcx
	mov	DWORD PTR [rax-20], 4096		; 00001000H
	mov	DWORD PTR [rax-16], 4096		; 00001000H
	mov	DWORD PTR [rax-12], 4096		; 00001000H
	mov	DWORD PTR [rax-8], 4096			; 00001000H
	mov	DWORD PTR [rax-4], 4096			; 00001000H
	jne	SHORT $LL103@Encode
	mov	rdx, 17592186048512			; 0000100000001000H
	lea	rax, OFFSET FLAT:?dad@@3PAHA		; dad
	mov	ecx, 256				; 00000100H
	npad	10
$LL102@Encode:
	mov	QWORD PTR [rax], rdx
	mov	QWORD PTR [rax+8], rdx
	mov	QWORD PTR [rax+16], rdx
	add	rax, 64					; 00000040H
	dec	rcx
	mov	QWORD PTR [rax-40], rdx
	mov	QWORD PTR [rax-32], rdx
	mov	QWORD PTR [rax-24], rdx
	mov	QWORD PTR [rax-16], rdx
	mov	QWORD PTR [rax-8], rdx
	jne	SHORT $LL102@Encode

; 555  :     s = 0;
; 556  :     r = N - F;
; 557  :     for (i = s; i < r; i++)
; 558  :         text_buf[i] = 0x20;

	lea	rsi, OFFSET FLAT:?text_buf@@3PAEA	; text_buf
	mov	ebp, 4036				; 00000fc4H
	mov	dl, 32					; 00000020H
	mov	rcx, rsi
	mov	r8d, ebp
	xor	edi, edi
	call	memset

; 559  :     for (len = 0; len < F && (c = fs._getb()) != EOF; len++)

	mov	r8, QWORD PTR fs+24
	mov	rax, QWORD PTR fs+32
	xor	r12d, r12d
	xor	ecx, ecx
$LL19@Encode:
	cmp	rax, r8
	je	SHORT $LN100@Encode
	movzx	edx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR fs+32, rax
	cmp	edx, -1
	je	SHORT $LN100@Encode

; 560  :         text_buf[r + len] = (unsigned char)c;

	mov	BYTE PTR [rcx+rsi+4036], dl
	inc	rcx
	inc	r12d
	cmp	rcx, 60					; 0000003cH
	jl	SHORT $LL19@Encode
$LN100@Encode:
	mov	DWORD PTR len$1$[rsp], r12d

; 561  :     textsize = len;

	mov	DWORD PTR ?textsize@@3IA, r12d		; textsize
	mov	ebx, 4035				; 00000fc3H
$LL16@Encode:

; 562  :     for (i = 1; i <= F; i++)
; 563  :         InsertNode(r - i);

	mov	ecx, ebx
	call	?InsertNode@@YAXH@Z			; InsertNode
	dec	ebx
	cmp	ebx, 3976				; 00000f88H
	jge	SHORT $LL16@Encode

; 564  :     InsertNode(r);

	mov	ecx, ebp
	call	?InsertNode@@YAXH@Z			; InsertNode

; 596  : 	tim_size = textsize;

	jmp	SHORT $LN109@Encode
	npad	5
$LL108@Encode:
	lea	rsi, OFFSET FLAT:?text_buf@@3PAEA	; text_buf
$LN109@Encode:

; 565  :     do {
; 566  :         if (match_length > len)

	mov	eax, DWORD PTR ?match_length@@3HA	; match_length

; 596  : 	tim_size = textsize;

	lea	r13, OFFSET FLAT:__ImageBase
	cmp	eax, r12d
	cmovg	eax, r12d
	xor	ebx, ebx
	mov	DWORD PTR ?match_length@@3HA, eax	; match_length
	cmp	eax, 2
	jg	$LN9@Encode

; 567  :             match_length = len;
; 568  :         if (match_length <= THRESHOLD) {
; 569  :             match_length = 1;

	movsxd	rax, ebp
	mov	DWORD PTR ?match_length@@3HA, 1		; match_length

; 570  : 			// textsize==56158    - FATAL :(
; 571  :             EncodeChar(text_buf[r]);

	movzx	r12d, BYTE PTR [rax+rsi]
	xor	esi, esi
	lea	eax, DWORD PTR [r12+627]
	mov	eax, DWORD PTR ?prnt@@3PAHA[r13+rax*4]
$LL46@Encode:
	shr	ebx, 1
	test	al, 1
	je	SHORT $LN43@Encode
	add	ebx, 32768				; 00008000H
$LN43@Encode:
	cdqe
	inc	esi
	mov	eax, DWORD PTR ?prnt@@3PAHA[r13+rax*4]
	cmp	eax, 626				; 00000272H
	jne	SHORT $LL46@Encode
	mov	edx, ebx
	mov	ecx, esi
	call	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode
	mov	ecx, r12d
	mov	DWORD PTR ?code@@3IA, ebx		; code
	mov	DWORD PTR ?len@@3IA, esi		; len
	call	?update@@YAXH@Z				; update

; 572  :         } else {

	mov	r15d, DWORD PTR fs+12
	mov	r13d, DWORD PTR fs+8
$LN104@Encode:

; 574  :             EncodePosition(match_position);

	mov	rsi, QWORD PTR fs+56
$LN57@Encode:

; 575  :         }
; 576  :         last_match_length = match_length;

	mov	r14d, DWORD PTR ?match_length@@3HA	; match_length

; 577  :         for (i = 0; i < last_match_length &&

	xor	r12d, r12d

; 578  : 			(c = fs._getb()) != EOF; i++) {

	test	r14d, r14d
	jle	SHORT $LN105@Encode
	mov	rbx, QWORD PTR fs+32
	lea	r15, OFFSET FLAT:?text_buf@@3PAEA	; text_buf
	npad	2
$LL7@Encode:
	cmp	rbx, QWORD PTR fs+24
	je	SHORT $LN106@Encode
	movzx	r9d, BYTE PTR [rbx]
	inc	rbx
	mov	QWORD PTR fs+32, rbx
	cmp	r9d, -1
	je	SHORT $LN106@Encode

; 579  :             DeleteNode(s);

	mov	ecx, edi
	call	?DeleteNode@@YAXH@Z			; DeleteNode

; 580  :             text_buf[s] = (unsigned char)c;

	movsxd	r11, edi
	mov	BYTE PTR [r11+r15], r9b

; 581  :             if (s < F - 1)

	cmp	edi, 59					; 0000003bH
	jge	SHORT $LN4@Encode

; 582  :                 text_buf[s + N] = (unsigned char)c;

	mov	BYTE PTR [r11+r15+4096], r9b
$LN4@Encode:

; 583  :             s = (s + 1) & (N - 1);
; 584  :             r = (r + 1) & (N - 1);

	lea	eax, DWORD PTR [rbp+1]
	inc	edi
	and	eax, 4095				; 00000fffH
	and	edi, 4095				; 00000fffH

; 585  :             InsertNode(r);

	mov	ecx, eax
	mov	ebp, eax
	call	?InsertNode@@YAXH@Z			; InsertNode
	inc	r12d
	cmp	r12d, r14d
	jl	SHORT $LL7@Encode
$LN106@Encode:
	mov	r15d, DWORD PTR fs+12
$LN105@Encode:

; 586  :         }
; 587  : 		textsize += i;

	add	DWORD PTR ?textsize@@3IA, r12d		; textsize

; 588  :         while (i++ < last_match_length) {

	cmp	r12d, r14d
	jge	$LN107@Encode

; 586  :         }
; 587  : 		textsize += i;

	sub	r14d, r12d
	mov	r12d, DWORD PTR len$1$[rsp]
	mov	ebx, r14d
	npad	5
$LL3@Encode:

; 589  :             DeleteNode(s);

	mov	ecx, edi
	call	?DeleteNode@@YAXH@Z			; DeleteNode

; 590  :             s = (s + 1) & (N - 1);
; 591  :             r = (r + 1) & (N - 1);

	lea	eax, DWORD PTR [rbp+1]
	inc	edi
	and	eax, 4095				; 00000fffH
	and	edi, 4095				; 00000fffH

; 592  :             if (--len) InsertNode(r);

	dec	r12d
	mov	ebp, eax
	je	SHORT $LN1@Encode
	mov	ecx, eax
	call	?InsertNode@@YAXH@Z			; InsertNode
$LN1@Encode:

; 588  :         while (i++ < last_match_length) {

	dec	rbx
	jne	SHORT $LL3@Encode
	mov	DWORD PTR len$1$[rsp], r12d

; 592  :             if (--len) InsertNode(r);

	jmp	$LN99@Encode
$LN9@Encode:

; 573  :             EncodeChar(255 - THRESHOLD + match_length);

	lea	r12d, DWORD PTR [rax+253]
	xor	esi, esi
	lea	eax, DWORD PTR [r12+627]
	mov	eax, DWORD PTR ?prnt@@3PAHA[r13+rax*4]
	npad	3
$LL52@Encode:
	shr	ebx, 1
	test	al, 1
	je	SHORT $LN49@Encode
	add	ebx, 32768				; 00008000H
$LN49@Encode:
	cdqe
	inc	esi
	mov	eax, DWORD PTR ?prnt@@3PAHA[r13+rax*4]
	cmp	eax, 626				; 00000272H
	jne	SHORT $LL52@Encode
	mov	edx, ebx
	mov	ecx, esi
	call	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode
	mov	ecx, r12d
	mov	DWORD PTR ?code@@3IA, ebx		; code
	mov	DWORD PTR ?len@@3IA, esi		; len
	call	?update@@YAXH@Z				; update

; 574  :             EncodePosition(match_position);

	mov	r14d, DWORD PTR ?match_position@@3HA	; match_position
	mov	eax, r14d
	shr	eax, 6
	movzx	edx, BYTE PTR ?p_code@@3PAEA[rax+r13]
	movzx	ecx, BYTE PTR ?p_len@@3PAEA[rax+r13]
	shl	edx, 8
	call	?PutCode@LZfs@@QEAAXHI@Z		; LZfs::PutCode
	mov	r15d, DWORD PTR fs+12
	mov	r13d, DWORD PTR fs+8
	and	r14d, 63				; 0000003fH
	mov	ecx, r15d
	add	r15d, 6
	shl	r14d, 10
	mov	DWORD PTR fs+12, r15d
	mov	eax, r14d
	shr	eax, cl
	or	r13d, eax
	mov	DWORD PTR fs+8, r13d
	cmp	r15d, 8
	jb	$LN104@Encode
	mov	rcx, QWORD PTR fs+56
	shr	r13d, 8
	cmp	rcx, QWORD PTR fs+48
	jne	SHORT $LN62@Encode
	mov	ebx, DWORD PTR fs+48
	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	sub	ebx, DWORD PTR fs+40
	lea	r8d, DWORD PTR [rbx+1024]
	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
	mov	ecx, ebx
	add	rcx, rax
	mov	QWORD PTR fs+40, rax
	lea	rax, QWORD PTR [rcx+1024]
	mov	QWORD PTR fs+56, rcx
	mov	QWORD PTR fs+48, rax
$LN62@Encode:
	mov	BYTE PTR [rcx], r13b
	mov	r15d, DWORD PTR fs+12
	mov	rsi, QWORD PTR fs+56
	add	r15d, -8				; fffffff8H
	inc	rsi
	mov	QWORD PTR fs+56, rsi
	mov	DWORD PTR fs+12, r15d
	cmp	r15d, 8
	jb	$LN58@Encode
	cmp	rsi, QWORD PTR fs+48
	mov	r12d, DWORD PTR fs+8
	jne	SHORT $LN67@Encode
	mov	ebx, DWORD PTR fs+48
	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	sub	ebx, DWORD PTR fs+40
	lea	r8d, DWORD PTR [rbx+1024]
	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
	mov	esi, ebx
	add	rsi, rax
	mov	QWORD PTR fs+40, rax
	lea	rax, QWORD PTR [rsi+1024]
	mov	QWORD PTR fs+56, rsi
	mov	QWORD PTR fs+48, rax
$LN67@Encode:
	add	DWORD PTR ?codesize@@3IA, 2		; codesize
	mov	BYTE PTR [rsi], r12b
	mov	r15d, DWORD PTR fs+12
	mov	rsi, QWORD PTR fs+56
	add	r15d, -8				; fffffff8H
	mov	ecx, 6
	inc	rsi
	sub	ecx, r15d
	mov	r13d, r14d
	shl	r13d, cl
	mov	QWORD PTR fs+56, rsi
	mov	DWORD PTR fs+12, r15d
	mov	DWORD PTR fs+8, r13d
	jmp	$LN57@Encode
$LN58@Encode:
	mov	r13d, DWORD PTR fs+8
	shl	r13d, 8
	inc	DWORD PTR ?codesize@@3IA		; codesize
	mov	DWORD PTR fs+8, r13d
	jmp	$LN57@Encode
$LN107@Encode:

; 592  :             if (--len) InsertNode(r);

	mov	r12d, DWORD PTR len$1$[rsp]
$LN99@Encode:

; 593  :         }
; 594  :     } while (len > 0);

	test	r12d, r12d
	jg	$LL108@Encode

; 595  :     fs.PutFlush();

	mov	r14, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+104]
	mov	rbp, QWORD PTR [rsp+88]
	test	r15d, r15d
	mov	r15, QWORD PTR [rsp+32]
	je	SHORT $LN75@Encode
	shr	r13d, 8
	cmp	rsi, QWORD PTR fs+48
	jne	SHORT $LN78@Encode
	mov	ebx, DWORD PTR fs+48
	mov	rdx, QWORD PTR fs+40
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	sub	ebx, DWORD PTR fs+40
	lea	r8d, DWORD PTR [rbx+1024]
	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
	mov	esi, ebx
	add	rsi, rax
	mov	QWORD PTR fs+40, rax
	lea	rax, QWORD PTR [rsi+1024]
	mov	QWORD PTR fs+56, rsi
	mov	QWORD PTR fs+48, rax
$LN78@Encode:
	mov	BYTE PTR [rsi], r13b
	inc	QWORD PTR fs+56
	inc	DWORD PTR ?codesize@@3IA		; codesize
$LN75@Encode:

; 596  : 	tim_size = textsize;

	mov	eax, DWORD PTR ?textsize@@3IA		; textsize
	mov	r13, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+96]
	mov	DWORD PTR ?tim_size@@3IA, eax		; tim_size
$LN24@Encode:

; 597  : }

	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?Encode@@YAXXZ ENDP					; Encode
PUBLIC	?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z		; _compressLZ
pdata	SEGMENT
$pdata$?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z DD imagerel $LN9
	DD	imagerel $LN9+96
	DD	imagerel $unwind$?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
dest$ = 48
dest_sz$ = 56
src$ = 64
src_sz$ = 72
?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z PROC		; _compressLZ

; 653  : {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 654  : 	u8*	start = (u8*) src;
; 655  : 	fs.Init_Input(start,start+src_sz);

	mov	eax, r9d
	mov	rdi, rdx
	mov	rbx, rcx
	add	rax, r8
	mov	QWORD PTR fs+16, r8
	mov	QWORD PTR fs+32, r8
	mov	QWORD PTR fs+24, rax
	xor	eax, eax
	mov	QWORD PTR fs+8, rax
	mov	QWORD PTR fs, rax

; 656  :     Encode();

	call	?Encode@@YAXXZ				; Encode

; 657  : 	*dest		= fs.OutPointer();

	mov	r11, QWORD PTR fs+40

; 658  : 	*dest_sz	= fs.OutSize();

	mov	eax, DWORD PTR fs+56
	sub	eax, r11d
	mov	QWORD PTR [rbx], r11

; 659  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR [rdi], eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_compressLZ@@YAXPEAPEAEPEAIPEAXI@Z ENDP		; _compressLZ
	ALIGN	4

fs	DB	040H DUP (?)
END
