; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?Reflect@@YAIID@Z				; Reflect
crc32_ready DD	01H DUP (?)
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\crc32.cpp
;	COMDAT ?Reflect@@YAIID@Z
_TEXT	SEGMENT
ref$ = 8
ch$ = 16
?Reflect@@YAIID@Z PROC					; Reflect, COMDAT

; 8    : {

	mov	r8d, ecx

; 12   : 
; 13   : 	// Swap bit 0 for bit 7 
; 14   : 	// bit 1 for bit 6, etc. 
; 15   : 	for(int i = 1; i < (ch + 1); i++) 

	movsx	ecx, dl
	xor	r9d, r9d
	lea	eax, DWORD PTR [rcx+1]
	cmp	eax, 1
	jle	SHORT $LN9@Reflect

; 9    : 	// Used only by Init_CRC32_Table(). 
; 10   : 
; 11   : 	u32 value(0); 

	dec	ecx
	lea	r10d, DWORD PTR [rax-1]
$LL4@Reflect:

; 16   : 	{ 
; 17   : 		if(ref & 1) 

	test	r8b, 1
	je	SHORT $LN1@Reflect

; 18   : 			value |= 1 << (ch - i); 

	mov	edx, 1
	shl	edx, cl
	or	r9d, edx
$LN1@Reflect:

; 19   : 		ref >>= 1; 

	shr	r8d, 1
	dec	ecx
	dec	r10
	jne	SHORT $LL4@Reflect
$LN9@Reflect:

; 20   : 	} 
; 21   : 	return value; 

	mov	eax, r9d

; 22   : } 

	ret	0
?Reflect@@YAIID@Z ENDP					; Reflect
PUBLIC	?crc32_init@@YAXXZ				; crc32_init
crc32_table DD	0100H DUP (?)
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?crc32_init@@YAXXZ PROC					; crc32_init

; 26   : 	// Call this function only once to initialize the CRC table. 
; 27   : 
; 28   : 	// This is the official polynomial used by CRC-32 
; 29   : 	// in PKZip, WinZip and Ethernet. 
; 30   : 	u32 ulPolynomial = 0x04c11db7; 
; 31   : 
; 32   : 	// 256 values representing ASCII character codes. 
; 33   : 	for(int i = 0; i <= 0xFF; i++) 

	xor	r9d, r9d
	lea	r10, OFFSET FLAT:crc32_table
	npad	6
$LL6@crc32_init:

; 34   : 	{ 
; 35   : 		crc32_table[i]=Reflect(i, 8) << 24; 

	xor	r8d, r8d
	mov	edx, r9d
	lea	ecx, QWORD PTR [r8+7]
	npad	6
$LL12@crc32_init:
	test	dl, 1
	je	SHORT $LN9@crc32_init
	mov	eax, 1
	shl	eax, cl
	or	r8d, eax
$LN9@crc32_init:
	dec	ecx
	shr	edx, 1
	cmp	ecx, -1
	jg	SHORT $LL12@crc32_init
	shl	r8d, 24

; 36   : 		for (int j = 0; j < 8; j++) 
; 37   : 			crc32_table[i] = (crc32_table[i] << 1) ^ (crc32_table[i] & (1 << 31) ? ulPolynomial : 0); 

	mov	eax, r8d
	and	eax, -2147483648			; 80000000H
	neg	eax
	lea	eax, DWORD PTR [r8+r8]
	sbb	ecx, ecx
	and	ecx, 79764919				; 04c11db7H
	xor	ecx, eax
	mov	eax, ecx
	and	eax, -2147483648			; 80000000H
	neg	eax
	lea	eax, DWORD PTR [rcx+rcx]
	sbb	edx, edx
	and	edx, 79764919				; 04c11db7H
	xor	edx, eax
	mov	eax, edx
	and	eax, -2147483648			; 80000000H
	neg	eax
	lea	eax, DWORD PTR [rdx+rdx]
	sbb	ecx, ecx
	and	ecx, 79764919				; 04c11db7H
	xor	ecx, eax
	mov	eax, ecx
	and	eax, -2147483648			; 80000000H
	neg	eax
	lea	eax, DWORD PTR [rcx+rcx]
	sbb	edx, edx
	and	edx, 79764919				; 04c11db7H
	xor	edx, eax
	mov	eax, edx
	and	eax, -2147483648			; 80000000H
	neg	eax
	lea	eax, DWORD PTR [rdx+rdx]
	sbb	ecx, ecx
	and	ecx, 79764919				; 04c11db7H
	xor	ecx, eax
	mov	eax, ecx
	and	eax, -2147483648			; 80000000H
	neg	eax
	lea	eax, DWORD PTR [rcx+rcx]
	sbb	edx, edx
	and	edx, 79764919				; 04c11db7H
	xor	edx, eax
	mov	eax, edx
	and	eax, -2147483648			; 80000000H
	neg	eax
	lea	eax, DWORD PTR [rdx+rdx]
	sbb	ecx, ecx
	and	ecx, 79764919				; 04c11db7H
	xor	ecx, eax
	mov	eax, ecx
	and	eax, -2147483648			; 80000000H
	neg	eax
	lea	eax, DWORD PTR [rcx+rcx]
	sbb	edx, edx
	and	edx, 79764919				; 04c11db7H
	xor	edx, eax

; 38   : 		crc32_table[i] = Reflect(crc32_table[i], 32); 

	xor	r8d, r8d
	lea	ecx, QWORD PTR [r8+31]
	mov	DWORD PTR [r10], edx
$LL18@crc32_init:
	test	dl, 1
	je	SHORT $LN15@crc32_init
	mov	eax, 1
	shl	eax, cl
	or	r8d, eax
$LN15@crc32_init:
	dec	ecx
	shr	edx, 1
	cmp	ecx, -1
	jg	SHORT $LL18@crc32_init
	inc	r9d
	mov	DWORD PTR [r10], r8d
	add	r10, 4
	cmp	r9d, 255				; 000000ffH
	jle	$LL6@crc32_init

; 39   : 	} 
; 40   : } 

	fatret	0
?crc32_init@@YAXXZ ENDP					; crc32_init
PUBLIC	?crc32@@YAIPEBXI@Z				; crc32
pdata	SEGMENT
$pdata$?crc32@@YAIPEBXI@Z DD imagerel $LN9
	DD	imagerel $LN9+107
	DD	imagerel $unwind$?crc32@@YAIPEBXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?crc32@@YAIPEBXI@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
P$ = 48
len$ = 56
?crc32@@YAIPEBXI@Z PROC					; crc32

; 43   : {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H

; 44   : 	if (!crc32_ready)	

	cmp	DWORD PTR crc32_ready, 0
	mov	r11d, edx
	mov	rbx, rcx
	jne	SHORT $LN3@crc32

; 45   : 	{
; 46   : 		crc32_init	();

	call	?crc32_init@@YAXXZ			; crc32_init

; 47   : 		crc32_ready	= TRUE;

	mov	DWORD PTR crc32_ready, 1
$LN3@crc32:

; 48   : 	}
; 49   : 
; 50   : 	// Pass a text string to this function and it will return the CRC. 
; 51   : 
; 52   : 	// Once the lookup table has been filled in by the two functions above, 
; 53   : 	// this function creates all CRCs using only the lookup table. 
; 54   : 
; 55   : 	// Be sure to use unsigned variables, 
; 56   : 	// because negative values introduce high bits 
; 57   : 	// where zero bits are required. 
; 58   : 
; 59   : 	// Start out with all bits set high. 
; 60   : 	u32		ulCRC		= 0xffffffff; 

	or	r8d, -1					; ffffffffH

; 61   : 	u8*		buffer		= (u8*)P;
; 62   : 
; 63   : 	// Perform the algorithm on each character 
; 64   : 	// in the string, using the lookup table values. 
; 65   : 	while(len--) 

	test	r11d, r11d
	je	SHORT $LN7@crc32
	lea	r9, OFFSET FLAT:crc32_table
	npad	12
$LL2@crc32:

; 66   : 		ulCRC = (ulCRC >> 8) ^ crc32_table[(ulCRC & 0xFF) ^ *buffer++]; 

	movzx	eax, BYTE PTR [rbx]
	movzx	edx, r8b
	mov	ecx, r8d
	xor	rdx, rax
	shr	ecx, 8
	inc	rbx
	mov	r8d, DWORD PTR [r9+rdx*4]
	xor	r8d, ecx
	dec	r11d
	jne	SHORT $LL2@crc32
$LN7@crc32:

; 67   : 
; 68   : 	// Exclusive OR the result with the beginning value. 
; 69   : 	return ulCRC ^ 0xffffffff; 

	not	r8d
	mov	eax, r8d

; 70   : } 

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?crc32@@YAIPEBXI@Z ENDP					; crc32
END
