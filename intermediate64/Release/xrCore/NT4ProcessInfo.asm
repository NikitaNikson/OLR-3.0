; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09EPMADGLA@PSAPI?4DLL?$AA@		; `string'
PUBLIC	??_C@_0BL@BFFHGONM@Unable?5to?5load?5PSAPI?4DLL?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@FIEJBLME@EnumProcessModules?$AA@	; `string'
PUBLIC	??_C@_0CO@IPHELLBC@GetProcAddress?5failed?5on?5EnumPro@ ; `string'
PUBLIC	??_C@_0BD@OMILCNII@GetModuleBaseNameA?$AA@	; `string'
PUBLIC	??_C@_0CO@BMACJKEA@GetProcAddress?5failed?5on?5GetModu@ ; `string'
PUBLIC	??_C@_0BF@OFAHHCBJ@GetModuleFileNameExA?$AA@	; `string'
PUBLIC	??_C@_0CP@EINOADCM@GetProcAddress?5failed?5on?5GetModu@ ; `string'
PUBLIC	??_C@_0BP@LPMPHDCM@Unable?5to?5OpenProcess?5on?5?$CF08X?6?$AA@ ; `string'
PUBLIC	??_C@_0CE@LAECLNDN@PSAPI?4DLL?5has?5been?5unloaded?5on?5u@ ; `string'
EXTRN	__imp_OpenProcess:PROC
	ALIGN	8

g_pGetModuleBaseName DQ 01H DUP (?)
g_pGetModuleFileNameEx DQ 01H DUP (?)
g_bInitialized DD 01H DUP (?)
	ALIGN	8

g_pEnumProcessModules DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CE@LAECLNDN@PSAPI?4DLL?5has?5been?5unloaded?5on?5u@
CONST	SEGMENT
??_C@_0CE@LAECLNDN@PSAPI?4DLL?5has?5been?5unloaded?5on?5u@ DB 'PSAPI.DLL '
	DB	'has been unloaded on us!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LPMPHDCM@Unable?5to?5OpenProcess?5on?5?$CF08X?6?$AA@
CONST	SEGMENT
??_C@_0BP@LPMPHDCM@Unable?5to?5OpenProcess?5on?5?$CF08X?6?$AA@ DB 'Unable'
	DB	' to OpenProcess on %08X', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EINOADCM@GetProcAddress?5failed?5on?5GetModu@
CONST	SEGMENT
??_C@_0CP@EINOADCM@GetProcAddress?5failed?5on?5GetModu@ DB 'GetProcAddres'
	DB	's failed on GetModuleFileNameExA', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OFAHHCBJ@GetModuleFileNameExA?$AA@
CONST	SEGMENT
??_C@_0BF@OFAHHCBJ@GetModuleFileNameExA?$AA@ DB 'GetModuleFileNameExA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BMACJKEA@GetProcAddress?5failed?5on?5GetModu@
CONST	SEGMENT
??_C@_0CO@BMACJKEA@GetProcAddress?5failed?5on?5GetModu@ DB 'GetProcAddres'
	DB	's failed on GetModuleBaseNameA!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OMILCNII@GetModuleBaseNameA?$AA@
CONST	SEGMENT
??_C@_0BD@OMILCNII@GetModuleBaseNameA?$AA@ DB 'GetModuleBaseNameA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IPHELLBC@GetProcAddress?5failed?5on?5EnumPro@
CONST	SEGMENT
??_C@_0CO@IPHELLBC@GetProcAddress?5failed?5on?5EnumPro@ DB 'GetProcAddres'
	DB	's failed on EnumProcessModules!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FIEJBLME@EnumProcessModules?$AA@
CONST	SEGMENT
??_C@_0BD@FIEJBLME@EnumProcessModules?$AA@ DB 'EnumProcessModules', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BFFHGONM@Unable?5to?5load?5PSAPI?4DLL?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BL@BFFHGONM@Unable?5to?5load?5PSAPI?4DLL?$CB?6?$AA@ DB 'Unable to '
	DB	'load PSAPI.DLL!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09EPMADGLA@PSAPI?4DLL?$AA@
CONST	SEGMENT
??_C@_09EPMADGLA@PSAPI?4DLL?$AA@ DB 'PSAPI.DLL', 00H	; `string'
PI_MUL_2 DD	040c90fdbr			; 6.28319
PUBLIC	?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z ; NT4GetLoadedModules
PUBLIC	?NTGetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z ; NTGetModuleBaseName
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?InitPSAPI@@YAHXZ DD imagerel ?InitPSAPI@@YAHXZ
	DD	imagerel ?InitPSAPI@@YAHXZ+30
	DD	imagerel $unwind$?InitPSAPI@@YAHXZ
$pdata$0$?InitPSAPI@@YAHXZ DD imagerel ?InitPSAPI@@YAHXZ+30
	DD	imagerel ?InitPSAPI@@YAHXZ+73
	DD	imagerel $chain$0$?InitPSAPI@@YAHXZ
$pdata$2$?InitPSAPI@@YAHXZ DD imagerel ?InitPSAPI@@YAHXZ+73
	DD	imagerel ?InitPSAPI@@YAHXZ+125
	DD	imagerel $chain$2$?InitPSAPI@@YAHXZ
$pdata$4$?InitPSAPI@@YAHXZ DD imagerel ?InitPSAPI@@YAHXZ+125
	DD	imagerel ?InitPSAPI@@YAHXZ+177
	DD	imagerel $chain$4$?InitPSAPI@@YAHXZ
$pdata$6$?InitPSAPI@@YAHXZ DD imagerel ?InitPSAPI@@YAHXZ+177
	DD	imagerel ?InitPSAPI@@YAHXZ+229
	DD	imagerel $chain$6$?InitPSAPI@@YAHXZ
$pdata$8$?InitPSAPI@@YAHXZ DD imagerel ?InitPSAPI@@YAHXZ+229
	DD	imagerel ?InitPSAPI@@YAHXZ+254
	DD	imagerel $chain$8$?InitPSAPI@@YAHXZ
$pdata$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z DD imagerel $LN266
	DD	imagerel $LN266+71
	DD	imagerel $unwind$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z
$pdata$0$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z DD imagerel $LN266+71
	DD	imagerel $LN266+282
	DD	imagerel $chain$0$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z
$pdata$1$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z DD imagerel $LN266+282
	DD	imagerel $LN266+304
	DD	imagerel $chain$1$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z
$pdata$?NTGetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z DD imagerel $LN5
	DD	imagerel $LN5+98
	DD	imagerel $unwind$?NTGetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z
xdata	SEGMENT
$unwind$?InitPSAPI@@YAHXZ DD 010401H
	DD	04204H
$chain$0$?InitPSAPI@@YAHXZ DD 020521H
	DD	043405H
	DD	imagerel ?InitPSAPI@@YAHXZ
	DD	imagerel ?InitPSAPI@@YAHXZ+30
	DD	imagerel $unwind$?InitPSAPI@@YAHXZ
$chain$2$?InitPSAPI@@YAHXZ DD 020021H
	DD	043400H
	DD	imagerel ?InitPSAPI@@YAHXZ
	DD	imagerel ?InitPSAPI@@YAHXZ+30
	DD	imagerel $unwind$?InitPSAPI@@YAHXZ
$chain$4$?InitPSAPI@@YAHXZ DD 020021H
	DD	043400H
	DD	imagerel ?InitPSAPI@@YAHXZ
	DD	imagerel ?InitPSAPI@@YAHXZ+30
	DD	imagerel $unwind$?InitPSAPI@@YAHXZ
$chain$6$?InitPSAPI@@YAHXZ DD 020021H
	DD	043400H
	DD	imagerel ?InitPSAPI@@YAHXZ
	DD	imagerel ?InitPSAPI@@YAHXZ+30
	DD	imagerel $unwind$?InitPSAPI@@YAHXZ
$chain$8$?InitPSAPI@@YAHXZ DD 020021H
	DD	043400H
	DD	imagerel ?InitPSAPI@@YAHXZ
	DD	imagerel ?InitPSAPI@@YAHXZ+30
	DD	imagerel $unwind$?InitPSAPI@@YAHXZ
$unwind$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z DD 081501H
	DD	0b7415H
	DD	0a5415H
	DD	093415H
	DD	0e0115215H
$chain$0$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z DD 020521H
	DD	086405H
	DD	imagerel $LN266
	DD	imagerel $LN266+71
	DD	imagerel $unwind$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z
$chain$1$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z DD 021H
	DD	imagerel $LN266
	DD	imagerel $LN266+71
	DD	imagerel $unwind$?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z
$unwind$?NTGetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\nt4processinfo.cpp
_TEXT	SEGMENT
hProcess$ = 48
hModule$ = 56
lpBaseName$ = 64
nSize$ = 72
?NTGetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z PROC ; NTGetModuleBaseName

; 212  : {

$LN5:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, r9d
	mov	rdi, r8
	mov	rsi, rdx
	mov	rbp, rcx

; 213  :     // Initialize PSAPI.DLL, if needed.
; 214  :     if ( FALSE == InitPSAPI ( ) )

	call	?InitPSAPI@@YAHXZ			; InitPSAPI
	test	eax, eax
	jne	SHORT $LN1@NTGetModul

; 215  :     {
; 216  :         ASSERT ( !"InitiPSAPI failed!" ) ;
; 217  :         SetLastErrorEx ( ERROR_DLL_INIT_FAILED , SLE_ERROR ) ;

	lea	edx, QWORD PTR [rax+1]
	mov	ecx, 1114				; 0000045aH
	call	QWORD PTR __imp_SetLastErrorEx

; 218  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN2@NTGetModul
$LN1@NTGetModul:

; 219  :     }
; 220  :     return ( g_pGetModuleBaseName ( hProcess    ,
; 221  :                                     hModule     ,
; 222  :                                     lpBaseName  ,
; 223  :                                     nSize        ) ) ;

	mov	r9d, ebx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rbp
	call	QWORD PTR g_pGetModuleBaseName
$LN2@NTGetModul:

; 224  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?NTGetModuleBaseName@@YAKPEAXPEAUHINSTANCE__@@PEADK@Z ENDP ; NTGetModuleBaseName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\nt4processinfo.cpp
_TEXT	SEGMENT
dwTotal$ = 32
dwPID$ = 64
uiCount$ = 72
paModArray$ = 80
pdwRealCount$ = 88
?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z PROC ; NT4GetLoadedModules

; 133  : {

$LN266:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	r14, r9
	mov	rbp, r8
	mov	edi, edx
	mov	ebx, ecx

; 134  : 
; 135  :     // Initialize PSAPI.DLL, if needed.
; 136  :     if ( FALSE == InitPSAPI ( ) )

	call	?InitPSAPI@@YAHXZ			; InitPSAPI
	test	eax, eax
	jne	SHORT $LN7@NT4GetLoad

; 137  :     {
; 138  :         ASSERT ( !"InitPSAPI failed!" ) ;
; 139  :         SetLastErrorEx ( ERROR_DLL_INIT_FAILED , SLE_ERROR ) ;

	lea	edx, QWORD PTR [rax+1]
	mov	ecx, 1114				; 0000045aH
	call	QWORD PTR __imp_SetLastErrorEx

; 140  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN8@NT4GetLoad
$LN7@NT4GetLoad:

; 141  :     }
; 142  : 
; 143  :     // Convert the process ID into a process handle.
; 144  :     HANDLE hProc = OpenProcess ( PROCESS_QUERY_INFORMATION |
; 145  :                                     PROCESS_VM_READ         ,
; 146  :                                  FALSE                      ,
; 147  :                                  dwPID                       ) ;

	mov	r8d, ebx
	xor	edx, edx
	mov	ecx, 1040				; 00000410H
	mov	QWORD PTR [rsp+64], rsi
	call	QWORD PTR __imp_OpenProcess
	mov	rsi, rax

; 148  :     ASSERT ( NULL != hProc ) ;
; 149  :     if ( NULL == hProc )

	test	rax, rax
	jne	SHORT $LN6@NT4GetLoad

; 150  :     {
; 151  :         TRACE1 ( "Unable to OpenProcess on %08X\n" , dwPID ) ;

	lea	rcx, OFFSET FLAT:??_C@_0BP@LPMPHDCM@Unable?5to?5OpenProcess?5on?5?$CF08X?6?$AA@
	mov	edx, ebx
	call	?Msg@@YAXPEBDZZ				; Msg

; 152  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	$LN264@NT4GetLoad
$LN6@NT4GetLoad:

; 153  :     }
; 154  : 
; 155  :     // Now get the modules for the specified process.
; 156  :     ASSERT ( NULL != g_pEnumProcessModules ) ;
; 157  :     // Because of possible DLL unload order differences, make sure that
; 158  :     // PSAPI.DLL is still loaded in case this function is called during
; 159  :     // shutdown.
; 160  :     ASSERT ( FALSE == IsBadCodePtr ( (FARPROC)g_pEnumProcessModules ) );
; 161  :     if ( TRUE == IsBadCodePtr ( (FARPROC)g_pEnumProcessModules ) )

	mov	rcx, QWORD PTR g_pEnumProcessModules
	call	QWORD PTR __imp_IsBadCodePtr
	cmp	eax, 1
	jne	SHORT $LN5@NT4GetLoad

; 162  :     {
; 163  :         TRACE0 ( "PSAPI.DLL has been unloaded on us!\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CE@LAECLNDN@PSAPI?4DLL?5has?5been?5unloaded?5on?5u@
	call	?Log@@YAXPEBD@Z				; Log

; 164  : 
; 165  :         // Close the process handle used.
; 166  :         VERIFY ( CloseHandle ( hProc ) ) ;

	mov	rcx, rsi
	call	QWORD PTR __imp_CloseHandle

; 167  : 
; 168  :         SetLastErrorEx ( ERROR_INVALID_DLL , SLE_ERROR ) ;

	mov	edx, 1
	mov	ecx, 1154				; 00000482H
	call	QWORD PTR __imp_SetLastErrorEx

; 169  : 
; 170  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN264@NT4GetLoad
$LN5@NT4GetLoad:

; 171  :     }
; 172  : 
; 173  :     DWORD dwTotal = 0 ;
; 174  :     BOOL bRet = g_pEnumProcessModules ( hProc                        ,
; 175  :                                         paModArray                   ,
; 176  :                                         uiCount * sizeof ( HMODULE ) ,
; 177  :                                         &dwTotal                      );

	lea	r8d, DWORD PTR [rdi*8]
	lea	r9, QWORD PTR dwTotal$[rsp]
	mov	rdx, rbp
	mov	rcx, rsi
	mov	DWORD PTR dwTotal$[rsp], 0
	call	QWORD PTR g_pEnumProcessModules

; 178  : 
; 179  :     // Close the process handle used.
; 180  :     VERIFY ( CloseHandle ( hProc ) ) ;

	mov	rcx, rsi
	mov	ebx, eax
	call	QWORD PTR __imp_CloseHandle

; 181  : 
; 182  :     // Convert the count from bytes to HMODULE values.
; 183  :     *pdwRealCount = dwTotal / sizeof ( HMODULE ) ;

	mov	ecx, DWORD PTR dwTotal$[rsp]
	mov	eax, ecx
	shr	eax, 3
	mov	DWORD PTR [r14], eax

; 184  : 
; 185  :     // If bRet was FALSE, and the user was not just asking for the
; 186  :     // total, there was a problem.
; 187  :     if ( ( ( FALSE == bRet ) && ( uiCount > 0 ) ) || ( 0 == dwTotal ) )

	test	ebx, ebx
	jne	SHORT $LN2@NT4GetLoad
	test	edi, edi
	jne	SHORT $LN3@NT4GetLoad
$LN2@NT4GetLoad:
	test	ecx, ecx
	je	SHORT $LN3@NT4GetLoad

; 188  :     {
; 189  :         ASSERT ( !"EnumProcessModules failed!\n" ) ;
; 190  :         return ( FALSE ) ;
; 191  :     }
; 192  : 
; 193  :     // If the total returned in pdwRealCount is larger than the value in
; 194  :     // uiCount, then return an error.  If uiCount is zero, then it is
; 195  :     // not an error.
; 196  :     if ( ( *pdwRealCount > uiCount ) && ( uiCount > 0 ) )

	cmp	eax, edi
	jbe	SHORT $LN1@NT4GetLoad
	test	edi, edi
	je	SHORT $LN1@NT4GetLoad

; 197  :     {
; 198  :         ASSERT ( !"Buffer is too small in NT4GetLoadedModules!\n" ) ;
; 199  :         SetLastErrorEx ( ERROR_INSUFFICIENT_BUFFER , SLE_ERROR ) ;

	mov	edx, 1
	lea	ecx, QWORD PTR [rdx+121]
	call	QWORD PTR __imp_SetLastErrorEx
$LN3@NT4GetLoad:

; 200  :         return ( FALSE ) ;

	xor	eax, eax
	jmp	SHORT $LN264@NT4GetLoad
$LN1@NT4GetLoad:

; 201  :     }
; 202  : 
; 203  :     // All OK, Jumpmaster!
; 204  :     SetLastError ( ERROR_SUCCESS ) ;

	xor	ecx, ecx
	call	QWORD PTR __imp_SetLastError

; 205  :     return ( TRUE ) ;

	mov	eax, 1
$LN264@NT4GetLoad:
	mov	rsi, QWORD PTR [rsp+64]
$LN8@NT4GetLoad:

; 206  : }

	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
?NT4GetLoadedModules@@YAHKIPEAPEAUHINSTANCE__@@PEAK@Z ENDP ; NT4GetLoadedModules
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\nt4processinfo.cpp
_TEXT	SEGMENT
?InitPSAPI@@YAHXZ PROC					; InitPSAPI

; 56   : {

	sub	rsp, 40					; 00000028H

; 57   :     if ( TRUE == g_bInitialized )

	cmp	DWORD PTR g_bInitialized, 1
	jne	SHORT $LN5@InitPSAPI

; 58   :     {
; 59   :         return ( TRUE ) ;

	mov	eax, 1

; 105  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN5@InitPSAPI:

; 60   :     }
; 61   : 
; 62   :     // Load up PSAPI.DLL.
; 63   :     HINSTANCE hInst = LoadLibraryA ( "PSAPI.DLL" ) ;

	lea	rcx, OFFSET FLAT:??_C@_09EPMADGLA@PSAPI?4DLL?$AA@
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp_LoadLibraryA
	mov	rbx, rax

; 64   :     ASSERT ( NULL != hInst ) ;
; 65   :     if ( NULL == hInst )

	test	rax, rax
	jne	SHORT $LN4@InitPSAPI

; 66   :     {
; 67   :         TRACE0 ( "Unable to load PSAPI.DLL!\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0BL@BFFHGONM@Unable?5to?5load?5PSAPI?4DLL?$CB?6?$AA@
	call	?Log@@YAXPEBD@Z				; Log
	mov	rbx, QWORD PTR [rsp+32]

; 68   :         return ( FALSE ) ;

	xor	eax, eax

; 105  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@InitPSAPI:

; 69   :     }
; 70   : 
; 71   :     // Now do the GetProcAddress stuff.
; 72   :     g_pEnumProcessModules =
; 73   :            (ENUMPROCESSMODULES)GetProcAddress ( hInst ,
; 74   :                                                 "EnumProcessModules" ) ;

	lea	rdx, OFFSET FLAT:??_C@_0BD@FIEJBLME@EnumProcessModules?$AA@
	mov	rcx, rax
	call	QWORD PTR __imp_GetProcAddress
	mov	QWORD PTR g_pEnumProcessModules, rax

; 75   :     ASSERT ( NULL != g_pEnumProcessModules ) ;
; 76   :     if ( NULL == g_pEnumProcessModules )

	test	rax, rax
	jne	SHORT $LN3@InitPSAPI

; 77   :     {
; 78   :         TRACE0 ( "GetProcAddress failed on EnumProcessModules!\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CO@IPHELLBC@GetProcAddress?5failed?5on?5EnumPro@
	call	?Log@@YAXPEBD@Z				; Log
	mov	rbx, QWORD PTR [rsp+32]

; 79   :         return ( FALSE ) ;

	xor	eax, eax

; 105  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@InitPSAPI:

; 80   :     }
; 81   : 
; 82   :     g_pGetModuleBaseName =
; 83   :         (GETMODULEBASENAME)GetProcAddress ( hInst ,
; 84   :                                             "GetModuleBaseNameA" ) ;

	lea	rdx, OFFSET FLAT:??_C@_0BD@OMILCNII@GetModuleBaseNameA?$AA@
	mov	rcx, rbx
	call	QWORD PTR __imp_GetProcAddress
	mov	QWORD PTR g_pGetModuleBaseName, rax

; 85   :     ASSERT ( NULL != g_pGetModuleBaseName ) ;
; 86   :     if ( NULL == g_pGetModuleBaseName )

	test	rax, rax
	jne	SHORT $LN2@InitPSAPI

; 87   :     {
; 88   :         TRACE0 ( "GetProcAddress failed on GetModuleBaseNameA!\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CO@BMACJKEA@GetProcAddress?5failed?5on?5GetModu@
	call	?Log@@YAXPEBD@Z				; Log
	mov	rbx, QWORD PTR [rsp+32]

; 89   :         return ( FALSE ) ;

	xor	eax, eax

; 105  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@InitPSAPI:

; 90   :     }
; 91   : 
; 92   :     g_pGetModuleFileNameEx =
; 93   :         (GETMODULEFILENAMEEX)GetProcAddress ( hInst ,
; 94   :                                               "GetModuleFileNameExA" ) ;

	lea	rdx, OFFSET FLAT:??_C@_0BF@OFAHHCBJ@GetModuleFileNameExA?$AA@
	mov	rcx, rbx
	call	QWORD PTR __imp_GetProcAddress
	mov	QWORD PTR g_pGetModuleFileNameEx, rax

; 95   :     ASSERT ( NULL != g_pGetModuleFileNameEx ) ;
; 96   :     if ( NULL == g_pGetModuleFileNameEx )

	test	rax, rax
	jne	SHORT $LN1@InitPSAPI

; 97   :     {
; 98   :         TRACE0 ( "GetProcAddress failed on GetModuleFileNameExA\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CP@EINOADCM@GetProcAddress?5failed?5on?5GetModu@
	call	?Log@@YAXPEBD@Z				; Log
	mov	rbx, QWORD PTR [rsp+32]

; 99   :         return ( FALSE ) ;

	xor	eax, eax

; 105  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@InitPSAPI:
	mov	rbx, QWORD PTR [rsp+32]

; 100  :     }
; 101  : 
; 102  :     // All OK, Jumpmaster!
; 103  :     g_bInitialized = TRUE ;

	mov	DWORD PTR g_bInitialized, 1

; 104  :     return ( TRUE ) ;

	mov	eax, 1

; 105  : }

	add	rsp, 40					; 00000028H
	ret	0
?InitPSAPI@@YAHXZ ENDP					; InitPSAPI
_TEXT	ENDS
END
