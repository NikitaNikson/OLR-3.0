; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?g_application_path@@3PADA			; g_application_path
PUBLIC	??_C@_0DF@DKBODLE@Serious?5trouble?5in?5the?5house?$CB?5?9?5@ ; `string'
PUBLIC	??_C@_0CD@LBDEJLAP@?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB@ ; `string'
PUBLIC	??_C@_0CD@KECBMHB@EXCEPTION_STACK_OVERFLOW?5occurre@ ; `string'
PUBLIC	??_C@_0CC@DCHDKHJI@Bad?5parameter?5to?5GetFaultReasonA@ ; `string'
PUBLIC	??_C@_0M@CMJODOBC@?5caused?5an?5?$AA@		; `string'
PUBLIC	??_C@_09KKJFIDEP@NTDLL?4DLL?$AA@		; `string'
PUBLIC	??_C@_0M@MEHCDCPC@?5in?5module?5?$AA@		; `string'
PUBLIC	??_C@_09KOIOCIHC@?$DMUNKNOWN?$DO?$AA@		; `string'
PUBLIC	??_C@_09BDMEFKPB@?5at?5?$CF016X?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_0BC@CLKPGJFG@?$CFs?$CI?$CJ?$CL?$CF04d?5byte?$CIs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5?$AA@			; `string'
PUBLIC	??_C@_0BL@GPBODGPP@?$CFs?0?5line?5?$CF04d?$CL?$CF04d?5byte?$CIs?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0O@LLCFKP@?$CFs?0?5line?5?$CF04d?$AA@	; `string'
PUBLIC	??_C@_0CI@FFBCHJIK@GetStackTraceString?5?9?5invalid?5pE@ ; `string'
PUBLIC	??_C@_0BL@EDAGAIPM@?$CK?$CK?$CK?5break?5by?5StackWalk?5?$CK?$CK?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BM@KOKCAGFJ@?5?$FLno?5module?5info?5for?50x?$CFp?$FN?5?$AA@ ; `string'
PUBLIC	??_C@_07CMMEBABO@0x?$CF016X?$AA@		; `string'
PUBLIC	??_C@_0BP@NDGHPOJN@?5?$CI0x?$CF08X?50x?$CF08X?50x?$CF08X?50x?$CF08X?$CJ?$AA@ ; `string'
PUBLIC	??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@		; `string'
PUBLIC	??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0DH@EPDHCNDC@FATAL?3?5inner?5exception?5in?5?5Inter@ ; `string'
PUBLIC	??_C@_0CG@KJGIGBGA@GetRegisterString?5?9?5invalid?5pExP@ ; `string'
PUBLIC	??_C@_0BL@CMOMFGDN@EXCEPTION_ACCESS_VIOLATION?$AA@ ; `string'
PUBLIC	??_C@_0CA@LEJEDDLG@EXCEPTION_DATATYPE_MISALIGNMENT?$AA@ ; `string'
PUBLIC	??_C@_0BF@FLLDOCJP@EXCEPTION_BREAKPOINT?$AA@	; `string'
PUBLIC	??_C@_0BG@HPCFEJHG@EXCEPTION_SINGLE_STEP?$AA@	; `string'
PUBLIC	??_C@_0CA@JNIHFDGO@EXCEPTION_ARRAY_BOUNDS_EXCEEDED?$AA@ ; `string'
PUBLIC	??_C@_0BP@NMNHALMC@EXCEPTION_FLT_DENORMAL_OPERAND?$AA@ ; `string'
PUBLIC	??_C@_0BN@PHPNMCML@EXCEPTION_FLT_DIVIDE_BY_ZERO?$AA@ ; `string'
PUBLIC	??_C@_0BN@KLCBBCKL@EXCEPTION_FLT_INEXACT_RESULT?$AA@ ; `string'
PUBLIC	??_C@_0CA@JJDIIMDB@EXCEPTION_FLT_INVALID_OPERATION?$AA@ ; `string'
PUBLIC	??_C@_0BH@LGFBHAFE@EXCEPTION_FLT_OVERFLOW?$AA@	; `string'
PUBLIC	??_C@_0BK@COBCCPEI@EXCEPTION_FLT_STACK_CHECK?$AA@ ; `string'
PUBLIC	??_C@_0BI@CHKFJJC@EXCEPTION_FLT_UNDERFLOW?$AA@	; `string'
PUBLIC	??_C@_0BN@LBLGDPIG@EXCEPTION_INT_DIVIDE_BY_ZERO?$AA@ ; `string'
PUBLIC	??_C@_0BH@HNBKDLPO@EXCEPTION_INT_OVERFLOW?$AA@	; `string'
PUBLIC	??_C@_0BL@HJPDFKEO@EXCEPTION_PRIV_INSTRUCTION?$AA@ ; `string'
PUBLIC	??_C@_0BI@BNDIILLI@EXCEPTION_IN_PAGE_ERROR?$AA@	; `string'
PUBLIC	??_C@_0BO@DLLOIENN@EXCEPTION_ILLEGAL_INSTRUCTION?$AA@ ; `string'
PUBLIC	??_C@_0CD@JGPJMHJA@EXCEPTION_NONCONTINUABLE_EXCEPTI@ ; `string'
PUBLIC	??_C@_0BJ@FNEOPPMM@EXCEPTION_STACK_OVERFLOW?$AA@ ; `string'
PUBLIC	??_C@_0BO@GJKCLCLP@EXCEPTION_INVALID_DISPOSITION?$AA@ ; `string'
PUBLIC	??_C@_0BF@BLPCMAHP@EXCEPTION_GUARD_PAGE?$AA@	; `string'
PUBLIC	??_C@_0BJ@BKJLBIPE@EXCEPTION_INVALID_HANDLE?$AA@ ; `string'
EXTRN	__imp_SymFunctionTableAccess64:PROC
EXTRN	__imp_SymGetLineFromAddr64:PROC
EXTRN	__imp_StackWalk64:PROC
EXTRN	__imp_wsprintfA:PROC
EXTRN	__imp_IsBadCodePtr:PROC
EXTRN	__imp_ReadProcessMemory:PROC
EXTRN	__imp_SymGetOptions:PROC
EXTRN	__imp_IsBadReadPtr:PROC
EXTRN	__imp_HeapFree:PROC
EXTRN	__imp_HeapAlloc:PROC
EXTRN	__imp_SymGetSymFromAddr64:PROC
EXTRN	__imp_SymGetModuleBase64:PROC
EXTRN	__imp_SymSetOptions:PROC
g_uiModCount DD	01H DUP (?)
g_bSymEngInit DD 01H DUP (?)
?g_application_path@@3PADA DB 0100H DUP (?)		; g_application_path
g_pfnOrigFilt DQ 01H DUP (?)
g_ahMod	DQ	01H DUP (?)
g_pfnCallBack DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BJ@BKJLBIPE@EXCEPTION_INVALID_HANDLE?$AA@
CONST	SEGMENT
??_C@_0BJ@BKJLBIPE@EXCEPTION_INVALID_HANDLE?$AA@ DB 'EXCEPTION_INVALID_HA'
	DB	'NDLE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BLPCMAHP@EXCEPTION_GUARD_PAGE?$AA@
CONST	SEGMENT
??_C@_0BF@BLPCMAHP@EXCEPTION_GUARD_PAGE?$AA@ DB 'EXCEPTION_GUARD_PAGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GJKCLCLP@EXCEPTION_INVALID_DISPOSITION?$AA@
CONST	SEGMENT
??_C@_0BO@GJKCLCLP@EXCEPTION_INVALID_DISPOSITION?$AA@ DB 'EXCEPTION_INVAL'
	DB	'ID_DISPOSITION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FNEOPPMM@EXCEPTION_STACK_OVERFLOW?$AA@
CONST	SEGMENT
??_C@_0BJ@FNEOPPMM@EXCEPTION_STACK_OVERFLOW?$AA@ DB 'EXCEPTION_STACK_OVER'
	DB	'FLOW', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JGPJMHJA@EXCEPTION_NONCONTINUABLE_EXCEPTI@
CONST	SEGMENT
??_C@_0CD@JGPJMHJA@EXCEPTION_NONCONTINUABLE_EXCEPTI@ DB 'EXCEPTION_NONCON'
	DB	'TINUABLE_EXCEPTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DLLOIENN@EXCEPTION_ILLEGAL_INSTRUCTION?$AA@
CONST	SEGMENT
??_C@_0BO@DLLOIENN@EXCEPTION_ILLEGAL_INSTRUCTION?$AA@ DB 'EXCEPTION_ILLEG'
	DB	'AL_INSTRUCTION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BNDIILLI@EXCEPTION_IN_PAGE_ERROR?$AA@
CONST	SEGMENT
??_C@_0BI@BNDIILLI@EXCEPTION_IN_PAGE_ERROR?$AA@ DB 'EXCEPTION_IN_PAGE_ERR'
	DB	'OR', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HJPDFKEO@EXCEPTION_PRIV_INSTRUCTION?$AA@
CONST	SEGMENT
??_C@_0BL@HJPDFKEO@EXCEPTION_PRIV_INSTRUCTION?$AA@ DB 'EXCEPTION_PRIV_INS'
	DB	'TRUCTION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HNBKDLPO@EXCEPTION_INT_OVERFLOW?$AA@
CONST	SEGMENT
??_C@_0BH@HNBKDLPO@EXCEPTION_INT_OVERFLOW?$AA@ DB 'EXCEPTION_INT_OVERFLOW'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LBLGDPIG@EXCEPTION_INT_DIVIDE_BY_ZERO?$AA@
CONST	SEGMENT
??_C@_0BN@LBLGDPIG@EXCEPTION_INT_DIVIDE_BY_ZERO?$AA@ DB 'EXCEPTION_INT_DI'
	DB	'VIDE_BY_ZERO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CHKFJJC@EXCEPTION_FLT_UNDERFLOW?$AA@
CONST	SEGMENT
??_C@_0BI@CHKFJJC@EXCEPTION_FLT_UNDERFLOW?$AA@ DB 'EXCEPTION_FLT_UNDERFLO'
	DB	'W', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@COBCCPEI@EXCEPTION_FLT_STACK_CHECK?$AA@
CONST	SEGMENT
??_C@_0BK@COBCCPEI@EXCEPTION_FLT_STACK_CHECK?$AA@ DB 'EXCEPTION_FLT_STACK'
	DB	'_CHECK', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LGFBHAFE@EXCEPTION_FLT_OVERFLOW?$AA@
CONST	SEGMENT
??_C@_0BH@LGFBHAFE@EXCEPTION_FLT_OVERFLOW?$AA@ DB 'EXCEPTION_FLT_OVERFLOW'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JJDIIMDB@EXCEPTION_FLT_INVALID_OPERATION?$AA@
CONST	SEGMENT
??_C@_0CA@JJDIIMDB@EXCEPTION_FLT_INVALID_OPERATION?$AA@ DB 'EXCEPTION_FLT'
	DB	'_INVALID_OPERATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KLCBBCKL@EXCEPTION_FLT_INEXACT_RESULT?$AA@
CONST	SEGMENT
??_C@_0BN@KLCBBCKL@EXCEPTION_FLT_INEXACT_RESULT?$AA@ DB 'EXCEPTION_FLT_IN'
	DB	'EXACT_RESULT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PHPNMCML@EXCEPTION_FLT_DIVIDE_BY_ZERO?$AA@
CONST	SEGMENT
??_C@_0BN@PHPNMCML@EXCEPTION_FLT_DIVIDE_BY_ZERO?$AA@ DB 'EXCEPTION_FLT_DI'
	DB	'VIDE_BY_ZERO', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NMNHALMC@EXCEPTION_FLT_DENORMAL_OPERAND?$AA@
CONST	SEGMENT
??_C@_0BP@NMNHALMC@EXCEPTION_FLT_DENORMAL_OPERAND?$AA@ DB 'EXCEPTION_FLT_'
	DB	'DENORMAL_OPERAND', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JNIHFDGO@EXCEPTION_ARRAY_BOUNDS_EXCEEDED?$AA@
CONST	SEGMENT
??_C@_0CA@JNIHFDGO@EXCEPTION_ARRAY_BOUNDS_EXCEEDED?$AA@ DB 'EXCEPTION_ARR'
	DB	'AY_BOUNDS_EXCEEDED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HPCFEJHG@EXCEPTION_SINGLE_STEP?$AA@
CONST	SEGMENT
??_C@_0BG@HPCFEJHG@EXCEPTION_SINGLE_STEP?$AA@ DB 'EXCEPTION_SINGLE_STEP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FLLDOCJP@EXCEPTION_BREAKPOINT?$AA@
CONST	SEGMENT
??_C@_0BF@FLLDOCJP@EXCEPTION_BREAKPOINT?$AA@ DB 'EXCEPTION_BREAKPOINT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LEJEDDLG@EXCEPTION_DATATYPE_MISALIGNMENT?$AA@
CONST	SEGMENT
??_C@_0CA@LEJEDDLG@EXCEPTION_DATATYPE_MISALIGNMENT?$AA@ DB 'EXCEPTION_DAT'
	DB	'ATYPE_MISALIGNMENT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CMOMFGDN@EXCEPTION_ACCESS_VIOLATION?$AA@
CONST	SEGMENT
??_C@_0BL@CMOMFGDN@EXCEPTION_ACCESS_VIOLATION?$AA@ DB 'EXCEPTION_ACCESS_V'
	DB	'IOLATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KJGIGBGA@GetRegisterString?5?9?5invalid?5pExP@
CONST	SEGMENT
??_C@_0CG@KJGIGBGA@GetRegisterString?5?9?5invalid?5pExP@ DB 'GetRegisterS'
	DB	'tring - invalid pExPtrs!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EPDHCNDC@FATAL?3?5inner?5exception?5in?5?5Inter@
CONST	SEGMENT
??_C@_0DH@EPDHCNDC@FATAL?3?5inner?5exception?5in?5?5Inter@ DB 'FATAL: inn'
	DB	'er exception in  InternalGetStackTraceString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
CONST	SEGMENT
??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@ DB '%s, %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@ DB '%s()', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NDGHPOJN@?5?$CI0x?$CF08X?50x?$CF08X?50x?$CF08X?50x?$CF08X?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@NDGHPOJN@?5?$CI0x?$CF08X?50x?$CF08X?50x?$CF08X?50x?$CF08X?$CJ?$AA@ DB ' '
	DB	'(0x%08X 0x%08X 0x%08X 0x%08X)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CMMEBABO@0x?$CF016X?$AA@
CONST	SEGMENT
??_C@_07CMMEBABO@0x?$CF016X?$AA@ DB '0x%016X', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KOKCAGFJ@?5?$FLno?5module?5info?5for?50x?$CFp?$FN?5?$AA@
CONST	SEGMENT
??_C@_0BM@KOKCAGFJ@?5?$FLno?5module?5info?5for?50x?$CFp?$FN?5?$AA@ DB ' ['
	DB	'no module info for 0x%p] ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EDAGAIPM@?$CK?$CK?$CK?5break?5by?5StackWalk?5?$CK?$CK?$CK?$AA@
CONST	SEGMENT
??_C@_0BL@EDAGAIPM@?$CK?$CK?$CK?5break?5by?5StackWalk?5?$CK?$CK?$CK?$AA@ DB '*'
	DB	'** break by StackWalk ***', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FFBCHJIK@GetStackTraceString?5?9?5invalid?5pE@
CONST	SEGMENT
??_C@_0CI@FFBCHJIK@GetStackTraceString?5?9?5invalid?5pE@ DB 'GetStackTrac'
	DB	'eString - invalid pExPtrs!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LLCFKP@?$CFs?0?5line?5?$CF04d?$AA@
CONST	SEGMENT
??_C@_0O@LLCFKP@?$CFs?0?5line?5?$CF04d?$AA@ DB '%s, line %04d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GPBODGPP@?$CFs?0?5line?5?$CF04d?$CL?$CF04d?5byte?$CIs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@GPBODGPP@?$CFs?0?5line?5?$CF04d?$CL?$CF04d?5byte?$CIs?$CJ?$AA@ DB '%'
	DB	's, line %04d+%04d byte(s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5?$AA@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5?$AA@ DB '%s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CLKPGJFG@?$CFs?$CI?$CJ?$CL?$CF04d?5byte?$CIs?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@CLKPGJFG@?$CFs?$CI?$CJ?$CL?$CF04d?5byte?$CIs?$CJ?$AA@ DB '%s()+'
	DB	'%04d byte(s)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BDMEFKPB@?5at?5?$CF016X?$AA@
CONST	SEGMENT
??_C@_09BDMEFKPB@?5at?5?$CF016X?$AA@ DB ' at %016X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KOIOCIHC@?$DMUNKNOWN?$DO?$AA@
CONST	SEGMENT
??_C@_09KOIOCIHC@?$DMUNKNOWN?$DO?$AA@ DB '<UNKNOWN>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MEHCDCPC@?5in?5module?5?$AA@
CONST	SEGMENT
??_C@_0M@MEHCDCPC@?5in?5module?5?$AA@ DB ' in module ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KKJFIDEP@NTDLL?4DLL?$AA@
CONST	SEGMENT
??_C@_09KKJFIDEP@NTDLL?4DLL?$AA@ DB 'NTDLL.DLL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CMJODOBC@?5caused?5an?5?$AA@
CONST	SEGMENT
??_C@_0M@CMJODOBC@?5caused?5an?5?$AA@ DB ' caused an ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DCHDKHJI@Bad?5parameter?5to?5GetFaultReasonA@
CONST	SEGMENT
??_C@_0CC@DCHDKHJI@Bad?5parameter?5to?5GetFaultReasonA@ DB 'Bad parameter'
	DB	' to GetFaultReasonA', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KECBMHB@EXCEPTION_STACK_OVERFLOW?5occurre@
CONST	SEGMENT
??_C@_0CD@KECBMHB@EXCEPTION_STACK_OVERFLOW?5occurre@ DB 'EXCEPTION_STACK_'
	DB	'OVERFLOW occurred', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LBDEJLAP@?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB@
CONST	SEGMENT
??_C@_0CD@LBDEJLAP@?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB@ DB '!'
	DB	'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@DKBODLE@Serious?5trouble?5in?5the?5house?$CB?5?9?5@
CONST	SEGMENT
??_C@_0DF@DKBODLE@Serious?5trouble?5in?5the?5house?$CB?5?9?5@ DB 'Serious'
	DB	' trouble in the house! - HeapAlloc failed!!!', 0aH, 00H ; `string'
PI_MUL_2 DD	040c90fdbr			; 6.28319
PUBLIC	?CleanupSymEng@@YAXXZ				; CleanupSymEng
PUBLIC	?InitSymEng@@YAXXZ				; InitSymEng
PUBLIC	?InternalSymGetLineFromAddr@@YAHPEAXKPEAKPEAU_IMAGEHLP_LINE64@@@Z ; InternalSymGetLineFromAddr
PUBLIC	?InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z ; InternalGetStackTraceString
PUBLIC	?CH_ReadProcessMemory@@YAHPEAXPEBX0KPEAK@Z	; CH_ReadProcessMemory
PUBLIC	?CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z ; CrashHandlerExceptionFilter
PUBLIC	??1CleanUpCrashHandler@@QEAA@XZ			; CleanUpCrashHandler::~CleanUpCrashHandler
PUBLIC	??0CleanUpCrashHandler@@QEAA@XZ			; CleanUpCrashHandler::CleanUpCrashHandler
PUBLIC	GetFirstStackTraceString
PUBLIC	GetNextStackTraceString
	ALIGN	4

g_stSymbol DB	0200H DUP (?)
g_stFrame DB	0108H DUP (?)
_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

g_szBuff DB	0400H DUP (?)
g_cBeforeAndAfter DB 01H DUP (?)
	ALIGN	4

g_stLine DB	028H DUP (?)
piecewise_construct DB 01H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$?CleanupSymEng@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$?CleanupSymEng@@YAXXZ
$pdata$?InitSymEng@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+102
	DD	imagerel $unwind$?InitSymEng@@YAXXZ
$pdata$?InternalSymGetLineFromAddr@@YAHPEAXKPEAKPEAU_IMAGEHLP_LINE64@@@Z DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$?InternalSymGetLineFromAddr@@YAHPEAXKPEAKPEAU_IMAGEHLP_LINE64@@@Z
$pdata$?InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z DD imagerel $LN28
	DD	imagerel $LN28+1574
	DD	imagerel $unwind$?InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?filt$0@?0??InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z@4HA DD imagerel ?filt$0@?0??InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z@4HA
	DD	imagerel ?filt$0@?0??InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z@4HA+21
	DD	imagerel $unwind$?filt$0@?0??InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z@4HA
pdata	ENDS
pdata	SEGMENT
$pdata$?CH_ReadProcessMemory@@YAHPEAXPEBX0KPEAK@Z DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$?CH_ReadProcessMemory@@YAHPEAXPEBX0KPEAK@Z
$pdata$?CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z DD imagerel $LN22
	DD	imagerel $LN22+335
	DD	imagerel $unwind$?CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?filt$0@?0??CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z@4HA DD imagerel ?filt$0@?0??CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z@4HA
	DD	imagerel ?filt$0@?0??CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z@4HA+21
	DD	imagerel $unwind$?filt$0@?0??CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fg_cBeforeAndAfter@@YAXXZ DD imagerel ??__Fg_cBeforeAndAfter@@YAXXZ
	DD	imagerel ??__Fg_cBeforeAndAfter@@YAXXZ+21
	DD	imagerel $unwind$??__Fg_cBeforeAndAfter@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eg_cBeforeAndAfter@@YAXXZ DD imagerel ??__Eg_cBeforeAndAfter@@YAXXZ
	DD	imagerel ??__Eg_cBeforeAndAfter@@YAXXZ+21
	DD	imagerel $unwind$??__Eg_cBeforeAndAfter@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1CleanUpCrashHandler@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+82
	DD	imagerel $unwind$??1CleanUpCrashHandler@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$GetFirstStackTraceString DD imagerel $LN3
	DD	imagerel $LN3+149
	DD	imagerel $unwind$GetFirstStackTraceString
$pdata$GetNextStackTraceString DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$GetNextStackTraceString
g_cBeforeAndAfter$initializer$ DQ FLAT:??__Eg_cBeforeAndAfter@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1CleanUpCrashHandler@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eg_cBeforeAndAfter@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fg_cBeforeAndAfter@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
xdata	SEGMENT
$unwind$?CleanupSymEng@@YAXXZ DD 010401H
	DD	04204H
$unwind$?InitSymEng@@YAXXZ DD 010401H
	DD	06204H
$unwind$?InternalSymGetLineFromAddr@@YAHPEAXKPEAKPEAU_IMAGEHLP_LINE64@@@Z DD 011701H
	DD	04217H
$unwind$?InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z DD 051309H
	DD	0140113H
	DD	0600b700cH
	DD	0300aH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN28+62
	DD	imagerel $LN28+1537
	DD	imagerel ?filt$0@?0??InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z@4HA
	DD	imagerel $LN28+1537
$unwind$?filt$0@?0??InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z@4HA DD 020601H
	DD	050029206H
$unwind$?CH_ReadProcessMemory@@YAHPEAXPEBX0KPEAK@Z DD 011801H
	DD	08218H
$unwind$?CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z DD 010909H
	DD	08209H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN22+73
	DD	imagerel $LN22+318
	DD	imagerel ?filt$0@?0??CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z@4HA
	DD	imagerel $LN22+318
$unwind$?filt$0@?0??CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z@4HA DD 020601H
	DD	050023206H
$unwind$GetFirstStackTraceString DD 010d01H
	DD	0420dH
$unwind$GetNextStackTraceString DD 010d01H
	DD	0420dH
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
_TEXT	SEGMENT
dwOpts$ = 48
pExPtrs$ = 56
GetNextStackTraceString PROC

; 656  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 657  :     // All error checking is in InternalGetStackTraceString.
; 658  :     // Assume that GetFirstStackTraceString has already initialized the
; 659  :     // stack frame information.
; 660  :     return ( InternalGetStackTraceString ( dwOpts , pExPtrs ) ) ;

	mov	rdx, QWORD PTR pExPtrs$[rsp]
	mov	ecx, DWORD PTR dwOpts$[rsp]
	call	?InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z ; InternalGetStackTraceString

; 661  : }

	add	rsp, 40					; 00000028H
	ret	0
GetNextStackTraceString ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
_TEXT	SEGMENT
dwOpts$ = 48
pExPtrs$ = 56
GetFirstStackTraceString PROC

; 611  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 612  :     // All the error checking is in the InternalGetStackTraceString
; 613  :     // function.
; 614  : 
; 615  :     // Initialize the STACKFRAME structure.
; 616  :     ZeroMemory ( &g_stFrame , sizeof ( STACKFRAME ) ) ;

	mov	r8d, 264				; 00000108H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:g_stFrame
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16

; 617  : 
; 618  :    #ifdef _X86_
; 619  :     g_stFrame.AddrPC.Offset       = pExPtrs->ContextRecord->Eip ;
; 620  :     g_stFrame.AddrPC.Mode         = AddrModeFlat                ;
; 621  :     g_stFrame.AddrStack.Offset    = pExPtrs->ContextRecord->Esp ;
; 622  :     g_stFrame.AddrStack.Mode      = AddrModeFlat                ;
; 623  :     g_stFrame.AddrFrame.Offset    = pExPtrs->ContextRecord->Ebp ;
; 624  :     g_stFrame.AddrFrame.Mode      = AddrModeFlat                ;
; 625  :     #else
; 626  : /*    g_stFrame.AddrPC.Offset       = (DWORD)pExPtrs->ContextRecord->Fir ;
; 627  :     g_stFrame.AddrPC.Mode         = AddrModeFlat ;
; 628  :     g_stFrame.AddrReturn.Offset   =
; 629  :                                    (DWORD)pExPtrs->ContextRecord->IntRa;
; 630  :     g_stFrame.AddrReturn.Mode     = AddrModeFlat ;
; 631  :     g_stFrame.AddrStack.Offset    =
; 632  :                                    (DWORD)pExPtrs->ContextRecord->IntSp;
; 633  :     g_stFrame.AddrStack.Mode      = AddrModeFlat ;
; 634  :     g_stFrame.AddrFrame.Offset    =
; 635  :                                    (DWORD)pExPtrs->ContextRecord->IntFp;
; 636  :     g_stFrame.AddrFrame.Mode      = AddrModeFlat ;*/
; 637  : 	g_stFrame.AddrPC.Offset       = (DWORD)pExPtrs->ContextRecord->Rip ;

	mov	rax, QWORD PTR pExPtrs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+248]
	mov	QWORD PTR g_stFrame, rax

; 638  :     g_stFrame.AddrPC.Mode         = AddrModeFlat ;

	mov	DWORD PTR g_stFrame+12, 3

; 639  :  //   g_stFrame.AddrReturn.Offset   =
; 640  :  //                                  (DWORD)pExPtrs->ContextRecord->IntRa;
; 641  : //    g_stFrame.AddrReturn.Mode     = AddrModeFlat ;
; 642  :     g_stFrame.AddrStack.Offset    =
; 643  :                                    (DWORD)pExPtrs->ContextRecord->Rsp;

	mov	rax, QWORD PTR pExPtrs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+152]
	mov	QWORD PTR g_stFrame+48, rax

; 644  :     g_stFrame.AddrStack.Mode      = AddrModeFlat ;

	mov	DWORD PTR g_stFrame+60, 3

; 645  :     g_stFrame.AddrFrame.Offset    =
; 646  :                                    (DWORD)pExPtrs->ContextRecord->Rbp;

	mov	rax, QWORD PTR pExPtrs$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+160]
	mov	QWORD PTR g_stFrame+32, rax

; 647  :     g_stFrame.AddrFrame.Mode      = AddrModeFlat ;

	mov	DWORD PTR g_stFrame+44, 3

; 648  :     #endif
; 649  : 
; 650  :     return ( InternalGetStackTraceString ( dwOpts , pExPtrs ) ) ;

	mov	rdx, QWORD PTR pExPtrs$[rsp]
	mov	ecx, DWORD PTR dwOpts$[rsp]
	call	?InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z ; InternalGetStackTraceString

; 651  : }

	add	rsp, 40					; 00000028H
	ret	0
GetFirstStackTraceString ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
;	COMDAT ??0CleanUpCrashHandler@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0CleanUpCrashHandler@@QEAA@XZ PROC			; CleanUpCrashHandler::CleanUpCrashHandler, COMDAT

; 102  :     CleanUpCrashHandler ( void )

	mov	QWORD PTR [rsp+8], rcx

; 103  :     {
; 104  :     }

	mov	rax, QWORD PTR this$[rsp]
	ret	0
??0CleanUpCrashHandler@@QEAA@XZ ENDP			; CleanUpCrashHandler::CleanUpCrashHandler
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
;	COMDAT ??1CleanUpCrashHandler@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1CleanUpCrashHandler@@QEAA@XZ PROC			; CleanUpCrashHandler::~CleanUpCrashHandler, COMDAT

; 106  :     {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 107  :         // Are there any outstanding memory allocations?
; 108  :         if ( NULL != g_ahMod )

	cmp	QWORD PTR g_ahMod, 0
	je	SHORT $LN2@CleanUpCra

; 109  :         {
; 110  :             VERIFY ( HeapFree ( GetProcessHeap ( ) ,

	call	QWORD PTR __imp_GetProcessHeap
	mov	r8, QWORD PTR g_ahMod
	xor	edx, edx
	mov	rcx, rax
	call	QWORD PTR __imp_HeapFree

; 111  :                                 0                  ,
; 112  :                                 g_ahMod             ) ) ;
; 113  :             g_ahMod = NULL ;

	mov	QWORD PTR g_ahMod, 0
$LN2@CleanUpCra:

; 114  :         }
; 115  :         if ( NULL != g_pfnOrigFilt )

	cmp	QWORD PTR g_pfnOrigFilt, 0
	je	SHORT $LN1@CleanUpCra

; 116  :         {
; 117  :             // Restore the original unhandled exception filter.
; 118  :             SetUnhandledExceptionFilter ( g_pfnOrigFilt ) ;

	mov	rcx, QWORD PTR g_pfnOrigFilt
	call	QWORD PTR __imp_SetUnhandledExceptionFilter
$LN1@CleanUpCra:

; 119  :         }
; 120  :     }

	add	rsp, 40					; 00000028H
	ret	0
??1CleanUpCrashHandler@@QEAA@XZ ENDP			; CleanUpCrashHandler::~CleanUpCrashHandler
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
;	COMDAT ??__Eg_cBeforeAndAfter@@YAXXZ
text$di	SEGMENT
??__Eg_cBeforeAndAfter@@YAXXZ PROC			; `dynamic initializer for 'g_cBeforeAndAfter'', COMDAT

; 124  : static CleanUpCrashHandler g_cBeforeAndAfter ;

	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:??__Fg_cBeforeAndAfter@@YAXXZ ; `dynamic atexit destructor for 'g_cBeforeAndAfter''
	call	atexit
	add	rsp, 40					; 00000028H
	ret	0
??__Eg_cBeforeAndAfter@@YAXXZ ENDP			; `dynamic initializer for 'g_cBeforeAndAfter''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fg_cBeforeAndAfter@@YAXXZ
text$yd	SEGMENT
??__Fg_cBeforeAndAfter@@YAXXZ PROC			; `dynamic atexit destructor for 'g_cBeforeAndAfter'', COMDAT
	sub	rsp, 40					; 00000028H
	lea	rcx, OFFSET FLAT:g_cBeforeAndAfter
	call	??1CleanUpCrashHandler@@QEAA@XZ		; CleanUpCrashHandler::~CleanUpCrashHandler
	add	rsp, 40					; 00000028H
	ret	0
??__Fg_cBeforeAndAfter@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_cBeforeAndAfter''
text$yd	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
_TEXT	SEGMENT
i$1 = 32
lRet$ = 36
bCallIt$2 = 40
hBaseAddr$3 = 48
tv75 = 56
pExPtrs$ = 80
?CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z PROC ; CrashHandlerExceptionFilter

; 257  : {

$LN22:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 258  :     LONG lRet = EXCEPTION_CONTINUE_SEARCH ;

	mov	DWORD PTR lRet$[rsp], 0

; 259  : 
; 260  :     // If the exception is an EXCEPTION_STACK_OVERFLOW, there isn't much
; 261  :     // you can do because the stack is blown. If you try to do anything,
; 262  :     // the odds are great that you'll just double-fault and bomb right
; 263  :     // out of your exception filter. Although I don't recommend doing so,
; 264  :     // you could play some games with the stack register and
; 265  :     // manipulate it so that you could regain enough space to run these
; 266  :     // functions. Of course, if you did change the stack register, you'd
; 267  :     // have problems walking the stack.
; 268  :     // I take the safe route and make some calls to OutputDebugString here.
; 269  :     // I still might double-fault, but because OutputDebugString does very
; 270  :     // little on the stack (something like 8-16 bytes), it's worth a
; 271  :     // shot. You can have your users download Mark Russinovich's
; 272  :     // DebugView/Enterprise Edition (www.sysinternals.com) so they can
; 273  :     // at least tell you what they see.
; 274  :     // The only problem is that I can't even be sure there's enough
; 275  :     // room on the stack to convert the instruction pointer.
; 276  :     // Fortunately, EXCEPTION_STACK_OVERFLOW doesn't happen very often.
; 277  : 
; 278  :     // Note that I still call your crash handler. I'm doing the logging
; 279  :     // work here in case the blown stack kills your crash handler.
; 280  :     if ( EXCEPTION_STACK_OVERFLOW ==
; 281  :                               pExPtrs->ExceptionRecord->ExceptionCode )

	mov	rax, QWORD PTR pExPtrs$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	DWORD PTR [rax], -1073741571		; c00000fdH
	jne	SHORT $LN14@CrashHandl

; 282  :     {
; 283  :         OutputDebugString ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CD@LBDEJLAP@?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB@
	call	QWORD PTR __imp_OutputDebugStringA

; 284  :         OutputDebugString ( "EXCEPTION_STACK_OVERFLOW occurred\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CD@KECBMHB@EXCEPTION_STACK_OVERFLOW?5occurre@
	call	QWORD PTR __imp_OutputDebugStringA

; 285  :         OutputDebugString ( "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CD@LBDEJLAP@?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB?$CB@
	call	QWORD PTR __imp_OutputDebugStringA
	npad	1
$LN14@CrashHandl:

; 286  :     }
; 287  : 
; 288  :     __try
; 289  :     {
; 290  : 
; 291  :         if ( NULL != g_pfnCallBack )

	cmp	QWORD PTR g_pfnCallBack, 0
	je	$LN12@CrashHandl

; 292  :         {
; 293  : 
; 294  :             // The symbol engine has to be initialized here so that
; 295  :             // I can look up the base module information for the
; 296  :             // crash address as well as get the symbol engine
; 297  :             // ready.
; 298  :             InitSymEng ( ) ;

	call	?InitSymEng@@YAXXZ			; InitSymEng

; 299  : 
; 300  :             // Check the g_ahMod list.
; 301  :             BOOL bCallIt = FALSE ;

	mov	DWORD PTR bCallIt$2[rsp], 0

; 302  :             if ( 0 == g_uiModCount )

	cmp	DWORD PTR g_uiModCount, 0
	jne	SHORT $LN11@CrashHandl

; 303  :             {
; 304  :                 bCallIt = TRUE ;

	mov	DWORD PTR bCallIt$2[rsp], 1

; 305  :             }
; 306  :             else

	jmp	SHORT $LN10@CrashHandl
$LN11@CrashHandl:

; 307  :             {
; 308  :                 HINSTANCE hBaseAddr = (HINSTANCE)
; 309  :                       SymGetModuleBase((HANDLE)GetCurrentProcessId ( ) ,
; 310  :                                        (DWORD)pExPtrs->
; 311  :                                             ExceptionRecord->
; 312  :                                                       ExceptionAddress);

	mov	rax, QWORD PTR pExPtrs$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	eax, DWORD PTR [rax+16]
	mov	QWORD PTR tv75[rsp], rax
	call	QWORD PTR __imp_GetCurrentProcessId
	mov	eax, eax
	mov	rcx, QWORD PTR tv75[rsp]
	mov	rdx, rcx
	mov	ecx, eax
	call	QWORD PTR __imp_SymGetModuleBase64
	mov	QWORD PTR hBaseAddr$3[rsp], rax

; 313  :                 if ( NULL != hBaseAddr )

	cmp	QWORD PTR hBaseAddr$3[rsp], 0
	je	SHORT $LN10@CrashHandl

; 314  :                 {
; 315  :                     for ( UINT i = 0 ; i < g_uiModCount ; i ++ )

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN8@CrashHandl
$LN7@CrashHandl:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN8@CrashHandl:
	mov	eax, DWORD PTR g_uiModCount
	cmp	DWORD PTR i$1[rsp], eax
	jae	SHORT $LN10@CrashHandl

; 316  :                     {
; 317  :                         if ( hBaseAddr == g_ahMod[ i ] )

	mov	eax, DWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR g_ahMod
	mov	rax, QWORD PTR [rcx+rax*8]
	cmp	QWORD PTR hBaseAddr$3[rsp], rax
	jne	SHORT $LN5@CrashHandl

; 318  :                         {
; 319  :                             bCallIt = TRUE ;

	mov	DWORD PTR bCallIt$2[rsp], 1

; 320  :                             break ;

	jmp	SHORT $LN10@CrashHandl
$LN5@CrashHandl:

; 321  :                         }
; 322  :                     }

	jmp	SHORT $LN7@CrashHandl
$LN10@CrashHandl:

; 323  :                 }
; 324  :             }
; 325  :             if ( TRUE == bCallIt )

	cmp	DWORD PTR bCallIt$2[rsp], 1
	jne	SHORT $LN4@CrashHandl

; 326  :             {
; 327  :                 // Check that the crash handler still exists in memory
; 328  :                 // before I call it. The user might have forgotten to
; 329  :                 // unregister, and the crash handler is invalid because
; 330  :                 // it got unloaded. If some other function loaded
; 331  :                 // back into the same address, however, there isn't much
; 332  :                 // I can do.
; 333  :                 ASSERT ( FALSE == IsBadCodePtr((FARPROC)g_pfnCallBack));
; 334  :                 if ( FALSE == IsBadCodePtr ( (FARPROC)g_pfnCallBack ) )

	mov	rcx, QWORD PTR g_pfnCallBack
	call	QWORD PTR __imp_IsBadCodePtr
	test	eax, eax
	jne	SHORT $LN3@CrashHandl

; 335  :                 {
; 336  :                     lRet = g_pfnCallBack ( pExPtrs ) ;

	mov	rcx, QWORD PTR pExPtrs$[rsp]
	call	QWORD PTR g_pfnCallBack
	mov	DWORD PTR lRet$[rsp], eax
$LN3@CrashHandl:

; 337  :                 }
; 338  :             }
; 339  :             else

	jmp	SHORT $LN2@CrashHandl
$LN4@CrashHandl:

; 340  :             {
; 341  :                 // Call the previous filter but only after it checks
; 342  :                 // out. I'm just being a little paranoid.
; 343  :                 ASSERT ( FALSE == IsBadCodePtr((FARPROC)g_pfnOrigFilt));
; 344  :                 if ( FALSE == IsBadCodePtr ( (FARPROC)g_pfnOrigFilt ) )

	mov	rcx, QWORD PTR g_pfnOrigFilt
	call	QWORD PTR __imp_IsBadCodePtr
	test	eax, eax
	jne	SHORT $LN2@CrashHandl

; 345  :                 {
; 346  :                     lRet = g_pfnOrigFilt ( pExPtrs ) ;

	mov	rcx, QWORD PTR pExPtrs$[rsp]
	call	QWORD PTR g_pfnOrigFilt
	mov	DWORD PTR lRet$[rsp], eax
$LN2@CrashHandl:

; 347  :                 }
; 348  :             }
; 349  :             CleanupSymEng ( ) ;

	call	?CleanupSymEng@@YAXXZ			; CleanupSymEng
$LN12@CrashHandl:

; 350  :         }
; 351  :     }

	jmp	SHORT $LN21@CrashHandl
$LN19@CrashHandl:

; 352  :     __except ( EXCEPTION_EXECUTE_HANDLER )
; 353  :     {
; 354  :         lRet = EXCEPTION_CONTINUE_SEARCH ;

	mov	DWORD PTR lRet$[rsp], 0
$LN21@CrashHandl:

; 355  :     }
; 356  :     return ( lRet ) ;

	mov	eax, DWORD PTR lRet$[rsp]
$LN17@CrashHandl:

; 357  : }

	add	rsp, 72					; 00000048H
	ret	0
?CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z ENDP ; CrashHandlerExceptionFilter
_TEXT	ENDS
; Function compile flags: /Odspy
text$x	SEGMENT
i$1 = 32
lRet$ = 36
bCallIt$2 = 40
hBaseAddr$3 = 48
tv75 = 56
pExPtrs$ = 80
?filt$0@?0??CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z@4HA PROC ; `CrashHandlerExceptionFilter'::`1'::filt$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
$LN18@filt$0:

; 352  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN20@filt$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?filt$0@?0??CrashHandlerExceptionFilter@@YAJPEAU_EXCEPTION_POINTERS@@@Z@4HA ENDP ; `CrashHandlerExceptionFilter'::`1'::filt$0
text$x	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
_TEXT	SEGMENT
tv66 = 48
__formal$ = 80
lpBaseAddress$ = 88
lpBuffer$ = 96
nSize$ = 104
lpNumberOfBytesRead$ = 112
?CH_ReadProcessMemory@@YAHPEAXPEBX0KPEAK@Z PROC		; CH_ReadProcessMemory

; 668  : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 669  :     return ( ReadProcessMemory ( GetCurrentProcess ( ) ,
; 670  :                                  lpBaseAddress         ,
; 671  :                                  lpBuffer              ,
; 672  :                                  nSize                 ,
; 673  : #ifdef _WIN64
; 674  : 								 (SIZE_T *)lpNumberOfBytesRead 
; 675  : #else
; 676  :                                  lpNumberOfBytesRead   
; 677  : #endif
; 678  : 								 ) ) ;

	mov	eax, DWORD PTR nSize$[rsp]
	mov	QWORD PTR tv66[rsp], rax
	call	QWORD PTR __imp_GetCurrentProcess
	mov	rcx, QWORD PTR lpNumberOfBytesRead$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, QWORD PTR tv66[rsp]
	mov	r9, rcx
	mov	r8, QWORD PTR lpBuffer$[rsp]
	mov	rdx, QWORD PTR lpBaseAddress$[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_ReadProcessMemory

; 679  : }

	add	rsp, 72					; 00000048H
	ret	0
?CH_ReadProcessMemory@@YAHPEAXPEBX0KPEAK@Z ENDP		; CH_ReadProcessMemory
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
_TEXT	SEGMENT
iCurr$1 = 80
dwDisp$2 = 84
szRet$ = 88
pSym$3 = 96
dwTemp$ = 104
dwModBase$ = 108
tv165 = 112
bSWRet$4 = 116
tv168 = 120
tv170 = 128
tv77 = 136
tv209 = 144
dwOpts$ = 192
pExPtrs$ = 200
?InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z PROC ; InternalGetStackTraceString

; 685  : {

$LN28:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 160				; 000000a0H

; 686  : 
; 687  :     ASSERT ( FALSE == IsBadReadPtr ( pExPtrs                      ,
; 688  :                                      sizeof ( EXCEPTION_POINTERS ) ) ) ;
; 689  :     if ( TRUE == IsBadReadPtr ( pExPtrs                      ,
; 690  :                                 sizeof ( EXCEPTION_POINTERS ) ) )

	mov	edx, 16
	mov	rcx, QWORD PTR pExPtrs$[rsp]
	call	QWORD PTR __imp_IsBadReadPtr
	cmp	eax, 1
	jne	SHORT $LN20@InternalGe

; 691  :     {
; 692  :         TRACE0 ( "GetStackTraceString - invalid pExPtrs!\n" ) ;

	lea	rcx, OFFSET FLAT:??_C@_0CI@FFBCHJIK@GetStackTraceString?5?9?5invalid?5pE@
	call	?Log@@YAXPEBD@Z				; Log

; 693  :         return ( NULL ) ;

	xor	eax, eax
	jmp	$LN23@InternalGe
$LN20@InternalGe:

; 694  :     }
; 695  : 
; 696  :     // The value that is returned
; 697  :     LPCTSTR szRet ;
; 698  :     // A temporary variable for all to use. This variable saves
; 699  :     // stack space.
; 700  :     DWORD dwTemp ;
; 701  :     // The module base address. I look this up right after the stack
; 702  :     // walk to ensure that the module is valid.
; 703  :     DWORD dwModBase ;
; 704  : 
; 705  :     __try
; 706  :     {
; 707  :         // Initialize the symbol engine in case it isn't initialized.
; 708  :         InitSymEng ( ) ;

	call	?InitSymEng@@YAXXZ			; InitSymEng

; 709  : 
; 710  : #ifdef _WIN64
; 711  : #define CH_MACHINE IMAGE_FILE_MACHINE_IA64
; 712  : #else
; 713  : #define CH_MACHINE IMAGE_FILE_MACHINE_I386
; 714  : #endif
; 715  :         // Note:  If the source file and line number functions are used,
; 716  :         //        StackWalk can cause an access violation.
; 717  :         BOOL bSWRet = StackWalk ( CH_MACHINE                        ,
; 718  :                                   (HANDLE)GetCurrentProcessId ( )   ,
; 719  :                                   GetCurrentThread ( )              ,
; 720  :                                   &g_stFrame                        ,
; 721  :                                   pExPtrs->ContextRecord            ,
; 722  :                                   (PREAD_PROCESS_MEMORY_ROUTINE)
; 723  :                                                CH_ReadProcessMemory ,
; 724  :                                   SymFunctionTableAccess            ,
; 725  :                                   SymGetModuleBase                  ,
; 726  :                                   NULL                               ) ;

	call	QWORD PTR __imp_GetCurrentThread
	mov	QWORD PTR tv77[rsp], rax
	call	QWORD PTR __imp_GetCurrentProcessId
	mov	eax, eax
	mov	QWORD PTR [rsp+64], 0
	mov	rcx, QWORD PTR __imp_SymGetModuleBase64
	mov	QWORD PTR [rsp+56], rcx
	mov	rcx, QWORD PTR __imp_SymFunctionTableAccess64
	mov	QWORD PTR [rsp+48], rcx
	lea	rcx, OFFSET FLAT:?CH_ReadProcessMemory@@YAHPEAXPEBX0KPEAK@Z ; CH_ReadProcessMemory
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR pExPtrs$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+32], rcx
	lea	r9, OFFSET FLAT:g_stFrame
	mov	rcx, QWORD PTR tv77[rsp]
	mov	r8, rcx
	mov	edx, eax
	mov	ecx, 512				; 00000200H
	call	QWORD PTR __imp_StackWalk64
	mov	DWORD PTR bSWRet$4[rsp], eax

; 727  :         if ( ( FALSE == bSWRet ) || ( 0 == g_stFrame.AddrFrame.Offset ))

	cmp	DWORD PTR bSWRet$4[rsp], 0
	je	SHORT $LN17@InternalGe
	cmp	QWORD PTR g_stFrame+32, 0
	jne	SHORT $LN18@InternalGe
$LN17@InternalGe:

; 728  :         {
; 729  : 			TRACE0("*** break by StackWalk ***");

	lea	rcx, OFFSET FLAT:??_C@_0BL@EDAGAIPM@?$CK?$CK?$CK?5break?5by?5StackWalk?5?$CK?$CK?$CK?$AA@
	call	?Log@@YAXPEBD@Z				; Log

; 730  :             szRet = NULL;

	mov	QWORD PTR szRet$[rsp], 0

; 731  :             return ( szRet ) ;

	mov	rax, QWORD PTR szRet$[rsp]
	jmp	$LN23@InternalGe
$LN18@InternalGe:

; 732  :         }
; 733  : 
; 734  :         // Before I get too carried away and start calculating
; 735  :         // everything, I need to double-check that the address returned
; 736  :         // by StackWalk really exists. I've seen cases in which
; 737  :         // StackWalk returns TRUE but the address doesn't belong to
; 738  :         // a module in the process.
; 739  :         dwModBase = SymGetModuleBase ( (HANDLE)GetCurrentProcessId ( ),
; 740  :                                         g_stFrame.AddrPC.Offset       );

	call	QWORD PTR __imp_GetCurrentProcessId
	mov	eax, eax
	mov	rdx, QWORD PTR g_stFrame
	mov	ecx, eax
	call	QWORD PTR __imp_SymGetModuleBase64
	mov	DWORD PTR dwModBase$[rsp], eax

; 741  :         if ( 0 == dwModBase )

	cmp	DWORD PTR dwModBase$[rsp], 0
	jne	SHORT $LN16@InternalGe

; 742  :         {
; 743  : 			// TRACE0("*** break by SymGetModuleBase ***");
; 744  : 			sprintf_s(g_szBuff, 1023, " [no module info for 0x%p] ", g_stFrame.AddrPC.Offset);

	mov	r9, QWORD PTR g_stFrame
	lea	r8, OFFSET FLAT:??_C@_0BM@KOKCAGFJ@?5?$FLno?5module?5info?5for?50x?$CFp?$FN?5?$AA@
	mov	edx, 1023				; 000003ffH
	lea	rcx, OFFSET FLAT:g_szBuff
	call	QWORD PTR __imp_sprintf_s

; 745  :             szRet = g_szBuff;

	lea	rax, OFFSET FLAT:g_szBuff
	mov	QWORD PTR szRet$[rsp], rax
$LN16@InternalGe:

; 746  :             // return ( szRet ) ;
; 747  :         }
; 748  : 
; 749  :         int iCurr = 0 ;

	mov	DWORD PTR iCurr$1[rsp], 0

; 750  : 
; 751  :         // At a minimum, put in the address.
; 752  : #ifdef _WIN64
; 753  :         iCurr += wsprintf ( g_szBuff + iCurr        ,
; 754  :                             _T ( "0x%016X" )         ,
; 755  :                             g_stFrame.AddrPC.Offset  ) ;

	movsxd	rax, DWORD PTR iCurr$1[rsp]
	lea	rcx, OFFSET FLAT:g_szBuff
	add	rcx, rax
	mov	rax, rcx
	mov	r8, QWORD PTR g_stFrame
	lea	rdx, OFFSET FLAT:??_C@_07CMMEBABO@0x?$CF016X?$AA@
	mov	rcx, rax
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax

; 756  : #else
; 757  :         iCurr += wsprintf ( g_szBuff + iCurr              ,
; 758  :                             _T ( "%04X:%08X" )            ,
; 759  :                             pExPtrs->ContextRecord->SegCs ,
; 760  :                             g_stFrame.AddrPC.Offset        ) ;
; 761  : #endif
; 762  : 
; 763  :         // Output the parameters?
; 764  :         if ( GSTSO_PARAMS == ( dwOpts & GSTSO_PARAMS ) )

	mov	eax, DWORD PTR dwOpts$[rsp]
	and	eax, 1
	cmp	eax, 1
	jne	$LN15@InternalGe

; 765  :         {
; 766  :             iCurr += wsprintf ( g_szBuff + iCurr          ,
; 767  :                                 _T ( " (0x%08X 0x%08X "\
; 768  :                                       "0x%08X 0x%08X)"  ) ,
; 769  :                                 g_stFrame.Params[ 0 ]     ,
; 770  :                                 g_stFrame.Params[ 1 ]     ,
; 771  :                                 g_stFrame.Params[ 2 ]     ,
; 772  :                                 g_stFrame.Params[ 3 ]      ) ;

	mov	eax, 8
	imul	rax, rax, 3
	lea	rcx, OFFSET FLAT:g_stFrame+88
	mov	edx, 8
	imul	rdx, rdx, 2
	lea	r8, OFFSET FLAT:g_stFrame+88
	mov	r9d, 8
	imul	r9, r9, 1
	lea	r10, OFFSET FLAT:g_stFrame+88
	mov	r11d, 8
	imul	r11, r11, 0
	lea	rbx, OFFSET FLAT:g_stFrame+88
	movsxd	rdi, DWORD PTR iCurr$1[rsp]
	lea	rsi, OFFSET FLAT:g_szBuff
	add	rsi, rdi
	mov	rdi, rsi
	mov	rax, QWORD PTR [rcx+rax]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR [r8+rdx]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR [r10+r9]
	mov	r8, QWORD PTR [rbx+r11]
	lea	rdx, OFFSET FLAT:??_C@_0BP@NDGHPOJN@?5?$CI0x?$CF08X?50x?$CF08X?50x?$CF08X?50x?$CF08X?$CJ?$AA@
	mov	rcx, rdi
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax
$LN15@InternalGe:

; 773  :         }
; 774  :         // Output the module name.
; 775  :         if ( GSTSO_MODULE == ( dwOpts & GSTSO_MODULE ) )

	mov	eax, DWORD PTR dwOpts$[rsp]
	and	eax, 2
	cmp	eax, 2
	jne	$LN14@InternalGe

; 776  :         {
; 777  :             iCurr += wsprintf ( g_szBuff + iCurr  , _T ( " " ) ) ;

	movsxd	rax, DWORD PTR iCurr$1[rsp]
	lea	rcx, OFFSET FLAT:g_szBuff
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	mov	rcx, rax
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax

; 778  : 
; 779  :             ASSERT ( iCurr < ( BUFF_SIZE - MAX_PATH ) ) ;
; 780  :             iCurr += BSUGetModuleBaseName ( GetCurrentProcess ( ) ,
; 781  :                                             (HINSTANCE)dwModBase  ,
; 782  :                                             g_szBuff + iCurr      ,
; 783  :                                             BUFF_SIZE - iCurr      ) ;

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR iCurr$1[rsp]
	mov	DWORD PTR tv165[rsp], eax
	movsxd	rcx, DWORD PTR iCurr$1[rsp]
	lea	rdx, OFFSET FLAT:g_szBuff
	add	rdx, rcx
	mov	rcx, rdx
	mov	QWORD PTR tv168[rsp], rcx
	mov	edx, DWORD PTR dwModBase$[rsp]
	mov	QWORD PTR tv170[rsp], rdx
	call	QWORD PTR __imp_GetCurrentProcess
	mov	ecx, DWORD PTR tv165[rsp]
	mov	r9d, ecx
	mov	rcx, QWORD PTR tv168[rsp]
	mov	r8, rcx
	mov	rcx, QWORD PTR tv170[rsp]
	mov	rdx, rcx
	mov	rcx, rax
	call	BSUGetModuleBaseName
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax
$LN14@InternalGe:

; 784  :         }
; 785  : 
; 786  :         ASSERT ( iCurr < ( BUFF_SIZE - MAX_PATH ) ) ;
; 787  :         DWORD dwDisp ;
; 788  : 
; 789  :         // Output the symbol name?
; 790  :         if ( GSTSO_SYMBOL == ( dwOpts & GSTSO_SYMBOL ) )

	mov	eax, DWORD PTR dwOpts$[rsp]
	and	eax, 4
	cmp	eax, 4
	jne	$LN13@InternalGe

; 791  :         {
; 792  : 
; 793  :             // Start looking up the exception address.
; 794  :             PIMAGEHLP_SYMBOL pSym = (PIMAGEHLP_SYMBOL)&g_stSymbol ;

	lea	rax, OFFSET FLAT:g_stSymbol
	mov	QWORD PTR pSym$3[rsp], rax

; 795  :             ZeroMemory ( pSym , SYM_BUFF_SIZE ) ;

	mov	r8d, 512				; 00000200H
	xor	edx, edx
	mov	rcx, QWORD PTR pSym$3[rsp]
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16

; 796  :             pSym->SizeOfStruct = sizeof ( IMAGEHLP_SYMBOL ) ;

	mov	rax, QWORD PTR pSym$3[rsp]
	mov	DWORD PTR [rax], 32			; 00000020H

; 797  :             pSym->MaxNameLength = SYM_BUFF_SIZE -
; 798  :                                   sizeof ( IMAGEHLP_SYMBOL ) ;

	mov	rax, QWORD PTR pSym$3[rsp]
	mov	DWORD PTR [rax+24], 480			; 000001e0H

; 799  : 
; 800  :             if ( TRUE ==
; 801  :                   SymGetSymFromAddr ( (HANDLE)GetCurrentProcessId ( ) ,
; 802  :                                       g_stFrame.AddrPC.Offset         ,
; 803  : #ifdef _WIN64
; 804  :                                       (PDWORD64)&dwDisp               ,
; 805  : #else
; 806  :                                       &dwDisp                         ,
; 807  : #endif
; 808  :                                       pSym                            ))

	call	QWORD PTR __imp_GetCurrentProcessId
	mov	eax, eax
	mov	r9, QWORD PTR pSym$3[rsp]
	lea	r8, QWORD PTR dwDisp$2[rsp]
	mov	rdx, QWORD PTR g_stFrame
	mov	ecx, eax
	call	QWORD PTR __imp_SymGetSymFromAddr64
	cmp	eax, 1
	jne	$LN12@InternalGe

; 809  :             {
; 810  :                 iCurr += wsprintf ( g_szBuff + iCurr , _T ( ", " ) ) ;

	movsxd	rax, DWORD PTR iCurr$1[rsp]
	lea	rcx, OFFSET FLAT:g_szBuff
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
	mov	rcx, rax
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax

; 811  : 
; 812  :                 // Copy no more symbol information than there's room for.
; 813  :                 dwTemp = lstrlen ( pSym->Name ) ;

	mov	rax, QWORD PTR pSym$3[rsp]
	add	rax, 28
	mov	rcx, rax
	call	QWORD PTR __imp_lstrlenA
	mov	DWORD PTR dwTemp$[rsp], eax

; 814  :                 if ( dwTemp > (DWORD)( BUFF_SIZE - iCurr -
; 815  :                                      ( MAX_SYM_SIZE + 50 ) ) )

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR iCurr$1[rsp]
	sub	eax, 306				; 00000132H
	cmp	DWORD PTR dwTemp$[rsp], eax
	jbe	SHORT $LN11@InternalGe

; 816  :                 {
; 817  :                     lstrcpyn ( g_szBuff + iCurr      ,
; 818  :                                pSym->Name            ,
; 819  :                                BUFF_SIZE - iCurr - 1  ) ;

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR iCurr$1[rsp]
	dec	eax
	mov	rcx, QWORD PTR pSym$3[rsp]
	add	rcx, 28
	movsxd	rdx, DWORD PTR iCurr$1[rsp]
	lea	rbx, OFFSET FLAT:g_szBuff
	add	rbx, rdx
	mov	rdx, rbx
	mov	QWORD PTR tv209[rsp], rdx
	mov	r8d, eax
	mov	rdx, rcx
	mov	rax, QWORD PTR tv209[rsp]
	mov	rcx, rax
	call	QWORD PTR __imp_lstrcpynA

; 820  :                     // Gotta leave now
; 821  :                     szRet = g_szBuff ;

	lea	rax, OFFSET FLAT:g_szBuff
	mov	QWORD PTR szRet$[rsp], rax

; 822  :                     return ( szRet ) ;

	mov	rax, QWORD PTR szRet$[rsp]
	jmp	$LN23@InternalGe

; 823  :                 }
; 824  :                 else

	jmp	SHORT $LN10@InternalGe
$LN11@InternalGe:

; 825  :                 {
; 826  :                     if ( dwDisp > 0 )

	cmp	DWORD PTR dwDisp$2[rsp], 0
	jbe	SHORT $LN9@InternalGe

; 827  :                     {
; 828  :                         iCurr += wsprintf ( g_szBuff + iCurr         ,
; 829  :                                             _T( "%s()") ,
; 830  :                                             pSym->Name               ,
; 831  :                                             dwDisp                   );

	mov	rax, QWORD PTR pSym$3[rsp]
	add	rax, 28
	movsxd	rcx, DWORD PTR iCurr$1[rsp]
	lea	rdx, OFFSET FLAT:g_szBuff
	add	rdx, rcx
	mov	rcx, rdx
	mov	r9d, DWORD PTR dwDisp$2[rsp]
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_04DLGOCPFH@?$CFs?$CI?$CJ?$AA@
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax

; 832  :                     }
; 833  :                     else

	jmp	SHORT $LN10@InternalGe
$LN9@InternalGe:

; 834  :                     {
; 835  :                         iCurr += wsprintf ( g_szBuff + iCurr ,
; 836  :                                             _T ( "%s" )      ,
; 837  :                                             pSym->Name        ) ;

	mov	rax, QWORD PTR pSym$3[rsp]
	add	rax, 28
	movsxd	rcx, DWORD PTR iCurr$1[rsp]
	lea	rdx, OFFSET FLAT:g_szBuff
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8, rax
	lea	rdx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax
$LN10@InternalGe:

; 838  :                     }
; 839  :                 }
; 840  :             }
; 841  :             else

	jmp	SHORT $LN13@InternalGe
$LN12@InternalGe:

; 842  :             {
; 843  :                 // If the symbol wasn't found, the source file and line
; 844  :                 // number won't be found either, so leave now.
; 845  :                 szRet = g_szBuff ;

	lea	rax, OFFSET FLAT:g_szBuff
	mov	QWORD PTR szRet$[rsp], rax

; 846  :                 return ( szRet ) ;

	mov	rax, QWORD PTR szRet$[rsp]
	jmp	$LN23@InternalGe
$LN13@InternalGe:

; 847  :             }
; 848  : 
; 849  :         }
; 850  : 
; 851  :         ASSERT ( iCurr < ( BUFF_SIZE - MAX_PATH ) ) ;
; 852  : 
; 853  :         // Output the source file and line number information?
; 854  :         if ( GSTSO_SRCLINE == ( dwOpts & GSTSO_SRCLINE ) )

	mov	eax, DWORD PTR dwOpts$[rsp]
	and	eax, 8
	cmp	eax, 8
	jne	$LN6@InternalGe

; 855  :         {
; 856  :             ZeroMemory ( &g_stLine , sizeof ( IMAGEHLP_LINE ) ) ;

	mov	r8d, 40					; 00000028H
	xor	edx, edx
	lea	rcx, OFFSET FLAT:g_stLine
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16

; 857  :             g_stLine.SizeOfStruct = sizeof ( IMAGEHLP_LINE ) ;

	mov	DWORD PTR g_stLine, 40			; 00000028H

; 858  : 
; 859  :             if ( TRUE ==
; 860  :                    InternalSymGetLineFromAddr ( (HANDLE)
; 861  :                                                   GetCurrentProcessId(),
; 862  :                                                 g_stFrame.AddrPC.Offset,
; 863  :                                                 &dwDisp                ,
; 864  :                                                 &g_stLine             ))

	call	QWORD PTR __imp_GetCurrentProcessId
	mov	eax, eax
	lea	r9, OFFSET FLAT:g_stLine
	lea	r8, QWORD PTR dwDisp$2[rsp]
	mov	edx, DWORD PTR g_stFrame
	mov	ecx, eax
	call	?InternalSymGetLineFromAddr@@YAHPEAXKPEAKPEAU_IMAGEHLP_LINE64@@@Z ; InternalSymGetLineFromAddr
	cmp	eax, 1
	jne	$LN6@InternalGe

; 865  :             {
; 866  :                 iCurr += wsprintf ( g_szBuff + iCurr , _T ( ", " ) ) ;

	movsxd	rax, DWORD PTR iCurr$1[rsp]
	lea	rcx, OFFSET FLAT:g_szBuff
	add	rcx, rax
	mov	rax, rcx
	lea	rdx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
	mov	rcx, rax
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax

; 867  : 
; 868  :                 // Copy no more of the source file and line number
; 869  :                 // information than there's room for.
; 870  :                 dwTemp = lstrlen ( g_stLine.FileName ) ;

	mov	rcx, QWORD PTR g_stLine+24
	call	QWORD PTR __imp_lstrlenA
	mov	DWORD PTR dwTemp$[rsp], eax

; 871  :                 if ( dwTemp > (DWORD)( BUFF_SIZE - iCurr -
; 872  :                                        ( MAX_PATH + 50     ) ) )

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR iCurr$1[rsp]
	sub	eax, 310				; 00000136H
	cmp	DWORD PTR dwTemp$[rsp], eax
	jbe	SHORT $LN4@InternalGe

; 873  :                 {
; 874  :                     lstrcpyn ( g_szBuff + iCurr      ,
; 875  :                                g_stLine.FileName     ,
; 876  :                                BUFF_SIZE - iCurr - 1  ) ;

	mov	eax, 1024				; 00000400H
	sub	eax, DWORD PTR iCurr$1[rsp]
	dec	eax
	movsxd	rcx, DWORD PTR iCurr$1[rsp]
	lea	rdx, OFFSET FLAT:g_szBuff
	add	rdx, rcx
	mov	rcx, rdx
	mov	r8d, eax
	mov	rdx, QWORD PTR g_stLine+24
	call	QWORD PTR __imp_lstrcpynA

; 877  :                     // Gotta leave now
; 878  :                     szRet = g_szBuff ;

	lea	rax, OFFSET FLAT:g_szBuff
	mov	QWORD PTR szRet$[rsp], rax

; 879  :                     return ( szRet ) ;

	mov	rax, QWORD PTR szRet$[rsp]
	jmp	$LN23@InternalGe

; 880  :                 }
; 881  :                 else

	jmp	$LN6@InternalGe
$LN4@InternalGe:

; 882  :                 {
; 883  :                     if ( dwDisp > 0 )

	cmp	DWORD PTR dwDisp$2[rsp], 0
	jbe	SHORT $LN2@InternalGe

; 884  :                     {
; 885  :                         iCurr += wsprintf(g_szBuff + iCurr             ,
; 886  :                                        _T("%s, %d"),
; 887  :                                           g_stLine.FileName            ,
; 888  :                                           g_stLine.LineNumber          ,
; 889  :                                           dwDisp                     );

	movsxd	rax, DWORD PTR iCurr$1[rsp]
	lea	rcx, OFFSET FLAT:g_szBuff
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, DWORD PTR dwDisp$2[rsp]
	mov	DWORD PTR [rsp+32], ecx
	mov	r9d, DWORD PTR g_stLine+16
	mov	r8, QWORD PTR g_stLine+24
	lea	rdx, OFFSET FLAT:??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
	mov	rcx, rax
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax

; 890  :                     }
; 891  :                     else

	jmp	SHORT $LN6@InternalGe
$LN2@InternalGe:

; 892  :                     {
; 893  :                         iCurr += wsprintf ( g_szBuff + iCurr       ,
; 894  :                                             _T ( "%s, %d" ) ,
; 895  :                                             g_stLine.FileName      ,
; 896  :                                             g_stLine.LineNumber     ) ;

	movsxd	rax, DWORD PTR iCurr$1[rsp]
	lea	rcx, OFFSET FLAT:g_szBuff
	add	rcx, rax
	mov	rax, rcx
	mov	r9d, DWORD PTR g_stLine+16
	mov	r8, QWORD PTR g_stLine+24
	lea	rdx, OFFSET FLAT:??_C@_06OJLEAOEG@?$CFs?0?5?$CFd?$AA@
	mov	rcx, rax
	call	QWORD PTR __imp_wsprintfA
	mov	ecx, DWORD PTR iCurr$1[rsp]
	add	ecx, eax
	mov	eax, ecx
	mov	DWORD PTR iCurr$1[rsp], eax
$LN6@InternalGe:

; 897  :                     }
; 898  :                 }
; 899  :             }
; 900  :         }
; 901  : 
; 902  :         szRet = g_szBuff ;

	lea	rax, OFFSET FLAT:g_szBuff
	mov	QWORD PTR szRet$[rsp], rax

; 903  :     }

	jmp	SHORT $LN27@InternalGe
$LN25@InternalGe:

; 904  :     __except ( EXCEPTION_EXECUTE_HANDLER )
; 905  :     {
; 906  : 		TRACE0("FATAL: inner exception in  InternalGetStackTraceString");

	lea	rcx, OFFSET FLAT:??_C@_0DH@EPDHCNDC@FATAL?3?5inner?5exception?5in?5?5Inter@
	call	?Log@@YAXPEBD@Z				; Log

; 907  :         ASSERT ( !"Crashed in InternalGetStackTraceString" ) ;
; 908  :         szRet = NULL ;

	mov	QWORD PTR szRet$[rsp], 0
$LN27@InternalGe:

; 909  :     }
; 910  : 
; 911  :     return ( szRet ) ;

	mov	rax, QWORD PTR szRet$[rsp]
$LN23@InternalGe:

; 912  : }

	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z ENDP ; InternalGetStackTraceString
_TEXT	ENDS
; Function compile flags: /Odspy
text$x	SEGMENT
iCurr$1 = 80
dwDisp$2 = 84
szRet$ = 88
pSym$3 = 96
dwTemp$ = 104
dwModBase$ = 108
tv165 = 112
bSWRet$4 = 116
tv168 = 120
tv170 = 128
tv77 = 136
tv209 = 144
dwOpts$ = 192
pExPtrs$ = 200
?filt$0@?0??InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z@4HA PROC ; `InternalGetStackTraceString'::`1'::filt$0
	push	rbp
	sub	rsp, 80					; 00000050H
	mov	rbp, rdx
$LN24@filt$0:

; 904  :     __except ( EXCEPTION_EXECUTE_HANDLER )

	mov	eax, 1
$LN26@filt$0:
	add	rsp, 80					; 00000050H
	pop	rbp
	ret	0
	int	3
?filt$0@?0??InternalGetStackTraceString@@YAPEBDKPEAU_EXCEPTION_POINTERS@@@Z@4HA ENDP ; `InternalGetStackTraceString'::`1'::filt$0
text$x	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
_TEXT	SEGMENT
hProcess$ = 48
dwAddr$ = 56
pdwDisplacement$ = 64
Line$ = 72
?InternalSymGetLineFromAddr@@YAHPEAXKPEAKPEAU_IMAGEHLP_LINE64@@@Z PROC ; InternalSymGetLineFromAddr

; 1155 : {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 1156 : #ifdef WORK_AROUND_SRCLINE_BUG
; 1157 : 
; 1158 :     // The problem is that the symbol engine finds only those source
; 1159 :     // line addresses (after the first lookup) that fall exactly on
; 1160 :     // a zero displacement. I'll walk backward 100 bytes to
; 1161 :     // find the line and return the proper displacement.
; 1162 :     DWORD dwTempDis = 0 ;
; 1163 :     while ( FALSE == SymGetLineFromAddr ( hProcess        ,
; 1164 :                                           dwAddr -
; 1165 :                                            dwTempDis      ,
; 1166 :                                           pdwDisplacement ,
; 1167 :                                           Line             ) )
; 1168 :     {
; 1169 :         dwTempDis += 1 ;
; 1170 :         if ( 100 == dwTempDis )
; 1171 :         {
; 1172 :             return ( FALSE ) ;
; 1173 :         }
; 1174 :     }
; 1175 : 
; 1176 :     // I found the line, and the source line information is correct, so
; 1177 :     // change the displacement if I had to search backward to find
; 1178 :     // the source line.
; 1179 :     if ( 0 != dwTempDis )
; 1180 :     {
; 1181 :         *pdwDisplacement = dwTempDis ;
; 1182 :     }
; 1183 :     return ( TRUE ) ;
; 1184 : 
; 1185 : #else  // WORK_AROUND_SRCLINE_BUG
; 1186 :     return ( SymGetLineFromAddr ( hProcess         ,
; 1187 :                                   dwAddr           ,
; 1188 :                                   pdwDisplacement  ,
; 1189 :                                   Line              ) ) ;

	mov	eax, DWORD PTR dwAddr$[rsp]
	mov	r9, QWORD PTR Line$[rsp]
	mov	r8, QWORD PTR pdwDisplacement$[rsp]
	mov	edx, eax
	mov	rcx, QWORD PTR hProcess$[rsp]
	call	QWORD PTR __imp_SymGetLineFromAddr64

; 1190 : #endif
; 1191 : }

	add	rsp, 40					; 00000028H
	ret	0
?InternalSymGetLineFromAddr@@YAHPEAXKPEAKPEAU_IMAGEHLP_LINE64@@@Z ENDP ; InternalSymGetLineFromAddr
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
_TEXT	SEGMENT
dwOpts$1 = 32
hPID$2 = 40
?InitSymEng@@YAXXZ PROC					; InitSymEng

; 1197 : {

$LN4:
	sub	rsp, 56					; 00000038H

; 1198 :     if ( FALSE == g_bSymEngInit )

	cmp	DWORD PTR g_bSymEngInit, 0
	jne	SHORT $LN1@InitSymEng

; 1199 :     {
; 1200 :         // Set up the symbol engine.
; 1201 :         DWORD dwOpts = SymGetOptions ( ) ;

	call	QWORD PTR __imp_SymGetOptions
	mov	DWORD PTR dwOpts$1[rsp], eax

; 1202 : 
; 1203 :         // Turn on line loading and deferred loading.
; 1204 :         SymSetOptions ( dwOpts                |
; 1205 :                         SYMOPT_DEFERRED_LOADS | SYMOPT_LOAD_ANYTHING | SYMOPT_UNDNAME |
; 1206 :                         SYMOPT_LOAD_LINES      ) ;

	mov	eax, DWORD PTR dwOpts$1[rsp]
	or	eax, 4
	or	eax, 64					; 00000040H
	or	eax, 2
	or	eax, 16
	mov	ecx, eax
	call	QWORD PTR __imp_SymSetOptions

; 1207 : 
; 1208 :         // Force the invade process flag no matter what operating system
; 1209 :         // I'm on.
; 1210 :         HANDLE hPID = (HANDLE)GetCurrentProcessId ( ) ;

	call	QWORD PTR __imp_GetCurrentProcessId
	mov	eax, eax
	mov	QWORD PTR hPID$2[rsp], rax

; 1211 :         VERIFY ( BSUSymInitialize ( (DWORD)hPID ,
; 1212 :                                     hPID        ,
; 1213 :                                     g_application_path,
; 1214 :                                     TRUE         ) ) ;

	mov	r9d, 1
	lea	r8, OFFSET FLAT:?g_application_path@@3PADA ; g_application_path
	mov	rdx, QWORD PTR hPID$2[rsp]
	mov	ecx, DWORD PTR hPID$2[rsp]
	call	BSUSymInitialize

; 1215 :         g_bSymEngInit = TRUE ;

	mov	DWORD PTR g_bSymEngInit, 1
$LN1@InitSymEng:

; 1216 :     }
; 1217 : }

	add	rsp, 56					; 00000038H
	ret	0
?InitSymEng@@YAXXZ ENDP					; InitSymEng
_TEXT	ENDS
; Function compile flags: /Odspy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\blackbox\crashhandler.cpp
_TEXT	SEGMENT
?CleanupSymEng@@YAXXZ PROC				; CleanupSymEng

; 1221 : {

$LN4:
	sub	rsp, 40					; 00000028H

; 1222 :     if ( TRUE == g_bSymEngInit )

	cmp	DWORD PTR g_bSymEngInit, 1
	jne	SHORT $LN1@CleanupSym

; 1223 :     {
; 1224 :         VERIFY ( SymCleanup ( (HANDLE)GetCurrentProcessId ( ) ) ) ;

	call	QWORD PTR __imp_GetCurrentProcessId
	mov	eax, eax
	mov	ecx, eax
	call	QWORD PTR __imp_SymCleanup

; 1225 :         g_bSymEngInit = FALSE ;

	mov	DWORD PTR g_bSymEngInit, 0
$LN1@CleanupSym:

; 1226 :     }
; 1227 : }

	add	rsp, 40					; 00000028H
	ret	0
?CleanupSymEng@@YAXXZ ENDP				; CleanupSymEng
_TEXT	ENDS
END
