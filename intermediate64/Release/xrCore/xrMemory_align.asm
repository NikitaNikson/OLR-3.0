; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_free:PROC
EXTRN	__imp__expand:PROC
EXTRN	__imp__msize:PROC
EXTRN	__imp_malloc:PROC
PUBLIC	?xr_aligned_free@@YAXPEAX@Z			; xr_aligned_free
PUBLIC	?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z	; xr_aligned_offset_realloc
PUBLIC	?xr_aligned_offset_malloc@@YAPEAX_K00@Z		; xr_aligned_offset_malloc
pdata	SEGMENT
$pdata$?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z DD imagerel $LN34
	DD	imagerel $LN34+323
	DD	imagerel $unwind$?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z
$pdata$?xr_aligned_offset_malloc@@YAPEAX_K00@Z DD imagerel $LN11
	DD	imagerel $LN11+106
	DD	imagerel $unwind$?xr_aligned_offset_malloc@@YAPEAX_K00@Z
xdata	SEGMENT
$unwind$?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z DD 0c7b01H
	DD	0bf47bH
	DD	0ae476H
	DD	09c46dH
	DD	085465H
	DD	070043208H
	DD	030026003H
$unwind$?xr_aligned_offset_malloc@@YAPEAX_K00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
_TEXT	SEGMENT
size$ = 48
offset$ = 56
?xr_aligned_offset_malloc@@YAPEAX_K00@Z PROC		; xr_aligned_offset_malloc

; 93   : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 94   : 	uintptr_t ptr, retptr, gap;
; 95   : 
; 96   : 	if (!IS_2_POW_N(align))
; 97   : 	{
; 98   : 		errno = EINVAL;
; 99   : 		return NULL;
; 100  : 	}
; 101  : 	if ( offset >= size && offset != 0)

	cmp	rdx, rcx
	jb	SHORT $LN2@xr_aligned
	test	rdx, rdx
	je	SHORT $LN2@xr_aligned

; 102  : 		size	= offset+1;

	lea	rcx, QWORD PTR [rdx+1]
$LN2@xr_aligned:

; 103  : 
; 104  : 	align = (align > PTR_SZ ? align : PTR_SZ) -1;
; 105  : 
; 106  : 	/* gap = number of bytes needed to round up offset to align with PTR_SZ*/
; 107  : 	gap = (0 - offset)&(PTR_SZ -1);

	mov	rdi, rdx

; 108  : 
; 109  : 	if ( (ptr =(uintptr_t)malloc(PTR_SZ +gap +align +size)) == (uintptr_t)NULL)

	add	rcx, 23
	neg	rdi
	and	edi, 7
	add	rcx, rdi
	call	QWORD PTR __imp_malloc
	mov	rdx, rax
	test	rax, rax
	jne	SHORT $LN1@xr_aligned

; 113  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;
; 114  : 
; 115  : 	return (void *)retptr;
; 116  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN1@xr_aligned:

; 110  : 		return NULL;
; 111  : 
; 112  : 	retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;

	lea	rax, QWORD PTR [rdi+23]
	add	rax, rdx
	add	rax, rbx
	and	rax, -16
	sub	rax, rbx

; 113  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;
; 114  : 
; 115  : 	return (void *)retptr;
; 116  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rcx, rax
	sub	rcx, rdi
	mov	QWORD PTR [rcx-8], rdx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?xr_aligned_offset_malloc@@YAPEAX_K00@Z ENDP		; xr_aligned_offset_malloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
_TEXT	SEGMENT
memblock$ = 64
size$ = 72
align$dead$ = 80
offset$dead$ = 88
?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z PROC	; xr_aligned_offset_realloc

; 185  : {

$LN34:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 186  : 	uintptr_t ptr, retptr, gap, stptr, diff;
; 187  : 	uintptr_t movsz, reqsz;
; 188  : 	int bFree = 0;

	xor	esi, esi
	mov	rdi, rdx
	mov	rbx, rcx

; 189  : 
; 190  : 	if (memblock == NULL)

	test	rcx, rcx
	jne	SHORT $LN12@xr_aligned
	lea	edx, QWORD PTR [rcx+1]
	mov	rcx, rdi

; 271  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	jmp	?xr_aligned_offset_malloc@@YAPEAX_K00@Z	; xr_aligned_offset_malloc
$LN12@xr_aligned:

; 191  : 	{
; 192  : 		return xr_aligned_offset_malloc(size, align, offset);
; 193  : 	}
; 194  : 	if ( size == 0)

	test	rdx, rdx
	jne	SHORT $LN11@xr_aligned

; 272  : 
; 273  : 
; 274  : /***
; 275  : *
; 276  : * void *xr_aligned_free(void *memblock)
; 277  : *       - Free the memory which was allocated using _aligned_malloc or
; 278  : *       _aligned_offset_memory
; 279  : *
; 280  : * Purpose:
; 281  : *       Frees the aligned memory block which was allocated using _aligned_malloc
; 282  : *       or _aligned_memory.
; 283  : *
; 284  : * Entry:
; 285  : *       void * memblock - pointer to the block of memory
; 286  : *
; 287  : *******************************************************************************/
; 288  : 
; 289  : void __stdcall xr_aligned_free(void *memblock)
; 290  : {
; 291  : 	uintptr_t ptr;
; 292  : 
; 293  : 	if (memblock == NULL)
; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rbx, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rbx-8]
	call	QWORD PTR __imp_free

; 195  : 	{
; 196  : 		xr_aligned_free(memblock);
; 197  : 		return NULL;

	xor	eax, eax

; 271  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN11@xr_aligned:

; 198  : 	}
; 199  : 	if ( offset >= size && offset != 0)

	cmp	rdx, 1
	ja	SHORT $LN10@xr_aligned

; 200  : 	{
; 201  : 		errno = EINVAL;

	call	QWORD PTR __imp__errno
	mov	DWORD PTR [rax], 22

; 202  : 		return NULL;

	xor	eax, eax

; 271  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN10@xr_aligned:
	mov	QWORD PTR [rsp+64], rbp

; 203  : 	}
; 204  : 
; 205  : 	stptr = (uintptr_t)memblock;
; 206  : 
; 207  : 	/* ptr points to the pointer to starting of the memory block */
; 208  : 	stptr = (stptr & ~(PTR_SZ -1)) - PTR_SZ;

	mov	rax, rcx
	mov	QWORD PTR [rsp+72], r12
	and	rax, -8
	mov	QWORD PTR [rsp+80], r14
	mov	QWORD PTR [rsp+88], r15

; 209  : 
; 210  : 	/* ptr is the pointer to the start of memory block*/
; 211  : 	stptr = *((uintptr_t *)stptr);

	mov	rbp, QWORD PTR [rax-8]

; 212  : 
; 213  : 	if (!IS_2_POW_N(align))
; 214  : 	{
; 215  : 		errno = EINVAL;
; 216  : 		return NULL;
; 217  : 	}
; 218  : 
; 219  : 	align = (align > PTR_SZ ? align : PTR_SZ) -1;
; 220  : 	/* gap = number of bytes needed to round up offset to align with PTR_SZ*/
; 221  : 	gap = (0 -offset)&(PTR_SZ -1);
; 222  : 
; 223  : 	diff = (uintptr_t)memblock - stptr;

	mov	r15, rcx

; 224  : 	/* Mov size is min of the size of data available and sizw requested.
; 225  : 	*/
; 226  : 	movsz = _msize((void *)stptr) - ((uintptr_t)memblock - stptr);

	mov	rcx, rbp
	sub	r15, rbp
	call	QWORD PTR __imp__msize

; 227  : 	movsz = movsz > size? size: movsz;
; 228  : 	reqsz = PTR_SZ +gap +align +size;

	lea	r14, QWORD PTR [rdi+30]
	mov	r12, rax
	mov	rax, rbp
	sub	rax, rbx
	add	r12, rax

; 229  : 
; 230  : 	/* First check if we can expand(reducing or expanding using expand) data
; 231  : 	* safely, ie no data is lost. eg, reducing alignment and keeping size
; 232  : 	* same might result in loss of data at the tail of data block while
; 233  : 	* expanding.
; 234  : 	*
; 235  : 	* If no, use malloc to allocate the new data and move data.
; 236  : 	*
; 237  : 	* If yes, expand and then check if we need to move the data.
; 238  : 	*/
; 239  : 	if ((stptr +align +PTR_SZ +gap)<(uintptr_t)memblock)

	lea	rax, QWORD PTR [rbp+30]
	cmp	r12, rdi
	cmova	r12, rdi
	cmp	rax, rbx
	jb	SHORT $LN32@xr_aligned

; 240  : 	{
; 241  : 		if ((ptr = (uintptr_t)malloc(reqsz)) == (uintptr_t) NULL)
; 242  : 			return NULL;
; 243  : 		bFree = 1;
; 244  : 	}
; 245  : 	else
; 246  : 	{
; 247  : 		if ((ptr = (uintptr_t)_expand((void *)stptr, reqsz)) == (uintptr_t)NULL)

	mov	rdx, r14
	mov	rcx, rbp
	call	QWORD PTR __imp__expand
	mov	rdi, rax
	test	rax, rax
	jne	SHORT $LN5@xr_aligned
$LN32@xr_aligned:

; 248  : 		{
; 249  : 			if ((ptr = (uintptr_t)malloc(reqsz)) == (uintptr_t) NULL)

	mov	rcx, r14
	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN31@xr_aligned
$LN4@xr_aligned:

; 250  : 				return NULL;
; 251  : 			bFree = 1;

	mov	esi, 1

; 252  : 		}
; 253  : 		else

	jmp	SHORT $LN3@xr_aligned
$LN5@xr_aligned:

; 254  : 			stptr = ptr;

	mov	rbp, rax
$LN3@xr_aligned:

; 255  : 	}
; 256  : 
; 257  : 
; 258  : 	if ( ptr == ((uintptr_t)memblock - diff)
; 259  : 		&& !( ((size_t)memblock + gap +offset) & ~(align) ))

	mov	rax, rbx
	sub	rax, r15
	cmp	rdi, rax
	jne	SHORT $LN2@xr_aligned
	lea	rax, QWORD PTR [rbx+8]
	test	rax, -16
	jne	SHORT $LN2@xr_aligned

; 260  : 	{
; 261  : 		return memblock;

	mov	rax, rbx
	jmp	SHORT $LN31@xr_aligned
$LN2@xr_aligned:

; 262  : 	}
; 263  : 
; 264  : 	retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;

	lea	rbx, QWORD PTR [rdi+31]

; 265  : 	memmove((void *)retptr, (void *)(stptr + diff), movsz);

	lea	rdx, QWORD PTR [r15+rbp]
	mov	r8, r12
	and	rbx, -16
	lea	rcx, QWORD PTR [rbx-1]
	call	QWORD PTR __imp_memmove

; 266  : 	if ( bFree)

	test	esi, esi
	je	SHORT $LN1@xr_aligned

; 267  : 		free ((void *)stptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN1@xr_aligned:

; 268  : 
; 269  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;

	mov	QWORD PTR [rbx-16], rdi

; 270  : 	return (void *)retptr;

	lea	rax, QWORD PTR [rbx-1]
$LN31@xr_aligned:
	mov	r14, QWORD PTR [rsp+80]
	mov	r12, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]
	mov	r15, QWORD PTR [rsp+88]

; 271  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z ENDP	; xr_aligned_offset_realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
_TEXT	SEGMENT
memblock$ = 8
?xr_aligned_free@@YAXPEAX@Z PROC			; xr_aligned_free

; 291  : 	uintptr_t ptr;
; 292  : 
; 293  : 	if (memblock == NULL)

	test	rcx, rcx
	je	SHORT $LN2@xr_aligned

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rcx, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rcx-8]
	rex_jmp	QWORD PTR __imp_free
$LN2@xr_aligned:

; 304  : }

	ret	0
?xr_aligned_free@@YAXPEAX@Z ENDP			; xr_aligned_free
_TEXT	ENDS
END
