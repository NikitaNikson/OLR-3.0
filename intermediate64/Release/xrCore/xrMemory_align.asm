; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_malloc:PROC
EXTRN	__imp__expand:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp__msize:PROC
PUBLIC	?xr_aligned_free@@YAXPEAX@Z			; xr_aligned_free
pdata	SEGMENT
$pdata$?xr_aligned_free@@YAXPEAX@Z DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$?xr_aligned_free@@YAXPEAX@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?xr_aligned_free@@YAXPEAX@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
xdata	ENDS
_TEXT	SEGMENT
memblock$ = 48
?xr_aligned_free@@YAXPEAX@Z PROC			; xr_aligned_free

; 290  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 291  : 	uintptr_t ptr;
; 292  : 
; 293  : 	if (memblock == NULL)

	test	rcx, rcx
	je	SHORT $LN2@xr_aligned

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rcx, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rcx-8]
	call	QWORD PTR __imp_free
$LN2@xr_aligned:

; 304  : }

	add	rsp, 40					; 00000028H
	ret	0
?xr_aligned_free@@YAXPEAX@Z ENDP			; xr_aligned_free
_TEXT	ENDS
PUBLIC	?xr_aligned_offset_malloc@@YAPEAX_K00@Z		; xr_aligned_offset_malloc
pdata	SEGMENT
$pdata$?xr_aligned_offset_malloc@@YAPEAX_K00@Z DD imagerel $LN10
	DD	imagerel $LN10+102
	DD	imagerel $unwind$?xr_aligned_offset_malloc@@YAPEAX_K00@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?xr_aligned_offset_malloc@@YAPEAX_K00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
size$ = 48
offset$ = 56
?xr_aligned_offset_malloc@@YAPEAX_K00@Z PROC		; xr_aligned_offset_malloc

; 93   : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 94   : 	uintptr_t ptr, retptr, gap;
; 95   : 
; 96   : 	if (!IS_2_POW_N(align))
; 97   : 	{
; 98   : 		errno = EINVAL;
; 99   : 		return NULL;
; 100  : 	}
; 101  : 	if ( offset >= size && offset != 0)

	cmp	rdx, rcx
	jb	SHORT $LN2@xr_aligned@2
	test	rdx, rdx
	je	SHORT $LN2@xr_aligned@2

; 102  : 		size	= offset+1;

	lea	rcx, QWORD PTR [rdx+1]
$LN2@xr_aligned@2:

; 103  : 
; 104  : 	align = (align > PTR_SZ ? align : PTR_SZ) -1;
; 105  : 
; 106  : 	/* gap = number of bytes needed to round up offset to align with PTR_SZ*/
; 107  : 	gap = (0 - offset)&(PTR_SZ -1);

	mov	rdi, rdx
	neg	rdi
	and	edi, 7

; 108  : 
; 109  : 	if ( (ptr =(uintptr_t)malloc(PTR_SZ +gap +align +size)) == (uintptr_t)NULL)

	lea	rcx, QWORD PTR [rdi+rcx+23]
	call	QWORD PTR __imp_malloc
	mov	r11, rax
	test	rax, rax
	jne	SHORT $LN1@xr_aligned@2

; 113  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;
; 114  : 
; 115  : 	return (void *)retptr;
; 116  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN1@xr_aligned@2:

; 110  : 		return NULL;
; 111  : 
; 112  : 	retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;

	add	rax, rdi
	lea	rax, QWORD PTR [rax+rbx+23]
	and	rax, -16
	sub	rax, rbx

; 113  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;
; 114  : 
; 115  : 	return (void *)retptr;
; 116  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rcx, rax
	sub	rcx, rdi
	mov	QWORD PTR [rcx-8], r11
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?xr_aligned_offset_malloc@@YAPEAX_K00@Z ENDP		; xr_aligned_offset_malloc
PUBLIC	?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z	; xr_aligned_offset_realloc
pdata	SEGMENT
$pdata$?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z DD imagerel $LN30
	DD	imagerel $LN30+360
	DD	imagerel $unwind$?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z DD 0ca601H
	DD	0be4a6H
	DD	0ad496H
	DD	09c491H
	DD	085489H
	DD	070043208H
	DD	030026003H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
memblock$ = 64
size$ = 72
?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z PROC	; xr_aligned_offset_realloc

; 185  : {

$LN30:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 186  : 	uintptr_t ptr, retptr, gap, stptr, diff;
; 187  : 	uintptr_t movsz, reqsz;
; 188  : 	int bFree = 0;

	xor	ebx, ebx
	mov	rsi, rdx
	mov	rdi, rcx

; 189  : 
; 190  : 	if (memblock == NULL)

	test	rcx, rcx
	jne	SHORT $LN12@xr_aligned@3

; 191  : 	{
; 192  : 		return xr_aligned_offset_malloc(size, align, offset);

	mov	eax, 2
	cmp	rdx, 1
	cmovbe	rsi, rax
	lea	rcx, QWORD PTR [rsi+30]
	call	QWORD PTR __imp_malloc
	test	rax, rax
	je	SHORT $LN18@xr_aligned@3
	lea	rbx, QWORD PTR [rax+31]
	and	rbx, -16
	dec	rbx
	mov	QWORD PTR [rbx-15], rax
$LN18@xr_aligned@3:
	mov	rax, rbx

; 271  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN12@xr_aligned@3:

; 193  : 	}
; 194  : 	if ( size == 0)

	test	rdx, rdx
	jne	SHORT $LN11@xr_aligned@3

; 195  : 	{
; 196  : 		xr_aligned_free(memblock);

	and	rdi, -8
	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free

; 197  : 		return NULL;

	xor	eax, eax

; 271  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN11@xr_aligned@3:

; 198  : 	}
; 199  : 	if ( offset >= size && offset != 0)

	cmp	rdx, 1
	ja	SHORT $LN10@xr_aligned@3

; 200  : 	{
; 201  : 		errno = EINVAL;

	call	QWORD PTR __imp__errno
	mov	DWORD PTR [rax], 22

; 202  : 		return NULL;

	xor	eax, eax

; 271  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN10@xr_aligned@3:
	mov	QWORD PTR [rsp+64], rbp

; 203  : 	}
; 204  : 
; 205  : 	stptr = (uintptr_t)memblock;
; 206  : 
; 207  : 	/* ptr points to the pointer to starting of the memory block */
; 208  : 	stptr = (stptr & ~(PTR_SZ -1)) - PTR_SZ;

	mov	rax, rcx
	mov	QWORD PTR [rsp+72], r12
	mov	QWORD PTR [rsp+80], r13

; 209  : 
; 210  : 	/* ptr is the pointer to the start of memory block*/
; 211  : 	stptr = *((uintptr_t *)stptr);
; 212  : 
; 213  : 	if (!IS_2_POW_N(align))
; 214  : 	{
; 215  : 		errno = EINVAL;
; 216  : 		return NULL;
; 217  : 	}
; 218  : 
; 219  : 	align = (align > PTR_SZ ? align : PTR_SZ) -1;
; 220  : 	/* gap = number of bytes needed to round up offset to align with PTR_SZ*/
; 221  : 	gap = (0 -offset)&(PTR_SZ -1);
; 222  : 
; 223  : 	diff = (uintptr_t)memblock - stptr;

	mov	r13, rcx
	and	rax, -8
	mov	rbp, QWORD PTR [rax-8]
	mov	QWORD PTR [rsp+88], r14

; 224  : 	/* Mov size is min of the size of data available and sizw requested.
; 225  : 	*/
; 226  : 	movsz = _msize((void *)stptr) - ((uintptr_t)memblock - stptr);

	mov	rcx, rbp
	sub	r13, rbp
	call	QWORD PTR __imp__msize

; 227  : 	movsz = movsz > size? size: movsz;
; 228  : 	reqsz = PTR_SZ +gap +align +size;

	lea	r12, QWORD PTR [rsi+30]
	mov	r14, rax
	mov	rax, rbp
	sub	rax, rdi
	add	r14, rax

; 229  : 
; 230  : 	/* First check if we can expand(reducing or expanding using expand) data
; 231  : 	* safely, ie no data is lost. eg, reducing alignment and keeping size
; 232  : 	* same might result in loss of data at the tail of data block while
; 233  : 	* expanding.
; 234  : 	*
; 235  : 	* If no, use malloc to allocate the new data and move data.
; 236  : 	*
; 237  : 	* If yes, expand and then check if we need to move the data.
; 238  : 	*/
; 239  : 	if ((stptr +align +PTR_SZ +gap)<(uintptr_t)memblock)

	lea	rax, QWORD PTR [rbp+30]
	cmp	r14, rsi
	cmova	r14, rsi
	cmp	rax, rdi

; 240  : 	{
; 241  : 		if ((ptr = (uintptr_t)malloc(reqsz)) == (uintptr_t) NULL)
; 242  : 			return NULL;

	jb	SHORT $LN29@xr_aligned@3

; 243  : 		bFree = 1;
; 244  : 	}
; 245  : 	else
; 246  : 	{
; 247  : 		if ((ptr = (uintptr_t)_expand((void *)stptr, reqsz)) == (uintptr_t)NULL)

	mov	rdx, r12
	mov	rcx, rbp
	call	QWORD PTR __imp__expand
	mov	rsi, rax
	test	rax, rax
	jne	SHORT $LN5@xr_aligned@3
$LN29@xr_aligned@3:

; 248  : 		{
; 249  : 			if ((ptr = (uintptr_t)malloc(reqsz)) == (uintptr_t) NULL)

	mov	rcx, r12
	call	QWORD PTR __imp_malloc
	mov	rsi, rax
	test	rax, rax
	je	SHORT $LN28@xr_aligned@3
$LN4@xr_aligned@3:

; 250  : 				return NULL;
; 251  : 			bFree = 1;

	mov	ebx, 1

; 252  : 		}
; 253  : 		else

	jmp	SHORT $LN3@xr_aligned@3
$LN5@xr_aligned@3:

; 254  : 			stptr = ptr;

	mov	rbp, rax
$LN3@xr_aligned@3:

; 255  : 	}
; 256  : 
; 257  : 
; 258  : 	if ( ptr == ((uintptr_t)memblock - diff)
; 259  : 		&& !( ((size_t)memblock + gap +offset) & ~(align) ))

	mov	rax, rdi
	sub	rax, r13
	cmp	rsi, rax
	jne	SHORT $LN2@xr_aligned@3
	lea	rax, QWORD PTR [rdi+8]
	test	rax, -16
	jne	SHORT $LN2@xr_aligned@3

; 260  : 	{
; 261  : 		return memblock;

	mov	rax, rdi
	jmp	SHORT $LN28@xr_aligned@3
$LN2@xr_aligned@3:

; 262  : 	}
; 263  : 
; 264  : 	retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;

	lea	rdi, QWORD PTR [rsi+31]

; 265  : 	memmove((void *)retptr, (void *)(stptr + diff), movsz);

	lea	rdx, QWORD PTR [r13+rbp]
	mov	r8, r14
	and	rdi, -16
	lea	rcx, QWORD PTR [rdi-1]
	call	QWORD PTR __imp_memmove

; 266  : 	if ( bFree)

	test	ebx, ebx
	je	SHORT $LN1@xr_aligned@3

; 267  : 		free ((void *)stptr);

	mov	rcx, rbp
	call	QWORD PTR __imp_free
$LN1@xr_aligned@3:

; 268  : 
; 269  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;

	mov	QWORD PTR [rdi-16], rsi

; 270  : 	return (void *)retptr;

	lea	rax, QWORD PTR [rdi-1]
$LN28@xr_aligned@3:
	mov	r13, QWORD PTR [rsp+80]
	mov	r12, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]
	mov	r14, QWORD PTR [rsp+88]

; 271  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z ENDP	; xr_aligned_offset_realloc
END
