; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DH@KPMKNEOL@?$CK?5?$FLwin32?$FN?3?5free?$FL?$CFd?5K?$FN?0?5reserved?$FL@ ; `string'
PUBLIC	??_C@_0BE@JDFKFEDA@bad?5pointer?5to?5heap?$AA@	; `string'
PUBLIC	??_C@_0P@HOOOAGPI@mem_usage_impl?$AA@		; `string'
PUBLIC	??_C@_0BB@HKMNIPC@memory_usage?4cpp?$AA@	; `string'
PUBLIC	??_C@_0BC@EKDFDBII@bad?5start?5of?5heap?$AA@	; `string'
PUBLIC	??_C@_0BB@CIDGGKDN@bad?5node?5in?5heap?$AA@	; `string'
EXTRN	__imp_VirtualQuery:PROC
EXTRN	__imp_HeapValidate:PROC
EXTRN	__imp_HeapWalk:PROC
EXTRN	__imp___doserrno:PROC
EXTRN	__imp__get_heap_handle:PROC
;	COMDAT ??_C@_0BB@CIDGGKDN@bad?5node?5in?5heap?$AA@
CONST	SEGMENT
??_C@_0BB@CIDGGKDN@bad?5node?5in?5heap?$AA@ DB 'bad node in heap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EKDFDBII@bad?5start?5of?5heap?$AA@
CONST	SEGMENT
??_C@_0BC@EKDFDBII@bad?5start?5of?5heap?$AA@ DB 'bad start of heap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HKMNIPC@memory_usage?4cpp?$AA@
CONST	SEGMENT
??_C@_0BB@HKMNIPC@memory_usage?4cpp?$AA@ DB 'memory_usage.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HOOOAGPI@mem_usage_impl?$AA@
CONST	SEGMENT
??_C@_0P@HOOOAGPI@mem_usage_impl?$AA@ DB 'mem_usage_impl', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JDFKFEDA@bad?5pointer?5to?5heap?$AA@
CONST	SEGMENT
??_C@_0BE@JDFKFEDA@bad?5pointer?5to?5heap?$AA@ DB 'bad pointer to heap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KPMKNEOL@?$CK?5?$FLwin32?$FN?3?5free?$FL?$CFd?5K?$FN?0?5reserved?$FL@
CONST	SEGMENT
??_C@_0DH@KPMKNEOL@?$CK?5?$FLwin32?$FN?3?5free?$FL?$CFd?5K?$FN?0?5reserved?$FL@ DB '*'
	DB	' [win32]: free[%d K], reserved[%d K], committed[%d K]', 00H ; `string'
PUBLIC	?heap_walk@@YAHPEAXPEAU_heapinfo@@@Z		; heap_walk
EXTRN	__C_specific_handler:PROC
pdata	SEGMENT
$pdata$?heap_walk@@YAHPEAXPEAU_heapinfo@@@Z DD imagerel $LN29
	DD	imagerel $LN29+348
	DD	imagerel $unwind$?heap_walk@@YAHPEAXPEAU_heapinfo@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?heap_walk@@YAHPEAXPEAU_heapinfo@@@Z DD 061709H
	DD	0113417H
	DD	0c0139217H
	DD	060107011H
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN29+191
	DD	imagerel $LN29+224
	DD	01H
	DD	imagerel $LN29+224
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\memory_usage.cpp
xdata	ENDS
_TEXT	SEGMENT
errflag$ = 32
Entry$ = 40
heap_handle$ = 112
_entry$ = 120
retval$ = 128
?heap_walk@@YAHPEAXPEAU_heapinfo@@@Z PROC		; heap_walk

; 41   : {

$LN29:
	mov	rax, rsp
	mov	QWORD PTR [rax+32], rbx
	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+8], rcx
	push	rsi
	push	rdi
	push	r12
	sub	rsp, 80					; 00000050H
	mov	rbx, rdx
	mov	rsi, rcx

; 42   :         PROCESS_HEAP_ENTRY Entry;
; 43   :         DWORD errval;
; 44   :         int errflag;
; 45   :         int retval = _HEAPOK;

	mov	DWORD PTR retval$[rsp], -2

; 46   : 
; 47   :         Entry.wFlags = 0;

	xor	r12d, r12d
	mov	WORD PTR [rax-50], r12w

; 48   :         Entry.iRegionIndex = 0;

	mov	BYTE PTR [rax-51], r12b

; 49   : 		Entry.cbData = 0;

	mov	DWORD PTR [rax-56], r12d

; 50   :         if ( (Entry.lpData = _entry->_pentry) == NULL ) {

	mov	r8, QWORD PTR [rdx]
	mov	QWORD PTR [rax-64], r8
	test	r8, r8
	jne	SHORT $LN17@heap_walk

; 51   :             if ( !HeapWalk( heap_handle, &Entry ) ) {

	lea	rdx, QWORD PTR [rax-64]
	call	QWORD PTR __imp_HeapWalk
	test	eax, eax
	jne	SHORT $LN26@heap_walk

; 52   :                 if ( GetLastError() == ERROR_CALL_NOT_IMPLEMENTED ) {

	call	QWORD PTR __imp_GetLastError
	cmp	eax, 120				; 00000078H
	jne	SHORT $LN15@heap_walk
$LN28@heap_walk:

; 53   :                     _doserrno = ERROR_CALL_NOT_IMPLEMENTED;

	call	QWORD PTR __imp___doserrno
	mov	DWORD PTR [rax], 120			; 00000078H

; 54   :                     errno = ENOSYS;

	call	QWORD PTR __imp__errno
	mov	DWORD PTR [rax], 40			; 00000028H
$LN27@heap_walk:

; 55   :                     return _HEAPEND;

	mov	eax, -5
	jmp	$LN18@heap_walk
$LN15@heap_walk:

; 56   :                 }
; 57   :                 return _HEAPBADBEGIN;

	mov	eax, -3
	jmp	$LN18@heap_walk
$LN26@heap_walk:

; 98   :                 /*
; 99   :                  * Exception occurred during the HeapWalk!
; 100  :                  */
; 101  :                 return _HEAPBADNODE;

	mov	edi, 1
	jmp	$LN4@heap_walk
$LN17@heap_walk:

; 58   :             }
; 59   :         }
; 60   :         else {
; 61   :             if ( _entry->_useflag == _USEDENTRY ) {

	cmp	DWORD PTR [rdx+16], 1
	jne	SHORT $LN25@heap_walk

; 62   :                 if ( !HeapValidate( heap_handle, 0, _entry->_pentry ) )

	xor	edx, edx
	call	QWORD PTR __imp_HeapValidate
	test	eax, eax
	jne	SHORT $LN12@heap_walk
$LN6@heap_walk:

; 63   :                     return _HEAPBADNODE;

	mov	eax, -4
	jmp	$LN18@heap_walk
$LN12@heap_walk:

; 64   :                 Entry.wFlags = PROCESS_HEAP_ENTRY_BUSY;

	mov	eax, 4
	mov	WORD PTR Entry$[rsp+14], ax
$LN25@heap_walk:
	mov	edi, 1
$nextBlock$96940:
	npad	1

; 65   :             }
; 66   : nextBlock:
; 67   :             /*
; 68   :              * Guard the HeapWalk call in case we were passed a bad pointer
; 69   :              * to an allegedly free block.
; 70   :              */
; 71   :             __try {
; 72   :                 errflag = 0;

	mov	DWORD PTR errflag$[rsp], r12d

; 73   :                 if ( !HeapWalk( heap_handle, &Entry ) )

	lea	rdx, QWORD PTR Entry$[rsp]
	mov	rcx, rsi
	call	QWORD PTR __imp_HeapWalk
	mov	ecx, r12d
	test	eax, eax
	cmove	ecx, edi
	mov	DWORD PTR errflag$[rsp], ecx

; 74   :                     errflag = 1;
; 75   :             }

	jmp	SHORT $LN24@heap_walk
$LN22@heap_walk:

; 76   :             __except( EXCEPTION_EXECUTE_HANDLER ) {
; 77   :                 errflag = 2;

	mov	ecx, 2
	mov	DWORD PTR errflag$[rsp], ecx
	xor	r12d, r12d
	lea	edi, QWORD PTR [rcx-1]
	mov	rbx, QWORD PTR _entry$[rsp]
	mov	rsi, QWORD PTR heap_handle$[rsp]
$LN24@heap_walk:

; 78   :             }
; 79   : 
; 80   :             /*
; 81   :              * Check errflag to see how HeapWalk fared...
; 82   :              */
; 83   :             if ( errflag == 1 ) {

	cmp	ecx, 1
	jne	SHORT $LN9@heap_walk

; 84   :                 /*
; 85   :                  * HeapWalk returned an error.
; 86   :                  */
; 87   :                 if ( (errval = GetLastError()) == ERROR_NO_MORE_ITEMS ) {

	call	QWORD PTR __imp_GetLastError
	cmp	eax, 259				; 00000103H

; 88   :                     return _HEAPEND;

	je	$LN27@heap_walk

; 89   :                 }
; 90   :                 else if ( errval == ERROR_CALL_NOT_IMPLEMENTED ) {

	cmp	eax, 120				; 00000078H
	jne	SHORT $LN6@heap_walk

; 91   :                     _doserrno = errval;
; 92   :                     errno = ENOSYS;
; 93   :                     return _HEAPEND;

	jmp	$LN28@heap_walk
$LN9@heap_walk:

; 94   :                 }
; 95   :                 return _HEAPBADNODE;
; 96   :             }
; 97   :             else if ( errflag == 2 ) {

	cmp	ecx, 2

; 98   :                 /*
; 99   :                  * Exception occurred during the HeapWalk!
; 100  :                  */
; 101  :                 return _HEAPBADNODE;

	je	SHORT $LN6@heap_walk
$LN4@heap_walk:

; 102  :             }
; 103  :         }
; 104  : 
; 105  :         if ( Entry.wFlags & (PROCESS_HEAP_REGION |
; 106  :              PROCESS_HEAP_UNCOMMITTED_RANGE) )

	movzx	ecx, BYTE PTR Entry$[rsp+14]
	test	cl, 3
	jne	SHORT $nextBlock$96940

; 107  :         {
; 108  :             goto nextBlock;
; 109  :         }
; 110  : 
; 111  :         _entry->_pentry = (int*)Entry.lpData;

	mov	rax, QWORD PTR Entry$[rsp]
	mov	QWORD PTR [rbx], rax

; 112  :         _entry->_size = Entry.cbData;

	mov	eax, DWORD PTR Entry$[rsp+8]
	mov	QWORD PTR [rbx+8], rax

; 113  :         if ( Entry.wFlags & PROCESS_HEAP_ENTRY_BUSY ) {

	movzx	eax, cl
	shr	eax, 2
	and	eax, 1
	mov	DWORD PTR [rbx+16], eax

; 114  :             _entry->_useflag = _USEDENTRY;
; 115  :         }
; 116  :         else {
; 117  :             _entry->_useflag = _FREEENTRY;
; 118  :         }
; 119  : 
; 120  :         return( retval );

	mov	eax, DWORD PTR retval$[rsp]
$LN18@heap_walk:

; 121  : }

	mov	rbx, QWORD PTR [rsp+136]
	add	rsp, 80					; 00000050H
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?heap_walk@@YAHPEAXPEAU_heapinfo@@@Z ENDP		; heap_walk
_TEXT	ENDS
PUBLIC	?vminfo@@YAXPEA_K00@Z				; vminfo
pdata	SEGMENT
$pdata$?vminfo@@YAXPEA_K00@Z DD imagerel $LN12
	DD	imagerel $LN12+161
	DD	imagerel $unwind$?vminfo@@YAXPEA_K00@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?vminfo@@YAXPEA_K00@Z DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
memory_info$ = 32
_free$ = 96
reserved$ = 104
committed$ = 112
?vminfo@@YAXPEA_K00@Z PROC				; vminfo

; 5    : XRCORE_API void vminfo (size_t *_free, size_t *reserved, size_t *committed) {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 80					; 00000050H

; 6    : 	MEMORY_BASIC_INFORMATION memory_info;
; 7    : 	memory_info.BaseAddress = 0;

	xor	eax, eax
	mov	rbx, r8
	mov	rdi, rdx

; 8    : 	*_free = *reserved = *committed = 0;

	mov	QWORD PTR [r8], rax
	mov	QWORD PTR [rdx], rax
	mov	rsi, rcx
	mov	QWORD PTR [rcx], rax

; 9    : 	while (VirtualQuery (memory_info.BaseAddress, &memory_info, sizeof (memory_info))) {

	lea	rdx, QWORD PTR memory_info$[rsp]
	lea	r8d, QWORD PTR [rax+48]
	xor	ecx, ecx
	mov	QWORD PTR memory_info$[rsp], rax
	call	QWORD PTR __imp_VirtualQuery
	test	rax, rax
	je	SHORT $LN6@vminfo
	npad	2
$LL7@vminfo:

; 10   : 		switch (memory_info.State) {

	mov	ecx, DWORD PTR memory_info$[rsp+32]
	mov	rax, QWORD PTR memory_info$[rsp+24]
	cmp	ecx, 4096				; 00001000H
	je	SHORT $LN1@vminfo
	cmp	ecx, 8192				; 00002000H
	je	SHORT $LN2@vminfo
	cmp	ecx, 65536				; 00010000H
	jne	SHORT $LN4@vminfo

; 11   : 		case MEM_FREE:
; 12   : 			*_free		+= memory_info.RegionSize;

	add	QWORD PTR [rsi], rax

; 13   : 			break;

	jmp	SHORT $LN4@vminfo
$LN2@vminfo:

; 14   : 		case MEM_RESERVE:
; 15   : 			*reserved	+= memory_info.RegionSize;

	add	QWORD PTR [rdi], rax

; 16   : 			break;

	jmp	SHORT $LN4@vminfo
$LN1@vminfo:

; 17   : 		case MEM_COMMIT:
; 18   : 			*committed += memory_info.RegionSize;

	add	QWORD PTR [rbx], rax
$LN4@vminfo:

; 19   : 			break;
; 20   : 		}
; 21   : 		memory_info.BaseAddress = (char *) memory_info.BaseAddress + memory_info.RegionSize;

	mov	rcx, QWORD PTR memory_info$[rsp]
	lea	rdx, QWORD PTR memory_info$[rsp]
	mov	r8d, 48					; 00000030H
	add	rcx, rax
	mov	QWORD PTR memory_info$[rsp], rcx
	call	QWORD PTR __imp_VirtualQuery
	test	rax, rax
	jne	SHORT $LL7@vminfo
$LN6@vminfo:

; 22   : 	}
; 23   : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?vminfo@@YAXPEA_K00@Z ENDP				; vminfo
PUBLIC	?log_vminfo@@YAXXZ				; log_vminfo
pdata	SEGMENT
$pdata$?log_vminfo@@YAXXZ DD imagerel $LN14
	DD	imagerel $LN14+177
	DD	imagerel $unwind$?log_vminfo@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?log_vminfo@@YAXXZ DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
memory_info$273956 = 32
?log_vminfo@@YAXXZ PROC					; log_vminfo

; 26   : {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 80					; 00000050H

; 27   : 	size_t  w_free, w_reserved, w_committed;
; 28   : 	vminfo	(&w_free, &w_reserved, &w_committed);

	xor	ebx, ebx
	lea	rdx, QWORD PTR memory_info$273956[rsp]
	xor	ecx, ecx
	lea	r8d, QWORD PTR [rbx+48]
	mov	QWORD PTR memory_info$273956[rsp], rbx
	mov	edi, ebx
	mov	esi, ebx
	call	QWORD PTR __imp_VirtualQuery
	test	rax, rax
	je	SHORT $LN8@log_vminfo
$LL9@log_vminfo:
	mov	ecx, DWORD PTR memory_info$273956[rsp+32]
	mov	rax, QWORD PTR memory_info$273956[rsp+24]
	cmp	ecx, 4096				; 00001000H
	je	SHORT $LN3@log_vminfo
	cmp	ecx, 8192				; 00002000H
	je	SHORT $LN4@log_vminfo
	cmp	ecx, 65536				; 00010000H
	jne	SHORT $LN6@log_vminfo
	add	rsi, rax
	jmp	SHORT $LN6@log_vminfo
$LN4@log_vminfo:
	add	rdi, rax
	jmp	SHORT $LN6@log_vminfo
$LN3@log_vminfo:
	add	rbx, rax
$LN6@log_vminfo:
	mov	rcx, QWORD PTR memory_info$273956[rsp]
	lea	rdx, QWORD PTR memory_info$273956[rsp]
	mov	r8d, 48					; 00000030H
	add	rcx, rax
	mov	QWORD PTR memory_info$273956[rsp], rcx
	call	QWORD PTR __imp_VirtualQuery
	test	rax, rax
	jne	SHORT $LL9@log_vminfo
$LN8@log_vminfo:

; 29   : 	Msg		(
; 30   : 		"* [win32]: free[%d K], reserved[%d K], committed[%d K]",
; 31   : 		w_free/1024,
; 32   : 		w_reserved/1024,
; 33   : 		w_committed/1024
; 34   : 	);

	shr	rbx, 10
	shr	rdi, 10
	shr	rsi, 10
	lea	rcx, OFFSET FLAT:??_C@_0DH@KPMKNEOL@?$CK?5?$FLwin32?$FN?3?5free?$FL?$CFd?5K?$FN?0?5reserved?$FL@
	mov	r9, rbx
	mov	r8, rdi
	mov	rdx, rsi

; 35   : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 80					; 00000050H
	pop	rdi
	jmp	?Msg@@YAXPEBDZZ				; Msg
?log_vminfo@@YAXXZ ENDP					; log_vminfo
PUBLIC	?mem_usage_impl@@YAIPEAXPEAI1@Z			; mem_usage_impl
pdata	SEGMENT
$pdata$?mem_usage_impl@@YAIPEAXPEAI1@Z DD imagerel $LN19
	DD	imagerel $LN19+243
	DD	imagerel $unwind$?mem_usage_impl@@YAIPEAXPEAI1@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?mem_usage_impl@@YAIPEAXPEAI1@Z DD 0a1801H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0d0149218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
hinfo$ = 48
heap_handle$ = 112
pBlocksUsed$ = 120
pBlocksFree$ = 128
?mem_usage_impl@@YAIPEAXPEAI1@Z PROC			; mem_usage_impl

; 124  : {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 80					; 00000050H

; 125  : 	_HEAPINFO		hinfo;
; 126  : 	int				heapstatus;
; 127  : 	hinfo._pentry	= NULL;

	xor	ebx, ebx
	mov	r12, rdx

; 128  : 	size_t	total	= 0;
; 129  : 	u32	blocks_free	= 0;
; 130  : 	u32	blocks_used	= 0;
; 131  : 	while( ( heapstatus = heap_walk( heap_handle, &hinfo ) ) == _HEAPOK )

	lea	rdx, QWORD PTR hinfo$[rsp]
	mov	r13, r8
	mov	rbp, rcx
	mov	QWORD PTR hinfo$[rsp], rbx
	mov	esi, ebx
	mov	edi, ebx
	call	?heap_walk@@YAHPEAXPEAU_heapinfo@@@Z	; heap_walk
	cmp	eax, -2
	jne	SHORT $LN12@mem_usage_
	npad	5
$LL13@mem_usage_:

; 132  : 	{ 
; 133  : 		if (hinfo._useflag == _USEDENTRY)	{

	cmp	DWORD PTR hinfo$[rsp+16], 1
	jne	SHORT $LN11@mem_usage_

; 134  : 			total		+= hinfo._size;

	add	rbx, QWORD PTR hinfo$[rsp+8]

; 135  : 			blocks_used	+= 1;

	inc	edi

; 136  : 		} else {

	jmp	SHORT $LN10@mem_usage_
$LN11@mem_usage_:

; 137  : 			blocks_free	+= 1;

	inc	esi
$LN10@mem_usage_:

; 128  : 	size_t	total	= 0;
; 129  : 	u32	blocks_free	= 0;
; 130  : 	u32	blocks_used	= 0;
; 131  : 	while( ( heapstatus = heap_walk( heap_handle, &hinfo ) ) == _HEAPOK )

	lea	rdx, QWORD PTR hinfo$[rsp]
	mov	rcx, rbp
	call	?heap_walk@@YAHPEAXPEAU_heapinfo@@@Z	; heap_walk
	cmp	eax, -2
	je	SHORT $LL13@mem_usage_
$LN12@mem_usage_:

; 138  : 		}
; 139  : 	}
; 140  : 	if (pBlocksFree)	*pBlocksFree= 1024*(u32)blocks_free;

	test	r13, r13
	je	SHORT $LN9@mem_usage_
	shl	esi, 10
	mov	DWORD PTR [r13], esi
$LN9@mem_usage_:

; 141  : 	if (pBlocksUsed)	*pBlocksUsed= 1024*(u32)blocks_used;

	test	r12, r12
	je	SHORT $LN8@mem_usage_
	shl	edi, 10
	mov	DWORD PTR [r12], edi
$LN8@mem_usage_:

; 142  : 
; 143  : 	switch( heapstatus )

	cmp	eax, -6
	je	SHORT $LN3@mem_usage_
	cmp	eax, -4
	je	SHORT $LN1@mem_usage_
	cmp	eax, -3
	jne	SHORT $LN17@mem_usage_

; 151  : 		break;
; 152  : 	case _HEAPBADBEGIN:
; 153  : 		FATAL			("bad start of heap");

	lea	rax, OFFSET FLAT:??_C@_0BC@EKDFDBII@bad?5start?5of?5heap?$AA@
	mov	r8d, 153				; 00000099H

; 154  : 		break;

	jmp	SHORT $LN18@mem_usage_
$LN1@mem_usage_:

; 155  : 	case _HEAPBADNODE:
; 156  : 		FATAL			("bad node in heap");

	lea	rax, OFFSET FLAT:??_C@_0BB@CIDGGKDN@bad?5node?5in?5heap?$AA@
	mov	r8d, 156				; 0000009cH

; 157  : 		break;

	jmp	SHORT $LN18@mem_usage_
$LN3@mem_usage_:

; 144  : 	{
; 145  : 	case _HEAPEMPTY:
; 146  : 		break;
; 147  : 	case _HEAPEND:
; 148  : 		break;
; 149  : 	case _HEAPBADPTR:
; 150  : 		FATAL			("bad pointer to heap");

	lea	rax, OFFSET FLAT:??_C@_0BE@JDFKFEDA@bad?5pointer?5to?5heap?$AA@
	mov	r8d, 150				; 00000096H
$LN18@mem_usage_:
	lea	r9, OFFSET FLAT:??_C@_0P@HOOOAGPI@mem_usage_impl?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BB@HKMNIPC@memory_usage?4cpp?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+32], rax
	call	?fatal@xrDebug@@QEAAXPEBDH00ZZ		; xrDebug::fatal
$LN17@mem_usage_:

; 158  : 	}
; 159  : 	return (u32) total;
; 160  : }

	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	mov	eax, ebx
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?mem_usage_impl@@YAIPEAXPEAI1@Z ENDP			; mem_usage_impl
PUBLIC	?mem_usage@xrMemory@@QEAAIPEAI0@Z		; xrMemory::mem_usage
pdata	SEGMENT
$pdata$?mem_usage@xrMemory@@QEAAIPEAI0@Z DD imagerel $LN3
	DD	imagerel $LN3+46
	DD	imagerel $unwind$?mem_usage@xrMemory@@QEAAIPEAI0@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?mem_usage@xrMemory@@QEAAIPEAI0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
pBlocksUsed$ = 56
pBlocksFree$ = 64
?mem_usage@xrMemory@@QEAAIPEAI0@Z PROC			; xrMemory::mem_usage

; 163  : {

$LN3:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rdi, rdx

; 164  : 	return				(mem_usage_impl((HANDLE)_get_heap_handle(),pBlocksUsed,pBlocksFree));

	call	QWORD PTR __imp__get_heap_handle
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rax

; 165  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	?mem_usage_impl@@YAIPEAXPEAI1@Z		; mem_usage_impl
?mem_usage@xrMemory@@QEAAIPEAI0@Z ENDP			; xrMemory::mem_usage
END
