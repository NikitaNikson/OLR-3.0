; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BE@LHNBCIB@xrMemory?3?3mem_alloc?$AA@	; `string'
PUBLIC	??_C@_0BI@MKKJNCPP@xrMemory_subst_msvc?4cpp?$AA@ ; `string'
PUBLIC	??_C@_0BC@KHLAADNE@size?5?$DM?50x7fffFFFF?$AA@	; `string'
PUBLIC	??_C@_0BG@BIILGNAF@xrMemory?3?3mem_realloc?$AA@	; `string'
PUBLIC	??_C@_0BC@MAGELDOC@Memory?5corruption?$AA@	; `string'
PUBLIC	??_C@_0BK@CPGKHBFC@p_current?$DMmem_pools_count?$AA@ ; `string'
;	COMDAT ?ignore_always@?BF@??mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BF@??mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z@4_NA DB 01H DUP (?) ; `xrMemory::mem_realloc'::`21'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??mem_alloc@xrMemory@@QEAAPEAX_K@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??mem_alloc@xrMemory@@QEAAPEAX_K@Z@4_NA DB 01H DUP (?) ; `xrMemory::mem_alloc'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0BK@CPGKHBFC@p_current?$DMmem_pools_count?$AA@
CONST	SEGMENT
??_C@_0BK@CPGKHBFC@p_current?$DMmem_pools_count?$AA@ DB 'p_current<mem_po'
	DB	'ols_count', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MAGELDOC@Memory?5corruption?$AA@
CONST	SEGMENT
??_C@_0BC@MAGELDOC@Memory?5corruption?$AA@ DB 'Memory corruption', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BIILGNAF@xrMemory?3?3mem_realloc?$AA@
CONST	SEGMENT
??_C@_0BG@BIILGNAF@xrMemory?3?3mem_realloc?$AA@ DB 'xrMemory::mem_realloc'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KHLAADNE@size?5?$DM?50x7fffFFFF?$AA@
CONST	SEGMENT
??_C@_0BC@KHLAADNE@size?5?$DM?50x7fffFFFF?$AA@ DB 'size < 0x7fffFFFF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MKKJNCPP@xrMemory_subst_msvc?4cpp?$AA@
CONST	SEGMENT
??_C@_0BI@MKKJNCPP@xrMemory_subst_msvc?4cpp?$AA@ DB 'xrMemory_subst_msvc.'
	DB	'cpp', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LHNBCIB@xrMemory?3?3mem_alloc?$AA@
CONST	SEGMENT
??_C@_0BE@LHNBCIB@xrMemory?3?3mem_alloc?$AA@ DB 'xrMemory::mem_alloc', 00H ; `string'
PUBLIC	?create@MEMPOOL@@QEAAPEAXXZ			; MEMPOOL::create
PUBLIC	?destroy@MEMPOOL@@QEAAXAEAPEAX@Z		; MEMPOOL::destroy
PUBLIC	?get_element@MEMPOOL@@QEAAIXZ			; MEMPOOL::get_element
PUBLIC	??$_min@I@@YAIII@Z				; _min<unsigned int>
PUBLIC	?get_pool@@YAI_K@Z				; get_pool
PUBLIC	?get_header@@YAIPEAX@Z				; get_header
PUBLIC	?acc_header@@YAPEAEPEAX@Z			; acc_header
PUBLIC	??1MEMPOOL@@QEAA@XZ				; MEMPOOL::~MEMPOOL
PUBLIC	??_H@YAXPEAX_KHP6APEAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0MEMPOOL@@QEAA@XZ				; MEMPOOL::MEMPOOL
PUBLIC	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z		; xrMemory::mem_realloc
PUBLIC	?mem_free@xrMemory@@QEAAXPEAX@Z			; xrMemory::mem_free
PUBLIC	?mem_alloc@xrMemory@@QEAAPEAX_K@Z		; xrMemory::mem_alloc
PUBLIC	?mem_pools@@3PAVMEMPOOL@@A			; mem_pools
?mem_pools@@3PAVMEMPOOL@@A DB 0870H DUP (?)		; mem_pools
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?create@MEMPOOL@@QEAAPEAXXZ DD imagerel $LN11
	DD	imagerel $LN11+71
	DD	imagerel $unwind$?create@MEMPOOL@@QEAAPEAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?destroy@MEMPOOL@@QEAAXAEAPEAX@Z DD imagerel $LN10
	DD	imagerel $LN10+59
	DD	imagerel $unwind$?destroy@MEMPOOL@@QEAAXAEAPEAX@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1MEMPOOL@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+31
	DD	imagerel $unwind$??1MEMPOOL@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_H@YAXPEAX_KHP6APEAX0@Z@Z DD imagerel $LN79
	DD	imagerel $LN79+49
	DD	imagerel $unwind$??_H@YAXPEAX_KHP6APEAX0@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0MEMPOOL@@QEAA@XZ DD imagerel $LN71
	DD	imagerel $LN71+47
	DD	imagerel $unwind$??0MEMPOOL@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fmem_pools@@YAXXZ DD imagerel ??__Fmem_pools@@YAXXZ
	DD	imagerel ??__Fmem_pools@@YAXXZ+179
	DD	imagerel $unwind$??__Fmem_pools@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Emem_pools@@YAXXZ DD imagerel ??__Emem_pools@@YAXXZ
	DD	imagerel ??__Emem_pools@@YAXXZ+91
	DD	imagerel $unwind$??__Emem_pools@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z DD imagerel $LN38
	DD	imagerel $LN38+325
	DD	imagerel $unwind$?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z
$pdata$?mem_free@xrMemory@@QEAAXPEAX@Z DD imagerel $LN27
	DD	imagerel $LN27+57
	DD	imagerel $unwind$?mem_free@xrMemory@@QEAAXPEAX@Z
$pdata$0$?mem_free@xrMemory@@QEAAXPEAX@Z DD imagerel $LN27+57
	DD	imagerel $LN27+101
	DD	imagerel $chain$0$?mem_free@xrMemory@@QEAAXPEAX@Z
$pdata$1$?mem_free@xrMemory@@QEAAXPEAX@Z DD imagerel $LN27+101
	DD	imagerel $LN27+107
	DD	imagerel $chain$1$?mem_free@xrMemory@@QEAAXPEAX@Z
$pdata$?mem_alloc@xrMemory@@QEAAPEAX_K@Z DD imagerel $LN46
	DD	imagerel $LN46+186
	DD	imagerel $unwind$?mem_alloc@xrMemory@@QEAAPEAX_K@Z
$pdata$0$?mem_alloc@xrMemory@@QEAAPEAX_K@Z DD imagerel $LN46+186
	DD	imagerel $LN46+270
	DD	imagerel $chain$0$?mem_alloc@xrMemory@@QEAAPEAX_K@Z
$pdata$2$?mem_alloc@xrMemory@@QEAAPEAX_K@Z DD imagerel $LN46+270
	DD	imagerel $LN46+355
	DD	imagerel $chain$2$?mem_alloc@xrMemory@@QEAAPEAX_K@Z
xdata	SEGMENT
$unwind$?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z DD 0a5a01H
	DD	0d745aH
	DD	0c3445H
	DD	0f6410H
	DD	0e5410H
	DD	0e00c9210H
$unwind$?mem_free@xrMemory@@QEAAXPEAX@Z DD 020601H
	DD	070023206H
$chain$0$?mem_free@xrMemory@@QEAAXPEAX@Z DD 020521H
	DD	063405H
	DD	imagerel $LN27
	DD	imagerel $LN27+57
	DD	imagerel $unwind$?mem_free@xrMemory@@QEAAXPEAX@Z
$chain$1$?mem_free@xrMemory@@QEAAXPEAX@Z DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+57
	DD	imagerel $unwind$?mem_free@xrMemory@@QEAAXPEAX@Z
$unwind$?mem_alloc@xrMemory@@QEAAPEAX_K@Z DD 040a01H
	DD	0d340aH
	DD	07006920aH
$chain$0$?mem_alloc@xrMemory@@QEAAPEAX_K@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN46
	DD	imagerel $LN46+186
	DD	imagerel $unwind$?mem_alloc@xrMemory@@QEAAPEAX_K@Z
$chain$2$?mem_alloc@xrMemory@@QEAAPEAX_K@Z DD 020021H
	DD	0c6400H
	DD	imagerel $LN46
	DD	imagerel $LN46+186
	DD	imagerel $unwind$?mem_alloc@xrMemory@@QEAAPEAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Emem_pools@@YAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fmem_pools@@YAXXZ DD 0a2e01H
	DD	08742eH
	DD	0a5413H
	DD	093413H
	DD	0f00f3213H
	DD	0600be00dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0MEMPOOL@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_H@YAXPEAX_KHP6APEAX0@Z@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1MEMPOOL@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?destroy@MEMPOOL@@QEAAXAEAPEAX@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?create@MEMPOOL@@QEAAPEAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
mem_pools$initializer$ DQ FLAT:??__Emem_pools@@YAXXZ
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
_TEXT	SEGMENT
this$ = 96
size$ = 104
?mem_alloc@xrMemory@@QEAAPEAX_K@Z PROC			; xrMemory::mem_alloc

; 42   : {

$LN46:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 43   : 	stat_calls++;

	inc	DWORD PTR [rcx]

; 44   : 	_ASSERT (size > 0);
; 45   : 	R_ASSERT (size < 0x7fffFFFF);

	xor	ebx, ebx
	mov	rdi, rdx
	cmp	BYTE PTR ?ignore_always@?3??mem_alloc@xrMemory@@QEAAPEAX_K@Z@4_NA, bl
	jne	SHORT $LN7@mem_alloc
	cmp	rdx, 2147483647				; 7fffffffH
	jb	SHORT $LN7@mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3??mem_alloc@xrMemory@@QEAAPEAX_K@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0BC@KHLAADNE@size?5?$DM?50x7fffFFFF?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BE@LHNBCIB@xrMemory?3?3mem_alloc?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0BI@MKKJNCPP@xrMemory_subst_msvc?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 45			; 0000002dH
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN7@mem_alloc:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 77   : 	if (!mem_initialized /*|| debug_mode*/)		

	cmp	DWORD PTR ?mem_initialized@@3HA, ebx	; mem_initialized

; 78   : 	{
; 79   : 		// generic
; 80   : 		//	Igor: Reserve 1 byte for xrMemory header
; 81   : 		void*	_real			=	xr_aligned_offset_malloc	(1 + size + _footer, 16, 0x1);

	lea	rcx, QWORD PTR [rdi+1]
	jne	SHORT $LN4@mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 101  : 	if ( offset >= size && offset != 0)

	cmp	rcx, 1
	mov	eax, 2
	cmovbe	rcx, rax

; 102  : 		size	= offset+1;
; 103  : 
; 104  : 	align = (align > PTR_SZ ? align : PTR_SZ) -1;
; 105  : 
; 106  : 	/* gap = number of bytes needed to round up offset to align with PTR_SZ*/
; 107  : 	gap = (0 - offset)&(PTR_SZ -1);
; 108  : 
; 109  : 	if ( (ptr =(uintptr_t)malloc(PTR_SZ +gap +align +size)) == (uintptr_t)NULL)

	add	rcx, 30
	call	QWORD PTR __imp_malloc
	test	rax, rax
	je	SHORT $LN16@mem_alloc

; 110  : 		return NULL;
; 111  : 
; 112  : 	retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;

	lea	rbx, QWORD PTR [rax+31]
	and	rbx, -16
	dec	rbx

; 113  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;

	mov	QWORD PTR [rbx-15], rax
$LN16@mem_alloc:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 83   : 		_ptr					=	(void*)(((u8*)_real)+1);

	lea	rax, QWORD PTR [rbx+1]

; 84   : 		*acc_header(_ptr)		=	mem_generic;

	mov	BYTE PTR [rax-1], 55			; 00000037H

; 107  : 			*acc_header(_ptr)	=	(u8)pool;
; 108  : 		}
; 109  : 	}
; 110  : 
; 111  : #ifdef DEBUG_MEMORY_MANAGER
; 112  : 	if		(debug_mode)		dbg_register		(_ptr,size,_name);
; 113  : 	if (mem_initialized)		debug_cs.Leave		();
; 114  : 	//if(g_globalCheckAddr==_ptr){
; 115  : 	//	__asm int 3;
; 116  : 	//}
; 117  : 	//if (_name && (0==strcmp(_name,"class ISpatial *")) && (size==376))
; 118  : 	//{
; 119  : 	//	__asm int 3;
; 120  : 	//}
; 121  : #endif // DEBUG_MEMORY_MANAGER
; 122  : #ifdef USE_MEMORY_MONITOR
; 123  : 	memory_monitor::monitor_alloc	(_ptr,size,_name);
; 124  : #endif // USE_MEMORY_MONITOR	
; 125  : 	return	_ptr;
; 126  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN4@mem_alloc:
	mov	QWORD PTR [rsp+96], rsi

; 28   : 	u32		pid					= u32(size/mem_pools_ebase);

	mov	rsi, rcx
	shr	rsi, 4
	cmp	esi, 54					; 00000036H
	jb	SHORT $LN2@mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 101  : 	if ( offset >= size && offset != 0)

	cmp	rcx, 1
	mov	eax, 2
	cmovbe	rcx, rax

; 102  : 		size	= offset+1;
; 103  : 
; 104  : 	align = (align > PTR_SZ ? align : PTR_SZ) -1;
; 105  : 
; 106  : 	/* gap = number of bytes needed to round up offset to align with PTR_SZ*/
; 107  : 	gap = (0 - offset)&(PTR_SZ -1);
; 108  : 
; 109  : 	if ( (ptr =(uintptr_t)malloc(PTR_SZ +gap +align +size)) == (uintptr_t)NULL)

	add	rcx, 30
	call	QWORD PTR __imp_malloc
	test	rax, rax
	je	SHORT $LN27@mem_alloc

; 110  : 		return NULL;
; 111  : 
; 112  : 	retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;

	lea	rbx, QWORD PTR [rax+31]
	and	rbx, -16
	dec	rbx

; 113  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;

	mov	QWORD PTR [rbx-15], rax
$LN27@mem_alloc:
	mov	rsi, QWORD PTR [rsp+96]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 99   : 			_ptr				=	(void*)(((u8*)_real)+1);

	lea	rax, QWORD PTR [rbx+1]

; 100  : 			*acc_header(_ptr)	=	mem_generic;

	mov	BYTE PTR [rax-1], 55			; 00000037H

; 107  : 			*acc_header(_ptr)	=	(u8)pool;
; 108  : 		}
; 109  : 	}
; 110  : 
; 111  : #ifdef DEBUG_MEMORY_MANAGER
; 112  : 	if		(debug_mode)		dbg_register		(_ptr,size,_name);
; 113  : 	if (mem_initialized)		debug_cs.Leave		();
; 114  : 	//if(g_globalCheckAddr==_ptr){
; 115  : 	//	__asm int 3;
; 116  : 	//}
; 117  : 	//if (_name && (0==strcmp(_name,"class ISpatial *")) && (size==376))
; 118  : 	//{
; 119  : 	//	__asm int 3;
; 120  : 	//}
; 121  : #endif // DEBUG_MEMORY_MANAGER
; 122  : #ifdef USE_MEMORY_MONITOR
; 123  : 	memory_monitor::monitor_alloc	(_ptr,size,_name);
; 124  : #endif // USE_MEMORY_MONITOR	
; 125  : 	return	_ptr;
; 126  : }

	mov	rbx, QWORD PTR [rsp+104]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN2@mem_alloc:

; 101  : 		} else {
; 102  : 			// pooled
; 103  : 			//	Igor: Reserve 1 byte for xrMemory header
; 104  : 			//	Already reserved when getting pool id
; 105  : 			void*	_real		=	mem_pools[pool].create();

	mov	eax, esi
	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rdi, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 36   : 		if (0==list)	block_create();

	cmp	QWORD PTR [rdi+32], rbx
	jne	SHORT $LN31@mem_alloc
	mov	rcx, rdi
	call	?block_create@MEMPOOL@@AEAAXXZ		; MEMPOOL::block_create
$LN31@mem_alloc:

; 37   : 
; 38   : 		void* E			= list;

	mov	rbx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 39   : 		list			= (u8*)*access(list);

	mov	rax, QWORD PTR [rbx]
	mov	QWORD PTR [rdi+32], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 106  : 			_ptr				=	(void*)(((u8*)_real)+1);

	lea	rax, QWORD PTR [rbx+1]

; 107  : 			*acc_header(_ptr)	=	(u8)pool;
; 108  : 		}
; 109  : 	}
; 110  : 
; 111  : #ifdef DEBUG_MEMORY_MANAGER
; 112  : 	if		(debug_mode)		dbg_register		(_ptr,size,_name);
; 113  : 	if (mem_initialized)		debug_cs.Leave		();
; 114  : 	//if(g_globalCheckAddr==_ptr){
; 115  : 	//	__asm int 3;
; 116  : 	//}
; 117  : 	//if (_name && (0==strcmp(_name,"class ISpatial *")) && (size==376))
; 118  : 	//{
; 119  : 	//	__asm int 3;
; 120  : 	//}
; 121  : #endif // DEBUG_MEMORY_MANAGER
; 122  : #ifdef USE_MEMORY_MONITOR
; 123  : 	memory_monitor::monitor_alloc	(_ptr,size,_name);
; 124  : #endif // USE_MEMORY_MONITOR	
; 125  : 	return	_ptr;
; 126  : }

	mov	rbx, QWORD PTR [rsp+104]
	mov	BYTE PTR [rax-1], sil
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?mem_alloc@xrMemory@@QEAAPEAX_K@Z ENDP			; xrMemory::mem_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
_TEXT	SEGMENT
this$ = 48
P$ = 56
?mem_free@xrMemory@@QEAAXPEAX@Z PROC			; xrMemory::mem_free

; 129  : {

$LN27:
	push	rdi
	sub	rsp, 32					; 00000020H

; 130  : 	stat_calls++;

	inc	DWORD PTR [rcx]

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdx-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rdi, QWORD PTR [rdx-1]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN3@mem_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN24@mem_free

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 165  : }

	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 303  : 	free((void *)ptr);

	rex_jmp	QWORD PTR __imp_free
$LN3@mem_free:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
$LN24@mem_free:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 165  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?mem_free@xrMemory@@QEAAXPEAX@Z ENDP			; xrMemory::mem_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
_TEXT	SEGMENT
this$ = 96
P$ = 104
size$ = 112
?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z PROC		; xrMemory::mem_realloc

; 174  : {

$LN38:
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	r14
	sub	rsp, 80					; 00000050H

; 175  : 	stat_calls++;

	inc	DWORD PTR [rcx]
	mov	rbp, r8
	mov	r14, rdx
	mov	rsi, rcx

; 176  : #ifdef PURE_ALLOC
; 177  : 	if (g_use_pure_alloc) {
; 178  : 		void							*result = realloc(P,size);
; 179  : #	ifdef USE_MEMORY_MONITOR
; 180  : 		memory_monitor::monitor_free	(P);
; 181  : 		memory_monitor::monitor_alloc	(result,size,_name);
; 182  : #	endif // USE_MEMORY_MONITOR
; 183  : 		return							(result);
; 184  : 	}
; 185  : #endif // PURE_ALLOC
; 186  : 	if (0==P) {

	test	rdx, rdx
	jne	SHORT $LN14@mem_reallo

; 187  : 		return mem_alloc	(size
; 188  : #	ifdef DEBUG_MEMORY_NAME
; 189  : 		,_name
; 190  : #	endif // DEBUG_MEMORY_NAME
; 191  : 		);

	mov	rdx, r8

; 266  : 	}
; 267  : 
; 268  : #ifdef DEBUG_MEMORY_MANAGER
; 269  : 	if (mem_initialized)		debug_cs.Leave	();
; 270  : 
; 271  : 	if(g_globalCheckAddr==_ptr)
; 272  : 		__asm int 3;
; 273  : #endif // DEBUG_MEMORY_MANAGER
; 274  : 
; 275  : 	return	_ptr;
; 276  : }

	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	r14

; 187  : 		return mem_alloc	(size
; 188  : #	ifdef DEBUG_MEMORY_NAME
; 189  : 		,_name
; 190  : #	endif // DEBUG_MEMORY_NAME
; 191  : 		);

	jmp	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
$LN14@mem_reallo:

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rcx, QWORD PTR [rdx-1]

; 192  : 	}
; 193  : 
; 194  : #ifdef DEBUG_MEMORY_MANAGER
; 195  : 	if(g_globalCheckAddr==P)
; 196  : 		__asm int 3;
; 197  : #endif // DEBUG_MEMORY_MANAGER
; 198  : 
; 199  : #ifdef DEBUG_MEMORY_MANAGER
; 200  : 	if (mem_initialized)		debug_cs.Enter		();
; 201  : #endif // DEBUG_MEMORY_MANAGER
; 202  : 	u32		p_current			= get_header(P);
; 203  : 	//	Igor: Reserve 1 byte for xrMemory header
; 204  : 	u32		p_new				= get_pool	(1+size+(debug_mode?4:0));

	lea	rdx, QWORD PTR [r8+1]
	mov	QWORD PTR [rsp+96], rbx

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	ebx, BYTE PTR [rcx]

; 26   : ICF	u32		get_pool			(size_t size)
; 27   : {
; 28   : 	u32		pid					= u32(size/mem_pools_ebase);
; 29   : 	if (pid>=mem_pools_count)	return mem_generic;

	mov	r8d, 55					; 00000037H
	mov	rax, rdx
	shr	rax, 4
	mov	QWORD PTR [rsp+104], rdi
	cmp	eax, 54					; 00000036H
	cmovae	eax, r8d

; 205  : 	//u32		p_new				= get_pool	(size+(debug_mode?4:0));
; 206  : 	u32		p_mode				;
; 207  : 
; 208  : 	if (mem_generic==p_current)	{

	cmp	ebx, r8d
	jne	SHORT $LN35@mem_reallo

; 209  : 		if (p_new<p_current)		p_mode	= 2	;

	cmp	eax, r8d
	jb	SHORT $LN33@mem_reallo

; 210  : 		else						p_mode	= 0	;
; 211  : 	} else 							p_mode	= 1	;
; 212  : 
; 213  : 	void*	_real				= (void*)(((u8*)P)-1);
; 214  : 	void*	_ptr				= NULL;
; 215  : 	if		(0==p_mode)
; 216  : 	{
; 217  : 		u32		_footer			=	debug_mode?4:0;
; 218  : #ifdef DEBUG_MEMORY_MANAGER
; 219  : 		if		(debug_mode)	{
; 220  : 			g_bDbgFillMemory	= false;
; 221  : 			dbg_unregister		(P);
; 222  : 			g_bDbgFillMemory	= true;
; 223  : 		}
; 224  : #endif // DEBUG_MEMORY_MANAGER
; 225  : 		//	Igor: Reserve 1 byte for xrMemory header
; 226  : 		void*	_real2			=	xr_aligned_offset_realloc	(_real,1+size+_footer,16,0x1);

	call	?xr_aligned_offset_realloc@@YAPEAXPEAX_K11@Z ; xr_aligned_offset_realloc

; 227  : 		//void*	_real2			=	xr_aligned_offset_realloc	(_real,size+_footer,16,0x1);
; 228  : 		_ptr					= (void*)(((u8*)_real2)+1);
; 229  : 		*acc_header(_ptr)		= mem_generic;

	mov	BYTE PTR [rax], 55			; 00000037H
	lea	rdi, QWORD PTR [rax+1]
	jmp	$LN1@mem_reallo
$LN33@mem_reallo:

; 254  : 		_ptr					= p_new;
; 255  : 	} else if (2==p_mode)		{
; 256  : 		// relocate into another mmgr(pooled) from real
; 257  : 		void*	p_old			= P;
; 258  : 		void*	p_new			= mem_alloc(size
; 259  : #	ifdef DEBUG_MEMORY_NAME
; 260  : 			,_name
; 261  : #	endif // DEBUG_MEMORY_NAME
; 262  : 		);

	mov	rdx, rbp
	mov	rcx, rsi
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 263  : 		mem_copy				(p_new,p_old,(u32)size);
; 264  : 		mem_free				(p_old);
; 265  : 		_ptr					= p_new;

	jmp	$LN36@mem_reallo
$LN35@mem_reallo:

; 230  : #ifdef DEBUG_MEMORY_MANAGER
; 231  : 		if		(debug_mode)	dbg_register	(_ptr,size,_name);
; 232  : #endif // DEBUG_MEMORY_MANAGER
; 233  : #ifdef USE_MEMORY_MONITOR
; 234  : 		memory_monitor::monitor_free	(P);
; 235  : 		memory_monitor::monitor_alloc	(_ptr,size,_name);
; 236  : #endif // USE_MEMORY_MONITOR
; 237  : 	} else if (1==p_mode)		{
; 238  : 		// pooled realloc
; 239  : 		R_ASSERT2				(p_current<mem_pools_count,"Memory corruption");

	cmp	BYTE PTR ?ignore_always@?BF@??mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z@4_NA, 0
	jne	SHORT $LN5@mem_reallo
	cmp	ebx, 54					; 00000036H
	jb	SHORT $LN5@mem_reallo
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?BF@??mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0BC@MAGELDOC@Memory?5corruption?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BK@CPGKHBFC@p_current?$DMmem_pools_count?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BG@BIILGNAF@xrMemory?3?3mem_realloc?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0BI@MKKJNCPP@xrMemory_subst_msvc?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 239			; 000000efH
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN5@mem_reallo:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 240  : 		u32		s_current		= mem_pools[p_current].get_element();

	lea	rcx, QWORD PTR [rbx+rbx*4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 31   : 	ICF u32				get_element		()	{ return s_element; }

	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A+12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 248  : 		);

	mov	rdx, rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 31   : 	ICF u32				get_element		()	{ return s_element; }

	mov	ebx, DWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 248  : 		);

	mov	rcx, rsi
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 251  : 		mem_copy				(p_new,p_old,_min(s_current-1,s_dest));

	lea	ecx, DWORD PTR [rbx-1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	cmp	ecx, ebp
	cmovb	ebp, ecx
$LN36@mem_reallo:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 251  : 		mem_copy				(p_new,p_old,_min(s_current-1,s_dest));

	mov	r8d, ebp
	mov	rdx, r14
	mov	rcx, rax
	mov	rdi, rax
	call	QWORD PTR [rsi+8]

; 252  : 		//mem_copy				(p_new,p_old,_min(s_current,s_dest));
; 253  : 		mem_free				(p_old);

	mov	rdx, r14
	mov	rcx, rsi
	call	?mem_free@xrMemory@@QEAAXPEAX@Z		; xrMemory::mem_free
$LN1@mem_reallo:

; 266  : 	}
; 267  : 
; 268  : #ifdef DEBUG_MEMORY_MANAGER
; 269  : 	if (mem_initialized)		debug_cs.Leave	();
; 270  : 
; 271  : 	if(g_globalCheckAddr==_ptr)
; 272  : 		__asm int 3;
; 273  : #endif // DEBUG_MEMORY_MANAGER
; 274  : 
; 275  : 	return	_ptr;
; 276  : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 80					; 00000050H
	pop	r14
	ret	0
?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z ENDP		; xrMemory::mem_realloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
;	COMDAT ??__Emem_pools@@YAXXZ
text$di	SEGMENT
??__Emem_pools@@YAXXZ PROC				; `dynamic initializer for 'mem_pools'', COMDAT

; 21   : MEMPOOL		mem_pools			[mem_pools_count];

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rbx, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	edi, 53					; 00000035H
	npad	10
$LL4@dynamic:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 40					; 00000028H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 41   : 	InitializeCriticalSection		( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, rax
	mov	QWORD PTR [rbx], rax
	call	QWORD PTR __imp_InitializeCriticalSection
	dec	edi
	lea	rbx, QWORD PTR [rbx+40]
	jns	SHORT $LL4@dynamic
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 21   : MEMPOOL		mem_pools			[mem_pools_count];

	lea	rcx, OFFSET FLAT:??__Fmem_pools@@YAXXZ	; `dynamic atexit destructor for 'mem_pools''
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	jmp	atexit
??__Emem_pools@@YAXXZ ENDP				; `dynamic initializer for 'mem_pools''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??__Fmem_pools@@YAXXZ
text$yd	SEGMENT
??__Fmem_pools@@YAXXZ PROC				; `dynamic atexit destructor for 'mem_pools'', COMDAT
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H
	lea	rsi, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A+2160
	mov	ebp, 53					; 00000035H
	lea	r15, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	xor	r14d, r14d
	mov	QWORD PTR [rsp+64], rdi
	npad	2
$LL4@dynamic:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 46   : 	DeleteCriticalSection			( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, QWORD PTR [rsi-40]
	lea	rsi, QWORD PTR [rsi-40]
	call	QWORD PTR __imp_DeleteCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rbx, QWORD PTR [rsi]
	test	rbx, rbx
	je	SHORT $LN11@dynamic
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rbx-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rbx

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN16@dynamic
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rbx, rbx
	je	SHORT $LN37@dynamic

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rbx, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rbx-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN37@dynamic
$LN16@dynamic:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rdi, QWORD PTR [r15+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [r15+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rdi+32]
	mov	QWORD PTR [rbx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rdi+32], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN37@dynamic:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	QWORD PTR [rsi], r14
$LN11@dynamic:
	dec	ebp
	jns	SHORT $LL4@dynamic
	mov	rdi, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
??__Fmem_pools@@YAXXZ ENDP				; `dynamic atexit destructor for 'mem_pools''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
;	COMDAT ??0MEMPOOL@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0MEMPOOL@@QEAA@XZ PROC				; MEMPOOL::MEMPOOL, COMDAT
$LN71:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 40					; 00000028H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 41   : 	InitializeCriticalSection		( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, rax
	mov	QWORD PTR [rbx], rax
	call	QWORD PTR __imp_InitializeCriticalSection
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0MEMPOOL@@QEAA@XZ ENDP				; MEMPOOL::MEMPOOL
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YAXPEAX_KHP6APEAX0@Z@Z
_TEXT	SEGMENT
__t$dead$ = 48
__s$dead$ = 56
__n$dead$ = 64
__f$dead$ = 72
??_H@YAXPEAX_KHP6APEAX0@Z@Z PROC			; `vector constructor iterator', COMDAT
$LN79:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	lea	rbx, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	edi, 53					; 00000035H
$LL2@vector:
	mov	rcx, rbx
	call	??0MEMPOOL@@QEAA@XZ
	add	rbx, 40					; 00000028H
	dec	edi
	jns	SHORT $LL2@vector
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_H@YAXPEAX_KHP6APEAX0@Z@Z ENDP			; `vector constructor iterator'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
;	COMDAT ??1MEMPOOL@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1MEMPOOL@@QEAA@XZ PROC				; MEMPOOL::~MEMPOOL, COMDAT
$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 46   : 	DeleteCriticalSection			( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_DeleteCriticalSection

; 47   : 	xr_free							( pmutex		);

	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
??1MEMPOOL@@QEAA@XZ ENDP				; MEMPOOL::~MEMPOOL
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
;	COMDAT ?acc_header@@YAPEAEPEAX@Z
_TEXT	SEGMENT
P$ = 8
?acc_header@@YAPEAEPEAX@Z PROC				; acc_header, COMDAT

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rax, QWORD PTR [rcx-1]
	ret	0
?acc_header@@YAPEAEPEAX@Z ENDP				; acc_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
;	COMDAT ?get_header@@YAIPEAX@Z
_TEXT	SEGMENT
P$ = 8
?get_header@@YAIPEAX@Z PROC				; get_header, COMDAT

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rcx-1]
	ret	0
?get_header@@YAIPEAX@Z ENDP				; get_header
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
;	COMDAT ?get_pool@@YAI_K@Z
_TEXT	SEGMENT
size$ = 8
?get_pool@@YAI_K@Z PROC					; get_pool, COMDAT

; 28   : 	u32		pid					= u32(size/mem_pools_ebase);

	shr	rcx, 4

; 29   : 	if (pid>=mem_pools_count)	return mem_generic;

	mov	eax, 55					; 00000037H
	cmp	ecx, 54					; 00000036H
	cmovae	ecx, eax
	mov	eax, ecx

; 30   : 	else						return pid;
; 31   : }

	ret	0
?get_pool@@YAI_K@Z ENDP					; get_pool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ??$_min@I@@YAIII@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??$_min@I@@YAIII@Z PROC					; _min<unsigned int>, COMDAT

; 93   : template <class T>	IC T		_min	(T a, T b)	{ return a<b?a:b;	}

	cmp	ecx, edx
	cmovb	edx, ecx
	mov	eax, edx
	ret	0
??$_min@I@@YAIII@Z ENDP					; _min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
;	COMDAT ?get_element@MEMPOOL@@QEAAIXZ
_TEXT	SEGMENT
this$ = 8
?get_element@MEMPOOL@@QEAAIXZ PROC			; MEMPOOL::get_element, COMDAT

; 31   : 	ICF u32				get_element		()	{ return s_element; }

	mov	eax, DWORD PTR [rcx+12]
	ret	0
?get_element@MEMPOOL@@QEAAIXZ ENDP			; MEMPOOL::get_element
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
;	COMDAT ?destroy@MEMPOOL@@QEAAXAEAPEAX@Z
_TEXT	SEGMENT
this$ = 48
P$ = 56
?destroy@MEMPOOL@@QEAAXAEAPEAX@Z PROC			; MEMPOOL::destroy, COMDAT

; 44   : 	{

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 44   : 	{

	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 21   : 	ICF void**			access			(void* P)	{ return (void**) ((void*)(P));	}

	mov	rdx, QWORD PTR [rbx]

; 45   : 		cs.Enter		();
; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rdi+32]
	mov	QWORD PTR [rdx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rdi+32], rdx

; 49   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
?destroy@MEMPOOL@@QEAAXAEAPEAX@Z ENDP			; MEMPOOL::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
;	COMDAT ?create@MEMPOOL@@QEAAPEAXXZ
_TEXT	SEGMENT
this$ = 48
?create@MEMPOOL@@QEAAPEAXXZ PROC			; MEMPOOL::create, COMDAT

; 34   : 	{

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 36   : 		if (0==list)	block_create();

	cmp	QWORD PTR [rdi+32], 0
	jne	SHORT $LN1@create
	mov	rcx, rdi
	call	?block_create@MEMPOOL@@AEAAXXZ		; MEMPOOL::block_create
$LN1@create:

; 37   : 
; 38   : 		void* E			= list;

	mov	rbx, QWORD PTR [rdi+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 39   : 		list			= (u8*)*access(list);

	mov	rdx, QWORD PTR [rbx]
	mov	QWORD PTR [rdi+32], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 41   : 		return			E;

	mov	rax, rbx

; 42   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?create@MEMPOOL@@QEAAPEAXXZ ENDP			; MEMPOOL::create
_TEXT	ENDS
END
