; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?g_pSharedMemoryContainer@@3PEAVsmem_container@@EA ; g_pSharedMemoryContainer
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BD@JJAGEJAN@x?3?2$smem_dump$?4txt?$AA@	; `string'
PUBLIC	??_C@_0BK@KPOBLFJH@?$CF4d?5?3?5crc?$FL?$CF6x?$FN?0?5?$CFd?5bytes?6?$AA@ ; `string'
EXTRN	__imp_fprintf:PROC
	ALIGN	8

?g_pSharedMemoryContainer@@3PEAVsmem_container@@EA DQ 01H DUP (?) ; g_pSharedMemoryContainer
_BSS	ENDS
;	COMDAT ??_C@_0BK@KPOBLFJH@?$CF4d?5?3?5crc?$FL?$CF6x?$FN?0?5?$CFd?5bytes?6?$AA@
CONST	SEGMENT
??_C@_0BK@KPOBLFJH@?$CF4d?5?3?5crc?$FL?$CF6x?$FN?0?5?$CFd?5bytes?6?$AA@ DB '%'
	DB	'4d : crc[%6x], %d bytes', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JJAGEJAN@x?3?2$smem_dump$?4txt?$AA@
CONST	SEGMENT
??_C@_0BD@JJAGEJAN@x?3?2$smem_dump$?4txt?$AA@ DB 'x:\$smem_dump$.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
PUBLIC	?smem_search@@YA_NPEBUsmem_value@@0@Z		; smem_search
PUBLIC	??$_Fn@V?$xalloc@PEAUsmem_value@@@@PEAUsmem_value@@PEAU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAUsmem_value@@@@PEAPEAUsmem_value@@$$QEAPEAU3@@Z ; std::_Alloc_construct::_Fn<xalloc<smem_value * __ptr64>,smem_value * __ptr64,smem_value * __ptr64>
PUBLIC	??$construct@PEAUsmem_value@@PEAU1@@?$allocator_traits@V?$xalloc@PEAUsmem_value@@@@@std@@SAXAEAV?$xalloc@PEAUsmem_value@@@@PEAPEAUsmem_value@@$$QEAPEAU3@@Z ; std::allocator_traits<xalloc<smem_value * __ptr64> >::construct<smem_value * __ptr64,smem_value * __ptr64>
PUBLIC	??$forward@PEAUsmem_value@@@std@@YA$$QEAPEAUsmem_value@@AEAPEAU1@@Z ; std::forward<smem_value * __ptr64>
PUBLIC	??$construct@PEAUsmem_value@@PEAU1@@?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@QEAAXPEAPEAUsmem_value@@$$QEAPEAU2@@Z ; std::_Wrap_alloc<xalloc<smem_value * __ptr64> >::construct<smem_value * __ptr64,smem_value * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
PUBLIC	??$_Find@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@U?$integral_constant@_N$0A@@0@@Z ; std::_Find<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
PUBLIC	??$_Advance@PEAPEAUsmem_value@@_J@std@@YAXAEAPEAPEAUsmem_value@@_JUrandom_access_iterator_tag@0@@Z ; std::_Advance<smem_value * __ptr64 * __ptr64,__int64>
PUBLIC	??$_Distance2@PEAPEAUsmem_value@@_J@std@@YAXPEAPEAUsmem_value@@0AEA_JUrandom_access_iterator_tag@0@@Z ; std::_Distance2<smem_value * __ptr64 * __ptr64,__int64>
PUBLIC	??$_Iter_cat@PEAPEAUsmem_value@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAPEAUsmem_value@@@Z ; std::_Iter_cat<smem_value * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >
PUBLIC	??$_Move@AEAPEAUsmem_value@@@std@@YA$$QEAPEAUsmem_value@@AEAPEAU1@@Z ; std::_Move<smem_value * __ptr64 & __ptr64>
PUBLIC	??$_Find@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@@Z ; std::_Find<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
PUBLIC	??$advance@PEAPEAUsmem_value@@_J@std@@YAXAEAPEAPEAUsmem_value@@_J@Z ; std::advance<smem_value * __ptr64 * __ptr64,__int64>
PUBLIC	??$_Distance@PEAPEAUsmem_value@@_J@std@@YAXPEAPEAUsmem_value@@0AEA_J@Z ; std::_Distance<smem_value * __ptr64 * __ptr64,__int64>
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAPEAPEAUsmem_value@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Unchecked
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAUsmem_value@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Rechecked
PUBLIC	??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
PUBLIC	??$_Val_type@PEAPEAUsmem_value@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@@Z ; std::_Val_type<smem_value * __ptr64 * __ptr64>
PUBLIC	??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>
PUBLIC	??$_Fill@PEAPEAUsmem_value@@PEAU1@@std@@YAXPEAPEAUsmem_value@@0AEBQEAU1@@Z ; std::_Fill<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
PUBLIC	??$_Uninitialized_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z ; std::_Uninitialized_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >
PUBLIC	??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>
PUBLIC	??$_Remove@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@@Z ; std::_Remove<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@AEAV10@PEAPEAUsmem_value@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >
PUBLIC	??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z ; std::_Lower_bound<smem_value * __ptr64 * __ptr64,smem_value * __ptr64,__int64,bool (__cdecl*)(smem_value const * __ptr64,smem_value const * __ptr64)>
PUBLIC	??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@YAPEAPEAUsmem_value@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >
PUBLIC	??$_Uninitialized_fill_n@PEAPEAUsmem_value@@_KPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z ; std::_Uninitialized_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >
PUBLIC	??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z ; std::_Copy_backward<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>
PUBLIC	??$fill@PEAPEAUsmem_value@@PEAU1@@std@@YAXPEAPEAUsmem_value@@0AEBQEAU1@@Z ; std::fill<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
PUBLIC	??$addressof@PEAUsmem_value@@@std@@YAPEAPEAUsmem_value@@AEAPEAU1@@Z ; std::addressof<smem_value * __ptr64>
PUBLIC	??$_Umove@PEAPEAUsmem_value@@@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU2@00@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Umove<smem_value * __ptr64 * __ptr64>
PUBLIC	??$addressof@QEAUsmem_value@@@std@@YAPEBQEAUsmem_value@@AEBQEAU1@@Z ; std::addressof<smem_value * __ptr64 const>
PUBLIC	??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z ; std::_Move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>
PUBLIC	??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@@Z ; std::remove<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64>
PUBLIC	??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z ; xr_free<smem_value>
PUBLIC	??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64,bool (__cdecl*)(smem_value const * __ptr64,smem_value const * __ptr64)>
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+=
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++
PUBLIC	?_Orphan_range@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEBAXPEAPEAUsmem_value@@0@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Orphan_range
PUBLIC	?_Ufill@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU3@_KPEBQEAU3@@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Ufill
PUBLIC	?_Grow_to@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEBA_K_K@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Grow_to
PUBLIC	?_Unused_capacity@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEBA_KXZ ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Unused_capacity
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAA@PEAPEAUsmem_value@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Compat
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAAEBQEAUsmem_value@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator*
PUBLIC	?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n
PUBLIC	?_Make_iter@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Make_iter
PUBLIC	?clear_and_free@?$xr_vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@@QEAAXXZ ; xr_vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::clear_and_free
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAAEAPEAUsmem_value@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator!=
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator==
PUBLIC	?erase@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@0@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::erase
PUBLIC	?insert@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@AEBQEAUsmem_value@@@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::insert
PUBLIC	?end@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@XZ ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::end
PUBLIC	?begin@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@XZ ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::begin
PUBLIC	?clear@?$xr_vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@@QEAAXXZ ; xr_vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::clear
PUBLIC	?dump@smem_container@@QEAAXXZ			; smem_container::dump
PUBLIC	?dock@smem_container@@QEAAPEAUsmem_value@@IIPEAX@Z ; smem_container::dock
PUBLIC	?stat_economy@smem_container@@QEAAIXZ		; smem_container::stat_economy
PUBLIC	?clean@smem_container@@QEAAXXZ			; smem_container::clean
PUBLIC	??1smem_container@@QEAA@XZ			; smem_container::~smem_container
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+60
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+56
	DD	imagerel $unwind$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z DD imagerel $LN29
	DD	imagerel $LN29+22
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z DD imagerel $LN29+22
	DD	imagerel $LN29+126
	DD	imagerel $chain$1$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z DD imagerel $LN29+126
	DD	imagerel $LN29+134
	DD	imagerel $chain$2$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_fill_n@PEAPEAUsmem_value@@_KPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninitialized_fill_n@PEAPEAUsmem_value@@_KPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z DD imagerel $LN8
	DD	imagerel $LN8+48
	DD	imagerel $unwind$??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAPEAUsmem_value@@@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU2@00@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Umove@PEAPEAUsmem_value@@@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU2@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z DD imagerel $LN8
	DD	imagerel $LN8+58
	DD	imagerel $unwind$??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z DD imagerel $LN30
	DD	imagerel $LN30+87
	DD	imagerel $unwind$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z DD imagerel $LN30+87
	DD	imagerel $LN30+131
	DD	imagerel $chain$0$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z DD imagerel $LN30+131
	DD	imagerel $LN30+149
	DD	imagerel $chain$1$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z DD imagerel $LN41
	DD	imagerel $LN41+37
	DD	imagerel $unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z DD imagerel $LN41+37
	DD	imagerel $LN41+136
	DD	imagerel $chain$1$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z DD imagerel $LN41+136
	DD	imagerel $LN41+156
	DD	imagerel $chain$2$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ufill@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU3@_KPEBQEAU3@@Z DD imagerel $LN12
	DD	imagerel $LN12+45
	DD	imagerel $unwind$?_Ufill@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU3@_KPEBQEAU3@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z DD imagerel $LN248
	DD	imagerel $LN248+702
	DD	imagerel $unwind$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA DD imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA+49
	DD	imagerel $unwind$?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA DD imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA+23
	DD	imagerel $unwind$?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@0@Z DD imagerel $LN79
	DD	imagerel $LN79+156
	DD	imagerel $unwind$?erase@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@AEBQEAUsmem_value@@@Z DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$?insert@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@AEBQEAUsmem_value@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?dump@smem_container@@QEAAXXZ DD imagerel $LN55
	DD	imagerel $LN55+184
	DD	imagerel $unwind$?dump@smem_container@@QEAAXXZ
$pdata$?dock@smem_container@@QEAAPEAUsmem_value@@IIPEAX@Z DD imagerel $LN137
	DD	imagerel $LN137+324
	DD	imagerel $unwind$?dock@smem_container@@QEAAPEAUsmem_value@@IIPEAX@Z
$pdata$?stat_economy@smem_container@@QEAAIXZ DD imagerel $LN51
	DD	imagerel $LN51+137
	DD	imagerel $unwind$?stat_economy@smem_container@@QEAAIXZ
$pdata$?clean@smem_container@@QEAAXXZ DD imagerel $LN224
	DD	imagerel $LN224+263
	DD	imagerel $unwind$?clean@smem_container@@QEAAXXZ
$pdata$??1smem_container@@QEAA@XZ DD imagerel $LN21
	DD	imagerel $LN21+74
	DD	imagerel $unwind$??1smem_container@@QEAA@XZ
xdata	SEGMENT
$unwind$?dump@smem_container@@QEAAXXZ DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0f0145218H
	DD	07010e012H
$unwind$?dock@smem_container@@QEAAPEAUsmem_value@@IIPEAX@Z DD 0c1c01H
	DD	011641cH
	DD	010541cH
	DD	0f341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
$unwind$?stat_economy@smem_container@@QEAAIXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?clean@smem_container@@QEAAXXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$??1smem_container@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@AEBQEAUsmem_value@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@0@Z DD 085501H
	DD	063455H
	DD	097415H
	DD	076415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z DD imagerel ?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
	DD	0ffffffffH
	DD	imagerel ?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z+217
	DD	00H
	DD	imagerel ?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z+298
	DD	0ffffffffH
	DD	imagerel ?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z+420
	DD	02H
	DD	imagerel ?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z+464
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA+13
	DD	01H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA+13
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$1$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$1$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
	DD	02H
	DD	imagerel $tryMap$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
	DD	09H
	DD	imagerel $ip2state$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
	DD	038H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z DD 0a2a19H
	DD	0f642aH
	DD	0e3425H
	DD	0f0137217H
	DD	0d00fe011H
	DD	0700bc00dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ufill@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU3@_KPEBQEAU3@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z DD 021H
	DD	imagerel $LN41
	DD	imagerel $LN41+37
	DD	imagerel $unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z DD 040a21H
	DD	09e40aH
	DD	087405H
	DD	imagerel $LN41
	DD	imagerel $LN41+37
	DD	imagerel $unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z DD 060d01H
	DD	0a340dH
	DD	0f009320dH
	DD	050066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+87
	DD	imagerel $unwind$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+87
	DD	imagerel $unwind$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAPEAUsmem_value@@@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU2@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_fill_n@PEAPEAUsmem_value@@_KPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+22
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z DD 040921H
	DD	07409H
	DD	023405H
	DD	imagerel $LN29
	DD	imagerel $LN29+22
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+51
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+52
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
_TEXT	SEGMENT
p$1 = 48
this$ = 48
??1smem_container@@QEAA@XZ PROC				; smem_container::~smem_container

; 101  : {

$LN21:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 102  : 	clean			();

	call	?clean@smem_container@@QEAAXXZ		; smem_container::clean
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	je	SHORT $LN7@smem_conta
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$1[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@PEAUsmem_value@@@@YAXAEAPEAPEAUsmem_value@@@Z ; xr_free<smem_value * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx+8], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+16], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+24], rax
$LN7@smem_conta:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 46   : 	DeleteCriticalSection			( (CRITICAL_SECTION*)pmutex	);

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_DeleteCriticalSection

; 47   : 	xr_free							( pmutex		);

	mov	rcx, rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 103  : }

	add	rsp, 32					; 00000020H
	pop	rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 47   : 	xr_free							( pmutex		);

	jmp	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
??1smem_container@@QEAA@XZ ENDP				; smem_container::~smem_container
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
_TEXT	SEGMENT
this$ = 48
?clean@smem_container@@QEAAXXZ PROC			; smem_container::clean

; 59   : {

$LN224:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

	mov	rdi, QWORD PTR [rsi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 63   : 	for (; it!=end; it++)	if (0==(*it)->dwReference)	xr_free	(*it);

	mov	rbx, QWORD PTR [rsi+8]
	cmp	rbx, rdi
	je	SHORT $LN3@clean
$LL30@clean:
	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN4@clean
	mov	rcx, rbx
	call	??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z ; xr_free<smem_value>
$LN4@clean:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rbx, 8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 63   : 	for (; it!=end; it++)	if (0==(*it)->dwReference)	xr_free	(*it);

	cmp	rbx, rdi
	jne	SHORT $LL30@clean
$LN3@clean:

; 64   : 	container.erase	(remove(container.begin(),container.end(),(smem_value*)0),container.end());

	mov	rdx, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

	mov	rbx, QWORD PTR [rsi+8]

; 2433 : 	}
; 2434 : 
; 2435 : template<class _InIt,
; 2436 : 	class _OutIt> inline
; 2437 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2438 : 		_OutIt _Dest)
; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked
; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}
; 2443 : 
; 2444 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2445 : template<class _InIt,
; 2446 : 	class _OutIt> inline
; 2447 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2448 : 		_OutIt _Dest)
; 2449 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2450 : 	return (_Rechecked(_Dest,
; 2451 : 		_Move(_Unchecked(_First), _Unchecked(_Last),
; 2452 : 			_Unchecked(_Dest))));
; 2453 : 	}
; 2454 : 
; 2455 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2456 : template<class _InIt,
; 2457 : 	class _OutIt> inline
; 2458 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2459 : 		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
; 2460 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2461 : 	return (_Move(_First, _Last,
; 2462 : 		_Dest));
; 2463 : 	}
; 2464 : 
; 2465 : template<class _InIt,
; 2466 : 	class _OutIt> inline
; 2467 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2468 : 		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
; 2469 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators
; 2470 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
; 2471 : 	_Move(_First, _Last,
; 2472 : 		_Unchecked(_Dest));
; 2473 : 	return (_Ans);
; 2474 : 	}
; 2475 : 
; 2476 : template<class _InIt,
; 2477 : 	class _OutIt> inline
; 2478 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2479 : 		_OutIt _Dest, true_type)
; 2480 : 	{	// move [_First, _Last) to [_Dest, ...), checked dest
; 2481 : 	return (_Move(_First, _Last,
; 2482 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2483 : 	}
; 2484 : 
; 2485 : template<class _InIt,
; 2486 : 	class _OutIt> inline
; 2487 : _SCL_INSECURE_DEPRECATE
; 2488 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2489 : 		_OutIt _Dest, false_type)
; 2490 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked dest
; 2491 : 	return (_Move(_First, _Last,
; 2492 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2493 : 	}
; 2494 : 
; 2495 : template<class _InIt,
; 2496 : 	class _OutIt> inline
; 2497 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2498 : 		_OutIt _Dest)
; 2499 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2500 : 	_DEBUG_RANGE(_First, _Last);
; 2501 : 	_DEBUG_POINTER(_Dest);
; 2502 : 	return (_Move(_Unchecked(_First), _Unchecked(_Last),
; 2503 : 		_Dest, _Is_checked(_Dest)));
; 2504 : 	}
; 2505 : 
; 2506 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2507 : template<class _InIt,
; 2508 : 	class _OutTy,
; 2509 : 	size_t _OutSize> inline
; 2510 : 	_OutTy *move(_InIt _First, _InIt _Last,
; 2511 : 		_OutTy (&_Dest)[_OutSize])
; 2512 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2513 : 	return (_Unchecked(
; 2514 : 		_STD move(_First, _Last,
; 2515 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2516 : 	}
; 2517 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2518 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2519 : 
; 2520 : 		// TEMPLATE FUNCTION move_backward
; 2521 : template<class _BidIt1,
; 2522 : 	class _BidIt2> inline
; 2523 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2524 : 		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators
; 2526 : 	while (_First != _Last)
; 2527 : 		*--_Dest = _STD move(*--_Last);
; 2528 : 	return (_Dest);
; 2529 : 	}
; 2530 : 
; 2531 : template<class _InIt,
; 2532 : 	class _OutIt> inline
; 2533 : 	_OutIt _Move_backward(_InIt _First, _InIt _Last,
; 2534 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2535 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars
; 2536 : 	ptrdiff_t _Count = _Last - _First;
; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));
; 2539 : 	return (_Dest - _Count);
; 2540 : 	}
; 2541 : 
; 2542 : template<class _BidIt1,
; 2543 : 	class _BidIt2> inline
; 2544 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2545 : 		_BidIt2 _Dest)
; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked
; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2549 : 	}
; 2550 : 
; 2551 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2552 : template<class _BidIt1,
; 2553 : 	class _BidIt2> inline
; 2554 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2555 : 		_BidIt2 _Dest)
; 2556 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2557 : 	return (_Rechecked(_Dest,
; 2558 : 		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2559 : 			_Unchecked(_Dest))));
; 2560 : 	}
; 2561 : 
; 2562 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2563 : template<class _BidIt1,
; 2564 : 	class _BidIt2> inline
; 2565 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2566 : 		_BidIt2 _Dest, true_type)
; 2567 : 	{	// move [_First, _Last) backwards to [..., _Dest), checked dest
; 2568 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2569 : 		_Dest));
; 2570 : 	}
; 2571 : 
; 2572 : template<class _BidIt1,
; 2573 : 	class _BidIt2> inline
; 2574 : _SCL_INSECURE_DEPRECATE
; 2575 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2576 : 		_BidIt2 _Dest, false_type)
; 2577 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest
; 2578 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2579 : 		_Dest));
; 2580 : 	}
; 2581 : 
; 2582 : template<class _BidIt1,
; 2583 : 	class _BidIt2> inline
; 2584 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2585 : 		_BidIt2 _Dest)
; 2586 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2587 : 	_DEBUG_RANGE(_First, _Last);
; 2588 : 	_DEBUG_POINTER(_Dest);
; 2589 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2590 : 		_Dest, _Is_checked(_Dest)));
; 2591 : 	}
; 2592 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2593 : 
; 2594 : 		// TEMPLATE FUNCTION fill
; 2595 : template<class _FwdIt,
; 2596 : 	class _Ty> inline
; 2597 : 	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2598 : 	{	// copy _Val through [_First, _Last)
; 2599 : 	for (; _First != _Last; ++_First)
; 2600 : 		*_First = _Val;
; 2601 : 	}
; 2602 : 
; 2603 : inline void _Fill(char *_First, char *_Last, char _Val)
; 2604 : 	{	// copy char _Val through [_First, _Last)
; 2605 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2606 : 	}
; 2607 : 
; 2608 : inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
; 2609 : 	{	// copy signed char _Val through [_First, _Last)
; 2610 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2611 : 	}
; 2612 : 
; 2613 : inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
; 2614 : 	{	// copy unsigned char _Val through [_First, _Last)
; 2615 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2616 : 	}
; 2617 : 
; 2618 : template<class _FwdIt,
; 2619 : 	class _Ty> inline
; 2620 : 	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2621 : 	{	// copy _Val through [_First, _Last)
; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}
; 2625 : 
; 2626 : 		// TEMPLATE FUNCTION fill_n
; 2627 : template<class _OutIt,
; 2628 : 	class _Diff,
; 2629 : 	class _Ty> inline
; 2630 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)
; 2633 : 		*_Dest = _Val;
; 2634 : 	return (_Dest);
; 2635 : 	}
; 2636 : 
; 2637 : inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
; 2638 : 	{	// copy char _Val _Count times through [_Dest, ...)
; 2639 : 	_CSTD memset(_Dest, _Val, _Count);
; 2640 : 	return (_Dest + _Count);
; 2641 : 	}
; 2642 : 
; 2643 : inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
; 2644 : 	signed char _Val)
; 2645 : 	{	// copy signed char _Val _Count times through [_Dest, ...)
; 2646 : 	_CSTD memset(_Dest, _Val, _Count);
; 2647 : 	return (_Dest + _Count);
; 2648 : 	}
; 2649 : 
; 2650 : inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
; 2651 : 	unsigned char _Val)
; 2652 : 	{	// copy unsigned char _Val _Count times through [_Dest, ...)
; 2653 : 	_CSTD memset(_Dest, _Val, _Count);
; 2654 : 	return (_Dest + _Count);
; 2655 : 	}
; 2656 : 
; 2657 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2658 : template<class _OutIt,
; 2659 : 	class _Diff,
; 2660 : 	class _Ty> inline
; 2661 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2662 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2663 : 	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
; 2664 : 	}
; 2665 : 
; 2666 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2667 : template<class _OutIt,
; 2668 : 	class _Diff,
; 2669 : 	class _Ty> inline
; 2670 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2671 : 		_Mutable_iterator_tag)
; 2672 : 	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator
; 2673 : 	return (_Fill_n(_Dest, _Count, _Val));
; 2674 : 	}
; 2675 : 
; 2676 : template<class _OutIt,
; 2677 : 	class _Diff,
; 2678 : 	class _Ty> inline
; 2679 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2680 : 		random_access_iterator_tag)
; 2681 : 	{	// copy _Val _Count times through [_Dest, ...), random-access iterator
; 2682 : 	_OutIt _Ans = _Dest + _Count;	// also checks range
; 2683 : 	_Fill_n(_Unchecked(_Dest), _Count, _Val);
; 2684 : 	return (_Ans);
; 2685 : 	}
; 2686 : 
; 2687 : template<class _OutIt,
; 2688 : 	class _Diff,
; 2689 : 	class _Ty> inline
; 2690 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2691 : 		true_type)
; 2692 : 	{	// copy _Val _Count times through [_Dest, ...), checked dest
; 2693 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2694 : 		_Iter_cat(_Dest)));
; 2695 : 	}
; 2696 : 
; 2697 : template<class _OutIt,
; 2698 : 	class _Diff,
; 2699 : 	class _Ty> inline
; 2700 : _SCL_INSECURE_DEPRECATE
; 2701 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2702 : 		false_type)
; 2703 : 	{	// copy _Val _Count times through [_Dest, ...), unchecked dest
; 2704 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2705 : 		_Iter_cat(_Dest)));
; 2706 : 	}
; 2707 : 
; 2708 : template<class _OutIt,
; 2709 : 	class _Diff,
; 2710 : 	class _Ty> inline
; 2711 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2712 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2713 : 	_DEBUG_POINTER(_Dest);
; 2714 : 	return (_Fill_n(_Dest, _Count, _Val,
; 2715 : 		_Is_checked(_Dest)));
; 2716 : 	}
; 2717 : 
; 2718 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2719 : template<class _OutTy,
; 2720 : 	size_t _OutSize,
; 2721 : 	class _Diff,
; 2722 : 	class _Ty> inline
; 2723 : 	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
; 2724 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2725 : 	return (_Unchecked(_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
; 2726 : 		_Count, _Val)));
; 2727 : 	}
; 2728 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2729 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2730 : 
; 2731 : 		// TEMPLATE FUNCTION equal
; 2732 : template<class _InIt1,
; 2733 : 	class _InIt2> inline
; 2734 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
; 2735 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2736 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2737 : 		if (!(*_First1 == *_First2))
; 2738 : 			return (false);
; 2739 : 	return (true);
; 2740 : 	}
; 2741 : 
; 2742 : inline bool _Equal(const char *_First1, const char *_Last1,
; 2743 : 	const char *_First2)
; 2744 : 	{	// compare [_First1, _Last1) to [_First2, ...), for chars
; 2745 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2746 : 	}
; 2747 : 
; 2748 : inline bool _Equal(const signed char *_First1, const signed char *_Last1,
; 2749 : 	const signed char *_First2)
; 2750 : 	{	// compare [_First1, _Last1) to [_First2, ...), for signed chars
; 2751 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2752 : 	}
; 2753 : 
; 2754 : inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
; 2755 : 	const unsigned char *_First2)
; 2756 : 	{	// compare [_First1, _Last1) to [_First2, ...), for unsigned chars
; 2757 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2758 : 	}
; 2759 : 
; 2760 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2761 : template<class _InIt1,
; 2762 : 	class _InIt2> inline
; 2763 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2764 : 		_InIt2 _First2)
; 2765 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2766 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2767 : 		_Unchecked(_First2)));
; 2768 : 	}
; 2769 : 
; 2770 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2771 : template<class _InIt1,
; 2772 : 	class _InIt2> inline
; 2773 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2774 : 		_InIt2 _First2, true_type)
; 2775 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked dest
; 2776 : 	return (_Equal(_First1, _Last1,
; 2777 : 		_First2));
; 2778 : 	}
; 2779 : 
; 2780 : template<class _InIt1,
; 2781 : 	class _InIt2> inline
; 2782 : _SCL_INSECURE_DEPRECATE
; 2783 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2784 : 		_InIt2 _First2, false_type)
; 2785 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked dest
; 2786 : 	return (_Equal(_First1, _Last1,
; 2787 : 		_First2));
; 2788 : 	}
; 2789 : 
; 2790 : template<class _InIt1,
; 2791 : 	class _InIt2> inline
; 2792 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2793 : 		_InIt2 _First2)
; 2794 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2795 : 	_DEBUG_RANGE(_First1, _Last1);
; 2796 : 	_DEBUG_POINTER(_First2);
; 2797 : 	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),
; 2798 : 		_First2, _Is_checked(_First2)));
; 2799 : 	}
; 2800 : 
; 2801 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2802 : template<class _InIt1,
; 2803 : 	class _InTy,
; 2804 : 	size_t _InSize> inline
; 2805 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InTy (&_First2)[_InSize])
; 2807 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2808 : 	return (_STD equal(_First1, _Last1,
; 2809 : 		_Array_iterator<_InTy, _InSize>(_First2)));
; 2810 : 	}
; 2811 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2812 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2813 : 
; 2814 : 		// TEMPLATE FUNCTION equal WITH PRED
; 2815 : template<class _InIt1,
; 2816 : 	class _InIt2,
; 2817 : 	class _Pr> inline
; 2818 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
; 2819 : 		_InIt2 _First2, _Pr _Pred)
; 2820 : 	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
; 2821 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2822 : 		if (!_Pred(*_First1, *_First2))
; 2823 : 			return (false);
; 2824 : 	return (true);
; 2825 : 	}
; 2826 : 
; 2827 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2828 : template<class _InIt1,
; 2829 : 	class _InIt2,
; 2830 : 	class _Pr> inline
; 2831 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2832 : 		_InIt2 _First2, _Pr _Pred)
; 2833 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2834 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2835 : 		_Unchecked(_First2), _Pred));
; 2836 : 	}
; 2837 : 
; 2838 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2839 : template<class _InIt1,
; 2840 : 	class _InIt2,
; 2841 : 	class _Pr> inline
; 2842 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2843 : 		_InIt2 _First2, _Pr _Pred, true_type)
; 2844 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked input
; 2845 : 	return (_Equal(_First1, _Last1,
; 2846 : 		_First2, _Pred));
; 2847 : 	}
; 2848 : 
; 2849 : template<class _InIt1,
; 2850 : 	class _InIt2,
; 2851 : 	class _Pr> inline
; 2852 : _SCL_INSECURE_DEPRECATE
; 2853 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2854 : 		_InIt2 _First2, _Pr _Pred, false_type)
; 2855 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked input
; 2856 : 	return (_Equal(_First1, _Last1,
; 2857 : 		_First2, _Pred));
; 2858 : 	}
; 2859 : 
; 2860 : template<class _InIt1,
; 2861 : 	class _InIt2,
; 2862 : 	class _Pr> inline
; 2863 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2864 : 		_InIt2 _First2, _Pr _Pred)
; 2865 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2866 : 	_DEBUG_RANGE(_First1, _Last1);
; 2867 : 	_DEBUG_POINTER(_First2);
; 2868 : 	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
; 2869 : 		_First2, _Pred, _Is_checked(_First2)));
; 2870 : 	}
; 2871 : 
; 2872 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2873 : template<class _InIt1,
; 2874 : 	class _InTy,
; 2875 : 	size_t _InSize,
; 2876 : 	class _Pr> inline
; 2877 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2878 : 		_InTy (&_First2)[_InSize], _Pr _Pred)
; 2879 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2880 : 	return (_STD equal(_First1, _Last1,
; 2881 : 		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
; 2882 : 	}
; 2883 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2884 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2885 : 
; 2886 : 		// TEMPLATE FUNCTION lexicographical_compare
; 2887 : template<class _InIt1,
; 2888 : 	class _InIt2> inline
; 2889 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2890 : 		_InIt2 _First2, _InIt2 _Last2)
; 2891 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2892 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2893 : 		if (_DEBUG_LT(*_First1, *_First2))
; 2894 : 			return (true);
; 2895 : 		else if (*_First2 < *_First1)
; 2896 : 			return (false);
; 2897 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2898 : 	}
; 2899 : 
; 2900 : inline bool _Lexicographical_compare(
; 2901 : 	const unsigned char *_First1, const unsigned char *_Last1,
; 2902 : 	const unsigned char *_First2, const unsigned char *_Last2)
; 2903 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for unsigned char
; 2904 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2905 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2906 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2907 : 	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
; 2908 : 	}
; 2909 : 
; 2910 :  #if CHAR_MAX == UCHAR_MAX
; 2911 : inline bool _Lexicographical_compare(
; 2912 : 	const char *_First1, const char *_Last1,
; 2913 : 	const char *_First2, const char *_Last2)
; 2914 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for nonnegative char
; 2915 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2916 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2917 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2918 : 	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
; 2919 : 	}
; 2920 :  #endif /* CHAR_MAX == UCHAR_MAX */
; 2921 : 
; 2922 : template<class _InIt1,
; 2923 : 	class _InIt2> inline
; 2924 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2925 : 		_InIt2 _First2, _InIt2 _Last2)
; 2926 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2927 : 	_DEBUG_RANGE(_First1, _Last1);
; 2928 : 	_DEBUG_RANGE(_First2, _Last2);
; 2929 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2930 : 		_Unchecked(_First2), _Unchecked(_Last2)));
; 2931 : 	}
; 2932 : 
; 2933 : 		// TEMPLATE FUNCTION lexicographical_compare WITH PRED
; 2934 : template<class _InIt1,
; 2935 : 	class _InIt2,
; 2936 : 	class _Pr> inline
; 2937 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2938 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2939 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2940 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2941 : 		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
; 2942 : 			return (true);
; 2943 : 		else if (_Pred(*_First2, *_First1))
; 2944 : 			return (false);
; 2945 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2946 : 	}
; 2947 : 
; 2948 : template<class _InIt1,
; 2949 : 	class _InIt2,
; 2950 : 	class _Pr> inline
; 2951 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2952 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2953 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2954 : 	_DEBUG_RANGE(_First1, _Last1);
; 2955 : 	_DEBUG_RANGE(_First2, _Last2);
; 2956 : 	_DEBUG_POINTER(_Pred);
; 2957 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2958 : 		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
; 2959 : 	}
; 2960 : 
; 2961 : 		// TEMPLATE FUNCTION find
; 2962 : template<class _Ty,
; 2963 : 	class _Ignored> inline
; 2964 : 	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
; 2965 : 	{	// signed _Elem, signed _Ty
; 2966 : 	return (SCHAR_MIN <= _Val && _Val <= SCHAR_MAX);
; 2967 : 	}
; 2968 : 
; 2969 : template<class _Ty> inline
; 2970 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
; 2971 : 	{	// signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
; 2972 : 	return (_Val <= SCHAR_MAX || static_cast<_Ty>(SCHAR_MIN) <= _Val);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _Ty> inline
; 2976 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
; 2977 : 	{	// signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
; 2978 : 	return (_Val <= SCHAR_MAX);
; 2979 : 	}
; 2980 : 
; 2981 : template<class _Ty,
; 2982 : 	class _Ignored> inline
; 2983 : 	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
; 2984 : 	{	// unsigned _Elem, signed _Ty
; 2985 : 	return (0 <= _Val && _Val <= UCHAR_MAX);
; 2986 : 	}
; 2987 : 
; 2988 : template<class _Ty,
; 2989 : 	class _Ignored> inline
; 2990 : 	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
; 2991 : 	{	// unsigned _Elem, unsigned _Ty
; 2992 : 	return (_Val <= UCHAR_MAX);
; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))
; 3015 : 		return (_Last);
; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));
; 3018 : 	return (_First ? _First : _Last);
; 3019 : 	}
; 3020 : 
; 3021 : template<class _InIt,
; 3022 : 	class _Ty> inline
; 3023 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
; 3024 : 	{	// find first matching _Val
; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rbx, rdx
	je	SHORT $LN221@clean
	npad	2
$LL89@clean:

; 3026 : 		if (*_First == _Val)

	cmp	QWORD PTR [rbx], 0
	je	SHORT $LN211@clean

; 2433 : 	}
; 2434 : 
; 2435 : template<class _InIt,
; 2436 : 	class _OutIt> inline
; 2437 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2438 : 		_OutIt _Dest)
; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked
; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}
; 2443 : 
; 2444 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2445 : template<class _InIt,
; 2446 : 	class _OutIt> inline
; 2447 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2448 : 		_OutIt _Dest)
; 2449 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2450 : 	return (_Rechecked(_Dest,
; 2451 : 		_Move(_Unchecked(_First), _Unchecked(_Last),
; 2452 : 			_Unchecked(_Dest))));
; 2453 : 	}
; 2454 : 
; 2455 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2456 : template<class _InIt,
; 2457 : 	class _OutIt> inline
; 2458 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2459 : 		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
; 2460 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2461 : 	return (_Move(_First, _Last,
; 2462 : 		_Dest));
; 2463 : 	}
; 2464 : 
; 2465 : template<class _InIt,
; 2466 : 	class _OutIt> inline
; 2467 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2468 : 		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
; 2469 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators
; 2470 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
; 2471 : 	_Move(_First, _Last,
; 2472 : 		_Unchecked(_Dest));
; 2473 : 	return (_Ans);
; 2474 : 	}
; 2475 : 
; 2476 : template<class _InIt,
; 2477 : 	class _OutIt> inline
; 2478 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2479 : 		_OutIt _Dest, true_type)
; 2480 : 	{	// move [_First, _Last) to [_Dest, ...), checked dest
; 2481 : 	return (_Move(_First, _Last,
; 2482 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2483 : 	}
; 2484 : 
; 2485 : template<class _InIt,
; 2486 : 	class _OutIt> inline
; 2487 : _SCL_INSECURE_DEPRECATE
; 2488 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2489 : 		_OutIt _Dest, false_type)
; 2490 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked dest
; 2491 : 	return (_Move(_First, _Last,
; 2492 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2493 : 	}
; 2494 : 
; 2495 : template<class _InIt,
; 2496 : 	class _OutIt> inline
; 2497 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2498 : 		_OutIt _Dest)
; 2499 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2500 : 	_DEBUG_RANGE(_First, _Last);
; 2501 : 	_DEBUG_POINTER(_Dest);
; 2502 : 	return (_Move(_Unchecked(_First), _Unchecked(_Last),
; 2503 : 		_Dest, _Is_checked(_Dest)));
; 2504 : 	}
; 2505 : 
; 2506 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2507 : template<class _InIt,
; 2508 : 	class _OutTy,
; 2509 : 	size_t _OutSize> inline
; 2510 : 	_OutTy *move(_InIt _First, _InIt _Last,
; 2511 : 		_OutTy (&_Dest)[_OutSize])
; 2512 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2513 : 	return (_Unchecked(
; 2514 : 		_STD move(_First, _Last,
; 2515 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2516 : 	}
; 2517 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2518 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2519 : 
; 2520 : 		// TEMPLATE FUNCTION move_backward
; 2521 : template<class _BidIt1,
; 2522 : 	class _BidIt2> inline
; 2523 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2524 : 		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators
; 2526 : 	while (_First != _Last)
; 2527 : 		*--_Dest = _STD move(*--_Last);
; 2528 : 	return (_Dest);
; 2529 : 	}
; 2530 : 
; 2531 : template<class _InIt,
; 2532 : 	class _OutIt> inline
; 2533 : 	_OutIt _Move_backward(_InIt _First, _InIt _Last,
; 2534 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2535 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars
; 2536 : 	ptrdiff_t _Count = _Last - _First;
; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));
; 2539 : 	return (_Dest - _Count);
; 2540 : 	}
; 2541 : 
; 2542 : template<class _BidIt1,
; 2543 : 	class _BidIt2> inline
; 2544 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2545 : 		_BidIt2 _Dest)
; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked
; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2549 : 	}
; 2550 : 
; 2551 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2552 : template<class _BidIt1,
; 2553 : 	class _BidIt2> inline
; 2554 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2555 : 		_BidIt2 _Dest)
; 2556 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2557 : 	return (_Rechecked(_Dest,
; 2558 : 		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2559 : 			_Unchecked(_Dest))));
; 2560 : 	}
; 2561 : 
; 2562 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2563 : template<class _BidIt1,
; 2564 : 	class _BidIt2> inline
; 2565 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2566 : 		_BidIt2 _Dest, true_type)
; 2567 : 	{	// move [_First, _Last) backwards to [..., _Dest), checked dest
; 2568 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2569 : 		_Dest));
; 2570 : 	}
; 2571 : 
; 2572 : template<class _BidIt1,
; 2573 : 	class _BidIt2> inline
; 2574 : _SCL_INSECURE_DEPRECATE
; 2575 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2576 : 		_BidIt2 _Dest, false_type)
; 2577 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest
; 2578 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2579 : 		_Dest));
; 2580 : 	}
; 2581 : 
; 2582 : template<class _BidIt1,
; 2583 : 	class _BidIt2> inline
; 2584 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2585 : 		_BidIt2 _Dest)
; 2586 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2587 : 	_DEBUG_RANGE(_First, _Last);
; 2588 : 	_DEBUG_POINTER(_Dest);
; 2589 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2590 : 		_Dest, _Is_checked(_Dest)));
; 2591 : 	}
; 2592 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2593 : 
; 2594 : 		// TEMPLATE FUNCTION fill
; 2595 : template<class _FwdIt,
; 2596 : 	class _Ty> inline
; 2597 : 	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2598 : 	{	// copy _Val through [_First, _Last)
; 2599 : 	for (; _First != _Last; ++_First)
; 2600 : 		*_First = _Val;
; 2601 : 	}
; 2602 : 
; 2603 : inline void _Fill(char *_First, char *_Last, char _Val)
; 2604 : 	{	// copy char _Val through [_First, _Last)
; 2605 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2606 : 	}
; 2607 : 
; 2608 : inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
; 2609 : 	{	// copy signed char _Val through [_First, _Last)
; 2610 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2611 : 	}
; 2612 : 
; 2613 : inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
; 2614 : 	{	// copy unsigned char _Val through [_First, _Last)
; 2615 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2616 : 	}
; 2617 : 
; 2618 : template<class _FwdIt,
; 2619 : 	class _Ty> inline
; 2620 : 	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2621 : 	{	// copy _Val through [_First, _Last)
; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}
; 2625 : 
; 2626 : 		// TEMPLATE FUNCTION fill_n
; 2627 : template<class _OutIt,
; 2628 : 	class _Diff,
; 2629 : 	class _Ty> inline
; 2630 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)
; 2633 : 		*_Dest = _Val;
; 2634 : 	return (_Dest);
; 2635 : 	}
; 2636 : 
; 2637 : inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
; 2638 : 	{	// copy char _Val _Count times through [_Dest, ...)
; 2639 : 	_CSTD memset(_Dest, _Val, _Count);
; 2640 : 	return (_Dest + _Count);
; 2641 : 	}
; 2642 : 
; 2643 : inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
; 2644 : 	signed char _Val)
; 2645 : 	{	// copy signed char _Val _Count times through [_Dest, ...)
; 2646 : 	_CSTD memset(_Dest, _Val, _Count);
; 2647 : 	return (_Dest + _Count);
; 2648 : 	}
; 2649 : 
; 2650 : inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
; 2651 : 	unsigned char _Val)
; 2652 : 	{	// copy unsigned char _Val _Count times through [_Dest, ...)
; 2653 : 	_CSTD memset(_Dest, _Val, _Count);
; 2654 : 	return (_Dest + _Count);
; 2655 : 	}
; 2656 : 
; 2657 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2658 : template<class _OutIt,
; 2659 : 	class _Diff,
; 2660 : 	class _Ty> inline
; 2661 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2662 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2663 : 	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
; 2664 : 	}
; 2665 : 
; 2666 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2667 : template<class _OutIt,
; 2668 : 	class _Diff,
; 2669 : 	class _Ty> inline
; 2670 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2671 : 		_Mutable_iterator_tag)
; 2672 : 	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator
; 2673 : 	return (_Fill_n(_Dest, _Count, _Val));
; 2674 : 	}
; 2675 : 
; 2676 : template<class _OutIt,
; 2677 : 	class _Diff,
; 2678 : 	class _Ty> inline
; 2679 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2680 : 		random_access_iterator_tag)
; 2681 : 	{	// copy _Val _Count times through [_Dest, ...), random-access iterator
; 2682 : 	_OutIt _Ans = _Dest + _Count;	// also checks range
; 2683 : 	_Fill_n(_Unchecked(_Dest), _Count, _Val);
; 2684 : 	return (_Ans);
; 2685 : 	}
; 2686 : 
; 2687 : template<class _OutIt,
; 2688 : 	class _Diff,
; 2689 : 	class _Ty> inline
; 2690 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2691 : 		true_type)
; 2692 : 	{	// copy _Val _Count times through [_Dest, ...), checked dest
; 2693 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2694 : 		_Iter_cat(_Dest)));
; 2695 : 	}
; 2696 : 
; 2697 : template<class _OutIt,
; 2698 : 	class _Diff,
; 2699 : 	class _Ty> inline
; 2700 : _SCL_INSECURE_DEPRECATE
; 2701 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2702 : 		false_type)
; 2703 : 	{	// copy _Val _Count times through [_Dest, ...), unchecked dest
; 2704 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2705 : 		_Iter_cat(_Dest)));
; 2706 : 	}
; 2707 : 
; 2708 : template<class _OutIt,
; 2709 : 	class _Diff,
; 2710 : 	class _Ty> inline
; 2711 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2712 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2713 : 	_DEBUG_POINTER(_Dest);
; 2714 : 	return (_Fill_n(_Dest, _Count, _Val,
; 2715 : 		_Is_checked(_Dest)));
; 2716 : 	}
; 2717 : 
; 2718 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2719 : template<class _OutTy,
; 2720 : 	size_t _OutSize,
; 2721 : 	class _Diff,
; 2722 : 	class _Ty> inline
; 2723 : 	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
; 2724 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2725 : 	return (_Unchecked(_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
; 2726 : 		_Count, _Val)));
; 2727 : 	}
; 2728 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2729 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2730 : 
; 2731 : 		// TEMPLATE FUNCTION equal
; 2732 : template<class _InIt1,
; 2733 : 	class _InIt2> inline
; 2734 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
; 2735 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2736 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2737 : 		if (!(*_First1 == *_First2))
; 2738 : 			return (false);
; 2739 : 	return (true);
; 2740 : 	}
; 2741 : 
; 2742 : inline bool _Equal(const char *_First1, const char *_Last1,
; 2743 : 	const char *_First2)
; 2744 : 	{	// compare [_First1, _Last1) to [_First2, ...), for chars
; 2745 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2746 : 	}
; 2747 : 
; 2748 : inline bool _Equal(const signed char *_First1, const signed char *_Last1,
; 2749 : 	const signed char *_First2)
; 2750 : 	{	// compare [_First1, _Last1) to [_First2, ...), for signed chars
; 2751 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2752 : 	}
; 2753 : 
; 2754 : inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
; 2755 : 	const unsigned char *_First2)
; 2756 : 	{	// compare [_First1, _Last1) to [_First2, ...), for unsigned chars
; 2757 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2758 : 	}
; 2759 : 
; 2760 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2761 : template<class _InIt1,
; 2762 : 	class _InIt2> inline
; 2763 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2764 : 		_InIt2 _First2)
; 2765 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2766 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2767 : 		_Unchecked(_First2)));
; 2768 : 	}
; 2769 : 
; 2770 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2771 : template<class _InIt1,
; 2772 : 	class _InIt2> inline
; 2773 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2774 : 		_InIt2 _First2, true_type)
; 2775 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked dest
; 2776 : 	return (_Equal(_First1, _Last1,
; 2777 : 		_First2));
; 2778 : 	}
; 2779 : 
; 2780 : template<class _InIt1,
; 2781 : 	class _InIt2> inline
; 2782 : _SCL_INSECURE_DEPRECATE
; 2783 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2784 : 		_InIt2 _First2, false_type)
; 2785 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked dest
; 2786 : 	return (_Equal(_First1, _Last1,
; 2787 : 		_First2));
; 2788 : 	}
; 2789 : 
; 2790 : template<class _InIt1,
; 2791 : 	class _InIt2> inline
; 2792 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2793 : 		_InIt2 _First2)
; 2794 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2795 : 	_DEBUG_RANGE(_First1, _Last1);
; 2796 : 	_DEBUG_POINTER(_First2);
; 2797 : 	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),
; 2798 : 		_First2, _Is_checked(_First2)));
; 2799 : 	}
; 2800 : 
; 2801 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2802 : template<class _InIt1,
; 2803 : 	class _InTy,
; 2804 : 	size_t _InSize> inline
; 2805 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InTy (&_First2)[_InSize])
; 2807 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2808 : 	return (_STD equal(_First1, _Last1,
; 2809 : 		_Array_iterator<_InTy, _InSize>(_First2)));
; 2810 : 	}
; 2811 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2812 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2813 : 
; 2814 : 		// TEMPLATE FUNCTION equal WITH PRED
; 2815 : template<class _InIt1,
; 2816 : 	class _InIt2,
; 2817 : 	class _Pr> inline
; 2818 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
; 2819 : 		_InIt2 _First2, _Pr _Pred)
; 2820 : 	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
; 2821 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2822 : 		if (!_Pred(*_First1, *_First2))
; 2823 : 			return (false);
; 2824 : 	return (true);
; 2825 : 	}
; 2826 : 
; 2827 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2828 : template<class _InIt1,
; 2829 : 	class _InIt2,
; 2830 : 	class _Pr> inline
; 2831 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2832 : 		_InIt2 _First2, _Pr _Pred)
; 2833 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2834 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2835 : 		_Unchecked(_First2), _Pred));
; 2836 : 	}
; 2837 : 
; 2838 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2839 : template<class _InIt1,
; 2840 : 	class _InIt2,
; 2841 : 	class _Pr> inline
; 2842 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2843 : 		_InIt2 _First2, _Pr _Pred, true_type)
; 2844 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked input
; 2845 : 	return (_Equal(_First1, _Last1,
; 2846 : 		_First2, _Pred));
; 2847 : 	}
; 2848 : 
; 2849 : template<class _InIt1,
; 2850 : 	class _InIt2,
; 2851 : 	class _Pr> inline
; 2852 : _SCL_INSECURE_DEPRECATE
; 2853 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2854 : 		_InIt2 _First2, _Pr _Pred, false_type)
; 2855 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked input
; 2856 : 	return (_Equal(_First1, _Last1,
; 2857 : 		_First2, _Pred));
; 2858 : 	}
; 2859 : 
; 2860 : template<class _InIt1,
; 2861 : 	class _InIt2,
; 2862 : 	class _Pr> inline
; 2863 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2864 : 		_InIt2 _First2, _Pr _Pred)
; 2865 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2866 : 	_DEBUG_RANGE(_First1, _Last1);
; 2867 : 	_DEBUG_POINTER(_First2);
; 2868 : 	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
; 2869 : 		_First2, _Pred, _Is_checked(_First2)));
; 2870 : 	}
; 2871 : 
; 2872 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2873 : template<class _InIt1,
; 2874 : 	class _InTy,
; 2875 : 	size_t _InSize,
; 2876 : 	class _Pr> inline
; 2877 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2878 : 		_InTy (&_First2)[_InSize], _Pr _Pred)
; 2879 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2880 : 	return (_STD equal(_First1, _Last1,
; 2881 : 		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
; 2882 : 	}
; 2883 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2884 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2885 : 
; 2886 : 		// TEMPLATE FUNCTION lexicographical_compare
; 2887 : template<class _InIt1,
; 2888 : 	class _InIt2> inline
; 2889 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2890 : 		_InIt2 _First2, _InIt2 _Last2)
; 2891 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2892 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2893 : 		if (_DEBUG_LT(*_First1, *_First2))
; 2894 : 			return (true);
; 2895 : 		else if (*_First2 < *_First1)
; 2896 : 			return (false);
; 2897 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2898 : 	}
; 2899 : 
; 2900 : inline bool _Lexicographical_compare(
; 2901 : 	const unsigned char *_First1, const unsigned char *_Last1,
; 2902 : 	const unsigned char *_First2, const unsigned char *_Last2)
; 2903 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for unsigned char
; 2904 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2905 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2906 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2907 : 	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
; 2908 : 	}
; 2909 : 
; 2910 :  #if CHAR_MAX == UCHAR_MAX
; 2911 : inline bool _Lexicographical_compare(
; 2912 : 	const char *_First1, const char *_Last1,
; 2913 : 	const char *_First2, const char *_Last2)
; 2914 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for nonnegative char
; 2915 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2916 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2917 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2918 : 	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
; 2919 : 	}
; 2920 :  #endif /* CHAR_MAX == UCHAR_MAX */
; 2921 : 
; 2922 : template<class _InIt1,
; 2923 : 	class _InIt2> inline
; 2924 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2925 : 		_InIt2 _First2, _InIt2 _Last2)
; 2926 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2927 : 	_DEBUG_RANGE(_First1, _Last1);
; 2928 : 	_DEBUG_RANGE(_First2, _Last2);
; 2929 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2930 : 		_Unchecked(_First2), _Unchecked(_Last2)));
; 2931 : 	}
; 2932 : 
; 2933 : 		// TEMPLATE FUNCTION lexicographical_compare WITH PRED
; 2934 : template<class _InIt1,
; 2935 : 	class _InIt2,
; 2936 : 	class _Pr> inline
; 2937 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2938 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2939 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2940 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2941 : 		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
; 2942 : 			return (true);
; 2943 : 		else if (_Pred(*_First2, *_First1))
; 2944 : 			return (false);
; 2945 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2946 : 	}
; 2947 : 
; 2948 : template<class _InIt1,
; 2949 : 	class _InIt2,
; 2950 : 	class _Pr> inline
; 2951 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2952 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2953 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2954 : 	_DEBUG_RANGE(_First1, _Last1);
; 2955 : 	_DEBUG_RANGE(_First2, _Last2);
; 2956 : 	_DEBUG_POINTER(_Pred);
; 2957 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2958 : 		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
; 2959 : 	}
; 2960 : 
; 2961 : 		// TEMPLATE FUNCTION find
; 2962 : template<class _Ty,
; 2963 : 	class _Ignored> inline
; 2964 : 	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
; 2965 : 	{	// signed _Elem, signed _Ty
; 2966 : 	return (SCHAR_MIN <= _Val && _Val <= SCHAR_MAX);
; 2967 : 	}
; 2968 : 
; 2969 : template<class _Ty> inline
; 2970 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
; 2971 : 	{	// signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
; 2972 : 	return (_Val <= SCHAR_MAX || static_cast<_Ty>(SCHAR_MIN) <= _Val);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _Ty> inline
; 2976 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
; 2977 : 	{	// signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
; 2978 : 	return (_Val <= SCHAR_MAX);
; 2979 : 	}
; 2980 : 
; 2981 : template<class _Ty,
; 2982 : 	class _Ignored> inline
; 2983 : 	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
; 2984 : 	{	// unsigned _Elem, signed _Ty
; 2985 : 	return (0 <= _Val && _Val <= UCHAR_MAX);
; 2986 : 	}
; 2987 : 
; 2988 : template<class _Ty,
; 2989 : 	class _Ignored> inline
; 2990 : 	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
; 2991 : 	{	// unsigned _Elem, unsigned _Ty
; 2992 : 	return (_Val <= UCHAR_MAX);
; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))
; 3015 : 		return (_Last);
; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));
; 3018 : 	return (_First ? _First : _Last);
; 3019 : 	}
; 3020 : 
; 3021 : template<class _InIt,
; 3022 : 	class _Ty> inline
; 3023 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
; 3024 : 	{	// find first matching _Val
; 3025 : 	for (; _First != _Last; ++_First)

	add	rbx, 8
	cmp	rbx, rdx
	jne	SHORT $LL89@clean
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	jmp	SHORT $LN221@clean
$LN211@clean:
	cmp	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 1744 : 	if (_First == _Last)

	je	SHORT $LN221@clean
	xor	ecx, ecx

; 1733 : 	for (++_First; _First != _Last; ++_First)

	lea	rax, QWORD PTR [rbx+8]
	mov	r9, rdx
	sub	r9, rax
	add	r9, 7
	shr	r9, 3
	cmp	rax, rdx
	cmova	r9, rcx
	test	r9, r9
	je	SHORT $LN221@clean
$LL111@clean:

; 1734 : 		if (!(*_First == _Val))

	mov	r8, QWORD PTR [rax]
	test	r8, r8
	je	SHORT $LN110@clean

; 1735 : 			*_Next++ = _Move(*_First);

	mov	QWORD PTR [rbx], r8
	add	rbx, 8
$LN110@clean:

; 1733 : 	for (++_First; _First != _Last; ++_First)

	inc	rcx
	add	rax, 8
	cmp	rcx, r9
	jne	SHORT $LL111@clean
$LN221@clean:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rax, QWORD PTR [rsi+8]
	cmp	rbx, rax

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())

	jne	SHORT $LN123@clean

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rdx, QWORD PTR [rsi+16]

; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())

	je	SHORT $LN222@clean
$LN123@clean:

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rdx

; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)

	je	SHORT $LN120@clean
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	mov	rax, QWORD PTR [rsi+16]

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

	mov	rcx, rbx
	sub	rax, rdx
	sar	rax, 3
	lea	rdi, QWORD PTR [rax*8]
	mov	r8, rdi
	call	QWORD PTR __imp_memmove

; 2432 : 	return (_Dest + _Count);

	lea	rax, QWORD PTR [rdi+rbx]
$LN222@clean:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1488 : 				this->_Mylast = _Ptr;

	mov	QWORD PTR [rsi+16], rax
$LN120@clean:

; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);
; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rax, QWORD PTR [rsi+16]
	cmp	QWORD PTR [rsi+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 65   : 	if (container.empty())	container.clear	();

	jne	SHORT $LN202@clean
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rsi+8]
	mov	QWORD PTR [rsi+16], rax
$LN202@clean:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rsi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 67   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
?clean@smem_container@@QEAAXXZ ENDP			; smem_container::clean
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
_TEXT	SEGMENT
this$ = 48
?stat_economy@smem_container@@QEAAIXZ PROC		; smem_container::stat_economy

; 82   : {

$LN51:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rdx, QWORD PTR [rdi+8]
	mov	r10, QWORD PTR [rdi+16]
	sub	r10, rdx
	xor	r8d, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 88   : 	counter			-= sizeof(cdb::allocator_type);

	mov	rbx, -33				; ffffffffffffffdfH
	add	r10, 7
	shr	r10, 3
	cmp	rdx, QWORD PTR [rdi+16]
	cmova	r10, r8

; 89   : 	const int		node_size = 20;
; 90   : 	for (; it!=end; it++)	{

	test	r10, r10
	je	SHORT $LN1@stat_econo
$LL28@stat_econo:

; 93   : 		counter		+= s64((s64((*it)->dwReference) - 1)*s64((*it)->dwLength));

	mov	rcx, QWORD PTR [rdx]
	add	rbx, -36				; ffffffffffffffdcH
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	inc	r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 93   : 		counter		+= s64((s64((*it)->dwReference) - 1)*s64((*it)->dwLength));

	mov	r9d, DWORD PTR [rcx]
	mov	ecx, DWORD PTR [rcx+8]
	lea	rdx, QWORD PTR [rdx+8]
	dec	r9
	imul	r9, rcx
	add	rbx, r9
	cmp	r8, r10
	jne	SHORT $LL28@stat_econo
$LN1@stat_econo:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rdi]
	call	QWORD PTR __imp_LeaveCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 97   : 	return			u32(s64(counter)/s64(1024));

	mov	rax, rbx

; 98   : }

	mov	rbx, QWORD PTR [rsp+48]
	cdq
	and	edx, 1023				; 000003ffH
	add	rax, rdx
	sar	rax, 10
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?stat_economy@smem_container@@QEAAIXZ ENDP		; smem_container::stat_economy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
_TEXT	SEGMENT
$T1 = 48
result$ = 112
this$ = 112
dwCRC$ = 120
dwLength$ = 128
ptr$ = 136
?dock@smem_container@@QEAAPEAUsmem_value@@IIPEAX@Z PROC	; smem_container::dock

; 9    : {

$LN137:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	r13, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 9    : {

	mov	r12, r9
	mov	edi, r8d
	mov	esi, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_EnterCriticalSection
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rbp, QWORD PTR [r13+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	r15, QWORD PTR [r13+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	r10, rbp
	sub	r10, r15
	sar	r10, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r10, r10
	jle	SHORT $LN47@dock
	npad	9
$LL48@dock:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r10
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	rdx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	r8, QWORD PTR [r15+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	mov	rcx, QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.h

; 27   : 	if (A->dwCRC < B->dwCRC)			return		true;

	mov	eax, DWORD PTR [rcx+4]
	cmp	eax, esi
	jb	SHORT $LN134@dock

; 28   : 	if (A->dwCRC > B->dwCRC)			return		false;

	ja	SHORT $LN46@dock

; 29   : 	return	A->dwLength < B->dwLength;

	cmp	DWORD PTR [rcx+8], edi
	setb	cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	test	cl, cl
	jne	SHORT $LN134@dock
$LN46@dock:

; 2519 : 			}
; 2520 : 		else
; 2521 : 			_Count = _Count2;

	mov	r10, rdx
	jmp	SHORT $LN45@dock
$LN134@dock:

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	r15, QWORD PTR [r8+8]
	sub	rax, rdx
	add	r10, rax
$LN45@dock:

; 2508 : 	while (0 < _Count)

	test	r10, r10
	jg	SHORT $LL48@dock
$LN47@dock:

; 2535 : 			_Dist_type(_First))));

	mov	rbx, r15
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbp, r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 23   : 	if (container.end() != it)	{

	je	SHORT $LN135@dock
$LL89@dock:

; 27   : 			if ((*it)->dwCRC	!= dwCRC)		break;

	mov	rcx, QWORD PTR [rbx]
	cmp	DWORD PTR [rcx+4], esi
	jne	SHORT $LN135@dock

; 28   : 			if ((*it)->dwLength != dwLength)	break;

	cmp	DWORD PTR [rcx+8], edi
	jne	SHORT $LN135@dock

; 29   : 			if (0==memcmp((*it)->value,ptr,dwLength))

	mov	r8, rdi
	add	rcx, 16
	mov	rdx, r12
	call	memcmp
	test	eax, eax
	je	SHORT $LN128@dock
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rbx, 8

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 26   : 			if (it==container.end())			break;

	jne	SHORT $LL89@dock
	jmp	SHORT $LN135@dock
$LN128@dock:

; 30   : 			{
; 31   : 				// really found
; 32   : 				result			= *it;

	mov	r14, QWORD PTR [rbx]

; 33   : 				break;
; 34   : 			}
; 35   : 		}
; 36   : 	}
; 37   : 
; 38   : 	// if not found - create new entry
; 39   : 	if (0==result)

	test	r14, r14
	jne	SHORT $LN119@dock
$LN135@dock:

; 40   : 	{
; 41   : 		result					= (smem_value*)	Memory.mem_alloc	(4*sizeof(u32) + dwLength
; 42   : #ifdef DEBUG_MEMORY_NAME
; 43   : 			, "storage: smem"
; 44   : #endif // DEBUG_MEMORY_NAME
; 45   : 			);

	lea	rdx, QWORD PTR [rdi+16]
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 46   : 		result->dwReference		= 0;
; 47   : 		result->dwCRC			= dwCRC;
; 48   : 		result->dwLength		= dwLength;
; 49   : 		CopyMemory			(result->value,ptr,dwLength);

	mov	r8, rdi
	mov	rdx, r12
	mov	DWORD PTR [rax], 0
	mov	DWORD PTR [rax+4], esi
	lea	rcx, QWORD PTR [rax+16]
	mov	r14, rax
	mov	QWORD PTR result$[rsp], rax
	mov	DWORD PTR [rax+8], edi
	call	memcpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	lea	rax, QWORD PTR result$[rsp]
	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR [r13+8]
	mov	r8, r15
	mov	QWORD PTR [rsp+32], rax
	call	?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n
$LN119@dock:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [r13]
	call	QWORD PTR __imp_LeaveCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 56   : }

	lea	r11, QWORD PTR [rsp+64]
	mov	rax, r14
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsi, QWORD PTR [r11+72]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?dock@smem_container@@QEAAPEAUsmem_value@@IIPEAX@Z ENDP	; smem_container::dock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp
_TEXT	SEGMENT
this$ = 80
?dump@smem_container@@QEAAXXZ PROC			; smem_container::dump

; 70   : {

$LN55:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 48					; 00000030H
	mov	r15, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rcx]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rdi, QWORD PTR [r15+8]

; 47   : 		{	// construct with pointer _Parg

	mov	rbx, QWORD PTR [r15+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 74   : 	FILE* F			= fopen("x:\\$smem_dump$.txt","w");

	lea	rdx, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
	lea	rcx, OFFSET FLAT:??_C@_0BD@JJAGEJAN@x?3?2$smem_dump$?4txt?$AA@
	call	QWORD PTR __imp_fopen
	xor	esi, esi
	mov	rbp, rbx
	sub	rbp, rdi
	mov	r14, rax
	add	rbp, 7
	shr	rbp, 3
	cmp	rdi, rbx
	cmova	rbp, rsi

; 75   : 	for (; it!=end; it++)

	test	rbp, rbp
	je	SHORT $LN1@dump
	npad	1
$LL28@dump:

; 76   : 		fprintf		(F,"%4d : crc[%6x], %d bytes\n",(*it)->dwReference,(*it)->dwCRC,(*it)->dwLength);

	mov	rcx, QWORD PTR [rdi]
	lea	rdx, OFFSET FLAT:??_C@_0BK@KPOBLFJH@?$CF4d?5?3?5crc?$FL?$CF6x?$FN?0?5?$CFd?5bytes?6?$AA@
	mov	eax, DWORD PTR [rcx+8]
	mov	r9d, DWORD PTR [rcx+4]
	mov	r8d, DWORD PTR [rcx]
	mov	rcx, r14
	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR __imp_fprintf
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	inc	rsi
	lea	rdi, QWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 75   : 	for (; it!=end; it++)

	cmp	rsi, rbp
	jne	SHORT $LL28@dump
$LN1@dump:

; 77   : 	fclose			(F);

	mov	rcx, r14
	call	QWORD PTR __imp_fclose
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [r15]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.cpp

; 79   : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+88]
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	r15
	pop	r14
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
?dump@smem_container@@QEAAXXZ ENDP			; smem_container::dump
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear@?$xr_vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$xr_vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@@QEAAXXZ PROC ; xr_vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::clear, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 132  : 	void	clear				()									{ clear_and_free	();			}

	ret	0
?clear@?$xr_vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@@QEAAXXZ ENDP ; xr_vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@XZ PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@XZ ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@XZ PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@XZ ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?insert@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@AEBQEAUsmem_value@@@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Where$ = 80
_Val$ = 88
?insert@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@AEBQEAUsmem_value@@@Z PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::insert, COMDAT

; 1327 : 		{	// insert _Val at _Where

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	mov	QWORD PTR [rsp+32], r9
	call	?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n
	mov	rax, rbx

; 1329 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?insert@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@AEBQEAUsmem_value@@@Z ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?erase@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_First_arg$ = 64
_Last_arg$ = 72
?erase@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@0@Z PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::erase, COMDAT

; 1463 : 		{	// erase [_First, _Last)

$LN79:
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	QWORD PTR [rsp+24], r8
	push	r14
	sub	rsp, 32					; 00000020H

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rax, QWORD PTR [rcx]

; 1463 : 		{	// erase [_First, _Last)

	mov	rdi, r8
	mov	rsi, rdx
	mov	r14, rcx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r8, rax

; 1464 : 		if (_First_arg == begin() && _Last_arg == end())

	jne	SHORT $LN4@erase

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r9, QWORD PTR [rcx+8]

; 1464 : 		if (_First_arg == begin() && _Last_arg == end())

	jne	SHORT $LN4@erase

; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	QWORD PTR [rcx+8], rax
$LN77@erase:

; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));

	mov	rax, rdx

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rdx], r8

; 1492 : 		}

	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN4@erase:

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r8, r9

; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)

	je	SHORT $LN77@erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+48], rbx

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

	mov	rdx, r9
	sub	rax, r9
	mov	rcx, rdi
	sar	rax, 3
	lea	rbx, QWORD PTR [rax*8]
	mov	r8, rbx
	call	QWORD PTR __imp_memmove

; 2432 : 	return (_Dest + _Count);

	lea	rax, QWORD PTR [rbx+rdi]
	mov	rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1492 : 		}

	mov	rdi, QWORD PTR [rsp+72]
	mov	QWORD PTR [r14+8], rax

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR _First_arg$[rsp]
	mov	QWORD PTR [rsi], rax

; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));

	mov	rax, rsi

; 1492 : 		}

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?erase@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@0@Z ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 206  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

	setne	al

; 211  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAAEAPEAUsmem_value@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAAEAPEAUsmem_value@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAAEAPEAUsmem_value@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++, COMDAT

; 340  : 		_Myiter _Tmp = *this;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 112  : 		++this->_Ptr;

	add	rax, 8
	mov	QWORD PTR [rcx], rax

; 341  : 		++*this;
; 342  : 		return (_Tmp);

	mov	rax, rdx

; 343  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?clear_and_free@?$xr_vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear_and_free@?$xr_vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@@QEAAXXZ PROC ; xr_vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::clear_and_free, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1510 : 		this->_Mylast = this->_Myfirst;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 127  : 	void	clear_and_free		()									{ inherited::clear();			}

	ret	0
?clear_and_free@?$xr_vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@@QEAAXXZ ENDP ; xr_vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::clear_and_free
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@@Z PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Make_iter, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rdx], r8

; 1045 : 		return (iterator(_Where._Ptr, this));

	mov	rax, rdx

; 1046 : 		}

	ret	0
?_Make_iter@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@@Z ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z
_TEXT	SEGMENT
_Ncopied$1 = 48
$T2 = 56
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$dead$ = 136
p$ = 136
p$ = 136
_Tmp$3 = 136
_Newvec$4 = 136
_Val$ = 144
?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n, COMDAT

; 1653 : 		{	// insert _Count * _Val at _Where

$LN248:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+120], rsi
	mov	rax, r8
	mov	r13, rdx
	mov	rdi, rcx

; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;

	mov	r9, QWORD PTR [rcx]
	mov	r12, r8
	sub	r12, r9
	sar	r12, 3

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rbx, QWORD PTR [rcx+16]
	mov	rsi, QWORD PTR [rcx+8]
	mov	r8, rbx
	sub	r8, rsi
	sar	r8, 3

; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)

	cmp	r8, 1
	jae	$LN10@Insert_n

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	rsi, r9
	sar	rsi, 3

; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	mov	rax, rcx
	sub	rax, rsi
	cmp	rax, 1
	jae	SHORT $LN9@Insert_n

; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN9@Insert_n:

; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);

	inc	rsi

; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rbx, r9
	sar	rbx, 3

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rbx
	shr	rax, 1
	sub	rcx, rax
	cmp	rcx, rbx
	jae	SHORT $LN47@Insert_n
	xor	ebx, ebx
	jmp	SHORT $LN48@Insert_n
$LN47@Insert_n:
	add	rbx, rax
$LN48@Insert_n:

; 1576 : 		if (_Capacity < _Count)

	cmp	rbx, rsi
	cmovb	rbx, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ebx
	shl	rdx, 3
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	r14, rax
	mov	QWORD PTR _Newvec$4[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

	mov	r15, QWORD PTR _Where$[rsp]
	sub	r15, QWORD PTR [rdi]
	sar	r15, 3

; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff

	lea	rcx, QWORD PTR [rax+r15*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	mov	r8, QWORD PTR _Val$[rsp]
	mov	esi, 1
	mov	edx, esi
	call	??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1677 : 			++_Ncopied;

	mov	DWORD PTR _Ncopied$1[rsp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r14
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1680 : 			++_Ncopied;

	mov	DWORD PTR _Ncopied$1[rsp], 2

; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix

	lea	r8, QWORD PTR [r15+1]
	lea	r8, QWORD PTR [r14+r8*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR _Where$[rsp]
	call	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rdi]
	mov	rsi, QWORD PTR [rdi+8]
	sub	rsi, rax
	sar	rsi, 3

; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();

	inc	rsi

; 1693 : 			if (this->_Myfirst != pointer())

	test	rax, rax
	je	SHORT $LN135@Insert_n
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rsp]
	call	??$xr_free@PEAUsmem_value@@@@YAXAEAPEAPEAUsmem_value@@@Z ; xr_free<smem_value * __ptr64>
$LN135@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1701 : 			this->_Myend = _Newvec + _Capacity;

	lea	rax, QWORD PTR [r14+rbx*8]
	mov	QWORD PTR [rdi+16], rax

; 1702 : 			this->_Mylast = _Newvec + _Count;

	lea	rax, QWORD PTR [r14+rsi*8]
	mov	QWORD PTR [rdi+8], rax

; 1703 : 			this->_Myfirst = _Newvec;

	mov	QWORD PTR [rdi], r14

; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))

	jmp	$LN218@Insert_n
$LN10@Insert_n:

; 1706 : 			< _Count)

	mov	rcx, rsi
	sub	rcx, rax
	sar	rcx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rdx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1706 : 			< _Count)

	cmp	rcx, 1
	jae	$LN3@Insert_n

; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence

	mov	rcx, QWORD PTR _Val$[rsp]
	mov	r14, QWORD PTR [rcx]
	mov	QWORD PTR _Tmp$3[rsp], r14

; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix

	lea	r8, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rcx, rax
	call	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end

	mov	rcx, QWORD PTR [rdi+8]
	mov	rax, rcx
	sub	rax, QWORD PTR _Where$[rsp]
	sar	rax, 3
	mov	esi, 1
	sub	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	lea	r8, QWORD PTR _Tmp$3[rsp]
	mov	rdx, rsi
	call	??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
	npad	1
	add	QWORD PTR [rdi+8], 8
	mov	rax, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1726 : 				_Tmp);	// insert up to old end

	add	rax, -8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

	mov	rcx, QWORD PTR _Where$[rsp]
	xor	ebx, ebx
	mov	rdx, rax
	sub	rdx, rcx
	add	rdx, 7
	shr	rdx, 3
	cmp	rcx, rax
	cmova	rdx, rbx

; 2599 : 	for (; _First != _Last; ++_First)

	test	rdx, rdx
	je	$LN218@Insert_n
	npad	11
$LL241@Insert_n:

; 2600 : 		*_First = _Val;

	mov	QWORD PTR [rcx], r14
	lea	rcx, QWORD PTR [rcx+8]

; 2599 : 	for (; _First != _Last; ++_First)

	inc	rbx
	cmp	rbx, rdx
	jne	SHORT $LL241@Insert_n
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1728 : 		else

	jmp	SHORT $LN218@Insert_n
$LN3@Insert_n:

; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence

	mov	rax, QWORD PTR _Val$[rsp]
	mov	r14, QWORD PTR [rax]

; 1734 : 				this->_Mylast);	// copy suffix

	lea	rbx, QWORD PTR [rsi-8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, rsi
	mov	rcx, rbx
	call	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1734 : 				this->_Mylast);	// copy suffix

	mov	QWORD PTR [rdi+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	mov	rdx, QWORD PTR _Where$[rsp]
	sub	rbx, rdx
	sar	rbx, 3

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rbx*8]
	sub	rsi, r8
	mov	rcx, rsi
	call	QWORD PTR __imp_memmove

; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

	mov	rcx, QWORD PTR _Where$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

	lea	rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rax
	je	SHORT $LN218@Insert_n
	npad	13
$LL220@Insert_n:

; 2600 : 		*_First = _Val;

	mov	QWORD PTR [rcx], r14

; 2599 : 	for (; _First != _Last; ++_First)

	add	rcx, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rax
	jne	SHORT $LL220@Insert_n
$LN218@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rdi]
	lea	rcx, QWORD PTR [rax+r12*8]

; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	QWORD PTR [r13], rcx

; 1741 : 			}
; 1742 : 		return (begin() + _Off);

	mov	rax, r13

; 1743 : 		}

	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN247@Insert_n:
?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
_Ncopied$1 = 48
$T2 = 56
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$dead$ = 136
p$ = 136
p$ = 136
_Tmp$3 = 136
_Newvec$4 = 136
_Val$ = 144
?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA PROC ; `std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n'::`1'::catch$0

; 1683 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR _Newvec$4[rbp]
	mov	QWORD PTR p$[rbp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rbp]
	call	??$xr_free@PEAUsmem_value@@@@YAXAEAPEAPEAUsmem_value@@@Z ; xr_free<smem_value * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1689 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA ENDP ; `std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ncopied$1 = 48
$T2 = 56
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$dead$ = 136
p$ = 136
p$ = 136
_Tmp$3 = 136
_Newvec$4 = 136
_Val$ = 144
?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA PROC ; `std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n'::`1'::catch$1

; 1717 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z$2:

; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$1@?0??_Insert_n@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@2@_KAEBQEAUsmem_value@@@Z@4HA ENDP ; `std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Insert_n'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAAEBQEAUsmem_value@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAAEBQEAUsmem_value@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAAEBQEAUsmem_value@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Compat, COMDAT

; 255  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAA@PEAPEAUsmem_value@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAA@PEAPEAUsmem_value@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAA@PEAPEAUsmem_value@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++, COMDAT

; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 8

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

	mov	rax, rcx

; 336  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEBA_KXZ PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 3

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@QEBA_KXZ ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEBA_K_K@Z PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r8, QWORD PTR [rcx]
	sar	r8, 3

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to
	xor	r8d, r8d

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU3@_KPEBQEAU3@@Z
_TEXT	SEGMENT
this$dead$ = 64
_Ptr$ = 72
_Count$ = 80
_Pval$ = 88
?_Ufill@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU3@_KPEBQEAU3@@Z PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Ufill, COMDAT

; 1746 : 		{	// copy initializing _Count * _Val, using allocator

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, r8
	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	mov	r8, r9
	mov	rdx, rdi
	mov	rcx, rbx
	call	??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1749 : 		return (_Ptr + _Count);

	lea	rax, QWORD PTR [rbx+rdi*8]

; 1750 : 		}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_Ufill@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU3@_KPEBQEAU3@@Z ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEBAXPEAPEAUsmem_value@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEBAXPEAPEAUsmem_value@@0@Z PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEBAXPEAPEAUsmem_value@@0@Z ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++, COMDAT

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 8

; 113  : 		return (*this);

	mov	rax, rcx

; 114  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax+r8*8]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx

; 368  : 		}

	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 171  : 		return (*this);

	mov	rax, rcx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Val$ = 88
_Pred$dead$ = 96
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z PROC ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64,bool (__cdecl*)(smem_value const * __ptr64,smem_value const * __ptr64)>, COMDAT

; 2531 : 	{	// find first element not before _Val, using _Pred

$LN41:
	mov	QWORD PTR [rsp+24], rbx
	push	rbp
	push	rsi
	push	r15
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
	mov	rbp, r9
	mov	rsi, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2531 : 	{	// find first element not before _Val, using _Pred

	mov	r15, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sar	rbx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jle	SHORT $LN38@lower_boun
	mov	QWORD PTR [rsp+64], rdi
	mov	QWORD PTR [rsp+72], r14
	npad	1
$LL16@lower_boun:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, rbx
	cdq
	sub	rax, rdx

; 2514 : 		if (_Pred(*_Mid, _Val))

	mov	rdx, QWORD PTR [rbp]
	sar	rax, 1
	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	r14, QWORD PTR [rsi+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	mov	rcx, QWORD PTR [r14]
	call	?smem_search@@YA_NPEBUsmem_value@@0@Z	; smem_search
	test	al, al
	je	SHORT $LN14@lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rcx, -1
	lea	rsi, QWORD PTR [r14+8]
	sub	rcx, rdi
	add	rbx, rcx

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN13@lower_boun
$LN14@lower_boun:

; 2521 : 			_Count = _Count2;

	mov	rbx, rdi
$LN13@lower_boun:

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jg	SHORT $LL16@lower_boun

; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));

	mov	r14, QWORD PTR [rsp+72]
	mov	rdi, QWORD PTR [rsp+64]
	mov	QWORD PTR [r15], rsi
	mov	rax, r15

; 2536 : 	}

	mov	rbx, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rsi
	pop	rbp
	ret	0
$LN38@lower_boun:
	mov	rbx, QWORD PTR [rsp+80]
	mov	QWORD PTR [rcx], rdx
	mov	rax, r15
	add	rsp, 32					; 00000020H
	pop	r15
	pop	rsi
	pop	rbp
	ret	0
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@P6A_NPEBU3@0@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@P6A_NPEBU2@2@Z@Z ENDP ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64,bool (__cdecl*)(smem_value const * __ptr64,smem_value const * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z PROC	; xr_free<smem_value>, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN30:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rdi, rdi
	je	SHORT $LN1@xr_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN6@xr_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN27@xr_free

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	QWORD PTR [rsi], 0
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@xr_free:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
$LN27@xr_free:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	QWORD PTR [rsi], 0
$LN1@xr_free:
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$xr_free@Usmem_value@@@@YAXAEAPEAUsmem_value@@@Z ENDP	; xr_free<smem_value>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_First$ = 16
_Last$ = 24
_Val$ = 32
??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@@Z PROC ; std::remove<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64>, COMDAT

; 1742 : 	{	// remove each matching _Val

	mov	QWORD PTR [rsp+16], rdx
	mov	r10, r9
	mov	r11, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN53@remove

; 3026 : 		if (*_First == _Val)

	mov	rax, QWORD PTR [r9]
$LL20@remove:
	cmp	QWORD PTR [rdx], rax
	je	SHORT $LN53@remove

; 3025 : 	for (; _First != _Last; ++_First)

	add	rdx, 8
	cmp	rdx, r8
	jne	SHORT $LL20@remove
$LN53@remove:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 1743 : 	_First = _STD find(_First, _Last, _Val);

	mov	QWORD PTR _First$[rsp], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rdx, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 1744 : 	if (_First == _Last)

	jne	SHORT $LN2@remove

; 1745 : 		return (_First);	// empty sequence, all done

	mov	QWORD PTR [rcx], rdx

; 1746 : 	else
; 1747 : 		return (_Rechecked(_First,
; 1748 : 			_Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));

	mov	rax, r11

; 1749 : 	}

	ret	0
$LN2@remove:
	xor	ecx, ecx

; 1733 : 	for (++_First; _First != _Last; ++_First)

	lea	rax, QWORD PTR [rdx+8]
	mov	r9, r8
	sub	r9, rax
	add	r9, 7
	shr	r9, 3
	cmp	rax, r8
	cmova	r9, rcx
	test	r9, r9
	je	SHORT $LN40@remove
$LL42@remove:

; 1734 : 		if (!(*_First == _Val))

	mov	r8, QWORD PTR [rax]
	cmp	r8, QWORD PTR [r10]
	je	SHORT $LN41@remove

; 1735 : 			*_Next++ = _Move(*_First);

	mov	QWORD PTR [rdx], r8
	add	rdx, 8
$LN41@remove:

; 1733 : 	for (++_First; _First != _Last; ++_First)

	inc	rcx
	add	rax, 8
	cmp	rcx, r9
	jne	SHORT $LL42@remove
$LN40@remove:

; 1746 : 	else
; 1747 : 		return (_Rechecked(_First,
; 1748 : 			_Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));

	mov	QWORD PTR [r11], rdx
	mov	rax, r11

; 1749 : 	}

	ret	0
??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@@Z ENDP ; std::remove<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z PROC ; std::_Move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	mov	rdi, r8

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	sar	rdx, 3

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rdi
	mov	r8, rbx
	call	QWORD PTR __imp_memmove

; 2432 : 	return (_Dest + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z ENDP ; std::_Move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QEAUsmem_value@@@std@@YAPEBQEAUsmem_value@@AEBQEAU1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@QEAUsmem_value@@@std@@YAPEBQEAUsmem_value@@AEBQEAU1@@Z PROC ; std::addressof<smem_value * __ptr64 const>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@QEAUsmem_value@@@std@@YAPEBQEAUsmem_value@@AEBQEAU1@@Z ENDP ; std::addressof<smem_value * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAPEAUsmem_value@@@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU2@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAPEAUsmem_value@@@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU2@00@Z PROC ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Umove<smem_value * __ptr64 * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAPEAUsmem_value@@@?$vector@PEAUsmem_value@@V?$xalloc@PEAUsmem_value@@@@@std@@IEAAPEAPEAUsmem_value@@PEAPEAU2@00@Z ENDP ; std::vector<smem_value * __ptr64,xalloc<smem_value * __ptr64> >::_Umove<smem_value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PEAUsmem_value@@@std@@YAPEAPEAUsmem_value@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAUsmem_value@@@std@@YAPEAPEAUsmem_value@@AEAPEAU1@@Z PROC ; std::addressof<smem_value * __ptr64>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@PEAUsmem_value@@@std@@YAPEAPEAUsmem_value@@AEAPEAU1@@Z ENDP ; std::addressof<smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$fill@PEAPEAUsmem_value@@PEAU1@@std@@YAXPEAPEAUsmem_value@@0AEBQEAU1@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$fill@PEAPEAUsmem_value@@PEAU1@@std@@YAXPEAPEAUsmem_value@@0AEBQEAU1@@Z PROC ; std::fill<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>, COMDAT

; 2621 : 	{	// copy _Val through [_First, _Last)

	xor	r9d, r9d
	mov	r10, rdx
	sub	r10, rcx
	add	r10, 7
	shr	r10, 3
	cmp	rcx, rdx
	cmova	r10, r9

; 2599 : 	for (; _First != _Last; ++_First)

	test	r10, r10
	je	SHORT $LN7@fill
	npad	3
$LL9@fill:

; 2600 : 		*_First = _Val;

	mov	rax, QWORD PTR [r8]
	inc	r9
	lea	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx-8], rax
	cmp	r9, r10
	jne	SHORT $LL9@fill
$LN7@fill:

; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}

	ret	0
??$fill@PEAPEAUsmem_value@@PEAU1@@std@@YAXPEAPEAUsmem_value@@0AEBQEAU1@@Z ENDP ; std::fill<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z PROC ; std::_Copy_backward<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>, COMDAT

; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx

; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

	mov	rbx, r8

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sar	rdx, 3

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rdx*8]
	mov	rdx, rcx
	sub	rbx, r8
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove

; 2366 : 	return (_Copy_backward(_First, _Last,
; 2367 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, rbx

; 2368 : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00@Z ENDP ; std::_Copy_backward<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PEAPEAUsmem_value@@_KPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
??$_Uninitialized_fill_n@PEAPEAUsmem_value@@_KPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z PROC ; std::_Uninitialized_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >, COMDAT

; 633  : 	{	// copy _Count * *_Pval to raw _First, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	call	??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>

; 634  : 	_Uninit_fill_n(_First, _Count, _Pval, _Al,
; 635  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 636  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_fill_n@PEAPEAUsmem_value@@_KPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z ENDP ; std::_Uninitialized_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@YAPEAPEAUsmem_value@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Iter$ = 8
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@YAPEAPEAUsmem_value@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >, COMDAT

; 396  : 	return (_Iter._Unchecked());

	mov	rax, rcx

; 397  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@YAPEAPEAUsmem_value@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > > >, COMDAT

; 706  : 	return (0);

	xor	eax, eax

; 707  : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
_Pred$dead$ = 40
__formal$dead$ = 48
??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z PROC ; std::_Lower_bound<smem_value * __ptr64 * __ptr64,smem_value * __ptr64,__int64,bool (__cdecl*)(smem_value const * __ptr64,smem_value const * __ptr64)>, COMDAT

; 2504 : 	{	// find first element not before _Val, using _Pred

$LN29:
	sub	rsp, 8
	mov	r9, rdx
	mov	r10, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	r9, rcx
	sar	r9, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jle	SHORT $LN27@Lower_boun

; 2514 : 		if (_Pred(*_Mid, _Val))

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp], rdi
	mov	rdi, QWORD PTR [r8]
	mov	ebx, DWORD PTR [rdi+4]
	npad	11
$LL4@Lower_boun:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	rdx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	r8, QWORD PTR [r10+rax*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	mov	r11, QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.h

; 27   : 	if (A->dwCRC < B->dwCRC)			return		true;

	mov	eax, DWORD PTR [r11+4]
	cmp	eax, ebx
	jb	SHORT $LN26@Lower_boun

; 28   : 	if (A->dwCRC > B->dwCRC)			return		false;

	ja	SHORT $LN2@Lower_boun

; 29   : 	return	A->dwLength < B->dwLength;

	mov	ecx, DWORD PTR [rdi+8]
	cmp	DWORD PTR [r11+8], ecx
	setb	cl
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	test	cl, cl
	jne	SHORT $LN26@Lower_boun
$LN2@Lower_boun:

; 2519 : 			}
; 2520 : 		else
; 2521 : 			_Count = _Count2;

	mov	r9, rdx
	jmp	SHORT $LN1@Lower_boun
$LN26@Lower_boun:

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	r10, QWORD PTR [r8+8]
	sub	rax, rdx
	add	r9, rax
$LN1@Lower_boun:

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jg	SHORT $LL4@Lower_boun
	mov	rdi, QWORD PTR [rsp]
	mov	rbx, QWORD PTR [rsp+16]
$LN27@Lower_boun:

; 2522 : 		}
; 2523 : 	return (_First);

	mov	rax, r10

; 2524 : 	}

	add	rsp, 8
	ret	0
??$_Lower_bound@PEAPEAUsmem_value@@PEAU1@_JP6A_NPEBU1@0@Z@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@P6A_NPEBU1@2@ZPEA_J@Z ENDP ; std::_Lower_bound<smem_value * __ptr64 * __ptr64,smem_value * __ptr64,__int64,bool (__cdecl*)(smem_value const * __ptr64,smem_value const * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@AEAV10@PEAPEAUsmem_value@@@Z
_TEXT	SEGMENT
_Iter$ = 8
_Right$ = 16
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@AEAV10@PEAPEAUsmem_value@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >, COMDAT

; 313  : 		this->_Ptr = _Right;

	mov	QWORD PTR [rcx], rdx

; 405  : 	return (_Iter._Rechecked(_Right));

	mov	rax, rcx

; 406  : 	}

	ret	0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@AEAV10@PEAPEAUsmem_value@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_First$ = 16
_Last$ = 24
_Val$ = 32
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64>, COMDAT

; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN29@find

; 3026 : 		if (*_First == _Val)

	mov	rax, QWORD PTR [r9]
$LL16@find:
	cmp	QWORD PTR [rdx], rax
	je	SHORT $LN29@find

; 3025 : 	for (; _First != _Last; ++_First)

	add	rdx, 8
	cmp	rdx, r8
	jne	SHORT $LL16@find
$LN29@find:

; 3052 : 	_DEBUG_RANGE(_First, _Last);
; 3053 : 	return (_Rechecked(_First,
; 3054 : 		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx

; 3055 : 	}

	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@PEAUsmem_value@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@0@V10@0AEBQEAUsmem_value@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Remove@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Remove@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@@Z PROC ; std::_Remove<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>, COMDAT

; 1731 : 	{	// remove each matching _Val

	xor	r9d, r9d

; 1732 : 	_FwdIt _Next = _First;
; 1733 : 	for (++_First; _First != _Last; ++_First)

	lea	rax, QWORD PTR [rcx+8]
	mov	r10, rdx
	sub	r10, rax
	add	r10, 7
	shr	r10, 3
	cmp	rax, rdx
	cmova	r10, r9
	test	r10, r10
	je	SHORT $LN13@Remove
$LL4@Remove:

; 1734 : 		if (!(*_First == _Val))

	mov	rdx, QWORD PTR [rax]
	cmp	rdx, QWORD PTR [r8]
	je	SHORT $LN3@Remove

; 1735 : 			*_Next++ = _Move(*_First);

	mov	QWORD PTR [rcx], rdx
	add	rcx, 8
$LN3@Remove:

; 1732 : 	_FwdIt _Next = _First;
; 1733 : 	for (++_First; _First != _Last; ++_First)

	inc	r9
	add	rax, 8
	cmp	r9, r10
	jne	SHORT $LL4@Remove
$LN13@Remove:

; 1736 : 	return (_Next);

	mov	rax, rcx

; 1737 : 	}

	ret	0
??$_Remove@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@@Z ENDP ; std::_Remove<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>, COMDAT

; 2428 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx
	mov	rdi, r8
	sar	rdx, 3

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rdi
	mov	r8, rbx
	call	QWORD PTR __imp_memmove

; 2432 : 	return (_Dest + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 2433 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Move@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z PROC ; std::_Uninitialized_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z ENDP ; std::_Uninitialized_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill@PEAPEAUsmem_value@@PEAU1@@std@@YAXPEAPEAUsmem_value@@0AEBQEAU1@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Fill@PEAPEAUsmem_value@@PEAU1@@std@@YAXPEAPEAUsmem_value@@0AEBQEAU1@@Z PROC ; std::_Fill<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>, COMDAT

; 2598 : 	{	// copy _Val through [_First, _Last)

	xor	r9d, r9d
	mov	r10, rdx
	sub	r10, rcx
	add	r10, 7
	shr	r10, 3
	cmp	rcx, rdx
	cmova	r10, r9

; 2599 : 	for (; _First != _Last; ++_First)

	test	r10, r10
	je	SHORT $LN1@Fill
	npad	3
$LL3@Fill:

; 2600 : 		*_First = _Val;

	mov	rax, QWORD PTR [r8]
	inc	r9
	lea	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx-8], rax
	cmp	r9, r10
	jne	SHORT $LL3@Fill
$LN1@Fill:

; 2601 : 	}

	ret	0
??$_Fill@PEAPEAUsmem_value@@PEAU1@@std@@YAXPEAPEAUsmem_value@@0AEBQEAU1@@Z ENDP ; std::_Fill<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>, COMDAT

; 2354 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx
	mov	rbx, r8
	sar	rdx, 3

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rdx*8]
	mov	rdx, rcx
	sub	rbx, r8
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove

; 2358 : 	return (_Dest - _Count);

	mov	rax, rbx

; 2359 : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Copy_backward@PEAPEAUsmem_value@@PEAPEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAUsmem_value@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAUsmem_value@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@@Z PROC ; std::_Val_type<smem_value * __ptr64 * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAPEAUsmem_value@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@@Z ENDP ; std::_Val_type<smem_value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>, COMDAT

; 611  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

$LN4:
	sub	rsp, 56					; 00000038H

; 612  : 	_Uninit_fill_n(_First, _Count,
; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	call	??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>

; 614  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAUsmem_value@@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAUsmem_value@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Rechecked, COMDAT

; 313  : 		this->_Ptr = _Right;

	mov	QWORD PTR [rcx], rdx

; 314  : 		return (*this);

	mov	rax, rcx

; 315  : 		}

	ret	0
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAUsmem_value@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAPEAPEAUsmem_value@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAPEAPEAUsmem_value@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Unchecked, COMDAT

; 319  : 		return (_Unchecked_type(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 320  : 		}

	ret	0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUsmem_value@@@std@@@std@@@std@@QEBAPEAPEAUsmem_value@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<smem_value * __ptr64> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance@PEAPEAUsmem_value@@_J@std@@YAXPEAPEAUsmem_value@@0AEA_J@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
??$_Distance@PEAPEAUsmem_value@@_J@std@@YAXPEAPEAUsmem_value@@0AEA_J@Z PROC ; std::_Distance<smem_value * __ptr64 * __ptr64,__int64>, COMDAT

; 750  : 	_Off += _Last - _First;

	sub	rdx, rcx
	sar	rdx, 3
	add	QWORD PTR [r8], rdx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 767  : 	}

	ret	0
??$_Distance@PEAPEAUsmem_value@@_J@std@@YAXPEAPEAUsmem_value@@0AEA_J@Z ENDP ; std::_Distance<smem_value * __ptr64 * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$advance@PEAPEAUsmem_value@@_J@std@@YAXAEAPEAPEAUsmem_value@@_J@Z
_TEXT	SEGMENT
_Where$ = 8
_Off$ = 16
??$advance@PEAPEAUsmem_value@@_J@std@@YAXAEAPEAPEAUsmem_value@@_J@Z PROC ; std::advance<smem_value * __ptr64 * __ptr64,__int64>, COMDAT

; 690  : 	_Where += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));
; 698  : 	}

	ret	0
??$advance@PEAPEAUsmem_value@@_J@std@@YAXAEAPEAPEAUsmem_value@@_J@Z ENDP ; std::advance<smem_value * __ptr64 * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Find@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Find@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@@Z PROC ; std::_Find<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>, COMDAT

; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN15@Find

; 3026 : 		if (*_First == _Val)

	mov	rax, QWORD PTR [r8]
$LL6@Find:
	cmp	QWORD PTR [rcx], rax
	je	SHORT $LN15@Find

; 3025 : 	for (; _First != _Last; ++_First)

	add	rcx, 8
	cmp	rcx, rdx
	jne	SHORT $LL6@Find
$LN15@Find:

; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

	mov	rax, rcx

; 3046 : 	}

	ret	0
??$_Find@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@@Z ENDP ; std::_Find<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAUsmem_value@@@std@@YA$$QEAPEAUsmem_value@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAUsmem_value@@@std@@YA$$QEAPEAUsmem_value@@AEAPEAU1@@Z PROC ; std::_Move<smem_value * __ptr64 & __ptr64>, COMDAT

; 1528 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, rcx

; 1529 : 	}

	ret	0
??$_Move@AEAPEAUsmem_value@@@std@@YA$$QEAPEAUsmem_value@@AEAPEAU1@@Z ENDP ; std::_Move<smem_value * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z PROC ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@U?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@@Z ENDP ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<smem_value * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>, COMDAT

; 585  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_fil:

; 594  : 	for (; 0 < _Count; --_Count, ++_First)

	test	rdx, rdx
	je	SHORT $LN4@Uninit_fil
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN30@Uninit_fil
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
$LN30@Uninit_fil:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 594  : 	for (; 0 < _Count; --_Count, ++_First)

	dec	rdx
	mov	QWORD PTR _Count$[rsp], rdx
	add	rcx, 8
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_fil
$LN4@Uninit_fil:

; 595  : 		_Al.construct(_First, *_Pval);
; 596  : 	_CATCH_ALL
; 597  : 	for (; _Next != _First; ++_Next)
; 598  : 		_Al.destroy(_Next);
; 599  : 	_RERAISE;
; 600  : 	_CATCH_END
; 601  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_fil:
??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>'::`1'::catch$0

; 596  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 597  : 	for (; _Next != _First; ++_Next)
; 598  : 		_Al.destroy(_Next);
; 599  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_fill_n@PEAPEAUsmem_value@@_KPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAXPEAPEAUsmem_value@@_KPEBQEAU1@AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_fill_n<smem_value * __ptr64 * __ptr64,unsigned __int64,smem_value * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PEAPEAUsmem_value@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAPEAUsmem_value@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$dead$ = 16
??$_Iter_cat@PEAPEAUsmem_value@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAPEAUsmem_value@@@Z PROC ; std::_Iter_cat<smem_value * __ptr64 * __ptr64>, COMDAT

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	rax, rcx

; 408  : 	}

	ret	0
??$_Iter_cat@PEAPEAUsmem_value@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAPEAUsmem_value@@@Z ENDP ; std::_Iter_cat<smem_value * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance2@PEAPEAUsmem_value@@_J@std@@YAXPEAPEAUsmem_value@@0AEA_JUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
__formal$dead$ = 32
??$_Distance2@PEAPEAUsmem_value@@_J@std@@YAXPEAPEAUsmem_value@@0AEA_JUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<smem_value * __ptr64 * __ptr64,__int64>, COMDAT

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

	sub	rdx, rcx
	sar	rdx, 3
	add	QWORD PTR [r8], rdx

; 751  : 	}

	ret	0
??$_Distance2@PEAPEAUsmem_value@@_J@std@@YAXPEAPEAUsmem_value@@0AEA_JUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<smem_value * __ptr64 * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Advance@PEAPEAUsmem_value@@_J@std@@YAXAEAPEAPEAUsmem_value@@_JUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_Where$ = 8
_Off$ = 16
__formal$dead$ = 24
??$_Advance@PEAPEAUsmem_value@@_J@std@@YAXAEAPEAPEAUsmem_value@@_JUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<smem_value * __ptr64 * __ptr64,__int64>, COMDAT

; 690  : 	_Where += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 691  : 	}

	ret	0
??$_Advance@PEAPEAUsmem_value@@_J@std@@YAXAEAPEAPEAUsmem_value@@_JUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<smem_value * __ptr64 * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Find@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
__formal$dead$ = 32
??$_Find@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>, COMDAT

; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN13@Find

; 3026 : 		if (*_First == _Val)

	mov	rax, QWORD PTR [r8]
$LL4@Find:
	cmp	QWORD PTR [rcx], rax
	je	SHORT $LN13@Find

; 3025 : 	for (; _First != _Last; ++_First)

	add	rcx, 8
	cmp	rcx, rdx
	jne	SHORT $LL4@Find
$LN13@Find:

; 3027 : 			break;
; 3028 : 	return (_First);

	mov	rax, rcx

; 3029 : 	}

	ret	0
??$_Find@PEAPEAUsmem_value@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@0AEBQEAU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find<smem_value * __ptr64 * __ptr64,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>, COMDAT

; 459  : 	{	// move [_First, _Last) to raw _Dest, using _Al, scalar type

$LN4:
	sub	rsp, 56					; 00000038H

; 460  : 	return (_Uninit_move(_First, _Last, _Dest,
; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>

; 462  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [r8], rax
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 8
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 8
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAPEAUsmem_value@@PEAPEAU1@V?$xalloc@PEAUsmem_value@@@@PEAU1@@std@@YAPEAPEAUsmem_value@@PEAPEAU1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<smem_value * __ptr64 * __ptr64,smem_value * __ptr64 * __ptr64,xalloc<smem_value * __ptr64>,smem_value * __ptr64>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAUsmem_value@@PEAU1@@?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@QEAAXPEAPEAUsmem_value@@$$QEAPEAU2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAUsmem_value@@PEAU1@@?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@QEAAXPEAPEAUsmem_value@@$$QEAPEAU2@@Z PROC ; std::_Wrap_alloc<xalloc<smem_value * __ptr64> >::construct<smem_value * __ptr64,smem_value * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAUsmem_value@@PEAU1@@?$_Wrap_alloc@V?$xalloc@PEAUsmem_value@@@@@std@@QEAAXPEAPEAUsmem_value@@$$QEAPEAU2@@Z ENDP ; std::_Wrap_alloc<xalloc<smem_value * __ptr64> >::construct<smem_value * __ptr64,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PEAUsmem_value@@@std@@YA$$QEAPEAUsmem_value@@AEAPEAU1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUsmem_value@@@std@@YA$$QEAPEAUsmem_value@@AEAPEAU1@@Z PROC ; std::forward<smem_value * __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@PEAUsmem_value@@@std@@YA$$QEAPEAUsmem_value@@AEAPEAU1@@Z ENDP ; std::forward<smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAUsmem_value@@PEAU1@@?$allocator_traits@V?$xalloc@PEAUsmem_value@@@@@std@@SAXAEAV?$xalloc@PEAUsmem_value@@@@PEAPEAUsmem_value@@$$QEAPEAU3@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAUsmem_value@@PEAU1@@?$allocator_traits@V?$xalloc@PEAUsmem_value@@@@@std@@SAXAEAV?$xalloc@PEAUsmem_value@@@@PEAPEAUsmem_value@@$$QEAPEAU3@@Z PROC ; std::allocator_traits<xalloc<smem_value * __ptr64> >::construct<smem_value * __ptr64,smem_value * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@PEAUsmem_value@@PEAU1@@?$allocator_traits@V?$xalloc@PEAUsmem_value@@@@@std@@SAXAEAV?$xalloc@PEAUsmem_value@@@@PEAPEAUsmem_value@@$$QEAPEAU3@@Z ENDP ; std::allocator_traits<xalloc<smem_value * __ptr64> >::construct<smem_value * __ptr64,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAUsmem_value@@@@PEAUsmem_value@@PEAU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAUsmem_value@@@@PEAPEAUsmem_value@@$$QEAPEAU3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@PEAUsmem_value@@@@PEAUsmem_value@@PEAU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAUsmem_value@@@@PEAPEAUsmem_value@@$$QEAPEAU3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<smem_value * __ptr64>,smem_value * __ptr64,smem_value * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8], rax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAUsmem_value@@@@PEAUsmem_value@@PEAU2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAUsmem_value@@@@PEAPEAUsmem_value@@$$QEAPEAU3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<smem_value * __ptr64>,smem_value * __ptr64,smem_value * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsharedmem.h
;	COMDAT ?smem_search@@YA_NPEBUsmem_value@@0@Z
_TEXT	SEGMENT
A$ = 8
B$ = 16
?smem_search@@YA_NPEBUsmem_value@@0@Z PROC		; smem_search, COMDAT

; 27   : 	if (A->dwCRC < B->dwCRC)			return		true;

	mov	eax, DWORD PTR [rcx+4]
	mov	r8d, DWORD PTR [rdx+4]
	mov	r9, rcx
	cmp	eax, r8d
	jae	SHORT $LN5@smem_searc
	mov	al, 1

; 30   : };

	ret	0
$LN5@smem_searc:

; 28   : 	if (A->dwCRC > B->dwCRC)			return		false;

	jbe	SHORT $LN1@smem_searc
	xor	al, al

; 30   : };

	ret	0
$LN1@smem_searc:

; 29   : 	return	A->dwLength < B->dwLength;

	mov	ecx, DWORD PTR [rdx+8]
	xor	eax, eax
	cmp	DWORD PTR [r9+8], ecx
	setb	al

; 30   : };

	ret	0
?smem_search@@YA_NPEBUsmem_value@@0@Z ENDP		; smem_search
_TEXT	ENDS
END
