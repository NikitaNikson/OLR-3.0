; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzo1x_decompress_dict_safe
EXTRN	memcpy:PROC
pdata	SEGMENT
$pdata$lzo1x_decompress_dict_safe DD imagerel $LN216
	DD	imagerel $LN216+1603
	DD	imagerel $unwind$lzo1x_decompress_dict_safe
pdata	ENDS
xdata	SEGMENT
$unwind$lzo1x_decompress_dict_safe DD 0b7001H
	DD	046470H
	DD	0d5466H
	DD	0f00f4213H
	DD	0d00be00dH
	DD	07007c009H
	DD	03006H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\rt_lzo1x_d.ch
xdata	ENDS
_TEXT	SEGMENT
dict_end$1$ = 96
in$ = 96
in_len$ = 104
out$ = 112
out_len$ = 120
dict_len$ = 128
lzo1x_decompress_dict_safe PROC

; 61   : {

$LN216:
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 62   :     register lzo_bytep op;
; 63   :     register const lzo_bytep ip;
; 64   :     register lzo_uint t;
; 65   : #if defined(COPY_DICT)
; 66   :     lzo_uint m_off;
; 67   :     const lzo_bytep dict_end;
; 68   : #else
; 69   :     register const lzo_bytep m_pos;
; 70   : #endif
; 71   : 
; 72   :     const lzo_bytep const ip_end = in + in_len;
; 73   : #if defined(HAVE_ANY_OP)
; 74   :     lzo_bytep const op_end = out + *out_len;

	mov	rax, QWORD PTR [r9]
	mov	rdi, rcx
	mov	rcx, QWORD PTR _LZO_Dictionary

; 75   : #endif
; 76   : #if defined(LZO1Z)
; 77   :     lzo_uint last_m_off = 0;
; 78   : #endif
; 79   : 
; 80   :     LZO_UNUSED(wrkmem);
; 81   : 
; 82   : #if defined(COPY_DICT)
; 83   :     if (dict)

	xor	r10d, r10d
	mov	r13, r8
	lea	r12, QWORD PTR [rdi+rdx]
	lea	r14, QWORD PTR [r8+rax]
	test	rcx, rcx
	je	SHORT $LN127@lzo1x_deco

; 84   :     {
; 85   :         if (dict_len > M4_MAX_OFFSET)

	mov	r15, QWORD PTR dict_len$[rsp]
	cmp	r15, 49151				; 0000bfffH
	jbe	SHORT $LN126@lzo1x_deco

; 86   :         {
; 87   :             dict += dict_len - M4_MAX_OFFSET;

	lea	rcx, QWORD PTR [rcx+r15-49151]

; 88   :             dict_len = M4_MAX_OFFSET;

	mov	r15d, 49151				; 0000bfffH
$LN126@lzo1x_deco:

; 89   :         }
; 90   :         dict_end = dict + dict_len;

	lea	r8, QWORD PTR [rcx+r15]

; 91   :     }
; 92   :     else

	jmp	SHORT $LN213@lzo1x_deco
$LN127@lzo1x_deco:

; 93   :     {
; 94   :         dict_len = 0;

	mov	r15, r10

; 95   :         dict_end = NULL;

	mov	r8, r10
$LN213@lzo1x_deco:

; 96   :     }
; 97   : #endif /* COPY_DICT */
; 98   : 
; 99   :     *out_len = 0;
; 100  : 
; 101  :     op = out;
; 102  :     ip = in;
; 103  : 
; 104  :     if (*ip > 17)

	movzx	eax, BYTE PTR [rdi]
	mov	QWORD PTR [rsp+104], rbp
	mov	QWORD PTR dict_end$1$[rsp], r8
	mov	QWORD PTR [rsp+32], rsi
	mov	QWORD PTR [r9], r10
	mov	rbx, r13
	cmp	al, 17
	jbe	SHORT $LN113@lzo1x_deco

; 105  :     {
; 106  :         t = *ip++ - 17;

	movzx	eax, al
	sub	eax, 17
	inc	rdi
	movsxd	rdx, eax

; 107  :         if (t < 4)

	cmp	rdx, 4
	jb	$match_next$97202

; 108  :             goto match_next;
; 109  :         assert(t > 0); NEED_OP(t); NEED_IP(t+1);

	mov	rax, r14
	sub	rax, r13
	cmp	rax, rdx
	jb	$output_overrun$97208
	mov	rcx, r12
	lea	rax, QWORD PTR [rdx+1]
	sub	rcx, rdi
	cmp	rcx, rax
	jb	$input_overrun$97213
	npad	14
$LL117@lzo1x_deco:

; 110  :         do *op++ = *ip++; while (--t > 0);

	movzx	eax, BYTE PTR [rdi]
	inc	rbx
	inc	rdi
	dec	rdx
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL117@lzo1x_deco

; 111  :         goto first_literal_run;

	jmp	$first_literal_run$97218
$LN113@lzo1x_deco:

; 112  :     }
; 113  : 
; 114  :     while (TEST_IP && TEST_OP)

	cmp	rdi, r12
	jae	$LN112@lzo1x_deco

; 115  :     {
; 116  :         t = *ip++;

	movzx	edx, BYTE PTR [rdi]
	inc	rdi

; 117  :         if (t >= 16)

	cmp	rdx, 16
	jae	$match$97224

; 118  :             goto match;
; 119  :         /* a literal run */
; 120  :         if (t == 0)

	test	rdx, rdx
	jne	SHORT $LN109@lzo1x_deco

; 121  :         {
; 122  :             NEED_IP(1);

	mov	rax, r12
	sub	rax, rdi
	cmp	rax, 1
	jb	$LN203@lzo1x_deco

; 123  :             while (*ip == 0)

	cmp	BYTE PTR [rdi], dl
	jne	SHORT $LN105@lzo1x_deco
	npad	8
$LL106@lzo1x_deco:

; 124  :             {
; 125  :                 t += 255;
; 126  :                 ip++;

	inc	rdi

; 127  :                 NEED_IP(1);

	mov	rax, r12
	add	rdx, 255				; 000000ffH
	sub	rax, rdi
	cmp	rax, 1
	jb	$LN203@lzo1x_deco

; 123  :             while (*ip == 0)

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LL106@lzo1x_deco
$LN105@lzo1x_deco:

; 128  :             }
; 129  :             t += 15 + *ip++;

	movzx	eax, BYTE PTR [rdi]
	add	eax, 15
	cdqe
	add	rdx, rax
	inc	rdi
$LN109@lzo1x_deco:

; 130  :         }
; 131  :         /* copy literals */
; 132  :         assert(t > 0); NEED_OP(t+3); NEED_IP(t+4);

	mov	rcx, r14
	lea	rax, QWORD PTR [rdx+3]
	sub	rcx, rbx
	cmp	rcx, rax
	jb	$LN195@lzo1x_deco
	mov	rcx, r12
	lea	rax, QWORD PTR [rdx+4]
	sub	rcx, rdi
	cmp	rcx, rax
	jb	$LN203@lzo1x_deco

; 133  : #if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
; 134  : #if !defined(LZO_UNALIGNED_OK_4)
; 135  :         if (PTR_ALIGNED2_4(op,ip))
; 136  :         {
; 137  : #endif
; 138  :         COPY4(op,ip);

	mov	eax, DWORD PTR [rdi]

; 139  :         op += 4; ip += 4;

	add	rbx, 4
	add	rdi, 4

; 140  :         if (--t > 0)

	dec	rdx
	mov	DWORD PTR [rbx-4], eax
	je	SHORT $first_literal_run$97218

; 141  :         {
; 142  :             if (t >= 4)

	cmp	rdx, 4
	jb	SHORT $LL88@lzo1x_deco
	npad	5
$LL96@lzo1x_deco:

; 143  :             {
; 144  :                 do {
; 145  :                     COPY4(op,ip);

	mov	eax, DWORD PTR [rdi]

; 146  :                     op += 4; ip += 4; t -= 4;

	sub	rdx, 4
	add	rbx, 4
	mov	DWORD PTR [rbx-4], eax
	add	rdi, 4

; 147  :                 } while (t >= 4);

	cmp	rdx, 4
	jae	SHORT $LL96@lzo1x_deco

; 148  :                 if (t > 0) do *op++ = *ip++; while (--t > 0);

	test	rdx, rdx
	je	SHORT $first_literal_run$97218
	npad	4
$LL92@lzo1x_deco:
	movzx	eax, BYTE PTR [rdi]
	inc	rbx
	inc	rdi
	dec	rdx
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL92@lzo1x_deco

; 149  :             }
; 150  :             else

	jmp	SHORT $first_literal_run$97218
	npad	13
$LL88@lzo1x_deco:

; 151  :                 do *op++ = *ip++; while (--t > 0);

	movzx	eax, BYTE PTR [rdi]
	inc	rbx
	inc	rdi
	dec	rdx
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL88@lzo1x_deco
$first_literal_run$97218:

; 152  :         }
; 153  : #if !defined(LZO_UNALIGNED_OK_4)
; 154  :         }
; 155  :         else
; 156  : #endif
; 157  : #endif
; 158  : #if !defined(LZO_UNALIGNED_OK_4)
; 159  :         {
; 160  :             *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
; 161  :             do *op++ = *ip++; while (--t > 0);
; 162  :         }
; 163  : #endif
; 164  : 
; 165  : 
; 166  : first_literal_run:
; 167  : 
; 168  : 
; 169  :         t = *ip++;

	movzx	edx, BYTE PTR [rdi]
	inc	rdi

; 170  :         if (t >= 16)

	cmp	rdx, 16
	jae	$match$97224

; 171  :             goto match;
; 172  : #if defined(COPY_DICT)
; 173  : #if defined(LZO1Z)
; 174  :         m_off = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
; 175  :         last_m_off = m_off;
; 176  : #else
; 177  :         m_off = (1 + M2_MAX_OFFSET) + (t >> 2) + (*ip++ << 2);

	movzx	eax, BYTE PTR [rdi]
	shr	rdx, 2
	inc	rdi
	shl	eax, 2
	movsxd	rcx, eax

; 178  : #endif
; 179  :         NEED_OP(3);

	mov	rax, r14
	sub	rax, rbx
	lea	rsi, QWORD PTR [rcx+rdx+2049]
	cmp	rax, 3
	jb	$LN195@lzo1x_deco

; 180  :         t = 3; COPY_DICT(t,m_off)

	mov	rax, rbx
	mov	edx, 3
	sub	rax, r13
	cmp	rsi, rax
	ja	SHORT $LN81@lzo1x_deco
	mov	rcx, rbx
	sub	rcx, rsi
	cmp	rsi, rdx
	jb	SHORT $LL78@lzo1x_deco
$LN72@lzo1x_deco:
	movzx	eax, WORD PTR [rcx]
	mov	WORD PTR [rbx], ax
	movzx	eax, BYTE PTR [rcx+2]
	mov	BYTE PTR [rbx+2], al
	jmp	$LN214@lzo1x_deco
	npad	10
$LL78@lzo1x_deco:
	movzx	eax, BYTE PTR [rcx]
	inc	rbx
	inc	rcx
	dec	rdx
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL78@lzo1x_deco
	jmp	$match_done$97293
$LN81@lzo1x_deco:
	mov	rax, r13
	sub	rax, rbx
	add	rsi, rax
	cmp	rsi, r15
	ja	$lookbehind_overrun$97286
	mov	rcx, r8
	sub	rcx, rsi
	cmp	rsi, rdx
	jae	SHORT $LN72@lzo1x_deco
	mov	rbp, rdx
	mov	rdx, rcx
	mov	r8, rsi
	mov	rcx, rbx
	sub	rbp, rsi
	call	memcpy
	add	rbx, rsi
	mov	rcx, r13
	npad	3
$LL71@lzo1x_deco:
	movzx	eax, BYTE PTR [rcx]
	inc	rbx
	inc	rcx
	dec	rbp
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL71@lzo1x_deco
	jmp	$match_done$97293
$match$97224:

; 181  : #else /* !COPY_DICT */
; 182  : #if defined(LZO1Z)
; 183  :         t = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
; 184  :         m_pos = op - t;
; 185  :         last_m_off = t;
; 186  : #else
; 187  :         m_pos = op - (1 + M2_MAX_OFFSET);
; 188  :         m_pos -= t >> 2;
; 189  :         m_pos -= *ip++ << 2;
; 190  : #endif
; 191  :         TEST_LB(m_pos); NEED_OP(3);
; 192  :         *op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;
; 193  : #endif /* COPY_DICT */
; 194  :         goto match_done;
; 195  : 
; 196  : 
; 197  :         /* handle matches */
; 198  :         do {
; 199  : match:
; 200  :             if (t >= 64)                /* a M2 match */

	cmp	rdx, 64					; 00000040H
	jb	SHORT $LN63@lzo1x_deco

; 201  :             {
; 202  : #if defined(COPY_DICT)
; 203  : #if defined(LZO1X)
; 204  :                 m_off = 1 + ((t >> 2) & 7) + (*ip++ << 3);

	movzx	eax, BYTE PTR [rdi]
	inc	rdi
	shl	eax, 3
	movsxd	rcx, eax
	mov	rax, rdx

; 205  :                 t = (t >> 5) - 1;

	shr	rdx, 5
	shr	rax, 2
	and	eax, 7
	dec	rdx
	lea	rbp, QWORD PTR [rcx+rax+1]
	jmp	$LN42@lzo1x_deco
$LN63@lzo1x_deco:

; 206  : #elif defined(LZO1Y)
; 207  :                 m_off = 1 + ((t >> 2) & 3) + (*ip++ << 2);
; 208  :                 t = (t >> 4) - 3;
; 209  : #elif defined(LZO1Z)
; 210  :                 m_off = t & 0x1f;
; 211  :                 if (m_off >= 0x1c)
; 212  :                     m_off = last_m_off;
; 213  :                 else
; 214  :                 {
; 215  :                     m_off = 1 + (m_off << 6) + (*ip++ >> 2);
; 216  :                     last_m_off = m_off;
; 217  :                 }
; 218  :                 t = (t >> 5) - 1;
; 219  : #endif
; 220  : #else /* !COPY_DICT */
; 221  : #if defined(LZO1X)
; 222  :                 m_pos = op - 1;
; 223  :                 m_pos -= (t >> 2) & 7;
; 224  :                 m_pos -= *ip++ << 3;
; 225  :                 t = (t >> 5) - 1;
; 226  : #elif defined(LZO1Y)
; 227  :                 m_pos = op - 1;
; 228  :                 m_pos -= (t >> 2) & 3;
; 229  :                 m_pos -= *ip++ << 2;
; 230  :                 t = (t >> 4) - 3;
; 231  : #elif defined(LZO1Z)
; 232  :                 {
; 233  :                     lzo_uint off = t & 0x1f;
; 234  :                     m_pos = op;
; 235  :                     if (off >= 0x1c)
; 236  :                     {
; 237  :                         assert(last_m_off > 0);
; 238  :                         m_pos -= last_m_off;
; 239  :                     }
; 240  :                     else
; 241  :                     {
; 242  :                         off = 1 + (off << 6) + (*ip++ >> 2);
; 243  :                         m_pos -= off;
; 244  :                         last_m_off = off;
; 245  :                     }
; 246  :                 }
; 247  :                 t = (t >> 5) - 1;
; 248  : #endif
; 249  :                 TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
; 250  :                 goto copy_match;
; 251  : #endif /* COPY_DICT */
; 252  :             }
; 253  :             else if (t >= 32)           /* a M3 match */

	cmp	rdx, 32					; 00000020H
	jb	SHORT $LN61@lzo1x_deco

; 254  :             {
; 255  :                 t &= 31;

	and	edx, 31

; 256  :                 if (t == 0)

	jne	SHORT $LN60@lzo1x_deco

; 257  :                 {
; 258  :                     NEED_IP(1);

	mov	rax, r12
	sub	rax, rdi
	cmp	rax, 1
	jb	$LN203@lzo1x_deco

; 259  :                     while (*ip == 0)

	cmp	BYTE PTR [rdi], dl
	jne	SHORT $LN56@lzo1x_deco
	npad	14
$LL57@lzo1x_deco:

; 260  :                     {
; 261  :                         t += 255;
; 262  :                         ip++;

	inc	rdi

; 263  :                         NEED_IP(1);

	mov	rax, r12
	add	rdx, 255				; 000000ffH
	sub	rax, rdi
	cmp	rax, 1
	jb	$LN203@lzo1x_deco

; 259  :                     while (*ip == 0)

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LL57@lzo1x_deco
$LN56@lzo1x_deco:

; 264  :                     }
; 265  :                     t += 31 + *ip++;

	movzx	eax, BYTE PTR [rdi]
	add	eax, 31
	cdqe
	add	rdx, rax
	inc	rdi
$LN60@lzo1x_deco:

; 266  :                 }
; 267  : #if defined(COPY_DICT)
; 268  : #if defined(LZO1Z)
; 269  :                 m_off = 1 + (ip[0] << 6) + (ip[1] >> 2);
; 270  :                 last_m_off = m_off;
; 271  : #else
; 272  :                 m_off = 1 + (ip[0] >> 2) + (ip[1] << 6);

	movzx	ecx, BYTE PTR [rdi]
	movzx	eax, BYTE PTR [rdi+1]
	shr	ecx, 2
	shl	eax, 6

; 273  : #endif
; 274  : #else /* !COPY_DICT */
; 275  : #if defined(LZO1Z)
; 276  :                 {
; 277  :                     lzo_uint off = 1 + (ip[0] << 6) + (ip[1] >> 2);
; 278  :                     m_pos = op - off;
; 279  :                     last_m_off = off;
; 280  :                 }
; 281  : #elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
; 282  :                 m_pos = op - 1;
; 283  :                 m_pos -= (* (const lzo_ushortp) ip) >> 2;
; 284  : #else
; 285  :                 m_pos = op - 1;
; 286  :                 m_pos -= (ip[0] >> 2) + (ip[1] << 6);
; 287  : #endif
; 288  : #endif /* COPY_DICT */
; 289  :                 ip += 2;

	add	rdi, 2
	lea	eax, DWORD PTR [rcx+rax+1]
	movsxd	rbp, eax
	jmp	$LN42@lzo1x_deco
$LN61@lzo1x_deco:

; 290  :             }
; 291  :             else if (t >= 16)           /* a M4 match */

	cmp	rdx, 16
	jb	$LN52@lzo1x_deco

; 292  :             {
; 293  : #if defined(COPY_DICT)
; 294  :                 m_off = (t & 8) << 11;

	mov	rbp, rdx
	and	ebp, 8
	shl	rbp, 11

; 295  : #else /* !COPY_DICT */
; 296  :                 m_pos = op;
; 297  :                 m_pos -= (t & 8) << 11;
; 298  : #endif /* COPY_DICT */
; 299  :                 t &= 7;

	and	edx, 7

; 300  :                 if (t == 0)

	jne	SHORT $LN51@lzo1x_deco

; 301  :                 {
; 302  :                     NEED_IP(1);

	mov	rax, r12
	sub	rax, rdi
	cmp	rax, 1
	jb	$LN203@lzo1x_deco

; 303  :                     while (*ip == 0)

	cmp	BYTE PTR [rdi], dl
	jne	SHORT $LN47@lzo1x_deco
	npad	9
$LL48@lzo1x_deco:

; 304  :                     {
; 305  :                         t += 255;
; 306  :                         ip++;

	inc	rdi

; 307  :                         NEED_IP(1);

	mov	rax, r12
	add	rdx, 255				; 000000ffH
	sub	rax, rdi
	cmp	rax, 1
	jb	$LN203@lzo1x_deco

; 303  :                     while (*ip == 0)

	cmp	BYTE PTR [rdi], 0
	je	SHORT $LL48@lzo1x_deco
$LN47@lzo1x_deco:

; 308  :                     }
; 309  :                     t += 7 + *ip++;

	movzx	eax, BYTE PTR [rdi]
	add	eax, 7
	cdqe
	add	rdx, rax
	inc	rdi
$LN51@lzo1x_deco:

; 310  :                 }
; 311  : #if defined(COPY_DICT)
; 312  : #if defined(LZO1Z)
; 313  :                 m_off += (ip[0] << 6) + (ip[1] >> 2);
; 314  : #else
; 315  :                 m_off += (ip[0] >> 2) + (ip[1] << 6);

	movzx	eax, BYTE PTR [rdi+1]
	movzx	ecx, BYTE PTR [rdi]

; 316  : #endif
; 317  :                 ip += 2;

	add	rdi, 2
	shl	eax, 6
	shr	ecx, 2
	add	eax, ecx
	cdqe
	add	rbp, rax

; 318  :                 if (m_off == 0)

	je	$eof_found$97328

; 319  :                     goto eof_found;
; 320  :                 m_off += 0x4000;

	add	rbp, 16384				; 00004000H
$LN42@lzo1x_deco:

; 352  : #else /* !COPY_DICT */
; 353  : #if defined(LZO1Z)
; 354  :                 t = 1 + (t << 6) + (*ip++ >> 2);
; 355  :                 m_pos = op - t;
; 356  :                 last_m_off = t;
; 357  : #else
; 358  :                 m_pos = op - 1;
; 359  :                 m_pos -= t >> 2;
; 360  :                 m_pos -= *ip++ << 2;
; 361  : #endif
; 362  :                 TEST_LB(m_pos); NEED_OP(2);
; 363  :                 *op++ = *m_pos++; *op++ = *m_pos;
; 364  : #endif /* COPY_DICT */
; 365  :                 goto match_done;
; 366  :             }
; 367  : 
; 368  :             /* copy match */
; 369  : #if defined(COPY_DICT)
; 370  : 
; 371  :             NEED_OP(t+3-1);

	mov	rax, r14
	lea	rsi, QWORD PTR [rdx+2]
	sub	rax, rbx
	cmp	rax, rsi
	jb	$LN195@lzo1x_deco

; 372  :             t += 3-1; COPY_DICT(t,m_off)

	mov	rax, rbx
	sub	rax, r13
	cmp	rbp, rax
	ja	SHORT $LN22@lzo1x_deco
	mov	rcx, rbx
	sub	rcx, rbp
	cmp	rbp, rsi
	jb	SHORT $LL19@lzo1x_deco
	mov	rdx, rcx
	mov	r8, rsi
	mov	rcx, rbx
	call	memcpy
	add	rbx, rsi
	jmp	$match_done$97293
$LL19@lzo1x_deco:
	movzx	eax, BYTE PTR [rcx]
	inc	rbx
	inc	rcx
	dec	rsi
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL19@lzo1x_deco
	jmp	$match_done$97293
$LN22@lzo1x_deco:
	mov	rax, r13
	sub	rax, rbx
	add	rbp, rax
	cmp	rbp, r15
	ja	$lookbehind_overrun$97286
	mov	rdx, r8
	mov	rcx, rbx
	sub	rdx, rbp
	cmp	rsi, rbp
	jbe	SHORT $LN13@lzo1x_deco
	mov	r8, rbp
	sub	rsi, rbp
	call	memcpy
	add	rbx, rbp
	mov	rcx, r13
	npad	8
$LL12@lzo1x_deco:
	movzx	eax, BYTE PTR [rcx]
	inc	rbx
	inc	rcx
	dec	rsi
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL12@lzo1x_deco
	jmp	$match_done$97293
$LN13@lzo1x_deco:
	mov	r8, rsi
	call	memcpy
	add	rbx, rsi

; 373  : 
; 374  : #else /* !COPY_DICT */
; 375  : 
; 376  :             TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
; 377  : #if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
; 378  : #if !defined(LZO_UNALIGNED_OK_4)
; 379  :             if (t >= 2 * 4 - (3 - 1) && PTR_ALIGNED2_4(op,m_pos))
; 380  :             {
; 381  :                 assert((op - m_pos) >= 4);  /* both pointers are aligned */
; 382  : #else
; 383  :             if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4)
; 384  :             {
; 385  : #endif
; 386  :                 COPY4(op,m_pos);
; 387  :                 op += 4; m_pos += 4; t -= 4 - (3 - 1);
; 388  :                 do {
; 389  :                     COPY4(op,m_pos);
; 390  :                     op += 4; m_pos += 4; t -= 4;
; 391  :                 } while (t >= 4);
; 392  :                 if (t > 0) do *op++ = *m_pos++; while (--t > 0);
; 393  :             }
; 394  :             else
; 395  : #endif
; 396  :             {
; 397  : copy_match:
; 398  :                 *op++ = *m_pos++; *op++ = *m_pos++;
; 399  :                 do *op++ = *m_pos++; while (--t > 0);
; 400  :             }
; 401  : 
; 402  : #endif /* COPY_DICT */
; 403  : 
; 404  : match_done:

	jmp	$match_done$97293
$LN52@lzo1x_deco:

; 321  : #if defined(LZO1Z)
; 322  :                 last_m_off = m_off;
; 323  : #endif
; 324  : #else /* !COPY_DICT */
; 325  : #if defined(LZO1Z)
; 326  :                 m_pos -= (ip[0] << 6) + (ip[1] >> 2);
; 327  : #elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
; 328  :                 m_pos -= (* (const lzo_ushortp) ip) >> 2;
; 329  : #else
; 330  :                 m_pos -= (ip[0] >> 2) + (ip[1] << 6);
; 331  : #endif
; 332  :                 ip += 2;
; 333  :                 if (m_pos == op)
; 334  :                     goto eof_found;
; 335  :                 m_pos -= 0x4000;
; 336  : #if defined(LZO1Z)
; 337  :                 last_m_off = pd((const lzo_bytep)op, m_pos);
; 338  : #endif
; 339  : #endif /* COPY_DICT */
; 340  :             }
; 341  :             else                            /* a M1 match */
; 342  :             {
; 343  : #if defined(COPY_DICT)
; 344  : #if defined(LZO1Z)
; 345  :                 m_off = 1 + (t << 6) + (*ip++ >> 2);
; 346  :                 last_m_off = m_off;
; 347  : #else
; 348  :                 m_off = 1 + (t >> 2) + (*ip++ << 2);

	movzx	eax, BYTE PTR [rdi]
	shr	rdx, 2
	inc	rdi
	shl	eax, 2
	movsxd	rcx, eax

; 349  : #endif
; 350  :                 NEED_OP(2);

	mov	rax, r14
	sub	rax, rbx
	lea	rsi, QWORD PTR [rcx+rdx+1]
	cmp	rax, 2
	jb	$LN195@lzo1x_deco

; 351  :                 t = 2; COPY_DICT(t,m_off)

	mov	rax, rbx
	mov	edx, 2
	sub	rax, r13
	cmp	rsi, rax
	ja	SHORT $LN39@lzo1x_deco
	mov	rcx, rbx
	sub	rcx, rsi
	cmp	rsi, rdx
	jb	SHORT $LL36@lzo1x_deco
	movzx	eax, WORD PTR [rcx]
	jmp	SHORT $LN215@lzo1x_deco
	npad	5
$LL36@lzo1x_deco:
	movzx	eax, BYTE PTR [rcx]
	inc	rbx
	inc	rcx
	dec	rdx
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL36@lzo1x_deco
	jmp	SHORT $match_done$97293
$LN39@lzo1x_deco:
	mov	rax, r13
	sub	rax, rbx
	add	rsi, rax
	cmp	rsi, r15
	ja	$lookbehind_overrun$97286
	mov	rax, r8
	sub	rax, rsi
	cmp	rsi, rdx
	jae	SHORT $LN30@lzo1x_deco
	mov	rbp, rdx
	mov	r8, rsi
	mov	rcx, rbx
	mov	rdx, rax
	sub	rbp, rsi
	call	memcpy
	add	rbx, rsi
	mov	rcx, r13
	npad	6
$LL29@lzo1x_deco:
	movzx	eax, BYTE PTR [rcx]
	inc	rbx
	inc	rcx
	dec	rbp
	mov	BYTE PTR [rbx-1], al
	jne	SHORT $LL29@lzo1x_deco
	jmp	SHORT $match_done$97293
$LN30@lzo1x_deco:
	movzx	eax, WORD PTR [rax]
$LN215@lzo1x_deco:
	mov	WORD PTR [rbx], ax
$LN214@lzo1x_deco:
	add	rbx, rdx
$match_done$97293:

; 405  : #if defined(LZO1Z)
; 406  :             t = ip[-1] & 3;
; 407  : #else
; 408  :             t = ip[-2] & 3;

	movzx	edx, BYTE PTR [rdi-2]

; 409  : #endif
; 410  :             if (t == 0)

	mov	r8, QWORD PTR dict_end$1$[rsp]
	and	edx, 3
	je	$LN113@lzo1x_deco
$match_next$97202:

; 411  :                 break;
; 412  : 
; 413  :             /* copy literals */
; 414  : match_next:
; 415  :             assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+1);

	mov	rax, r14
	sub	rax, rbx
	cmp	rax, rdx
	jb	$LN195@lzo1x_deco
	mov	rcx, r12
	lea	rax, QWORD PTR [rdx+1]
	sub	rcx, rdi
	cmp	rcx, rax
	jb	SHORT $LN203@lzo1x_deco

; 416  : #if 0
; 417  :             do *op++ = *ip++; while (--t > 0);
; 418  : #else
; 419  :             *op++ = *ip++;

	movzx	eax, BYTE PTR [rdi]
	inc	rbx
	inc	rdi
	mov	BYTE PTR [rbx-1], al

; 420  :             if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }

	cmp	rdx, 1
	jbe	SHORT $LN2@lzo1x_deco
	movzx	eax, BYTE PTR [rdi]
	inc	rbx
	inc	rdi
	mov	BYTE PTR [rbx-1], al
	cmp	rdx, 2
	jbe	SHORT $LN2@lzo1x_deco
	movzx	eax, BYTE PTR [rdi]
	inc	rbx
	inc	rdi
	mov	BYTE PTR [rbx-1], al
$LN2@lzo1x_deco:

; 421  : #endif
; 422  :             t = *ip++;

	movzx	edx, BYTE PTR [rdi]

; 423  :         } while (TEST_IP && TEST_OP);

	mov	r8, QWORD PTR dict_end$1$[rsp]
	inc	rdi
	cmp	rdi, r12
	jb	$match$97224
	jmp	$LN113@lzo1x_deco
$eof_found$97328:

; 430  : #endif
; 431  : 
; 432  : eof_found:
; 433  :     assert(t == 1);
; 434  :     *out_len = pd(op, out);

	mov	rax, QWORD PTR out_len$[rsp]
	sub	rbx, r13
	mov	QWORD PTR [rax], rbx

; 435  :     return (ip == ip_end ? LZO_E_OK :
; 436  :            (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));

	cmp	rdi, r12
	jne	SHORT $LN130@lzo1x_deco
	xor	r10d, r10d
	mov	eax, r10d
	jmp	SHORT $LN128@lzo1x_deco
$LN130@lzo1x_deco:
	mov	ecx, -8
	mov	r10d, -4
	cmp	rdi, r12
	cmovb	r10d, ecx
	mov	eax, r10d
	jmp	SHORT $LN128@lzo1x_deco
$LN203@lzo1x_deco:

; 61   : {

	mov	r9, QWORD PTR out_len$[rsp]
$input_overrun$97213:

; 437  : 
; 438  : 
; 439  : #if defined(HAVE_NEED_IP)
; 440  : input_overrun:
; 441  :     *out_len = pd(op, out);

	sub	rbx, r13

; 442  :     return LZO_E_INPUT_OVERRUN;

	mov	eax, -4
	mov	QWORD PTR [r9], rbx
	jmp	SHORT $LN128@lzo1x_deco
$lookbehind_overrun$97286:

; 449  : #endif
; 450  : 
; 451  : #if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
; 452  : lookbehind_overrun:
; 453  :     *out_len = pd(op, out);

	mov	rax, QWORD PTR out_len$[rsp]
	sub	rbx, r13
	mov	QWORD PTR [rax], rbx

; 454  :     return LZO_E_LOOKBEHIND_OVERRUN;

	mov	eax, -6
	jmp	SHORT $LN128@lzo1x_deco
$LN195@lzo1x_deco:

; 61   : {

	mov	r9, QWORD PTR out_len$[rsp]
$output_overrun$97208:

; 443  : #endif
; 444  : 
; 445  : #if defined(HAVE_NEED_OP)
; 446  : output_overrun:
; 447  :     *out_len = pd(op, out);

	sub	rbx, r13

; 448  :     return LZO_E_OUTPUT_OVERRUN;

	mov	eax, -5
	mov	QWORD PTR [r9], rbx
	jmp	SHORT $LN128@lzo1x_deco
$LN112@lzo1x_deco:

; 424  :     }
; 425  : 
; 426  : #if defined(HAVE_TEST_IP) || defined(HAVE_TEST_OP)
; 427  :     /* no EOF code was found */
; 428  :     *out_len = pd(op, out);

	mov	rax, QWORD PTR out_len$[rsp]
	sub	rbx, r13
	mov	QWORD PTR [rax], rbx

; 429  :     return LZO_E_EOF_NOT_FOUND;

	mov	eax, -7
$LN128@lzo1x_deco:
	mov	rsi, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+104]

; 455  : #endif
; 456  : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rbx
	ret	0
lzo1x_decompress_dict_safe ENDP
END
