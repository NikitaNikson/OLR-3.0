; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?g_bEnableStatGather@@3HA			; g_bEnableStatGather
EXTRN	__imp_memmove:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Orphan_all@_Container_base0@std@@QEAAXXZ:PROC
EXTRN	atexit:PROC
?g_bEnableStatGather@@3HA DD 01H DUP (?)		; g_bEnableStatGather
_BSS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
PUBLIC	??0CTimer@@QEAA@XZ				; CTimer::CTimer
PUBLIC	??0CTimerBase@@QEAA@XZ				; CTimerBase::CTimerBase
PUBLIC	??1pauseMngr@@QEAA@XZ				; pauseMngr::~pauseMngr
PUBLIC	??1?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ ; xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::~xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >
PUBLIC	??1?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::~vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >
PUBLIC	?_Tidy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXXZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Tidy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >::_Getal
PUBLIC	??0?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >
PUBLIC	??0?$xalloc@PEAVCTimer_paused@@@@QEAA@XZ	; xalloc<CTimer_paused * __ptr64>::xalloc<CTimer_paused * __ptr64>
PUBLIC	?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@_K@Z ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::deallocate
PUBLIC	?deallocate@?$xalloc@PEAVCTimer_paused@@@@QEBAXPEAPEAVCTimer_paused@@_K@Z ; xalloc<CTimer_paused * __ptr64>::deallocate
PUBLIC	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
PUBLIC	?_Destroy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXPEAPEAVCTimer_paused@@0@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Destroy
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAXPEAPEAVCTimer_paused@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >
PUBLIC	??$_Ptr_cat@PEAVCTimer_paused@@PEAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVCTimer_paused@@0@Z ; std::_Ptr_cat<CTimer_paused * __ptr64,CTimer_paused * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAXPEAPEAVCTimer_paused@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >
PUBLIC	?Pause@CTimer_paused_ex@@QEAAXH@Z		; CTimer_paused_ex::Pause
PUBLIC	?GetElapsed_ticks@CTimerBase@@QEBA_KXZ		; CTimerBase::GetElapsed_ticks
PUBLIC	?capacity@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::capacity
PUBLIC	?max_size@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SA_KAEBV?$xalloc@PEAVCTimer_paused@@@@@Z ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::max_size
PUBLIC	??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@PEAVCTimer_paused@@@@@Z ; std::_Alloc_max_size::_Fn<xalloc<CTimer_paused * __ptr64> >
PUBLIC	?max_size@?$xalloc@PEAVCTimer_paused@@@@QEBA_KXZ ; xalloc<CTimer_paused * __ptr64>::max_size
PUBLIC	?_Xlen@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXXZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Xlen
PUBLIC	??$construct@PEAVCTimer_paused@@AEAPEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@AEAPEAV2@@Z ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>
PUBLIC	??$forward@AEAPEAVCTimer_paused@@@std@@YAAEAPEAVCTimer_paused@@AEAPEAV1@@Z ; std::forward<CTimer_paused * __ptr64 & __ptr64>
PUBLIC	??$construct@PEAVCTimer_paused@@AEAPEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEAPEAV3@@Z ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@AEAPEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEAPEAV3@@Z ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>
PUBLIC	?construct@?$xalloc@PEAVCTimer_paused@@@@QEAAXPEAPEAVCTimer_paused@@AEBQEAV2@@Z ; xalloc<CTimer_paused * __ptr64>::construct
PUBLIC	??$_Construct@PEAVCTimer_paused@@AEBQEAV1@@std@@YAXPEAPEAVCTimer_paused@@AEBQEAV1@@Z ; std::_Construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>
PUBLIC	??$forward@AEBQEAVCTimer_paused@@@std@@YAAEBQEAVCTimer_paused@@AEBQEAV1@@Z ; std::forward<CTimer_paused * __ptr64 const & __ptr64>
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	??$construct@PEAVCTimer_paused@@AEBQEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@AEBQEAV2@@Z ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>
PUBLIC	??$construct@PEAVCTimer_paused@@AEBQEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEBQEAV3@@Z ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>
PUBLIC	??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@AEBQEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEBQEAV3@@Z ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@QEAA@AEBV?$xalloc@PEAVCTimer_paused@@@@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> >::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAPEAPEAVCTimer_paused@@_K@Z ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::allocate
PUBLIC	?allocate@?$xalloc@PEAVCTimer_paused@@@@QEBAPEAPEAVCTimer_paused@@_KPEBX@Z ; xalloc<CTimer_paused * __ptr64>::allocate
PUBLIC	??$xr_alloc@PEAVCTimer_paused@@@@YAPEAPEAVCTimer_paused@@I@Z ; xr_alloc<CTimer_paused * __ptr64>
PUBLIC	?size@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::size
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAA@PEAPEAVCTimer_paused@@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??$_Rechecked@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAAEAPEAPEAVCTimer_paused@@AEAPEAPEAV1@PEAPEAV1@@Z ; std::_Rechecked<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>
PUBLIC	??$_Unchecked@PEAPEAVCTimer_paused@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@@Z ; std::_Unchecked<CTimer_paused * __ptr64 * __ptr64>
PUBLIC	??$destroy@PEAVCTimer_paused@@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@@Z ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::destroy<CTimer_paused * __ptr64>
PUBLIC	??$destroy@PEAVCTimer_paused@@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@@Z ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::destroy<CTimer_paused * __ptr64>
PUBLIC	??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@@Z ; std::_Alloc_destroy::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>
PUBLIC	?destroy@?$xalloc@PEAVCTimer_paused@@@@QEAAXPEAPEAVCTimer_paused@@@Z ; xalloc<CTimer_paused * __ptr64>::destroy
PUBLIC	??$_Destroy@PEAVCTimer_paused@@@std@@YAXPEAPEAVCTimer_paused@@@Z ; std::_Destroy<CTimer_paused * __ptr64>
PUBLIC	??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@PEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@$$QEAPEAV3@@Z ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64>
PUBLIC	??$construct@PEAVCTimer_paused@@PEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@$$QEAPEAV3@@Z ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64>
PUBLIC	??$forward@PEAVCTimer_paused@@@std@@YA$$QEAPEAVCTimer_paused@@AEAPEAV1@@Z ; std::forward<CTimer_paused * __ptr64>
PUBLIC	??$construct@PEAVCTimer_paused@@PEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@$$QEAPEAV2@@Z ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>
PUBLIC	??$_Val_type@PEAPEAVCTimer_paused@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@@Z ; std::_Val_type<CTimer_paused * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >
PUBLIC	??$_Find@PEAPEAVCTimer_paused@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@0AEBQEAV1@U?$integral_constant@_N$0A@@0@@Z ; std::_Find<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64>
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAPEAPEAVCTimer_paused@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Unchecked
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAVCTimer_paused@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Rechecked
PUBLIC	??$_Uninitialized_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z ; std::_Uninitialized_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >
PUBLIC	??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@AEAV10@PEAPEAVCTimer_paused@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >
PUBLIC	??$_Find@PEAPEAVCTimer_paused@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@0AEBQEAV1@@Z ; std::_Find<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@YAPEAPEAVCTimer_paused@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >
PUBLIC	??$_Umove@PEAPEAVCTimer_paused@@@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAPEAPEAVCTimer_paused@@PEAPEAV2@00@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Umove<CTimer_paused * __ptr64 * __ptr64>
PUBLIC	??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00@Z ; std::_Move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>
PUBLIC	??$addressof@QEAVCTimer_paused@@@std@@YAPEBQEAVCTimer_paused@@AEBQEAV1@@Z ; std::addressof<CTimer_paused * __ptr64 const>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@PEAVCTimer_paused@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@V10@0AEBQEAVCTimer_paused@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >,CTimer_paused * __ptr64>
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Compat
PUBLIC	?_Grow_to@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBA_K_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Grow_to
PUBLIC	?_Unused_capacity@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Unused_capacity
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAA@PEAPEAVCTimer_paused@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator==
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator++
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAAEBQEAVCTimer_paused@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator*
PUBLIC	?_Orphan_range@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXPEAPEAVCTimer_paused@@0@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reserve
PUBLIC	?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate
PUBLIC	?_Inside@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBA_NPEBQEAVCTimer_paused@@@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Inside
PUBLIC	?_Make_iter@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Make_iter
PUBLIC	??0?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator++
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAAEAPEAVCTimer_paused@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator!=
PUBLIC	?erase@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::erase
PUBLIC	?push_back@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXAEBQEAVCTimer_paused@@@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::push_back
PUBLIC	?end@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@XZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::end
PUBLIC	?begin@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@XZ ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::begin
PUBLIC	?reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::reserve
PUBLIC	??0?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ ; xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >
PUBLIC	?UnRegister@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z ; pauseMngr::UnRegister
PUBLIC	?Register@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z	; pauseMngr::Register
PUBLIC	?Pause@pauseMngr@@QEAAXH@Z			; pauseMngr::Pause
PUBLIC	??0pauseMngr@@QEAA@XZ				; pauseMngr::pauseMngr
PUBLIC	?FrameEnd@CStatTimer@@QEAAXXZ			; CStatTimer::FrameEnd
PUBLIC	?FrameStart@CStatTimer@@QEAAXXZ			; CStatTimer::FrameStart
PUBLIC	??0CStatTimer@@QEAA@XZ				; CStatTimer::CStatTimer
PUBLIC	?CalcEMA@@YAMAEAMMMM@Z				; CalcEMA
PUBLIC	?g_pauseMngr@@3VpauseMngr@@A			; g_pauseMngr
PUBLIC	__isa_available_default
PUBLIC	__real@24e69595
PUBLIC	__real@33d6bf95
PUBLIC	__real@37800080
PUBLIC	__real@3a83126f
PUBLIC	__real@3b80807d
PUBLIC	__real@3c23d70a
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e22f983
PUBLIC	__real@3f000000
PUBLIC	__real@3f666666
PUBLIC	__real@3f7d70a4
PUBLIC	__real@3f7fbe77
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@40c90fdb
PUBLIC	__real@412e848000000000
PUBLIC	__real@42fc0000
PUBLIC	__real@437f0000
PUBLIC	__real@43e0000000000000
PUBLIC	__real@43f0000000000000
PUBLIC	__real@447a0000
PUBLIC	__real@477fff00
PUBLIC	__xmm@0000000000000000000000003f800000
PUBLIC	__xmm@00000000000000003f80000000000000
PUBLIC	__xmm@00000000000000003ff0000000000000
PUBLIC	__xmm@000000003f8000000000000000000000
PUBLIC	__xmm@00000001000000010000000100000001
PUBLIC	__xmm@00000003000000020000000100000000
PUBLIC	__xmm@0000000c0000000c0000000c0000000c
PUBLIC	__xmm@00000273000002730000027300000273
PUBLIC	__xmm@3f800000000000000000000000000000
PUBLIC	__xmm@3ff00000000000000000000000000000
PUBLIC	__xmm@7fffffff7fffffff7fffffff7fffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	_CxxThrowException:PROC
EXTRN	__C_specific_handler:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__RTCastToVoid:PROC
EXTRN	__chkstk:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__isa_available:DWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
?g_pauseMngr@@3VpauseMngr@@A DB 020H DUP (?)		; g_pauseMngr
_BSS	ENDS
;	COMDAT __isa_available_default
_BSS	SEGMENT
__isa_available_default DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1pauseMngr@@QEAA@XZ DD imagerel $LN19
	DD	imagerel $LN19+51
	DD	imagerel $unwind$??1pauseMngr@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ DD imagerel $LN17
	DD	imagerel $LN17+51
	DD	imagerel $unwind$??1?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+51
	DD	imagerel $unwind$??1?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+51
	DD	imagerel $unwind$?_Tidy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@_K@Z DD imagerel $LN6
	DD	imagerel $LN6+29
	DD	imagerel $unwind$?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$xalloc@PEAVCTimer_paused@@@@QEBAXPEAPEAVCTimer_paused@@_K@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$?deallocate@?$xalloc@PEAVCTimer_paused@@@@QEBAXPEAPEAVCTimer_paused@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z DD imagerel $LN30
	DD	imagerel $LN30+87
	DD	imagerel $unwind$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z DD imagerel $LN30+87
	DD	imagerel $LN30+131
	DD	imagerel $chain$0$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z DD imagerel $LN30+131
	DD	imagerel $LN30+149
	DD	imagerel $chain$1$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Pause@CTimer_paused_ex@@QEAAXH@Z DD imagerel $LN15
	DD	imagerel $LN15+166
	DD	imagerel $unwind$?Pause@CTimer_paused_ex@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetElapsed_ticks@CTimerBase@@QEBA_KXZ DD imagerel $LN8
	DD	imagerel $LN8+67
	DD	imagerel $unwind$?GetElapsed_ticks@CTimerBase@@QEBA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+60
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAPEAVCTimer_paused@@@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAPEAPEAVCTimer_paused@@PEAPEAV2@00@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Umove@PEAPEAVCTimer_paused@@@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAPEAPEAVCTimer_paused@@PEAPEAV2@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00@Z DD imagerel $LN8
	DD	imagerel $LN8+58
	DD	imagerel $unwind$??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD imagerel $LN47
	DD	imagerel $LN47+140
	DD	imagerel $unwind$?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD imagerel $LN54
	DD	imagerel $LN54+153
	DD	imagerel $unwind$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA+40
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z DD imagerel $LN18
	DD	imagerel $LN18+75
	DD	imagerel $unwind$?erase@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXAEBQEAVCTimer_paused@@@Z DD imagerel $LN69
	DD	imagerel $LN69+134
	DD	imagerel $unwind$?push_back@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXAEBQEAVCTimer_paused@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?UnRegister@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z DD imagerel $LN80
	DD	imagerel $LN80+68
	DD	imagerel $unwind$?UnRegister@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z
$pdata$?Register@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z DD imagerel $LN71
	DD	imagerel $LN71+151
	DD	imagerel $unwind$?Register@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z
$pdata$?Pause@pauseMngr@@QEAAXH@Z DD imagerel $LN42
	DD	imagerel $LN42+20
	DD	imagerel $unwind$?Pause@pauseMngr@@QEAAXH@Z
$pdata$0$?Pause@pauseMngr@@QEAAXH@Z DD imagerel $LN42+20
	DD	imagerel $LN42+62
	DD	imagerel $chain$0$?Pause@pauseMngr@@QEAAXH@Z
$pdata$1$?Pause@pauseMngr@@QEAAXH@Z DD imagerel $LN42+62
	DD	imagerel $LN42+73
	DD	imagerel $chain$1$?Pause@pauseMngr@@QEAAXH@Z
$pdata$??0pauseMngr@@QEAA@XZ DD imagerel $LN37
	DD	imagerel $LN37+61
	DD	imagerel $unwind$??0pauseMngr@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Fg_pauseMngr@@YAXXZ DD imagerel ??__Fg_pauseMngr@@YAXXZ
	DD	imagerel ??__Fg_pauseMngr@@YAXXZ+78
	DD	imagerel $unwind$??__Fg_pauseMngr@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eg_pauseMngr@@YAXXZ DD imagerel ??__Eg_pauseMngr@@YAXXZ
	DD	imagerel ??__Eg_pauseMngr@@YAXXZ+47
	DD	imagerel $unwind$??__Eg_pauseMngr@@YAXXZ
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffff7fffffff7fffffff7fffffff
CONST	SEGMENT
__xmm@7fffffff7fffffff7fffffff7fffffff DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __xmm@3ff00000000000000000000000000000
CONST	SEGMENT
__xmm@3ff00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, '?'
CONST	ENDS
;	COMDAT __xmm@3f800000000000000000000000000000
CONST	SEGMENT
__xmm@3f800000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __xmm@00000273000002730000027300000273
CONST	SEGMENT
__xmm@00000273000002730000027300000273 DB 's', 02H, 00H, 00H, 's', 02H, 00H
	DB	00H, 's', 02H, 00H, 00H, 's', 02H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000c0000000c0000000c0000000c
CONST	SEGMENT
__xmm@0000000c0000000c0000000c0000000c DB 0cH, 00H, 00H, 00H, 0cH, 00H, 00H
	DB	00H, 0cH, 00H, 00H, 00H, 0cH, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000003000000020000000100000000
CONST	SEGMENT
__xmm@00000003000000020000000100000000 DB 00H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 02H, 00H, 00H, 00H, 03H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000001000000010000000100000001
CONST	SEGMENT
__xmm@00000001000000010000000100000001 DB 01H, 00H, 00H, 00H, 01H, 00H, 00H
	DB	00H, 01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@000000003f8000000000000000000000
CONST	SEGMENT
__xmm@000000003f8000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 080H, '?', 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000003ff0000000000000
CONST	SEGMENT
__xmm@00000000000000003ff0000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 0f0H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@00000000000000003f80000000000000
CONST	SEGMENT
__xmm@00000000000000003f80000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 080H
	DB	'?', 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __xmm@0000000000000000000000003f800000
CONST	SEGMENT
__xmm@0000000000000000000000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43f0000000000000
CONST	SEGMENT
__real@43f0000000000000 DQ 043f0000000000000r	; 1.84467e+019
CONST	ENDS
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+018
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42fc0000
CONST	SEGMENT
__real@42fc0000 DD 042fc0000r			; 126
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT __real@40c90fdb
CONST	SEGMENT
__real@40c90fdb DD 040c90fdbr			; 6.28319
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f7fbe77
CONST	SEGMENT
__real@3f7fbe77 DD 03f7fbe77r			; 0.999
CONST	ENDS
;	COMDAT __real@3f7d70a4
CONST	SEGMENT
__real@3f7d70a4 DD 03f7d70a4r			; 0.99
CONST	ENDS
;	COMDAT __real@3f666666
CONST	SEGMENT
__real@3f666666 DD 03f666666r			; 0.9
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e22f983
CONST	SEGMENT
__real@3e22f983 DD 03e22f983r			; 0.159155
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3b80807d
CONST	SEGMENT
__real@3b80807d DD 03b80807dr			; 0.00392157
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@37800080
CONST	SEGMENT
__real@37800080 DD 037800080r			; 1.5259e-005
CONST	ENDS
;	COMDAT __real@33d6bf95
CONST	SEGMENT
__real@33d6bf95 DD 033d6bf95r			; 1e-007
CONST	ENDS
;	COMDAT __real@24e69595
CONST	SEGMENT
__real@24e69595 DD 024e69595r			; 1e-016
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eg_pauseMngr@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Fg_pauseMngr@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
xdata	SEGMENT
$unwind$?UnRegister@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z DD 020601H
	DD	030023206H
$unwind$?Register@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
$unwind$?Pause@pauseMngr@@QEAAXH@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
$chain$0$?Pause@pauseMngr@@QEAAXH@Z DD 020521H
	DD	063405H
	DD	imagerel $LN42
	DD	imagerel $LN42+20
	DD	imagerel $unwind$?Pause@pauseMngr@@QEAAXH@Z
$chain$1$?Pause@pauseMngr@@QEAAXH@Z DD 021H
	DD	imagerel $LN42
	DD	imagerel $LN42+20
	DD	imagerel $unwind$?Pause@pauseMngr@@QEAAXH@Z
$unwind$??0pauseMngr@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXAEBQEAVCTimer_paused@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z+62
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z+78
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD 081e19H
	DD	0d741eH
	DD	0c6419H
	DD	0a3414H
	DD	0e0027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAPEAVCTimer_paused@@@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAPEAPEAVCTimer_paused@@PEAPEAV2@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00U_Scalar_ptr_iterator_tag@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+52
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetElapsed_ticks@CTimerBase@@QEBA_KXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Pause@CTimer_paused_ex@@QEAAXH@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+87
	DD	imagerel $unwind$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+87
	DD	imagerel $unwind$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$xalloc@PEAVCTimer_paused@@@@QEBAXPEAPEAVCTimer_paused@@_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@_K@Z DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1pauseMngr@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
CRT$XCU	SEGMENT
g_pauseMngr$initializer$ DQ FLAT:??__Eg_pauseMngr@@YAXXZ
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
CRT$XCU	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
_TEXT	SEGMENT
avg$ = 8
src$ = 16
period$ = 24
treshold$ = 32
?CalcEMA@@YAMAEAMMMM@Z PROC				; CalcEMA

; 8    : 	float f = 1 / period;

	movss	xmm0, DWORD PTR __real@3f800000

; 9    : 	avg = avg > treshold ? avg * (1 - f) + src * f : src;

	movss	xmm5, DWORD PTR [rcx]
	comiss	xmm5, xmm3
	movaps	xmm4, xmm0
	divss	xmm4, xmm2
	jbe	SHORT $LN3@CalcEMA
	subss	xmm0, xmm4
	mulss	xmm4, xmm1
	mulss	xmm0, xmm5
	addss	xmm0, xmm4
	movss	DWORD PTR [rcx], xmm0

; 11   : }

	ret	0
$LN3@CalcEMA:

; 9    : 	avg = avg > treshold ? avg * (1 - f) + src * f : src;

	movss	DWORD PTR [rcx], xmm1

; 10   : 	return avg;

	movaps	xmm0, xmm1

; 11   : }

	ret	0
?CalcEMA@@YAMAEAMMMM@Z ENDP				; CalcEMA
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
_TEXT	SEGMENT
this$ = 8
??0CStatTimer@@QEAA@XZ PROC				; CStatTimer::CStatTimer
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h

; 28   : 				CTimerBase		()		: qwStartTime(0),qwPausedTime(0),qwPauseAccum(0),bPause(FALSE)		{ }

	xor	eax, eax

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}
; 30   : 	ICF u64		GetElapsed_ticks()const	{	if(bPause) return	qwPausedTime; else return CPU::QPC()-qwStartTime-CPU::qpc_overhead-qwPauseAccum; }
; 31   : 	IC	u32		GetElapsed_ms	()const	{	return u32(GetElapsed_ticks()*u64(1000)/CPU::qpc_freq );	}
; 32   : 	IC	float	GetElapsed_sec	()const	{
; 33   : #ifndef _EDITOR
; 34   : 		FPU::m64r	()			;
; 35   : #endif        
; 36   : 		float		_result		=		float(double(GetElapsed_ticks())/double(CPU::qpc_freq )	)	;
; 37   : #ifndef _EDITOR
; 38   : 		FPU::m24r	()			;
; 39   : #endif
; 40   : 		return		_result		;
; 41   : 	}
; 42   : 	IC	void	Dump			() const
; 43   : 	{
; 44   : 		Msg("* Elapsed time (sec): %f",GetElapsed_sec());
; 45   : 	}
; 46   : };
; 47   : 
; 48   : class XRCORE_API CTimer : public CTimerBase {
; 49   : private:
; 50   : 	typedef CTimerBase					inherited;
; 51   : 
; 52   : private:
; 53   : 	float				m_time_factor;
; 54   : 	u64					m_real_ticks;
; 55   : 	u64					m_ticks;
; 56   : 
; 57   : private:
; 58   : 	IC	u64				GetElapsed_ticks(const u64 &current_ticks) const
; 59   : 	{
; 60   : 		u64				delta = current_ticks - m_real_ticks;
; 61   : 		double			delta_d = (double)delta;
; 62   : 		double			time_factor_d = time_factor();
; 63   : 		double			time = delta_d*time_factor_d + .5;
; 64   : 		u64				result = (u64)time;
; 65   : 		return			(m_ticks + result);
; 66   : 	}
; 67   : 
; 68   : public:
; 69   : 	IC					CTimer			() : m_time_factor(1.f), m_real_ticks(0), m_ticks(0) {}

	mov	DWORD PTR [rcx+32], 1065353216		; 3f800000H

; 28   : 				CTimerBase		()		: qwStartTime(0),qwPausedTime(0),qwPauseAccum(0),bPause(FALSE)		{ }

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	DWORD PTR [rcx+24], eax

; 29   : 	ICF	void	Start			()		{	if(bPause) return;	qwStartTime = CPU::QPC()-qwPauseAccum;		}
; 30   : 	ICF u64		GetElapsed_ticks()const	{	if(bPause) return	qwPausedTime; else return CPU::QPC()-qwStartTime-CPU::qpc_overhead-qwPauseAccum; }
; 31   : 	IC	u32		GetElapsed_ms	()const	{	return u32(GetElapsed_ticks()*u64(1000)/CPU::qpc_freq );	}
; 32   : 	IC	float	GetElapsed_sec	()const	{
; 33   : #ifndef _EDITOR
; 34   : 		FPU::m64r	()			;
; 35   : #endif        
; 36   : 		float		_result		=		float(double(GetElapsed_ticks())/double(CPU::qpc_freq )	)	;
; 37   : #ifndef _EDITOR
; 38   : 		FPU::m24r	()			;
; 39   : #endif
; 40   : 		return		_result		;
; 41   : 	}
; 42   : 	IC	void	Dump			() const
; 43   : 	{
; 44   : 		Msg("* Elapsed time (sec): %f",GetElapsed_sec());
; 45   : 	}
; 46   : };
; 47   : 
; 48   : class XRCORE_API CTimer : public CTimerBase {
; 49   : private:
; 50   : 	typedef CTimerBase					inherited;
; 51   : 
; 52   : private:
; 53   : 	float				m_time_factor;
; 54   : 	u64					m_real_ticks;
; 55   : 	u64					m_ticks;
; 56   : 
; 57   : private:
; 58   : 	IC	u64				GetElapsed_ticks(const u64 &current_ticks) const
; 59   : 	{
; 60   : 		u64				delta = current_ticks - m_real_ticks;
; 61   : 		double			delta_d = (double)delta;
; 62   : 		double			time_factor_d = time_factor();
; 63   : 		double			time = delta_d*time_factor_d + .5;
; 64   : 		u64				result = (u64)time;
; 65   : 		return			(m_ticks + result);
; 66   : 	}
; 67   : 
; 68   : public:
; 69   : 	IC					CTimer			() : m_time_factor(1.f), m_real_ticks(0), m_ticks(0) {}

	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 17   : 	accum	= 0;

	mov	QWORD PTR [rcx+56], rax

; 18   : 	result	= 0.f;

	mov	DWORD PTR [rcx+64], eax

; 19   : 	count	= 0;

	mov	DWORD PTR [rcx+100], eax

; 20   : }

	mov	rax, rcx
	ret	0
??0CStatTimer@@QEAA@XZ ENDP				; CStatTimer::CStatTimer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
_TEXT	SEGMENT
this$ = 8
?FrameStart@CStatTimer@@QEAAXXZ PROC			; CStatTimer::FrameStart

; 24   : 	accum	= 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+56], rax

; 25   : 	count	= 0;

	mov	QWORD PTR [rcx+100], rax

; 26   : 	cycles  = 0;
; 27   : }

	ret	0
?FrameStart@CStatTimer@@QEAAXXZ ENDP			; CStatTimer::FrameStart
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
_TEXT	SEGMENT
this$ = 8
?FrameEnd@CStatTimer@@QEAAXXZ PROC			; CStatTimer::FrameEnd

; 30   : 	float _time			= 1000.f*float(double(accum)/double(CPU::qpc_freq)	)	;

	mov	rax, QWORD PTR [rcx+56]
	movsdx	xmm2, QWORD PTR __real@43f0000000000000
	xorps	xmm0, xmm0
	cvtsi2sd xmm0, rax
	test	rax, rax
	jns	SHORT $LN18@FrameEnd
	addsd	xmm0, xmm2
$LN18@FrameEnd:
	mov	rax, QWORD PTR ?qpc_freq@CPU@@3_KA	; CPU::qpc_freq
	xorps	xmm1, xmm1
	cvtsi2sd xmm1, rax
	test	rax, rax
	jns	SHORT $LN17@FrameEnd
	addsd	xmm1, xmm2
$LN17@FrameEnd:

; 31   : 	if (_time > result)	result	=	_time		;

	movss	xmm3, DWORD PTR __real@3c23d70a
	movss	xmm4, DWORD PTR __real@3f7d70a4
	divsd	xmm0, xmm1
	movss	xmm1, DWORD PTR [rcx+64]
	cvtpd2ps xmm0, xmm0
	mulss	xmm0, DWORD PTR __real@447a0000
	comiss	xmm0, xmm1
	ja	SHORT $LN19@FrameEnd

; 32   : 	else				result	=	0.99f*result + 0.01f*_time; // EMA 100

	mulss	xmm0, xmm3
	mulss	xmm1, xmm4
	addss	xmm0, xmm1
$LN19@FrameEnd:

; 9    : 	avg = avg > treshold ? avg * (1 - f) + src * f : src;

	movss	xmm2, DWORD PTR __real@3dcccccd

; 32   : 	else				result	=	0.99f*result + 0.01f*_time; // EMA 100

	movss	DWORD PTR [rcx+64], xmm0

; 33   : 	CalcEMA(xrs[0], result, 10);

	movss	xmm1, xmm0

; 9    : 	avg = avg > treshold ? avg * (1 - f) + src * f : src;

	movss	xmm0, DWORD PTR [rcx+68]
	comiss	xmm0, xmm2
	jbe	SHORT $LN7@FrameEnd
	mulss	xmm0, DWORD PTR __real@3f666666
	mulss	xmm1, xmm2
	addss	xmm0, xmm1
	jmp	SHORT $LN8@FrameEnd
$LN7@FrameEnd:
	movaps	xmm0, xmm1
$LN8@FrameEnd:
	movss	DWORD PTR [rcx+68], xmm0
	movss	xmm0, DWORD PTR [rcx+72]

; 34   : 	CalcEMA(xrs[1], result, 100);

	movss	xmm1, DWORD PTR [rcx+64]

; 9    : 	avg = avg > treshold ? avg * (1 - f) + src * f : src;

	comiss	xmm0, xmm2
	jbe	SHORT $LN11@FrameEnd
	mulss	xmm0, xmm4
	mulss	xmm1, xmm3
	addss	xmm0, xmm1
	jmp	SHORT $LN12@FrameEnd
$LN11@FrameEnd:
	movaps	xmm0, xmm1
$LN12@FrameEnd:
	movss	DWORD PTR [rcx+72], xmm0
	movss	xmm1, DWORD PTR [rcx+76]

; 35   : 	CalcEMA(xrs[2], result, 1000);

	movss	xmm0, DWORD PTR [rcx+64]

; 9    : 	avg = avg > treshold ? avg * (1 - f) + src * f : src;

	comiss	xmm1, xmm2
	jbe	SHORT $LN15@FrameEnd
	mulss	xmm0, DWORD PTR __real@3a83126f
	mulss	xmm1, DWORD PTR __real@3f7fbe77
	addss	xmm0, xmm1
$LN15@FrameEnd:
	movss	DWORD PTR [rcx+76], xmm0

; 36   : }

	ret	0
?FrameEnd@CStatTimer@@QEAAXXZ ENDP			; CStatTimer::FrameEnd
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
;	COMDAT ??__Eg_pauseMngr@@YAXXZ
text$di	SEGMENT
$T1 = 48
??__Eg_pauseMngr@@YAXXZ PROC				; `dynamic initializer for 'g_pauseMngr'', COMDAT

; 38   : XRCORE_API pauseMngr	g_pauseMngr;

	sub	rsp, 40					; 00000028H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 642  : 		return (_Alty());

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >

; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	lea	rcx, OFFSET FLAT:?g_pauseMngr@@3VpauseMngr@@A ; g_pauseMngr
	mov	edx, 3
	call	?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 38   : XRCORE_API pauseMngr	g_pauseMngr;

	lea	rcx, OFFSET FLAT:??__Fg_pauseMngr@@YAXXZ ; `dynamic atexit destructor for 'g_pauseMngr''
	add	rsp, 40					; 00000028H
	jmp	atexit
??__Eg_pauseMngr@@YAXXZ ENDP				; `dynamic initializer for 'g_pauseMngr''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??__Fg_pauseMngr@@YAXXZ
text$yd	SEGMENT
$T1 = 48
p$2 = 56
??__Fg_pauseMngr@@YAXXZ PROC				; `dynamic atexit destructor for 'g_pauseMngr'', COMDAT
	sub	rsp, 40					; 00000028H

; 1623 : 		if (this->_Myfirst != pointer())

	cmp	QWORD PTR ?g_pauseMngr@@3VpauseMngr@@A, 0
	je	SHORT $LN9@dynamic

; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);

	call	?_Destroy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXPEAPEAVCTimer_paused@@0@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Destroy

; 642  : 		return (_Alty());

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR ?g_pauseMngr@@3VpauseMngr@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$2[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$2[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR ?g_pauseMngr@@3VpauseMngr@@A+16, 0
	xorps	xmm0, xmm0
	movdqu	XMMWORD PTR ?g_pauseMngr@@3VpauseMngr@@A, xmm0
$LN9@dynamic:
	add	rsp, 40					; 00000028H
	ret	0
??__Fg_pauseMngr@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_pauseMngr''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
_TEXT	SEGMENT
this$ = 48
??0pauseMngr@@QEAA@XZ PROC				; pauseMngr::pauseMngr

; 42   : {

$LN37:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 42   : {

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 42   : {

	mov	DWORD PTR [rcx+24], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)

	cmp	rax, 3
	jae	SHORT $LN35@pauseMngr

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	mov	edx, 3
	call	?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate
$LN35@pauseMngr:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 44   : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0pauseMngr@@QEAA@XZ ENDP				; pauseMngr::pauseMngr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
_TEXT	SEGMENT
this$ = 48
b$ = 56
?Pause@pauseMngr@@QEAAXH@Z PROC				; pauseMngr::Pause

; 47   : {

$LN42:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	esi, edx
	mov	rdi, rcx

; 48   : 	if(m_paused == b)return;

	cmp	DWORD PTR [rcx+24], edx
	je	SHORT $LN5@Pause
	mov	QWORD PTR [rsp+48], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

	mov	rbx, QWORD PTR [rcx]

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 51   : 	for(;it!=m_timers.end();++it)

	je	SHORT $LN1@Pause
$LL17@Pause:

; 52   : 		(*it)->Pause(b);

	mov	rcx, QWORD PTR [rbx]
	mov	edx, esi
	call	?Pause@CTimer_paused_ex@@QEAAXH@Z	; CTimer_paused_ex::Pause
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rbx, 8

; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR [rdi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 51   : 	for(;it!=m_timers.end();++it)

	jne	SHORT $LL17@Pause
$LN1@Pause:
	mov	rbx, QWORD PTR [rsp+48]

; 53   : 
; 54   : 	m_paused = b;

	mov	DWORD PTR [rdi+24], esi
$LN5@Pause:

; 55   : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Pause@pauseMngr@@QEAAXH@Z ENDP				; pauseMngr::Pause
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
_TEXT	SEGMENT
this$ = 48
t$ = 56
?Register@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z PROC	; pauseMngr::Register

; 57   : void pauseMngr::Register (CTimer_paused* t){

$LN71:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 57   : void pauseMngr::Register (CTimer_paused* t){

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rcx, QWORD PTR t$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 57   : void pauseMngr::Register (CTimer_paused* t){

	mov	rdi, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rcx, rax
	jae	SHORT $LN6@Register
	mov	rcx, QWORD PTR [rbx]
	lea	rdx, QWORD PTR t$[rsp]
	cmp	rcx, rdx
	ja	SHORT $LN6@Register

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rdi, QWORD PTR t$[rsp]
	sub	rdi, rcx
	sar	rdi, 3

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN5@Register

; 1248 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reserve
$LN5@Register:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN63@Register
	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax+rdi*8]
	mov	QWORD PTR [rdx], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 59   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@Register:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN3@Register

; 1257 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reserve
$LN3@Register:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rbx+8]
	test	rax, rax
	je	SHORT $LN63@Register
	mov	QWORD PTR [rax], rdi
$LN63@Register:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 59   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Register@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z ENDP	; pauseMngr::Register
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp
_TEXT	SEGMENT
this$ = 48
t$ = 56
?UnRegister@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z PROC	; pauseMngr::UnRegister

; 61   : void pauseMngr::UnRegister (CTimer_paused* t){

$LN80:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 396  : 	return (_Iter._Unchecked());

	mov	r8, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 61   : void pauseMngr::UnRegister (CTimer_paused* t){

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

	mov	rcx, QWORD PTR [rcx]

; 2432 : 	return (_Dest + _Count);
; 2433 : 	}
; 2434 : 
; 2435 : template<class _InIt,
; 2436 : 	class _OutIt> inline
; 2437 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2438 : 		_OutIt _Dest)
; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked
; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}
; 2443 : 
; 2444 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2445 : template<class _InIt,
; 2446 : 	class _OutIt> inline
; 2447 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2448 : 		_OutIt _Dest)
; 2449 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2450 : 	return (_Rechecked(_Dest,
; 2451 : 		_Move(_Unchecked(_First), _Unchecked(_Last),
; 2452 : 			_Unchecked(_Dest))));
; 2453 : 	}
; 2454 : 
; 2455 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2456 : template<class _InIt,
; 2457 : 	class _OutIt> inline
; 2458 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2459 : 		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
; 2460 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2461 : 	return (_Move(_First, _Last,
; 2462 : 		_Dest));
; 2463 : 	}
; 2464 : 
; 2465 : template<class _InIt,
; 2466 : 	class _OutIt> inline
; 2467 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2468 : 		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
; 2469 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators
; 2470 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
; 2471 : 	_Move(_First, _Last,
; 2472 : 		_Unchecked(_Dest));
; 2473 : 	return (_Ans);
; 2474 : 	}
; 2475 : 
; 2476 : template<class _InIt,
; 2477 : 	class _OutIt> inline
; 2478 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2479 : 		_OutIt _Dest, true_type)
; 2480 : 	{	// move [_First, _Last) to [_Dest, ...), checked dest
; 2481 : 	return (_Move(_First, _Last,
; 2482 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2483 : 	}
; 2484 : 
; 2485 : template<class _InIt,
; 2486 : 	class _OutIt> inline
; 2487 : _SCL_INSECURE_DEPRECATE
; 2488 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2489 : 		_OutIt _Dest, false_type)
; 2490 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked dest
; 2491 : 	return (_Move(_First, _Last,
; 2492 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2493 : 	}
; 2494 : 
; 2495 : template<class _InIt,
; 2496 : 	class _OutIt> inline
; 2497 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2498 : 		_OutIt _Dest)
; 2499 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2500 : 	_DEBUG_RANGE(_First, _Last);
; 2501 : 	_DEBUG_POINTER(_Dest);
; 2502 : 	return (_Move(_Unchecked(_First), _Unchecked(_Last),
; 2503 : 		_Dest, _Is_checked(_Dest)));
; 2504 : 	}
; 2505 : 
; 2506 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2507 : template<class _InIt,
; 2508 : 	class _OutTy,
; 2509 : 	size_t _OutSize> inline
; 2510 : 	_OutTy *move(_InIt _First, _InIt _Last,
; 2511 : 		_OutTy (&_Dest)[_OutSize])
; 2512 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2513 : 	return (_Unchecked(
; 2514 : 		_STD move(_First, _Last,
; 2515 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2516 : 	}
; 2517 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2518 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2519 : 
; 2520 : 		// TEMPLATE FUNCTION move_backward
; 2521 : template<class _BidIt1,
; 2522 : 	class _BidIt2> inline
; 2523 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2524 : 		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators
; 2526 : 	while (_First != _Last)
; 2527 : 		*--_Dest = _STD move(*--_Last);
; 2528 : 	return (_Dest);
; 2529 : 	}
; 2530 : 
; 2531 : template<class _InIt,
; 2532 : 	class _OutIt> inline
; 2533 : 	_OutIt _Move_backward(_InIt _First, _InIt _Last,
; 2534 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2535 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars
; 2536 : 	ptrdiff_t _Count = _Last - _First;
; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));
; 2539 : 	return (_Dest - _Count);
; 2540 : 	}
; 2541 : 
; 2542 : template<class _BidIt1,
; 2543 : 	class _BidIt2> inline
; 2544 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2545 : 		_BidIt2 _Dest)
; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked
; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2549 : 	}
; 2550 : 
; 2551 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2552 : template<class _BidIt1,
; 2553 : 	class _BidIt2> inline
; 2554 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2555 : 		_BidIt2 _Dest)
; 2556 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2557 : 	return (_Rechecked(_Dest,
; 2558 : 		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2559 : 			_Unchecked(_Dest))));
; 2560 : 	}
; 2561 : 
; 2562 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2563 : template<class _BidIt1,
; 2564 : 	class _BidIt2> inline
; 2565 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2566 : 		_BidIt2 _Dest, true_type)
; 2567 : 	{	// move [_First, _Last) backwards to [..., _Dest), checked dest
; 2568 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2569 : 		_Dest));
; 2570 : 	}
; 2571 : 
; 2572 : template<class _BidIt1,
; 2573 : 	class _BidIt2> inline
; 2574 : _SCL_INSECURE_DEPRECATE
; 2575 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2576 : 		_BidIt2 _Dest, false_type)
; 2577 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest
; 2578 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2579 : 		_Dest));
; 2580 : 	}
; 2581 : 
; 2582 : template<class _BidIt1,
; 2583 : 	class _BidIt2> inline
; 2584 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2585 : 		_BidIt2 _Dest)
; 2586 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2587 : 	_DEBUG_RANGE(_First, _Last);
; 2588 : 	_DEBUG_POINTER(_Dest);
; 2589 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2590 : 		_Dest, _Is_checked(_Dest)));
; 2591 : 	}
; 2592 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2593 : 
; 2594 : 		// TEMPLATE FUNCTION fill
; 2595 : template<class _FwdIt,
; 2596 : 	class _Ty> inline
; 2597 : 	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2598 : 	{	// copy _Val through [_First, _Last)
; 2599 : 	for (; _First != _Last; ++_First)
; 2600 : 		*_First = _Val;
; 2601 : 	}
; 2602 : 
; 2603 : inline void _Fill(char *_First, char *_Last, char _Val)
; 2604 : 	{	// copy char _Val through [_First, _Last)
; 2605 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2606 : 	}
; 2607 : 
; 2608 : inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
; 2609 : 	{	// copy signed char _Val through [_First, _Last)
; 2610 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2611 : 	}
; 2612 : 
; 2613 : inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
; 2614 : 	{	// copy unsigned char _Val through [_First, _Last)
; 2615 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2616 : 	}
; 2617 : 
; 2618 : template<class _FwdIt,
; 2619 : 	class _Ty> inline
; 2620 : 	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2621 : 	{	// copy _Val through [_First, _Last)
; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}
; 2625 : 
; 2626 : 		// TEMPLATE FUNCTION fill_n
; 2627 : template<class _OutIt,
; 2628 : 	class _Diff,
; 2629 : 	class _Ty> inline
; 2630 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)
; 2633 : 		*_Dest = _Val;
; 2634 : 	return (_Dest);
; 2635 : 	}
; 2636 : 
; 2637 : inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
; 2638 : 	{	// copy char _Val _Count times through [_Dest, ...)
; 2639 : 	_CSTD memset(_Dest, _Val, _Count);
; 2640 : 	return (_Dest + _Count);
; 2641 : 	}
; 2642 : 
; 2643 : inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
; 2644 : 	signed char _Val)
; 2645 : 	{	// copy signed char _Val _Count times through [_Dest, ...)
; 2646 : 	_CSTD memset(_Dest, _Val, _Count);
; 2647 : 	return (_Dest + _Count);
; 2648 : 	}
; 2649 : 
; 2650 : inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
; 2651 : 	unsigned char _Val)
; 2652 : 	{	// copy unsigned char _Val _Count times through [_Dest, ...)
; 2653 : 	_CSTD memset(_Dest, _Val, _Count);
; 2654 : 	return (_Dest + _Count);
; 2655 : 	}
; 2656 : 
; 2657 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2658 : template<class _OutIt,
; 2659 : 	class _Diff,
; 2660 : 	class _Ty> inline
; 2661 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2662 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2663 : 	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
; 2664 : 	}
; 2665 : 
; 2666 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2667 : template<class _OutIt,
; 2668 : 	class _Diff,
; 2669 : 	class _Ty> inline
; 2670 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2671 : 		_Mutable_iterator_tag)
; 2672 : 	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator
; 2673 : 	return (_Fill_n(_Dest, _Count, _Val));
; 2674 : 	}
; 2675 : 
; 2676 : template<class _OutIt,
; 2677 : 	class _Diff,
; 2678 : 	class _Ty> inline
; 2679 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2680 : 		random_access_iterator_tag)
; 2681 : 	{	// copy _Val _Count times through [_Dest, ...), random-access iterator
; 2682 : 	_OutIt _Ans = _Dest + _Count;	// also checks range
; 2683 : 	_Fill_n(_Unchecked(_Dest), _Count, _Val);
; 2684 : 	return (_Ans);
; 2685 : 	}
; 2686 : 
; 2687 : template<class _OutIt,
; 2688 : 	class _Diff,
; 2689 : 	class _Ty> inline
; 2690 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2691 : 		true_type)
; 2692 : 	{	// copy _Val _Count times through [_Dest, ...), checked dest
; 2693 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2694 : 		_Iter_cat(_Dest)));
; 2695 : 	}
; 2696 : 
; 2697 : template<class _OutIt,
; 2698 : 	class _Diff,
; 2699 : 	class _Ty> inline
; 2700 : _SCL_INSECURE_DEPRECATE
; 2701 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2702 : 		false_type)
; 2703 : 	{	// copy _Val _Count times through [_Dest, ...), unchecked dest
; 2704 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2705 : 		_Iter_cat(_Dest)));
; 2706 : 	}
; 2707 : 
; 2708 : template<class _OutIt,
; 2709 : 	class _Diff,
; 2710 : 	class _Ty> inline
; 2711 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2712 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2713 : 	_DEBUG_POINTER(_Dest);
; 2714 : 	return (_Fill_n(_Dest, _Count, _Val,
; 2715 : 		_Is_checked(_Dest)));
; 2716 : 	}
; 2717 : 
; 2718 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2719 : template<class _OutTy,
; 2720 : 	size_t _OutSize,
; 2721 : 	class _Diff,
; 2722 : 	class _Ty> inline
; 2723 : 	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
; 2724 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2725 : 	return (_Unchecked(_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
; 2726 : 		_Count, _Val)));
; 2727 : 	}
; 2728 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2729 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2730 : 
; 2731 : 		// TEMPLATE FUNCTION equal
; 2732 : template<class _InIt1,
; 2733 : 	class _InIt2> inline
; 2734 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
; 2735 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2736 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2737 : 		if (!(*_First1 == *_First2))
; 2738 : 			return (false);
; 2739 : 	return (true);
; 2740 : 	}
; 2741 : 
; 2742 : inline bool _Equal(const char *_First1, const char *_Last1,
; 2743 : 	const char *_First2)
; 2744 : 	{	// compare [_First1, _Last1) to [_First2, ...), for chars
; 2745 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2746 : 	}
; 2747 : 
; 2748 : inline bool _Equal(const signed char *_First1, const signed char *_Last1,
; 2749 : 	const signed char *_First2)
; 2750 : 	{	// compare [_First1, _Last1) to [_First2, ...), for signed chars
; 2751 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2752 : 	}
; 2753 : 
; 2754 : inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
; 2755 : 	const unsigned char *_First2)
; 2756 : 	{	// compare [_First1, _Last1) to [_First2, ...), for unsigned chars
; 2757 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2758 : 	}
; 2759 : 
; 2760 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2761 : template<class _InIt1,
; 2762 : 	class _InIt2> inline
; 2763 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2764 : 		_InIt2 _First2)
; 2765 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2766 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2767 : 		_Unchecked(_First2)));
; 2768 : 	}
; 2769 : 
; 2770 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2771 : template<class _InIt1,
; 2772 : 	class _InIt2> inline
; 2773 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2774 : 		_InIt2 _First2, true_type)
; 2775 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked dest
; 2776 : 	return (_Equal(_First1, _Last1,
; 2777 : 		_First2));
; 2778 : 	}
; 2779 : 
; 2780 : template<class _InIt1,
; 2781 : 	class _InIt2> inline
; 2782 : _SCL_INSECURE_DEPRECATE
; 2783 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2784 : 		_InIt2 _First2, false_type)
; 2785 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked dest
; 2786 : 	return (_Equal(_First1, _Last1,
; 2787 : 		_First2));
; 2788 : 	}
; 2789 : 
; 2790 : template<class _InIt1,
; 2791 : 	class _InIt2> inline
; 2792 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2793 : 		_InIt2 _First2)
; 2794 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2795 : 	_DEBUG_RANGE(_First1, _Last1);
; 2796 : 	_DEBUG_POINTER(_First2);
; 2797 : 	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),
; 2798 : 		_First2, _Is_checked(_First2)));
; 2799 : 	}
; 2800 : 
; 2801 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2802 : template<class _InIt1,
; 2803 : 	class _InTy,
; 2804 : 	size_t _InSize> inline
; 2805 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InTy (&_First2)[_InSize])
; 2807 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2808 : 	return (_STD equal(_First1, _Last1,
; 2809 : 		_Array_iterator<_InTy, _InSize>(_First2)));
; 2810 : 	}
; 2811 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2812 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2813 : 
; 2814 : 		// TEMPLATE FUNCTION equal WITH PRED
; 2815 : template<class _InIt1,
; 2816 : 	class _InIt2,
; 2817 : 	class _Pr> inline
; 2818 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
; 2819 : 		_InIt2 _First2, _Pr _Pred)
; 2820 : 	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
; 2821 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2822 : 		if (!_Pred(*_First1, *_First2))
; 2823 : 			return (false);
; 2824 : 	return (true);
; 2825 : 	}
; 2826 : 
; 2827 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2828 : template<class _InIt1,
; 2829 : 	class _InIt2,
; 2830 : 	class _Pr> inline
; 2831 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2832 : 		_InIt2 _First2, _Pr _Pred)
; 2833 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2834 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2835 : 		_Unchecked(_First2), _Pred));
; 2836 : 	}
; 2837 : 
; 2838 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2839 : template<class _InIt1,
; 2840 : 	class _InIt2,
; 2841 : 	class _Pr> inline
; 2842 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2843 : 		_InIt2 _First2, _Pr _Pred, true_type)
; 2844 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked input
; 2845 : 	return (_Equal(_First1, _Last1,
; 2846 : 		_First2, _Pred));
; 2847 : 	}
; 2848 : 
; 2849 : template<class _InIt1,
; 2850 : 	class _InIt2,
; 2851 : 	class _Pr> inline
; 2852 : _SCL_INSECURE_DEPRECATE
; 2853 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2854 : 		_InIt2 _First2, _Pr _Pred, false_type)
; 2855 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked input
; 2856 : 	return (_Equal(_First1, _Last1,
; 2857 : 		_First2, _Pred));
; 2858 : 	}
; 2859 : 
; 2860 : template<class _InIt1,
; 2861 : 	class _InIt2,
; 2862 : 	class _Pr> inline
; 2863 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2864 : 		_InIt2 _First2, _Pr _Pred)
; 2865 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2866 : 	_DEBUG_RANGE(_First1, _Last1);
; 2867 : 	_DEBUG_POINTER(_First2);
; 2868 : 	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
; 2869 : 		_First2, _Pred, _Is_checked(_First2)));
; 2870 : 	}
; 2871 : 
; 2872 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2873 : template<class _InIt1,
; 2874 : 	class _InTy,
; 2875 : 	size_t _InSize,
; 2876 : 	class _Pr> inline
; 2877 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2878 : 		_InTy (&_First2)[_InSize], _Pr _Pred)
; 2879 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2880 : 	return (_STD equal(_First1, _Last1,
; 2881 : 		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
; 2882 : 	}
; 2883 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2884 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2885 : 
; 2886 : 		// TEMPLATE FUNCTION lexicographical_compare
; 2887 : template<class _InIt1,
; 2888 : 	class _InIt2> inline
; 2889 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2890 : 		_InIt2 _First2, _InIt2 _Last2)
; 2891 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2892 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2893 : 		if (_DEBUG_LT(*_First1, *_First2))
; 2894 : 			return (true);
; 2895 : 		else if (*_First2 < *_First1)
; 2896 : 			return (false);
; 2897 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2898 : 	}
; 2899 : 
; 2900 : inline bool _Lexicographical_compare(
; 2901 : 	const unsigned char *_First1, const unsigned char *_Last1,
; 2902 : 	const unsigned char *_First2, const unsigned char *_Last2)
; 2903 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for unsigned char
; 2904 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2905 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2906 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2907 : 	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
; 2908 : 	}
; 2909 : 
; 2910 :  #if CHAR_MAX == UCHAR_MAX
; 2911 : inline bool _Lexicographical_compare(
; 2912 : 	const char *_First1, const char *_Last1,
; 2913 : 	const char *_First2, const char *_Last2)
; 2914 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for nonnegative char
; 2915 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2916 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2917 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2918 : 	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
; 2919 : 	}
; 2920 :  #endif /* CHAR_MAX == UCHAR_MAX */
; 2921 : 
; 2922 : template<class _InIt1,
; 2923 : 	class _InIt2> inline
; 2924 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2925 : 		_InIt2 _First2, _InIt2 _Last2)
; 2926 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2927 : 	_DEBUG_RANGE(_First1, _Last1);
; 2928 : 	_DEBUG_RANGE(_First2, _Last2);
; 2929 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2930 : 		_Unchecked(_First2), _Unchecked(_Last2)));
; 2931 : 	}
; 2932 : 
; 2933 : 		// TEMPLATE FUNCTION lexicographical_compare WITH PRED
; 2934 : template<class _InIt1,
; 2935 : 	class _InIt2,
; 2936 : 	class _Pr> inline
; 2937 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2938 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2939 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2940 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2941 : 		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
; 2942 : 			return (true);
; 2943 : 		else if (_Pred(*_First2, *_First1))
; 2944 : 			return (false);
; 2945 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2946 : 	}
; 2947 : 
; 2948 : template<class _InIt1,
; 2949 : 	class _InIt2,
; 2950 : 	class _Pr> inline
; 2951 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2952 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2953 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2954 : 	_DEBUG_RANGE(_First1, _Last1);
; 2955 : 	_DEBUG_RANGE(_First2, _Last2);
; 2956 : 	_DEBUG_POINTER(_Pred);
; 2957 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2958 : 		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
; 2959 : 	}
; 2960 : 
; 2961 : 		// TEMPLATE FUNCTION find
; 2962 : template<class _Ty,
; 2963 : 	class _Ignored> inline
; 2964 : 	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
; 2965 : 	{	// signed _Elem, signed _Ty
; 2966 : 	return (SCHAR_MIN <= _Val && _Val <= SCHAR_MAX);
; 2967 : 	}
; 2968 : 
; 2969 : template<class _Ty> inline
; 2970 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
; 2971 : 	{	// signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
; 2972 : 	return (_Val <= SCHAR_MAX || static_cast<_Ty>(SCHAR_MIN) <= _Val);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _Ty> inline
; 2976 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
; 2977 : 	{	// signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
; 2978 : 	return (_Val <= SCHAR_MAX);
; 2979 : 	}
; 2980 : 
; 2981 : template<class _Ty,
; 2982 : 	class _Ignored> inline
; 2983 : 	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
; 2984 : 	{	// unsigned _Elem, signed _Ty
; 2985 : 	return (0 <= _Val && _Val <= UCHAR_MAX);
; 2986 : 	}
; 2987 : 
; 2988 : template<class _Ty,
; 2989 : 	class _Ignored> inline
; 2990 : 	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
; 2991 : 	{	// unsigned _Elem, unsigned _Ty
; 2992 : 	return (_Val <= UCHAR_MAX);
; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))
; 3015 : 		return (_Last);
; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));
; 3018 : 	return (_First ? _First : _Last);
; 3019 : 	}
; 3020 : 
; 3021 : template<class _InIt,
; 3022 : 	class _Ty> inline
; 3023 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
; 3024 : 	{	// find first matching _Val
; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rcx, r8
	je	SHORT $LN70@UnRegister
$LL35@UnRegister:

; 3026 : 		if (*_First == _Val)

	cmp	QWORD PTR [rcx], rdx
	je	SHORT $LN77@UnRegister

; 2432 : 	return (_Dest + _Count);
; 2433 : 	}
; 2434 : 
; 2435 : template<class _InIt,
; 2436 : 	class _OutIt> inline
; 2437 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2438 : 		_OutIt _Dest)
; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked
; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}
; 2443 : 
; 2444 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2445 : template<class _InIt,
; 2446 : 	class _OutIt> inline
; 2447 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2448 : 		_OutIt _Dest)
; 2449 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2450 : 	return (_Rechecked(_Dest,
; 2451 : 		_Move(_Unchecked(_First), _Unchecked(_Last),
; 2452 : 			_Unchecked(_Dest))));
; 2453 : 	}
; 2454 : 
; 2455 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2456 : template<class _InIt,
; 2457 : 	class _OutIt> inline
; 2458 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2459 : 		_OutIt _Dest, input_iterator_tag, _Mutable_iterator_tag)
; 2460 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
; 2461 : 	return (_Move(_First, _Last,
; 2462 : 		_Dest));
; 2463 : 	}
; 2464 : 
; 2465 : template<class _InIt,
; 2466 : 	class _OutIt> inline
; 2467 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2468 : 		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
; 2469 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators
; 2470 : 	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
; 2471 : 	_Move(_First, _Last,
; 2472 : 		_Unchecked(_Dest));
; 2473 : 	return (_Ans);
; 2474 : 	}
; 2475 : 
; 2476 : template<class _InIt,
; 2477 : 	class _OutIt> inline
; 2478 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2479 : 		_OutIt _Dest, true_type)
; 2480 : 	{	// move [_First, _Last) to [_Dest, ...), checked dest
; 2481 : 	return (_Move(_First, _Last,
; 2482 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2483 : 	}
; 2484 : 
; 2485 : template<class _InIt,
; 2486 : 	class _OutIt> inline
; 2487 : _SCL_INSECURE_DEPRECATE
; 2488 : 	_OutIt _Move(_InIt _First, _InIt _Last,
; 2489 : 		_OutIt _Dest, false_type)
; 2490 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked dest
; 2491 : 	return (_Move(_First, _Last,
; 2492 : 		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
; 2493 : 	}
; 2494 : 
; 2495 : template<class _InIt,
; 2496 : 	class _OutIt> inline
; 2497 : 	_OutIt move(_InIt _First, _InIt _Last,
; 2498 : 		_OutIt _Dest)
; 2499 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2500 : 	_DEBUG_RANGE(_First, _Last);
; 2501 : 	_DEBUG_POINTER(_Dest);
; 2502 : 	return (_Move(_Unchecked(_First), _Unchecked(_Last),
; 2503 : 		_Dest, _Is_checked(_Dest)));
; 2504 : 	}
; 2505 : 
; 2506 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2507 : template<class _InIt,
; 2508 : 	class _OutTy,
; 2509 : 	size_t _OutSize> inline
; 2510 : 	_OutTy *move(_InIt _First, _InIt _Last,
; 2511 : 		_OutTy (&_Dest)[_OutSize])
; 2512 : 	{	// move [_First, _Last) to [_Dest, ...)
; 2513 : 	return (_Unchecked(
; 2514 : 		_STD move(_First, _Last,
; 2515 : 			_Array_iterator<_OutTy, _OutSize>(_Dest))));
; 2516 : 	}
; 2517 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2518 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2519 : 
; 2520 : 		// TEMPLATE FUNCTION move_backward
; 2521 : template<class _BidIt1,
; 2522 : 	class _BidIt2> inline
; 2523 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2524 : 		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
; 2525 : 	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators
; 2526 : 	while (_First != _Last)
; 2527 : 		*--_Dest = _STD move(*--_Last);
; 2528 : 	return (_Dest);
; 2529 : 	}
; 2530 : 
; 2531 : template<class _InIt,
; 2532 : 	class _OutIt> inline
; 2533 : 	_OutIt _Move_backward(_InIt _First, _InIt _Last,
; 2534 : 		_OutIt _Dest, _Scalar_ptr_iterator_tag)
; 2535 : 	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars
; 2536 : 	ptrdiff_t _Count = _Last - _First;
; 2537 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2538 : 		_Count * sizeof (*_First));
; 2539 : 	return (_Dest - _Count);
; 2540 : 	}
; 2541 : 
; 2542 : template<class _BidIt1,
; 2543 : 	class _BidIt2> inline
; 2544 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2545 : 		_BidIt2 _Dest)
; 2546 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked
; 2547 : 	return (_Move_backward(_First, _Last,
; 2548 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2549 : 	}
; 2550 : 
; 2551 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2552 : template<class _BidIt1,
; 2553 : 	class _BidIt2> inline
; 2554 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2555 : 		_BidIt2 _Dest)
; 2556 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2557 : 	return (_Rechecked(_Dest,
; 2558 : 		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2559 : 			_Unchecked(_Dest))));
; 2560 : 	}
; 2561 : 
; 2562 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2563 : template<class _BidIt1,
; 2564 : 	class _BidIt2> inline
; 2565 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2566 : 		_BidIt2 _Dest, true_type)
; 2567 : 	{	// move [_First, _Last) backwards to [..., _Dest), checked dest
; 2568 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2569 : 		_Dest));
; 2570 : 	}
; 2571 : 
; 2572 : template<class _BidIt1,
; 2573 : 	class _BidIt2> inline
; 2574 : _SCL_INSECURE_DEPRECATE
; 2575 : 	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2576 : 		_BidIt2 _Dest, false_type)
; 2577 : 	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest
; 2578 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2579 : 		_Dest));
; 2580 : 	}
; 2581 : 
; 2582 : template<class _BidIt1,
; 2583 : 	class _BidIt2> inline
; 2584 : 	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
; 2585 : 		_BidIt2 _Dest)
; 2586 : 	{	// move [_First, _Last) backwards to [..., _Dest)
; 2587 : 	_DEBUG_RANGE(_First, _Last);
; 2588 : 	_DEBUG_POINTER(_Dest);
; 2589 : 	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
; 2590 : 		_Dest, _Is_checked(_Dest)));
; 2591 : 	}
; 2592 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2593 : 
; 2594 : 		// TEMPLATE FUNCTION fill
; 2595 : template<class _FwdIt,
; 2596 : 	class _Ty> inline
; 2597 : 	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2598 : 	{	// copy _Val through [_First, _Last)
; 2599 : 	for (; _First != _Last; ++_First)
; 2600 : 		*_First = _Val;
; 2601 : 	}
; 2602 : 
; 2603 : inline void _Fill(char *_First, char *_Last, char _Val)
; 2604 : 	{	// copy char _Val through [_First, _Last)
; 2605 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2606 : 	}
; 2607 : 
; 2608 : inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
; 2609 : 	{	// copy signed char _Val through [_First, _Last)
; 2610 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2611 : 	}
; 2612 : 
; 2613 : inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
; 2614 : 	{	// copy unsigned char _Val through [_First, _Last)
; 2615 : 	_CSTD memset(_First, _Val, _Last - _First);
; 2616 : 	}
; 2617 : 
; 2618 : template<class _FwdIt,
; 2619 : 	class _Ty> inline
; 2620 : 	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
; 2621 : 	{	// copy _Val through [_First, _Last)
; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}
; 2625 : 
; 2626 : 		// TEMPLATE FUNCTION fill_n
; 2627 : template<class _OutIt,
; 2628 : 	class _Diff,
; 2629 : 	class _Ty> inline
; 2630 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2631 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2632 : 	for (; 0 < _Count; --_Count, ++_Dest)
; 2633 : 		*_Dest = _Val;
; 2634 : 	return (_Dest);
; 2635 : 	}
; 2636 : 
; 2637 : inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
; 2638 : 	{	// copy char _Val _Count times through [_Dest, ...)
; 2639 : 	_CSTD memset(_Dest, _Val, _Count);
; 2640 : 	return (_Dest + _Count);
; 2641 : 	}
; 2642 : 
; 2643 : inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
; 2644 : 	signed char _Val)
; 2645 : 	{	// copy signed char _Val _Count times through [_Dest, ...)
; 2646 : 	_CSTD memset(_Dest, _Val, _Count);
; 2647 : 	return (_Dest + _Count);
; 2648 : 	}
; 2649 : 
; 2650 : inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
; 2651 : 	unsigned char _Val)
; 2652 : 	{	// copy unsigned char _Val _Count times through [_Dest, ...)
; 2653 : 	_CSTD memset(_Dest, _Val, _Count);
; 2654 : 	return (_Dest + _Count);
; 2655 : 	}
; 2656 : 
; 2657 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2658 : template<class _OutIt,
; 2659 : 	class _Diff,
; 2660 : 	class _Ty> inline
; 2661 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2662 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2663 : 	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
; 2664 : 	}
; 2665 : 
; 2666 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2667 : template<class _OutIt,
; 2668 : 	class _Diff,
; 2669 : 	class _Ty> inline
; 2670 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2671 : 		_Mutable_iterator_tag)
; 2672 : 	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator
; 2673 : 	return (_Fill_n(_Dest, _Count, _Val));
; 2674 : 	}
; 2675 : 
; 2676 : template<class _OutIt,
; 2677 : 	class _Diff,
; 2678 : 	class _Ty> inline
; 2679 : 	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2680 : 		random_access_iterator_tag)
; 2681 : 	{	// copy _Val _Count times through [_Dest, ...), random-access iterator
; 2682 : 	_OutIt _Ans = _Dest + _Count;	// also checks range
; 2683 : 	_Fill_n(_Unchecked(_Dest), _Count, _Val);
; 2684 : 	return (_Ans);
; 2685 : 	}
; 2686 : 
; 2687 : template<class _OutIt,
; 2688 : 	class _Diff,
; 2689 : 	class _Ty> inline
; 2690 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2691 : 		true_type)
; 2692 : 	{	// copy _Val _Count times through [_Dest, ...), checked dest
; 2693 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2694 : 		_Iter_cat(_Dest)));
; 2695 : 	}
; 2696 : 
; 2697 : template<class _OutIt,
; 2698 : 	class _Diff,
; 2699 : 	class _Ty> inline
; 2700 : _SCL_INSECURE_DEPRECATE
; 2701 : 	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
; 2702 : 		false_type)
; 2703 : 	{	// copy _Val _Count times through [_Dest, ...), unchecked dest
; 2704 : 	return (_Fill_n1(_Dest, _Count, _Val,
; 2705 : 		_Iter_cat(_Dest)));
; 2706 : 	}
; 2707 : 
; 2708 : template<class _OutIt,
; 2709 : 	class _Diff,
; 2710 : 	class _Ty> inline
; 2711 : 	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
; 2712 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2713 : 	_DEBUG_POINTER(_Dest);
; 2714 : 	return (_Fill_n(_Dest, _Count, _Val,
; 2715 : 		_Is_checked(_Dest)));
; 2716 : 	}
; 2717 : 
; 2718 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2719 : template<class _OutTy,
; 2720 : 	size_t _OutSize,
; 2721 : 	class _Diff,
; 2722 : 	class _Ty> inline
; 2723 : 	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
; 2724 : 	{	// copy _Val _Count times through [_Dest, ...)
; 2725 : 	return (_Unchecked(_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
; 2726 : 		_Count, _Val)));
; 2727 : 	}
; 2728 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2729 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2730 : 
; 2731 : 		// TEMPLATE FUNCTION equal
; 2732 : template<class _InIt1,
; 2733 : 	class _InIt2> inline
; 2734 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
; 2735 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2736 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2737 : 		if (!(*_First1 == *_First2))
; 2738 : 			return (false);
; 2739 : 	return (true);
; 2740 : 	}
; 2741 : 
; 2742 : inline bool _Equal(const char *_First1, const char *_Last1,
; 2743 : 	const char *_First2)
; 2744 : 	{	// compare [_First1, _Last1) to [_First2, ...), for chars
; 2745 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2746 : 	}
; 2747 : 
; 2748 : inline bool _Equal(const signed char *_First1, const signed char *_Last1,
; 2749 : 	const signed char *_First2)
; 2750 : 	{	// compare [_First1, _Last1) to [_First2, ...), for signed chars
; 2751 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2752 : 	}
; 2753 : 
; 2754 : inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
; 2755 : 	const unsigned char *_First2)
; 2756 : 	{	// compare [_First1, _Last1) to [_First2, ...), for unsigned chars
; 2757 : 	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
; 2758 : 	}
; 2759 : 
; 2760 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2761 : template<class _InIt1,
; 2762 : 	class _InIt2> inline
; 2763 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2764 : 		_InIt2 _First2)
; 2765 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2766 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2767 : 		_Unchecked(_First2)));
; 2768 : 	}
; 2769 : 
; 2770 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2771 : template<class _InIt1,
; 2772 : 	class _InIt2> inline
; 2773 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2774 : 		_InIt2 _First2, true_type)
; 2775 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked dest
; 2776 : 	return (_Equal(_First1, _Last1,
; 2777 : 		_First2));
; 2778 : 	}
; 2779 : 
; 2780 : template<class _InIt1,
; 2781 : 	class _InIt2> inline
; 2782 : _SCL_INSECURE_DEPRECATE
; 2783 : 	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
; 2784 : 		_InIt2 _First2, false_type)
; 2785 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked dest
; 2786 : 	return (_Equal(_First1, _Last1,
; 2787 : 		_First2));
; 2788 : 	}
; 2789 : 
; 2790 : template<class _InIt1,
; 2791 : 	class _InIt2> inline
; 2792 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2793 : 		_InIt2 _First2)
; 2794 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2795 : 	_DEBUG_RANGE(_First1, _Last1);
; 2796 : 	_DEBUG_POINTER(_First2);
; 2797 : 	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),
; 2798 : 		_First2, _Is_checked(_First2)));
; 2799 : 	}
; 2800 : 
; 2801 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2802 : template<class _InIt1,
; 2803 : 	class _InTy,
; 2804 : 	size_t _InSize> inline
; 2805 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2806 : 		_InTy (&_First2)[_InSize])
; 2807 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2808 : 	return (_STD equal(_First1, _Last1,
; 2809 : 		_Array_iterator<_InTy, _InSize>(_First2)));
; 2810 : 	}
; 2811 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2812 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2813 : 
; 2814 : 		// TEMPLATE FUNCTION equal WITH PRED
; 2815 : template<class _InIt1,
; 2816 : 	class _InIt2,
; 2817 : 	class _Pr> inline
; 2818 : 	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
; 2819 : 		_InIt2 _First2, _Pr _Pred)
; 2820 : 	{	// compare [_First1, _Last1) to [_First2, ...) using _Pred
; 2821 : 	for (; _First1 != _Last1; ++_First1, ++_First2)
; 2822 : 		if (!_Pred(*_First1, *_First2))
; 2823 : 			return (false);
; 2824 : 	return (true);
; 2825 : 	}
; 2826 : 
; 2827 :  #if _ITERATOR_DEBUG_LEVEL == 0
; 2828 : template<class _InIt1,
; 2829 : 	class _InIt2,
; 2830 : 	class _Pr> inline
; 2831 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2832 : 		_InIt2 _First2, _Pr _Pred)
; 2833 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2834 : 	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
; 2835 : 		_Unchecked(_First2), _Pred));
; 2836 : 	}
; 2837 : 
; 2838 :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2839 : template<class _InIt1,
; 2840 : 	class _InIt2,
; 2841 : 	class _Pr> inline
; 2842 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2843 : 		_InIt2 _First2, _Pr _Pred, true_type)
; 2844 : 	{	// compare [_First1, _Last1) to [_First2, ...), checked input
; 2845 : 	return (_Equal(_First1, _Last1,
; 2846 : 		_First2, _Pred));
; 2847 : 	}
; 2848 : 
; 2849 : template<class _InIt1,
; 2850 : 	class _InIt2,
; 2851 : 	class _Pr> inline
; 2852 : _SCL_INSECURE_DEPRECATE
; 2853 : 	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
; 2854 : 		_InIt2 _First2, _Pr _Pred, false_type)
; 2855 : 	{	// compare [_First1, _Last1) to [_First2, ...), unchecked input
; 2856 : 	return (_Equal(_First1, _Last1,
; 2857 : 		_First2, _Pred));
; 2858 : 	}
; 2859 : 
; 2860 : template<class _InIt1,
; 2861 : 	class _InIt2,
; 2862 : 	class _Pr> inline
; 2863 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2864 : 		_InIt2 _First2, _Pr _Pred)
; 2865 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2866 : 	_DEBUG_RANGE(_First1, _Last1);
; 2867 : 	_DEBUG_POINTER(_First2);
; 2868 : 	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
; 2869 : 		_First2, _Pred, _Is_checked(_First2)));
; 2870 : 	}
; 2871 : 
; 2872 :  #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
; 2873 : template<class _InIt1,
; 2874 : 	class _InTy,
; 2875 : 	size_t _InSize,
; 2876 : 	class _Pr> inline
; 2877 : 	bool equal(_InIt1 _First1, _InIt1 _Last1,
; 2878 : 		_InTy (&_First2)[_InSize], _Pr _Pred)
; 2879 : 	{	// compare [_First1, _Last1) to [_First2, ...)
; 2880 : 	return (_STD equal(_First1, _Last1,
; 2881 : 		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
; 2882 : 	}
; 2883 :  #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
; 2884 :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 2885 : 
; 2886 : 		// TEMPLATE FUNCTION lexicographical_compare
; 2887 : template<class _InIt1,
; 2888 : 	class _InIt2> inline
; 2889 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2890 : 		_InIt2 _First2, _InIt2 _Last2)
; 2891 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2892 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2893 : 		if (_DEBUG_LT(*_First1, *_First2))
; 2894 : 			return (true);
; 2895 : 		else if (*_First2 < *_First1)
; 2896 : 			return (false);
; 2897 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2898 : 	}
; 2899 : 
; 2900 : inline bool _Lexicographical_compare(
; 2901 : 	const unsigned char *_First1, const unsigned char *_Last1,
; 2902 : 	const unsigned char *_First2, const unsigned char *_Last2)
; 2903 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for unsigned char
; 2904 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2905 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2906 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2907 : 	return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
; 2908 : 	}
; 2909 : 
; 2910 :  #if CHAR_MAX == UCHAR_MAX
; 2911 : inline bool _Lexicographical_compare(
; 2912 : 	const char *_First1, const char *_Last1,
; 2913 : 	const char *_First2, const char *_Last2)
; 2914 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2), for nonnegative char
; 2915 : 	ptrdiff_t _Num1 = _Last1 - _First1;
; 2916 : 	ptrdiff_t _Num2 = _Last2 - _First2;
; 2917 : 	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
; 2918 : 	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
; 2919 : 	}
; 2920 :  #endif /* CHAR_MAX == UCHAR_MAX */
; 2921 : 
; 2922 : template<class _InIt1,
; 2923 : 	class _InIt2> inline
; 2924 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2925 : 		_InIt2 _First2, _InIt2 _Last2)
; 2926 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2)
; 2927 : 	_DEBUG_RANGE(_First1, _Last1);
; 2928 : 	_DEBUG_RANGE(_First2, _Last2);
; 2929 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2930 : 		_Unchecked(_First2), _Unchecked(_Last2)));
; 2931 : 	}
; 2932 : 
; 2933 : 		// TEMPLATE FUNCTION lexicographical_compare WITH PRED
; 2934 : template<class _InIt1,
; 2935 : 	class _InIt2,
; 2936 : 	class _Pr> inline
; 2937 : 	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2938 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2939 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2940 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
; 2941 : 		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
; 2942 : 			return (true);
; 2943 : 		else if (_Pred(*_First2, *_First1))
; 2944 : 			return (false);
; 2945 : 	return (_First1 == _Last1 && _First2 != _Last2);
; 2946 : 	}
; 2947 : 
; 2948 : template<class _InIt1,
; 2949 : 	class _InIt2,
; 2950 : 	class _Pr> inline
; 2951 : 	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
; 2952 : 		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
; 2953 : 	{	// order [_First1, _Last1) vs. [_First2, _Last2) using _Pred
; 2954 : 	_DEBUG_RANGE(_First1, _Last1);
; 2955 : 	_DEBUG_RANGE(_First2, _Last2);
; 2956 : 	_DEBUG_POINTER(_Pred);
; 2957 : 	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
; 2958 : 		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
; 2959 : 	}
; 2960 : 
; 2961 : 		// TEMPLATE FUNCTION find
; 2962 : template<class _Ty,
; 2963 : 	class _Ignored> inline
; 2964 : 	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
; 2965 : 	{	// signed _Elem, signed _Ty
; 2966 : 	return (SCHAR_MIN <= _Val && _Val <= SCHAR_MAX);
; 2967 : 	}
; 2968 : 
; 2969 : template<class _Ty> inline
; 2970 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
; 2971 : 	{	// signed _Elem, unsigned _Ty, -1 == static_cast<_Ty>(-1)
; 2972 : 	return (_Val <= SCHAR_MAX || static_cast<_Ty>(SCHAR_MIN) <= _Val);
; 2973 : 	}
; 2974 : 
; 2975 : template<class _Ty> inline
; 2976 : 	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
; 2977 : 	{	// signed _Elem, unsigned _Ty, -1 != static_cast<_Ty>(-1)
; 2978 : 	return (_Val <= SCHAR_MAX);
; 2979 : 	}
; 2980 : 
; 2981 : template<class _Ty,
; 2982 : 	class _Ignored> inline
; 2983 : 	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
; 2984 : 	{	// unsigned _Elem, signed _Ty
; 2985 : 	return (0 <= _Val && _Val <= UCHAR_MAX);
; 2986 : 	}
; 2987 : 
; 2988 : template<class _Ty,
; 2989 : 	class _Ignored> inline
; 2990 : 	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
; 2991 : 	{	// unsigned _Elem, unsigned _Ty
; 2992 : 	return (_Val <= UCHAR_MAX);
; 2993 : 	}
; 2994 : 
; 2995 : template<class _InIt,
; 2996 : 	class _Ty> inline
; 2997 : 	bool _Within_limits(_InIt, const _Ty& _Val)
; 2998 : 	{	// check whether _Val is within the limits of _Elem
; 2999 : 	typedef typename remove_pointer<_InIt>::type _Elem;
; 3000 : 	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
; 3001 : 		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
; 3002 : 	}
; 3003 : 
; 3004 : template<class _InIt> inline
; 3005 : 	bool _Within_limits(_InIt, const bool&)
; 3006 : 	{	// bools are always within the limits of _Elem
; 3007 : 	return (true);
; 3008 : 	}
; 3009 : 
; 3010 : template<class _InIt,
; 3011 : 	class _Ty> inline
; 3012 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
; 3013 : 	{	// find first byte matching integral _Val
; 3014 : 	if (!_Within_limits(_First, _Val))
; 3015 : 		return (_Last);
; 3016 : 	_First = static_cast<_InIt>(_CSTD memchr(
; 3017 : 		_First, static_cast<unsigned char>(_Val), _Last - _First));
; 3018 : 	return (_First ? _First : _Last);
; 3019 : 	}
; 3020 : 
; 3021 : template<class _InIt,
; 3022 : 	class _Ty> inline
; 3023 : 	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
; 3024 : 	{	// find first matching _Val
; 3025 : 	for (; _First != _Last; ++_First)

	add	rcx, 8
	cmp	rcx, r8
	jne	SHORT $LL35@UnRegister
$LN77@UnRegister:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rcx, r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 63   : 	if( it!=m_timers.end() )

	je	SHORT $LN70@UnRegister
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1454 : 			_VIPTR(_Where));

	lea	rdx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	sub	r8, rdx

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

	and	r8, -8
	call	QWORD PTR __imp_memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1456 : 		--this->_Mylast;

	add	QWORD PTR [rbx+8], -8
$LN70@UnRegister:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.cpp

; 65   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?UnRegister@pauseMngr@@QEAAXPEAVCTimer_paused@@@Z ENDP	; pauseMngr::UnRegister
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ PROC ; xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	rax, rcx
	ret	0
??0?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ ENDP ; xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$dead$ = 16
?reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAX_K@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::reserve, COMDAT

; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1000 : 		if (capacity() < _Count)

	cmp	rax, 3
	jae	SHORT $LN2@reserve

; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);

	mov	edx, 3
	jmp	?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate
$LN2@reserve:

; 1005 : 			}
; 1006 : 		}

	ret	0
?reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAX_K@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@XZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@XZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@XZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@XZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXAEBQEAVCTimer_paused@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXAEBQEAVCTimer_paused@@@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::push_back, COMDAT

; 1243 : 		{	// insert element at end

$LN69:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]

; 1243 : 		{	// insert element at end

	mov	rdi, rdx
	mov	rbx, rcx

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN4@push_back
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	sub	rdi, rcx
	sar	rdi, 3

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN61@push_back
	mov	rax, QWORD PTR [rbx]
	mov	rcx, QWORD PTR [rax+rdi*8]
	mov	QWORD PTR [rdx], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 8

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN61@push_back
	mov	rax, QWORD PTR [rdi]
	mov	QWORD PTR [rcx], rax
$LN61@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 8

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXAEBQEAVCTimer_paused@@@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?erase@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Where$ = 64
?erase@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::erase, COMDAT

; 1452 : 		{	// erase element at where

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rdi, rdx

; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));

	lea	rdx, QWORD PTR [r8+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	mov	r8, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1452 : 		{	// erase element at where

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2431 : 		_Count * sizeof (*_First));

	mov	rcx, rax
	sub	r8, rdx
	and	r8, -8
	call	QWORD PTR __imp_memmove
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR _Where$[rsp]

; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;

	add	QWORD PTR [rbx+8], -8

; 1458 : 		}

	mov	rbx, QWORD PTR [rsp+48]

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rdi], rax

; 1457 : 		return (_Make_iter(_Where));

	mov	rax, rdi

; 1458 : 		}

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?erase@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

	setne	al

; 211  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAAEAPEAVCTimer_paused@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAAEAPEAVCTimer_paused@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAAEAPEAVCTimer_paused@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator++, COMDAT

; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 8

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

	mov	rax, rcx

; 336  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 681  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Make_iter, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rdx], r8

; 1045 : 		return (iterator(_Where._Ptr, this));

	mov	rax, rdx

; 1046 : 		}

	ret	0
?_Make_iter@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@2@@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBA_NPEBQEAVCTimer_paused@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBA_NPEBQEAVCTimer_paused@@@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Inside, COMDAT

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1584 : 		}

	ret	0
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	xor	al, al

; 1584 : 		}

	ret	0
?_Inside@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBA_NPEBQEAVCTimer_paused@@@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
p$ = 88
p$ = 88
_Ptr$ = 88
_Count$ = 88
?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate, COMDAT

; 1587 : 		{	// move to array of exactly _Count elements

$LN54:
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	r14, rdx
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, edx
	shl	rdx, 3
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	rsi, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, rax
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]
	sub	rdi, rax
	sar	rdi, 3

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

	test	rax, rax
	je	SHORT $LN49@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rsp]
	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
$LN49@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

	lea	rax, QWORD PTR [rsi+r14*8]
	mov	QWORD PTR [rbx+16], rax

; 1607 : 		this->_Mylast = _Ptr + _Size;

	lea	rax, QWORD PTR [rsi+rdi*8]
	mov	QWORD PTR [rbx+8], rax

; 1608 : 		this->_Myfirst = _Ptr;

	mov	QWORD PTR [rbx], rsi

; 1609 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN53@Reallocate:
?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
p$ = 88
p$ = 88
_Ptr$ = 88
_Count$ = 88
?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate'::`1'::catch$0

; 1592 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	QWORD PTR p$[rbp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rbp]
	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1594 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reserve, COMDAT

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

$LN47:
	sub	rsp, 40					; 00000028H

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, QWORD PTR [rcx+8]
	mov	rax, rdx
	sub	rax, r8
	sar	rax, 3

; 1613 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r10, QWORD PTR [rcx]

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	r9, 2305843009213693951			; 1fffffffffffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r8, r10

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	rax, r9

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sar	r8, 3

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	sub	rax, r8
	cmp	rax, 1
	jae	SHORT $LN1@Reserve

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@Reserve:

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rdx, r10

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	r8

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sar	rdx, 3

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rdx
	shr	rax, 1
	sub	r9, rax
	cmp	r9, rdx
	jae	SHORT $LN29@Reserve
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate
$LN29@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rax

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN46@Reserve:
?_Reserve@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAX_K@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXPEAPEAVCTimer_paused@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXPEAPEAVCTimer_paused@@0@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXPEAPEAVCTimer_paused@@0@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAAEBQEAVCTimer_paused@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAAEBQEAVCTimer_paused@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAAEBQEAVCTimer_paused@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator++, COMDAT

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 8

; 113  : 		return (*this);

	mov	rax, rcx

; 114  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 206  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAA@PEAPEAVCTimer_paused@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAA@PEAPEAVCTimer_paused@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAA@PEAPEAVCTimer_paused@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 3

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBA_K_K@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r8, QWORD PTR [rcx]
	sar	r8, 3

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to
	xor	r8d, r8d

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Compat, COMDAT

; 255  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@PEAVCTimer_paused@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@V10@0AEBQEAVCTimer_paused@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_First$ = 16
_Last$ = 24
_Val$ = 32
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@PEAVCTimer_paused@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@V10@0AEBQEAVCTimer_paused@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >,CTimer_paused * __ptr64>, COMDAT

; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rdx, r8
	je	SHORT $LN29@find

; 3026 : 		if (*_First == _Val)

	mov	rax, QWORD PTR [r9]
$LL16@find:
	cmp	QWORD PTR [rdx], rax
	je	SHORT $LN29@find

; 3025 : 	for (; _First != _Last; ++_First)

	add	rdx, 8
	cmp	rdx, r8
	jne	SHORT $LL16@find
$LN29@find:

; 3052 : 	_DEBUG_RANGE(_First, _Last);
; 3053 : 	return (_Rechecked(_First,
; 3054 : 		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));

	mov	QWORD PTR [rcx], rdx
	mov	rax, rcx

; 3055 : 	}

	ret	0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@PEAVCTimer_paused@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@V10@0AEBQEAVCTimer_paused@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QEAVCTimer_paused@@@std@@YAPEBQEAVCTimer_paused@@AEBQEAV1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@QEAVCTimer_paused@@@std@@YAPEBQEAVCTimer_paused@@AEBQEAV1@@Z PROC ; std::addressof<CTimer_paused * __ptr64 const>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@QEAVCTimer_paused@@@std@@YAPEBQEAVCTimer_paused@@AEBQEAV1@@Z ENDP ; std::addressof<CTimer_paused * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00@Z PROC ; std::_Move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	mov	rdi, r8

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	sar	rdx, 3

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rdi
	mov	r8, rbx
	call	QWORD PTR __imp_memmove

; 2432 : 	return (_Dest + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2442 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00@Z ENDP ; std::_Move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAPEAVCTimer_paused@@@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAPEAPEAVCTimer_paused@@PEAPEAV2@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAPEAVCTimer_paused@@@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAPEAPEAVCTimer_paused@@PEAPEAV2@00@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Umove<CTimer_paused * __ptr64 * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAPEAVCTimer_paused@@@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAPEAPEAVCTimer_paused@@PEAPEAV2@00@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Umove<CTimer_paused * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@YAPEAPEAVCTimer_paused@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Iter$ = 8
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@YAPEAPEAVCTimer_paused@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >, COMDAT

; 396  : 	return (_Iter._Unchecked());

	mov	rax, rcx

; 397  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@YAPEAPEAVCTimer_paused@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Find@PEAPEAVCTimer_paused@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@0AEBQEAV1@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Find@PEAPEAVCTimer_paused@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@0AEBQEAV1@@Z PROC ; std::_Find<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64>, COMDAT

; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN15@Find

; 3026 : 		if (*_First == _Val)

	mov	rax, QWORD PTR [r8]
$LL6@Find:
	cmp	QWORD PTR [rcx], rax
	je	SHORT $LN15@Find

; 3025 : 	for (; _First != _Last; ++_First)

	add	rcx, 8
	cmp	rcx, rdx
	jne	SHORT $LL6@Find
$LN15@Find:

; 3035 : 	// activate optimization for pointers to (const) bytes and integral values
; 3036 : 	typedef integral_constant<bool,
; 3037 : 		(  is_same<_InIt, char *>::value
; 3038 : 		|| is_same<_InIt, signed char *>::value
; 3039 : 		|| is_same<_InIt, unsigned char *>::value
; 3040 : 		|| is_same<_InIt, const char *>::value
; 3041 : 		|| is_same<_InIt, const signed char *>::value
; 3042 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3043 : 		&& is_integral<_Ty>::value
; 3044 : 	> _Memchr_opt;
; 3045 : 	return (_Find(_First, _Last, _Val, _Memchr_opt()));

	mov	rax, rcx

; 3046 : 	}

	ret	0
??$_Find@PEAPEAVCTimer_paused@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@0AEBQEAV1@@Z ENDP ; std::_Find<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@AEAV10@PEAPEAVCTimer_paused@@@Z
_TEXT	SEGMENT
_Iter$ = 8
_Right$ = 16
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@AEAV10@PEAPEAVCTimer_paused@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >, COMDAT

; 313  : 		this->_Ptr = _Right;

	mov	QWORD PTR [rcx], rdx

; 405  : 	return (_Iter._Rechecked(_Right));

	mov	rax, rcx

; 406  : 	}

	ret	0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@0@AEAV10@PEAPEAVCTimer_paused@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>, COMDAT

; 2428 : 	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 2429 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx
	mov	rdi, r8
	sar	rdx, 3

; 2430 : 	_CSTD memmove(&*_Dest, &*_First,
; 2431 : 		_Count * sizeof (*_First));

	lea	rbx, QWORD PTR [rdx*8]
	mov	rdx, rcx
	mov	rcx, rdi
	mov	r8, rbx
	call	QWORD PTR __imp_memmove

; 2432 : 	return (_Dest + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 2433 : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Move@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z PROC ; std::_Uninitialized_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z ENDP ; std::_Uninitialized_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAVCTimer_paused@@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAVCTimer_paused@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Rechecked, COMDAT

; 313  : 		this->_Ptr = _Right;

	mov	QWORD PTR [rcx], rdx

; 314  : 		return (*this);

	mov	rax, rcx

; 315  : 		}

	ret	0
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAVCTimer_paused@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAPEAPEAVCTimer_paused@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAPEAPEAVCTimer_paused@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Unchecked, COMDAT

; 319  : 		return (_Unchecked_type(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 320  : 		}

	ret	0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEBAPEAPEAVCTimer_paused@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Find@PEAPEAVCTimer_paused@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@0AEBQEAV1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
__formal$dead$ = 32
??$_Find@PEAPEAVCTimer_paused@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@0AEBQEAV1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64>, COMDAT

; 3025 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN13@Find

; 3026 : 		if (*_First == _Val)

	mov	rax, QWORD PTR [r8]
$LL4@Find:
	cmp	QWORD PTR [rcx], rax
	je	SHORT $LN13@Find

; 3025 : 	for (; _First != _Last; ++_First)

	add	rcx, 8
	cmp	rcx, rdx
	jne	SHORT $LL4@Find
$LN13@Find:

; 3027 : 			break;
; 3028 : 	return (_First);

	mov	rax, rcx

; 3029 : 	}

	ret	0
??$_Find@PEAPEAVCTimer_paused@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@0AEBQEAV1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z PROC ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z ENDP ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAVCTimer_paused@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAVCTimer_paused@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@@Z PROC ; std::_Val_type<CTimer_paused * __ptr64 * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAPEAVCTimer_paused@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@@Z ENDP ; std::_Val_type<CTimer_paused * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>, COMDAT

; 459  : 	{	// move [_First, _Last) to raw _Dest, using _Al, scalar type

$LN4:
	sub	rsp, 56					; 00000038H

; 460  : 	return (_Uninit_move(_First, _Last, _Dest,
; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>

; 462  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [r8], rax
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 8
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 8
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAPEAVCTimer_paused@@PEAPEAV1@V?$xalloc@PEAVCTimer_paused@@@@PEAV1@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@00AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64,xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVCTimer_paused@@PEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@$$QEAPEAV2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVCTimer_paused@@PEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@$$QEAPEAV2@@Z PROC ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAVCTimer_paused@@PEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@$$QEAPEAV2@@Z ENDP ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PEAVCTimer_paused@@@std@@YA$$QEAPEAVCTimer_paused@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAVCTimer_paused@@@std@@YA$$QEAPEAVCTimer_paused@@AEAPEAV1@@Z PROC ; std::forward<CTimer_paused * __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@PEAVCTimer_paused@@@std@@YA$$QEAPEAVCTimer_paused@@AEAPEAV1@@Z ENDP ; std::forward<CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVCTimer_paused@@PEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVCTimer_paused@@PEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@$$QEAPEAV3@@Z PROC ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@PEAVCTimer_paused@@PEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@$$QEAPEAV3@@Z ENDP ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@PEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@$$QEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@PEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@$$QEAPEAV3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8], rax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@PEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@$$QEAPEAV3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy@PEAVCTimer_paused@@@std@@YAXPEAPEAVCTimer_paused@@@Z
_TEXT	SEGMENT
_Ptr$dead$ = 8
??$_Destroy@PEAVCTimer_paused@@@std@@YAXPEAPEAVCTimer_paused@@@Z PROC ; std::_Destroy<CTimer_paused * __ptr64>, COMDAT

; 55   : 	_Ptr->~_Ty();
; 56   : 	}

	ret	0
??$_Destroy@PEAVCTimer_paused@@@std@@YAXPEAPEAVCTimer_paused@@@Z ENDP ; std::_Destroy<CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?destroy@?$xalloc@PEAVCTimer_paused@@@@QEAAXPEAPEAVCTimer_paused@@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$dead$ = 16
?destroy@?$xalloc@PEAVCTimer_paused@@@@QEAAXPEAPEAVCTimer_paused@@@Z PROC ; xalloc<CTimer_paused * __ptr64>::destroy, COMDAT

; 85   : 							void					destroy			(pointer p)								{	std::_Destroy(p);			}

	ret	0
?destroy@?$xalloc@PEAVCTimer_paused@@@@QEAAXPEAPEAVCTimer_paused@@@Z ENDP ; xalloc<CTimer_paused * __ptr64>::destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$dead$ = 24
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@@Z PROC ; std::_Alloc_destroy::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>, COMDAT

; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@@_Alloc_destroy@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@@Z ENDP ; std::_Alloc_destroy::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAVCTimer_paused@@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAVCTimer_paused@@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@@Z PROC ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::destroy<CTimer_paused * __ptr64>, COMDAT

; 475  : 		{	// destroy object at _Ptr
; 476  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 477  : 		}

	ret	0
??$destroy@PEAVCTimer_paused@@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@@Z ENDP ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::destroy<CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAVCTimer_paused@@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAVCTimer_paused@@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@@Z PROC ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::destroy<CTimer_paused * __ptr64>, COMDAT

; 878  : 		{	// destroy object at _Ptr
; 879  : 		_Mytraits::destroy(*this, _Ptr);
; 880  : 		}

	ret	0
??$destroy@PEAVCTimer_paused@@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@@Z ENDP ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::destroy<CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAPEAVCTimer_paused@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAPEAVCTimer_paused@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@@Z PROC ; std::_Unchecked<CTimer_paused * __ptr64 * __ptr64>, COMDAT

; 281  : 	return (_Src);

	mov	rax, rcx

; 282  : 	}

	ret	0
??$_Unchecked@PEAPEAVCTimer_paused@@@std@@YAPEAPEAVCTimer_paused@@PEAPEAV1@@Z ENDP ; std::_Unchecked<CTimer_paused * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAAEAPEAPEAVCTimer_paused@@AEAPEAPEAV1@PEAPEAV1@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Src$ = 16
??$_Rechecked@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAAEAPEAPEAVCTimer_paused@@AEAPEAPEAV1@PEAPEAV1@@Z PROC ; std::_Rechecked<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>, COMDAT

; 289  : 	_Dest = _Src;

	mov	QWORD PTR [rcx], rdx

; 290  : 	return (_Dest);

	mov	rax, rcx

; 291  : 	}

	ret	0
??$_Rechecked@PEAPEAVCTimer_paused@@PEAPEAV1@@std@@YAAEAPEAPEAVCTimer_paused@@AEAPEAPEAV1@PEAPEAV1@@Z ENDP ; std::_Rechecked<CTimer_paused * __ptr64 * __ptr64,CTimer_paused * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 55   : 		}

	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAA@PEAPEAVCTimer_paused@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAA@PEAPEAVCTimer_paused@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@@std@@QEAA@PEAPEAVCTimer_paused@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?size@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::size, COMDAT

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1149 : 		}

	ret	0
?size@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_alloc@PEAVCTimer_paused@@@@YAPEAPEAVCTimer_paused@@I@Z
_TEXT	SEGMENT
count$ = 8
??$xr_alloc@PEAVCTimer_paused@@@@YAPEAPEAVCTimer_paused@@I@Z PROC ; xr_alloc<CTimer_paused * __ptr64>, COMDAT

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ecx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	shl	rdx, 3
	jmp	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
??$xr_alloc@PEAVCTimer_paused@@@@YAPEAPEAVCTimer_paused@@I@Z ENDP ; xr_alloc<CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?allocate@?$xalloc@PEAVCTimer_paused@@@@QEBAPEAPEAVCTimer_paused@@_KPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
n$ = 16
p$dead$ = 24
?allocate@?$xalloc@PEAVCTimer_paused@@@@QEBAPEAPEAVCTimer_paused@@_KPEBX@Z PROC ; xalloc<CTimer_paused * __ptr64>::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, edx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	shl	rdx, 3
	jmp	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
?allocate@?$xalloc@PEAVCTimer_paused@@@@QEBAPEAPEAVCTimer_paused@@_KPEBX@Z ENDP ; xalloc<CTimer_paused * __ptr64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAPEAPEAVCTimer_paused@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAPEAPEAVCTimer_paused@@_K@Z PROC ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::allocate, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, edx
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	shl	rdx, 3
	jmp	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
?allocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAPEAPEAVCTimer_paused@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> >::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> >, COMDAT

; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 485  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@PEAVCTimer_paused@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> >::_Vector_val<std::_Simple_types<CTimer_paused * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@QEAA@AEBV?$xalloc@PEAVCTimer_paused@@@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@QEAA@AEBV?$xalloc@PEAVCTimer_paused@@@@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 589  : 		{	// construct allocator from _Al
; 590  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@QEAA@AEBV?$xalloc@PEAVCTimer_paused@@@@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@AEBQEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEBQEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@AEBQEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEBQEAV3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8], rax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@AEBQEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEBQEAV3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVCTimer_paused@@AEBQEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEBQEAV3@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVCTimer_paused@@AEBQEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEBQEAV3@@Z PROC ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@PEAVCTimer_paused@@AEBQEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEBQEAV3@@Z ENDP ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVCTimer_paused@@AEBQEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@AEBQEAV2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVCTimer_paused@@AEBQEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@AEBQEAV2@@Z PROC ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAVCTimer_paused@@AEBQEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@AEBQEAV2@@Z ENDP ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\new
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 60   : 	return (_Where);

	mov	rax, rdx

; 61   : 	}

	ret	0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEBQEAVCTimer_paused@@@std@@YAAEBQEAVCTimer_paused@@AEBQEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAVCTimer_paused@@@std@@YAAEBQEAVCTimer_paused@@AEBQEAV1@@Z PROC ; std::forward<CTimer_paused * __ptr64 const & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEBQEAVCTimer_paused@@@std@@YAAEBQEAVCTimer_paused@@AEBQEAV1@@Z ENDP ; std::forward<CTimer_paused * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Construct@PEAVCTimer_paused@@AEBQEAV1@@std@@YAXPEAPEAVCTimer_paused@@AEBQEAV1@@Z
_TEXT	SEGMENT
_Ptr$ = 8
_Val$ = 16
??$_Construct@PEAVCTimer_paused@@AEBQEAV1@@std@@YAXPEAPEAVCTimer_paused@@AEBQEAV1@@Z PROC ; std::_Construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>, COMDAT

; 39   : 	void *_Vptr = _Ptr;
; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN3@Construct
	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax
$LN3@Construct:

; 41   : 	}

	ret	0
??$_Construct@PEAVCTimer_paused@@AEBQEAV1@@std@@YAXPEAPEAVCTimer_paused@@AEBQEAV1@@Z ENDP ; std::_Construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?construct@?$xalloc@PEAVCTimer_paused@@@@QEAAXPEAPEAVCTimer_paused@@AEBQEAV2@@Z
_TEXT	SEGMENT
this$dead$ = 8
p$ = 16
_Val$ = 24
?construct@?$xalloc@PEAVCTimer_paused@@@@QEAAXPEAPEAVCTimer_paused@@AEBQEAV2@@Z PROC ; xalloc<CTimer_paused * __ptr64>::construct, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN5@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN5@construct:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 84   : 							void					construct		(pointer p, const T& _Val)				{	std::_Construct(p, _Val);	}

	ret	0
?construct@?$xalloc@PEAVCTimer_paused@@@@QEAAXPEAPEAVCTimer_paused@@AEBQEAV2@@Z ENDP ; xalloc<CTimer_paused * __ptr64>::construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@AEAPEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEAPEAV3@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@AEAPEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEAPEAV3@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8], rax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@PEAVCTimer_paused@@AEAPEAV2@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEAPEAV3@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CTimer_paused * __ptr64>,CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVCTimer_paused@@AEAPEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEAPEAV3@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVCTimer_paused@@AEAPEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEAPEAV3@@Z PROC ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@PEAVCTimer_paused@@AEAPEAV1@@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SAXAEAV?$xalloc@PEAVCTimer_paused@@@@PEAPEAVCTimer_paused@@AEAPEAV3@@Z ENDP ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEAVCTimer_paused@@@std@@YAAEAPEAVCTimer_paused@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAVCTimer_paused@@@std@@YAAEAPEAVCTimer_paused@@AEAPEAV1@@Z PROC ; std::forward<CTimer_paused * __ptr64 & __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@AEAPEAVCTimer_paused@@@std@@YAAEAPEAVCTimer_paused@@AEAPEAV1@@Z ENDP ; std::forward<CTimer_paused * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAVCTimer_paused@@AEAPEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@AEAPEAV2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAVCTimer_paused@@AEAPEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@AEAPEAV2@@Z PROC ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAVCTimer_paused@@AEAPEAV1@@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@AEAPEAV2@@Z ENDP ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::construct<CTimer_paused * __ptr64,CTimer_paused * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXXZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Xlen, COMDAT

; 1753 : 		{	// report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEBAXXZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?max_size@?$xalloc@PEAVCTimer_paused@@@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$xalloc@PEAVCTimer_paused@@@@QEBA_KXZ PROC	; xalloc<CTimer_paused * __ptr64>::max_size, COMDAT

; 86   : 							size_type				max_size		() const								{	size_type _Count = (size_type)(-1) / sizeof (T);	return (0 < _Count ? _Count : 1);	}

	mov	rax, 2305843009213693951		; 1fffffffffffffffH
	ret	0
?max_size@?$xalloc@PEAVCTimer_paused@@@@QEBA_KXZ ENDP	; xalloc<CTimer_paused * __ptr64>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@PEAVCTimer_paused@@@@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@PEAVCTimer_paused@@@@@Z PROC ; std::_Alloc_max_size::_Fn<xalloc<CTimer_paused * __ptr64> >, COMDAT

; 381  : 		return (_Al.max_size());

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 382  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAVCTimer_paused@@@@@_Alloc_max_size@std@@SA_KHAEBV?$xalloc@PEAVCTimer_paused@@@@@Z ENDP ; std::_Alloc_max_size::_Fn<xalloc<CTimer_paused * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SA_KAEBV?$xalloc@PEAVCTimer_paused@@@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SA_KAEBV?$xalloc@PEAVCTimer_paused@@@@@Z PROC ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::max_size, COMDAT

; 481  : 		return (_Alloc_max_size::_Fn(0, _Al));

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 482  : 		}

	ret	0
?max_size@?$allocator_traits@V?$xalloc@PEAVCTimer_paused@@@@@std@@SA_KAEBV?$xalloc@PEAVCTimer_paused@@@@@Z ENDP ; std::allocator_traits<xalloc<CTimer_paused * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::max_size, COMDAT

; 884  : 		return (_Mytraits::max_size(*this));

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 885  : 		}

	ret	0
?max_size@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::max_size, COMDAT

; 1153 : 		return (this->_Getal().max_size());

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1154 : 		}

	ret	0
?max_size@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::capacity, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1011 : 		}

	ret	0
?capacity@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEBA_KXZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_math.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
;	COMDAT ?GetElapsed_ticks@CTimerBase@@QEBA_KXZ
_TEXT	SEGMENT
_dest$1 = 48
this$ = 48
?GetElapsed_ticks@CTimerBase@@QEBA_KXZ PROC		; CTimerBase::GetElapsed_ticks, COMDAT

; 30   : 	ICF u64		GetElapsed_ticks()const	{	if(bPause) return	qwPausedTime; else return CPU::QPC()-qwStartTime-CPU::qpc_overhead-qwPauseAccum; }

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	cmp	DWORD PTR [rcx+24], 0
	mov	rbx, rcx
	je	SHORT $LN2@GetElapsed
	mov	rax, QWORD PTR [rcx+8]
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@GetElapsed:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_math.cpp

; 143  : 		QueryPerformanceCounter			((PLARGE_INTEGER)&_dest);

	lea	rcx, QWORD PTR _dest$1[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 144  : 		qpc_counter	++	;

	inc	DWORD PTR ?qpc_counter@CPU@@3IA		; CPU::qpc_counter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h

; 30   : 	ICF u64		GetElapsed_ticks()const	{	if(bPause) return	qwPausedTime; else return CPU::QPC()-qwStartTime-CPU::qpc_overhead-qwPauseAccum; }

	mov	rax, QWORD PTR _dest$1[rsp]
	sub	rax, QWORD PTR [rbx+16]
	sub	rax, QWORD PTR [rbx]
	sub	rax, QWORD PTR ?qpc_overhead@CPU@@3_KA	; CPU::qpc_overhead
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?GetElapsed_ticks@CTimerBase@@QEBA_KXZ ENDP		; CTimerBase::GetElapsed_ticks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_math.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_math.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_math.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
;	COMDAT ?Pause@CTimer_paused_ex@@QEAAXH@Z
_TEXT	SEGMENT
_dest$1 = 48
_dest$2 = 48
this$ = 48
b$ = 56
?Pause@CTimer_paused_ex@@QEAAXH@Z PROC			; CTimer_paused_ex::Pause, COMDAT

; 139  : 	IC void		Pause			(BOOL b){

$LN15:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rbx, rcx

; 140  : 		if(bPause==b)			return	;

	cmp	DWORD PTR [rcx+32], edx
	je	$LN4@Pause
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_math.cpp

; 143  : 		QueryPerformanceCounter			((PLARGE_INTEGER)&_dest);

	lea	rcx, QWORD PTR _dest$2[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h

; 142  : 		u64		_current		=		CPU::QPC()-CPU::qpc_overhead	;

	mov	rax, QWORD PTR _dest$2[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_math.cpp

; 144  : 		qpc_counter	++	;

	inc	DWORD PTR ?qpc_counter@CPU@@3IA		; CPU::qpc_counter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h

; 142  : 		u64		_current		=		CPU::QPC()-CPU::qpc_overhead	;

	sub	rax, QWORD PTR ?qpc_overhead@CPU@@3_KA	; CPU::qpc_overhead

; 143  : 		if( b )	{

	test	edi, edi
	je	SHORT $LN2@Pause

; 144  : 			save_clock			= _current				;

	mov	QWORD PTR [rbx+64], rax

; 30   : 	ICF u64		GetElapsed_ticks()const	{	if(bPause) return	qwPausedTime; else return CPU::QPC()-qwStartTime-CPU::qpc_overhead-qwPauseAccum; }

	cmp	DWORD PTR [rbx+32], 0
	je	SHORT $LN9@Pause
	mov	rax, QWORD PTR [rbx+16]

; 148  : 		}
; 149  : 		bPause = b;

	mov	DWORD PTR [rbx+32], edi
	mov	QWORD PTR [rbx+16], rax

; 150  : 	}

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@Pause:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_math.cpp

; 143  : 		QueryPerformanceCounter			((PLARGE_INTEGER)&_dest);

	lea	rcx, QWORD PTR _dest$1[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 144  : 		qpc_counter	++	;

	inc	DWORD PTR ?qpc_counter@CPU@@3IA		; CPU::qpc_counter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h

; 30   : 	ICF u64		GetElapsed_ticks()const	{	if(bPause) return	qwPausedTime; else return CPU::QPC()-qwStartTime-CPU::qpc_overhead-qwPauseAccum; }

	mov	rax, QWORD PTR _dest$1[rsp]
	sub	rax, QWORD PTR [rbx+24]
	sub	rax, QWORD PTR [rbx+8]
	sub	rax, QWORD PTR ?qpc_overhead@CPU@@3_KA	; CPU::qpc_overhead

; 148  : 		}
; 149  : 		bPause = b;

	mov	DWORD PTR [rbx+32], edi
	mov	QWORD PTR [rbx+16], rax

; 150  : 	}

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Pause:

; 145  : 			qwPausedTime		= CTimerBase::GetElapsed_ticks()	;
; 146  : 		}else	{
; 147  : 			qwPauseAccum		+=		_current - save_clock;

	sub	rax, QWORD PTR [rbx+64]

; 148  : 		}
; 149  : 		bPause = b;

	mov	DWORD PTR [rbx+32], edi
	add	QWORD PTR [rbx+24], rax
$LN4@Pause:

; 150  : 	}

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?Pause@CTimer_paused_ex@@QEAAXH@Z ENDP			; CTimer_paused_ex::Pause
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAXPEAPEAVCTimer_paused@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAXPEAPEAVCTimer_paused@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >, COMDAT

; 90   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAXPEAPEAVCTimer_paused@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PEAVCTimer_paused@@PEAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVCTimer_paused@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@PEAVCTimer_paused@@PEAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVCTimer_paused@@0@Z PROC ; std::_Ptr_cat<CTimer_paused * __ptr64,CTimer_paused * __ptr64>, COMDAT

; 444  : 	{	// return pointer category from pointers

	mov	QWORD PTR [rsp+16], rdx

; 445  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 446  : 	return (_Cat);

	movzx	eax, BYTE PTR _Cat$[rsp]

; 447  : 	}

	ret	0
??$_Ptr_cat@PEAVCTimer_paused@@PEAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAVCTimer_paused@@0@Z ENDP ; std::_Ptr_cat<CTimer_paused * __ptr64,CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAXPEAPEAVCTimer_paused@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAXPEAPEAVCTimer_paused@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >, COMDAT

; 96   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 97   : 	}

	ret	0
??$_Destroy_range@U?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@YAXPEAPEAVCTimer_paused@@0AEAU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXPEAPEAVCTimer_paused@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXPEAPEAVCTimer_paused@@0@Z PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Destroy, COMDAT

; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}

	ret	0
?_Destroy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXPEAPEAVCTimer_paused@@0@Z ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z
_TEXT	SEGMENT
P$ = 48
??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z PROC ; xr_free<CTimer_paused * __ptr64>, COMDAT

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

$LN30:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rdi, rdi
	je	SHORT $LN1@xr_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN6@xr_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN27@xr_free

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	QWORD PTR [rsi], 0
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@xr_free:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
$LN27@xr_free:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	QWORD PTR [rsi], 0
$LN1@xr_free:
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ENDP ; xr_free<CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?deallocate@?$xalloc@PEAVCTimer_paused@@@@QEBAXPEAPEAVCTimer_paused@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
p$ = 56
n$dead$ = 64
?deallocate@?$xalloc@PEAVCTimer_paused@@@@QEBAXPEAPEAVCTimer_paused@@_K@Z PROC ; xalloc<CTimer_paused * __ptr64>::deallocate, COMDAT

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	sub	rsp, 40					; 00000028H
	lea	rcx, QWORD PTR p$[rsp]
	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$xalloc@PEAVCTimer_paused@@@@QEBAXPEAPEAVCTimer_paused@@_K@Z ENDP ; xalloc<CTimer_paused * __ptr64>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
p$ = 64
_Count$dead$ = 64
?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@_K@Z PROC ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::deallocate, COMDAT

; 857  : 		{	// deallocate object at _Ptr, ignore size

$LN6:
	mov	QWORD PTR [rsp+24], r8
	sub	rsp, 40					; 00000028H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$[rsp], rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 859  : 		}

	add	rsp, 40					; 00000028H
	ret	0
?deallocate@?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAAXPEAPEAVCTimer_paused@@_K@Z ENDP ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@PEAVCTimer_paused@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xalloc@PEAVCTimer_paused@@@@QEAA@XZ PROC		; xalloc<CTimer_paused * __ptr64>::xalloc<CTimer_paused * __ptr64>, COMDAT

; 76   : 													xalloc			()										{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@PEAVCTimer_paused@@@@QEAA@XZ ENDP		; xalloc<CTimer_paused * __ptr64>::xalloc<CTimer_paused * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >, COMDAT

; 802  : 		}

	mov	rax, rcx
	ret	0
??0?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >::_Wrap_alloc<xalloc<CTimer_paused * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >::_Getal, COMDAT

; 642  : 		return (_Alty());

	mov	rax, rdx

; 643  : 		}

	ret	0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$xalloc@PEAVCTimer_paused@@@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXXZ
_TEXT	SEGMENT
p$ = 48
this$ = 48
?_Tidy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXXZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Tidy, COMDAT

; 1622 : 		{	// free all storage

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN1@Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN1@Tidy:

; 1632 : 			}
; 1633 : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Tidy@?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@IEAAXXZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
p$1 = 48
this$ = 48
??1?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ PROC ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::~vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >, COMDAT

; 944  : 		{	// destroy the object

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	mov	rax, QWORD PTR [rcx]

; 944  : 		{	// destroy the object

	mov	rbx, rcx

; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);
; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);
; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);
; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1584 : 		}
; 1585 : 
; 1586 : 	void _Reallocate(size_type _Count)
; 1587 : 		{	// move to array of exactly _Count elements
; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())
; 1599 : 			{	// destroy and deallocate old array
; 1600 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1601 : 			this->_Getal().deallocate(this->_Myfirst,
; 1602 : 				this->_Myend - this->_Myfirst);
; 1603 : 			}
; 1604 : 
; 1605 : 		this->_Orphan_all();
; 1606 : 		this->_Myend = _Ptr + _Count;
; 1607 : 		this->_Mylast = _Ptr + _Size;
; 1608 : 		this->_Myfirst = _Ptr;
; 1609 : 		}
; 1610 : 
; 1611 : 	void _Reserve(size_type _Count)
; 1612 : 		{	// ensure room for _Count new elements, grow exponentially
; 1613 : 		if (_Unused_capacity() < _Count)
; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)
; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));
; 1618 : 			}
; 1619 : 		}
; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())

	test	rax, rax
	je	SHORT $LN3@vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$1[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN3@vector:

; 945  : 		_Tidy();
; 946  : 		}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@std@@QEAA@XZ ENDP ; std::vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::~vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ
_TEXT	SEGMENT
p$1 = 48
this$ = 48
??1?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ PROC ; xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::~xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >, COMDAT
$LN17:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN5@xr_vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$1[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN5@xr_vector:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1?$xr_vector@PEAVCTimer_paused@@V?$xalloc@PEAVCTimer_paused@@@@@@QEAA@XZ ENDP ; xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >::~xr_vector<CTimer_paused * __ptr64,xalloc<CTimer_paused * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??1pauseMngr@@QEAA@XZ
_TEXT	SEGMENT
p$1 = 48
this$ = 48
??1pauseMngr@@QEAA@XZ PROC				; pauseMngr::~pauseMngr, COMDAT
$LN19:
	push	rbx
	sub	rsp, 32					; 00000020H

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	test	rax, rax
	je	SHORT $LN7@pauseMngr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$1[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@PEAVCTimer_paused@@@@YAXAEAPEAPEAVCTimer_paused@@@Z ; xr_free<CTimer_paused * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN7@pauseMngr:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1pauseMngr@@QEAA@XZ ENDP				; pauseMngr::~pauseMngr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
;	COMDAT ??0CTimerBase@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0CTimerBase@@QEAA@XZ PROC				; CTimerBase::CTimerBase, COMDAT

; 28   : 				CTimerBase		()		: qwStartTime(0),qwPausedTime(0),qwPauseAccum(0),bPause(FALSE)		{ }

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	DWORD PTR [rcx+24], eax
	mov	rax, rcx
	ret	0
??0CTimerBase@@QEAA@XZ ENDP				; CTimerBase::CTimerBase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ftimer.h
;	COMDAT ??0CTimer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0CTimer@@QEAA@XZ PROC					; CTimer::CTimer, COMDAT

; 28   : 				CTimerBase		()		: qwStartTime(0),qwPausedTime(0),qwPauseAccum(0),bPause(FALSE)		{ }

	xor	eax, eax

; 69   : 	IC					CTimer			() : m_time_factor(1.f), m_real_ticks(0), m_ticks(0) {}

	mov	DWORD PTR [rcx+32], 1065353216		; 3f800000H

; 28   : 				CTimerBase		()		: qwStartTime(0),qwPausedTime(0),qwPauseAccum(0),bPause(FALSE)		{ }

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	DWORD PTR [rcx+24], eax

; 69   : 	IC					CTimer			() : m_time_factor(1.f), m_real_ticks(0), m_ticks(0) {}

	mov	QWORD PTR [rcx+40], rax
	mov	QWORD PTR [rcx+48], rax
	mov	rax, rcx
	ret	0
??0CTimer@@QEAA@XZ ENDP					; CTimer::CTimer
_TEXT	ENDS
END
