; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@NDJPHIGH@FileDownload?$AA@		; `string'
PUBLIC	??_C@_06ODPOMCLF@FS?4cpp?$AA@			; `string'
PUBLIC	??_C@_07DAHKOGFN@hFile?$DO0?$AA@		; `string'
PUBLIC	??_C@_0BG@MHEELJOF@Can?8t?5read?5file?5data?3?$AA@ ; `string'
PUBLIC	??_C@_0BD@OMBPCKBP@r_bytes?$DN?$DN?$CIint?$CJsize?$AA@ ; `string'
PUBLIC	??_C@_0N@OHMAIPMK@FileCompress?$AA@		; `string'
PUBLIC	??_C@_03HBKIKOFI@H?$DO0?$AA@			; `string'
PUBLIC	??_C@_0P@MHGIJJCK@FileDecompress?$AA@		; `string'
PUBLIC	??_C@_0DK@HIOEDNGA@FATAL?3?5signatures?5doesn?8t?5match?0@ ; `string'
PUBLIC	??_C@_0BC@MHGJGJKA@strncmp?$CIM?0F?08?$CJ?$DN?$DN0?$AA@ ; `string'
PUBLIC	??_C@_0BC@LFPNBCKC@IReader?3?3r_string?$AA@	; `string'
PUBLIC	??_C@_0BO@CBOGAODA@Dest?5string?5less?5than?5needed?4?$AA@ ; `string'
PUBLIC	??_C@_0O@CCNJDAAG@sz?$DM?$CItgt_sz?91?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BD@HIDJIKAI@IReader?3?3r_stringZ?$AA@	; `string'
PUBLIC	??_C@_09KHGJHDDP@sz?$DMtgt_sz?$AA@		; `string'
PUBLIC	??_C@_0BP@JFCPEDIH@CVirtualFileRW?3?3CVirtualFileRW?$AA@ ; `string'
PUBLIC	??_C@_0BP@JJGNJHJF@hSrcFile?$CB?$DNINVALID_HANDLE_VALUE?$AA@ ; `string'
PUBLIC	??_C@_04EBKMHHBE@Size?$AA@			; `string'
PUBLIC	??_C@_0BO@DODFDMMA@hSrcMap?$CB?$DNINVALID_HANDLE_VALUE?$AA@ ; `string'
PUBLIC	??_C@_04PJOLNDGD@data?$AA@			; `string'
PUBLIC	??_C@_0CH@JKOJKKOC@CVirtualFileReader?3?3CVirtualFile@ ; `string'
PUBLIC	??_R2CVirtualFileReader@@8			; CVirtualFileReader::`RTTI Base Class Array'
PUBLIC	??_R2CCompressedReader@@8			; CCompressedReader::`RTTI Base Class Array'
PUBLIC	??_R2CFileReader@@8				; CFileReader::`RTTI Base Class Array'
PUBLIC	??_R2CPackReader@@8				; CPackReader::`RTTI Base Class Array'
PUBLIC	??_R2CTempReader@@8				; CTempReader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CVirtualFileReader@@8		; CVirtualFileReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CCompressedReader@@8		; CCompressedReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CFileReader@@8			; CFileReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CPackReader@@8			; CPackReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CTempReader@@8			; CTempReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3CVirtualFileReader@@8			; CVirtualFileReader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCVirtualFileReader@@@8			; CVirtualFileReader `RTTI Type Descriptor'
PUBLIC	??_R3CCompressedReader@@8			; CCompressedReader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCCompressedReader@@@8			; CCompressedReader `RTTI Type Descriptor'
PUBLIC	??_R3CFileReader@@8				; CFileReader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCFileReader@@@8				; CFileReader `RTTI Type Descriptor'
PUBLIC	??_R3CPackReader@@8				; CPackReader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCPackReader@@@8				; CPackReader `RTTI Type Descriptor'
PUBLIC	??_R3CTempReader@@8				; CTempReader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVCTempReader@@@8				; CTempReader `RTTI Type Descriptor'
PUBLIC	??_R4CVirtualFileReader@@6B@			; CVirtualFileReader::`RTTI Complete Object Locator'
PUBLIC	??_R4CCompressedReader@@6B@			; CCompressedReader::`RTTI Complete Object Locator'
PUBLIC	??_R4CFileReader@@6B@				; CFileReader::`RTTI Complete Object Locator'
PUBLIC	??_R4CPackReader@@6B@				; CPackReader::`RTTI Complete Object Locator'
PUBLIC	??_R4CTempReader@@6B@				; CTempReader::`RTTI Complete Object Locator'
PUBLIC	??_7CVirtualFileReader@@6B@			; CVirtualFileReader::`vftable'
PUBLIC	??_7CCompressedReader@@6B@			; CCompressedReader::`vftable'
PUBLIC	??_7CFileReader@@6B@				; CFileReader::`vftable'
PUBLIC	?g_dummy_stuff@@3P6AXPEBXAEBIPEAX@ZEA		; g_dummy_stuff
PUBLIC	??_7CPackReader@@6B@				; CPackReader::`vftable'
PUBLIC	??_7CTempReader@@6B@				; CTempReader::`vftable'
EXTRN	__imp_MapViewOfFile:PROC
EXTRN	__imp_CreateFileMappingA:PROC
EXTRN	__imp_GetFileSize:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_UnmapViewOfFile:PROC
EXTRN	__imp_vsprintf:PROC
EXTRN	__imp_filelength:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp__write:PROC
EXTRN	__imp_open:PROC
EXTRN	__imp__close:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp__filelength:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_?_open@@YAHPEBDHH@Z:PROC
EXTRN	__imp__mkdir:PROC
;	COMDAT ?ignore_always@?BA@???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BA@???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA DB 01H DUP (?) ; `CVirtualFileReader::CVirtualFileReader'::`16'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?M@???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?M@???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA DB 01H DUP (?) ; `CVirtualFileReader::CVirtualFileReader'::`12'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?7???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA DB 01H DUP (?) ; `CVirtualFileReader::CVirtualFileReader'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA DB 01H DUP (?) ; `CVirtualFileReader::CVirtualFileReader'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BA@???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BA@???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA DB 01H DUP (?) ; `CVirtualFileRW::CVirtualFileRW'::`16'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?M@???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?M@???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA DB 01H DUP (?) ; `CVirtualFileRW::CVirtualFileRW'::`12'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?7???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?7???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA DB 01H DUP (?) ; `CVirtualFileRW::CVirtualFileRW'::`8'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA DB 01H DUP (?) ; `CVirtualFileRW::CVirtualFileRW'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??r_stringZ@IReader@@QEAAXPEADI@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??r_stringZ@IReader@@QEAAXPEADI@Z@4_NA DB 01H DUP (?) ; `IReader::r_stringZ'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??r_string@IReader@@QEAAXPEADI@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??r_string@IReader@@QEAAXPEADI@Z@4_NA DB 01H DUP (?) ; `IReader::r_string'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?L@??FileDecompress@@YAPEAXPEBD0PEAI@Z@4_NA
_BSS	SEGMENT
?ignore_always@?L@??FileDecompress@@YAPEAXPEBD0PEAI@Z@4_NA DB 01H DUP (?) ; `FileDecompress'::`11'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??FileDecompress@@YAPEAXPEBD0PEAI@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??FileDecompress@@YAPEAXPEBD0PEAI@Z@4_NA DB 01H DUP (?) ; `FileDecompress'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??FileCompress@@YAXPEBD0PEAXI@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??FileCompress@@YAXPEBD0PEAXI@Z@4_NA DB 01H DUP (?) ; `FileCompress'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?L@??FileDownload@@YAPEAXPEBDPEAI@Z@4_NA
_BSS	SEGMENT
?ignore_always@?L@??FileDownload@@YAPEAXPEBDPEAI@Z@4_NA DB 01H DUP (?) ; `FileDownload'::`11'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?6??FileDownload@@YAPEAXPEBDPEAI@Z@4_NA
_BSS	SEGMENT
?ignore_always@?6??FileDownload@@YAPEAXPEBDPEAI@Z@4_NA DB 01H DUP (?) ; `FileDownload'::`7'::ignore_always
?g_dummy_stuff@@3P6AXPEBXAEBIPEAX@ZEA DQ 01H DUP (?)	; g_dummy_stuff
_BSS	ENDS
;	COMDAT ??_7CTempReader@@6B@
CONST	SEGMENT
??_7CTempReader@@6B@ DQ FLAT:??_R4CTempReader@@6B@	; CTempReader::`vftable'
	DQ	FLAT:??_ECTempReader@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7CPackReader@@6B@
CONST	SEGMENT
??_7CPackReader@@6B@ DQ FLAT:??_R4CPackReader@@6B@	; CPackReader::`vftable'
	DQ	FLAT:??_ECPackReader@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7CFileReader@@6B@
CONST	SEGMENT
??_7CFileReader@@6B@ DQ FLAT:??_R4CFileReader@@6B@	; CFileReader::`vftable'
	DQ	FLAT:??_ECFileReader@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7CCompressedReader@@6B@
CONST	SEGMENT
??_7CCompressedReader@@6B@ DQ FLAT:??_R4CCompressedReader@@6B@ ; CCompressedReader::`vftable'
	DQ	FLAT:??_ECCompressedReader@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7CVirtualFileReader@@6B@
CONST	SEGMENT
??_7CVirtualFileReader@@6B@ DQ FLAT:??_R4CVirtualFileReader@@6B@ ; CVirtualFileReader::`vftable'
	DQ	FLAT:??_ECVirtualFileReader@@UEAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R4CTempReader@@6B@
rdata$r	SEGMENT
??_R4CTempReader@@6B@ DD 01H				; CTempReader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCTempReader@@@8
	DD	imagerel ??_R3CTempReader@@8
	DD	imagerel ??_R4CTempReader@@6B@
rdata$r	ENDS
;	COMDAT ??_R4CPackReader@@6B@
rdata$r	SEGMENT
??_R4CPackReader@@6B@ DD 01H				; CPackReader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCPackReader@@@8
	DD	imagerel ??_R3CPackReader@@8
	DD	imagerel ??_R4CPackReader@@6B@
rdata$r	ENDS
;	COMDAT ??_R4CFileReader@@6B@
rdata$r	SEGMENT
??_R4CFileReader@@6B@ DD 01H				; CFileReader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCFileReader@@@8
	DD	imagerel ??_R3CFileReader@@8
	DD	imagerel ??_R4CFileReader@@6B@
rdata$r	ENDS
;	COMDAT ??_R4CCompressedReader@@6B@
rdata$r	SEGMENT
??_R4CCompressedReader@@6B@ DD 01H			; CCompressedReader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCCompressedReader@@@8
	DD	imagerel ??_R3CCompressedReader@@8
	DD	imagerel ??_R4CCompressedReader@@6B@
rdata$r	ENDS
;	COMDAT ??_R4CVirtualFileReader@@6B@
rdata$r	SEGMENT
??_R4CVirtualFileReader@@6B@ DD 01H			; CVirtualFileReader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVCVirtualFileReader@@@8
	DD	imagerel ??_R3CVirtualFileReader@@8
	DD	imagerel ??_R4CVirtualFileReader@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVCTempReader@@@8
data$r	SEGMENT
??_R0?AVCTempReader@@@8 DQ FLAT:??_7type_info@@6B@	; CTempReader `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCTempReader@@', 00H
data$r	ENDS
;	COMDAT ??_R3CTempReader@@8
rdata$r	SEGMENT
??_R3CTempReader@@8 DD 00H				; CTempReader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2CTempReader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPackReader@@@8
data$r	SEGMENT
??_R0?AVCPackReader@@@8 DQ FLAT:??_7type_info@@6B@	; CPackReader `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCPackReader@@', 00H
data$r	ENDS
;	COMDAT ??_R3CPackReader@@8
rdata$r	SEGMENT
??_R3CPackReader@@8 DD 00H				; CPackReader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2CPackReader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFileReader@@@8
data$r	SEGMENT
??_R0?AVCFileReader@@@8 DQ FLAT:??_7type_info@@6B@	; CFileReader `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCFileReader@@', 00H
data$r	ENDS
;	COMDAT ??_R3CFileReader@@8
rdata$r	SEGMENT
??_R3CFileReader@@8 DD 00H				; CFileReader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2CFileReader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCompressedReader@@@8
data$r	SEGMENT
??_R0?AVCCompressedReader@@@8 DQ FLAT:??_7type_info@@6B@ ; CCompressedReader `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCCompressedReader@@', 00H
data$r	ENDS
;	COMDAT ??_R3CCompressedReader@@8
rdata$r	SEGMENT
??_R3CCompressedReader@@8 DD 00H			; CCompressedReader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2CCompressedReader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCVirtualFileReader@@@8
data$r	SEGMENT
??_R0?AVCVirtualFileReader@@@8 DQ FLAT:??_7type_info@@6B@ ; CVirtualFileReader `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVCVirtualFileReader@@', 00H
data$r	ENDS
;	COMDAT ??_R3CVirtualFileReader@@8
rdata$r	SEGMENT
??_R3CVirtualFileReader@@8 DD 00H			; CVirtualFileReader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2CVirtualFileReader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTempReader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTempReader@@8 DD imagerel ??_R0?AVCTempReader@@@8 ; CTempReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CTempReader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPackReader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPackReader@@8 DD imagerel ??_R0?AVCPackReader@@@8 ; CPackReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CPackReader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CFileReader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CFileReader@@8 DD imagerel ??_R0?AVCFileReader@@@8 ; CFileReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CFileReader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CCompressedReader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCompressedReader@@8 DD imagerel ??_R0?AVCCompressedReader@@@8 ; CCompressedReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CCompressedReader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CVirtualFileReader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CVirtualFileReader@@8 DD imagerel ??_R0?AVCVirtualFileReader@@@8 ; CVirtualFileReader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3CVirtualFileReader@@8
rdata$r	ENDS
;	COMDAT ??_R2CTempReader@@8
rdata$r	SEGMENT
??_R2CTempReader@@8 DD imagerel ??_R1A@?0A@EA@CTempReader@@8 ; CTempReader::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@IReader@@8
	DD	imagerel ??_R1A@?0A@EA@?$IReaderBase@VIReader@@@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2CPackReader@@8
rdata$r	SEGMENT
??_R2CPackReader@@8 DD imagerel ??_R1A@?0A@EA@CPackReader@@8 ; CPackReader::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@IReader@@8
	DD	imagerel ??_R1A@?0A@EA@?$IReaderBase@VIReader@@@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2CFileReader@@8
rdata$r	SEGMENT
??_R2CFileReader@@8 DD imagerel ??_R1A@?0A@EA@CFileReader@@8 ; CFileReader::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@IReader@@8
	DD	imagerel ??_R1A@?0A@EA@?$IReaderBase@VIReader@@@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2CCompressedReader@@8
rdata$r	SEGMENT
??_R2CCompressedReader@@8 DD imagerel ??_R1A@?0A@EA@CCompressedReader@@8 ; CCompressedReader::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@IReader@@8
	DD	imagerel ??_R1A@?0A@EA@?$IReaderBase@VIReader@@@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2CVirtualFileReader@@8
rdata$r	SEGMENT
??_R2CVirtualFileReader@@8 DD imagerel ??_R1A@?0A@EA@CVirtualFileReader@@8 ; CVirtualFileReader::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@IReader@@8
	DD	imagerel ??_R1A@?0A@EA@?$IReaderBase@VIReader@@@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_C@_0CH@JKOJKKOC@CVirtualFileReader?3?3CVirtualFile@
CONST	SEGMENT
??_C@_0CH@JKOJKKOC@CVirtualFileReader?3?3CVirtualFile@ DB 'CVirtualFileRe'
	DB	'ader::CVirtualFileReader', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data?$AA@
CONST	SEGMENT
??_C@_04PJOLNDGD@data?$AA@ DB 'data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DODFDMMA@hSrcMap?$CB?$DNINVALID_HANDLE_VALUE?$AA@
CONST	SEGMENT
??_C@_0BO@DODFDMMA@hSrcMap?$CB?$DNINVALID_HANDLE_VALUE?$AA@ DB 'hSrcMap!='
	DB	'INVALID_HANDLE_VALUE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EBKMHHBE@Size?$AA@
CONST	SEGMENT
??_C@_04EBKMHHBE@Size?$AA@ DB 'Size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JJGNJHJF@hSrcFile?$CB?$DNINVALID_HANDLE_VALUE?$AA@
CONST	SEGMENT
??_C@_0BP@JJGNJHJF@hSrcFile?$CB?$DNINVALID_HANDLE_VALUE?$AA@ DB 'hSrcFile'
	DB	'!=INVALID_HANDLE_VALUE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JFCPEDIH@CVirtualFileRW?3?3CVirtualFileRW?$AA@
CONST	SEGMENT
??_C@_0BP@JFCPEDIH@CVirtualFileRW?3?3CVirtualFileRW?$AA@ DB 'CVirtualFile'
	DB	'RW::CVirtualFileRW', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KHGJHDDP@sz?$DMtgt_sz?$AA@
CONST	SEGMENT
??_C@_09KHGJHDDP@sz?$DMtgt_sz?$AA@ DB 'sz<tgt_sz', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HIDJIKAI@IReader?3?3r_stringZ?$AA@
CONST	SEGMENT
??_C@_0BD@HIDJIKAI@IReader?3?3r_stringZ?$AA@ DB 'IReader::r_stringZ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CCNJDAAG@sz?$DM?$CItgt_sz?91?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@CCNJDAAG@sz?$DM?$CItgt_sz?91?$CJ?$AA@ DB 'sz<(tgt_sz-1)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CBOGAODA@Dest?5string?5less?5than?5needed?4?$AA@
CONST	SEGMENT
??_C@_0BO@CBOGAODA@Dest?5string?5less?5than?5needed?4?$AA@ DB 'Dest strin'
	DB	'g less than needed.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LFPNBCKC@IReader?3?3r_string?$AA@
CONST	SEGMENT
??_C@_0BC@LFPNBCKC@IReader?3?3r_string?$AA@ DB 'IReader::r_string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MHGJGJKA@strncmp?$CIM?0F?08?$CJ?$DN?$DN0?$AA@
CONST	SEGMENT
??_C@_0BC@MHGJGJKA@strncmp?$CIM?0F?08?$CJ?$DN?$DN0?$AA@ DB 'strncmp(M,F,8'
	DB	')==0', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@HIOEDNGA@FATAL?3?5signatures?5doesn?8t?5match?0@
CONST	SEGMENT
??_C@_0DK@HIOEDNGA@FATAL?3?5signatures?5doesn?8t?5match?0@ DB 'FATAL: sig'
	DB	'natures doesn''t match, file(%s) / requested(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MHGIJJCK@FileDecompress?$AA@
CONST	SEGMENT
??_C@_0P@MHGIJJCK@FileDecompress?$AA@ DB 'FileDecompress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HBKIKOFI@H?$DO0?$AA@
CONST	SEGMENT
??_C@_03HBKIKOFI@H?$DO0?$AA@ DB 'H>0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OHMAIPMK@FileCompress?$AA@
CONST	SEGMENT
??_C@_0N@OHMAIPMK@FileCompress?$AA@ DB 'FileCompress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OMBPCKBP@r_bytes?$DN?$DN?$CIint?$CJsize?$AA@
CONST	SEGMENT
??_C@_0BD@OMBPCKBP@r_bytes?$DN?$DN?$CIint?$CJsize?$AA@ DB 'r_bytes==(int)'
	DB	'size', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MHEELJOF@Can?8t?5read?5file?5data?3?$AA@
CONST	SEGMENT
??_C@_0BG@MHEELJOF@Can?8t?5read?5file?5data?3?$AA@ DB 'Can''t read file d'
	DB	'ata:', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07DAHKOGFN@hFile?$DO0?$AA@
CONST	SEGMENT
??_C@_07DAHKOGFN@hFile?$DO0?$AA@ DB 'hFile>0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06ODPOMCLF@FS?4cpp?$AA@
CONST	SEGMENT
??_C@_06ODPOMCLF@FS?4cpp?$AA@ DB 'FS.cpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NDJPHIGH@FileDownload?$AA@
CONST	SEGMENT
??_C@_0N@NDJPHIGH@FileDownload?$AA@ DB 'FileDownload', 00H ; `string'
EPS_S	DD	033d6bf95r			; 1e-007
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??$_Fn@V?$xalloc@I@@II@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAI$$QEAI@Z ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int>
PUBLIC	??$construct@II@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI$$QEAI@Z ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int>
PUBLIC	??$forward@I@std@@YA$$QEAIAEAI@Z		; std::forward<unsigned int>
PUBLIC	??$construct@II@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI$$QEAI@Z ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int>
PUBLIC	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
PUBLIC	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
PUBLIC	??$_Val_type@PEAI@std@@YAPEAIPEAI@Z		; std::_Val_type<unsigned int * __ptr64>
PUBLIC	??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >
PUBLIC	??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ; std::_Uninitialized_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >
PUBLIC	??R?$xr_special_free@$00VIReader@@@@QEAAXAEAPEAVIReader@@@Z ; xr_special_free<1,IReader>::operator()
PUBLIC	??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Umove<unsigned int * __ptr64>
PUBLIC	??$addressof@$$CBI@std@@YAPEBIAEBI@Z		; std::addressof<unsigned int const >
PUBLIC	??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z	; xr_delete<IReader>
PUBLIC	??$xr_new@VIReader@@PEAXII@@YAPEAVIReader@@AEBQEAXAEBI1@Z ; xr_new<IReader,void * __ptr64,unsigned int,unsigned int>
PUBLIC	??$xr_new@VCTempReader@@PEAEII@@YAPEAVCTempReader@@AEBQEAEAEBI1@Z ; xr_new<CTempReader,unsigned char * __ptr64,unsigned int,unsigned int>
PUBLIC	??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator-=
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEBIXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
PUBLIC	?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@IV?$xalloc@I@@@std@@IEBA_K_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Grow_to
PUBLIC	?_Unused_capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ ; std::vector<unsigned int,xalloc<unsigned int> >::_Unused_capacity
PUBLIC	??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator-
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEAIXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
PUBLIC	?_Orphan_range@?$vector@IV?$xalloc@I@@@std@@IEBAXPEAI0@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Orphan_range
PUBLIC	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
PUBLIC	?_Inside@?$vector@IV?$xalloc@I@@@std@@IEBA_NPEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Inside
PUBLIC	?end@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,xalloc<unsigned int> >::end
PUBLIC	?pop_back@?$vector@IV?$xalloc@I@@@std@@QEAAXXZ	; std::vector<unsigned int,xalloc<unsigned int> >::pop_back
PUBLIC	?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::push_back
PUBLIC	?back@?$vector@IV?$xalloc@I@@@std@@QEAAAEAIXZ	; std::vector<unsigned int,xalloc<unsigned int> >::back
PUBLIC	?pop@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAXXZ ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::pop
PUBLIC	?push@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAXAEBI@Z ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::push
PUBLIC	?top@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAAEAIXZ ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::top
PUBLIC	?magnitude@?$_vector3@M@@QEBAMXZ		; _vector3<float>::magnitude
PUBLIC	?div@?$_vector3@M@@QEAAAEAU1@AEBU1@M@Z		; _vector3<float>::div
PUBLIC	??1CVirtualFileReader@@UEAA@XZ			; CVirtualFileReader::~CVirtualFileReader
PUBLIC	??_GCVirtualFileReader@@UEAAPEAXI@Z		; CVirtualFileReader::`scalar deleting destructor'
PUBLIC	??0CVirtualFileReader@@QEAA@PEBD@Z		; CVirtualFileReader::CVirtualFileReader
PUBLIC	??0CVirtualFileRW@@QEAA@PEBD@Z			; CVirtualFileRW::CVirtualFileRW
PUBLIC	??1CCompressedReader@@UEAA@XZ			; CCompressedReader::~CCompressedReader
PUBLIC	??_GCCompressedReader@@UEAAPEAXI@Z		; CCompressedReader::`scalar deleting destructor'
PUBLIC	??1CFileReader@@UEAA@XZ				; CFileReader::~CFileReader
PUBLIC	??_GCFileReader@@UEAAPEAXI@Z			; CFileReader::`scalar deleting destructor'
PUBLIC	??0CFileReader@@QEAA@PEBD@Z			; CFileReader::CFileReader
PUBLIC	??1CPackReader@@UEAA@XZ				; CPackReader::~CPackReader
PUBLIC	??1CTempReader@@UEAA@XZ				; CTempReader::~CTempReader
PUBLIC	?skip_stringZ@IReader@@QEAAXXZ			; IReader::skip_stringZ
PUBLIC	?r_stringZ@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z ; IReader::r_stringZ
PUBLIC	?r_stringZ@IReader@@QEAAXAEAVshared_str@@@Z	; IReader::r_stringZ
PUBLIC	?r_stringZ@IReader@@QEAAXPEADI@Z		; IReader::r_stringZ
PUBLIC	?r_string@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z ; IReader::r_string
PUBLIC	?r_string@IReader@@QEAAXPEADI@Z			; IReader::r_string
PUBLIC	?advance_term_string@IReader@@IEAAIXZ		; IReader::advance_term_string
PUBLIC	?is_term@@YAHD@Z				; is_term
PUBLIC	?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z ; IReader::open_chunk_iterator
PUBLIC	?close@IReader@@QEAAXXZ				; IReader::close
PUBLIC	?open_chunk@IReader@@QEAAPEAV1@I@Z		; IReader::open_chunk
PUBLIC	?w_printf@IWriter@@QEAAXPEBDZZ			; IWriter::w_printf
PUBLIC	?w_sdir@IWriter@@QEAAXAEBU?$_vector3@M@@@Z	; IWriter::w_sdir
PUBLIC	?w_chunk@IWriter@@QEAAXIPEAXI@Z			; IWriter::w_chunk
PUBLIC	?w_compressed@IWriter@@QEAAXPEAXI@Z		; IWriter::w_compressed
PUBLIC	?chunk_size@IWriter@@QEAAIXZ			; IWriter::chunk_size
PUBLIC	?close_chunk@IWriter@@QEAAXXZ			; IWriter::close_chunk
PUBLIC	?open_chunk@IWriter@@QEAAXI@Z			; IWriter::open_chunk
PUBLIC	?save_to@CMemoryWriter@@QEAA_NPEBD@Z		; CMemoryWriter::save_to
PUBLIC	?FileDownload@@YAPEAXPEBDPEAI@Z			; FileDownload
PUBLIC	?VerifyPath@@YAXPEBD@Z				; VerifyPath
PUBLIC	??_GCPackReader@@UEAAPEAXI@Z			; CPackReader::`scalar deleting destructor'
PUBLIC	??_GCTempReader@@UEAAPEAXI@Z			; CTempReader::`scalar deleting destructor'
PUBLIC	??0CTempReader@@QEAA@PEAXHH@Z			; CTempReader::CTempReader
PUBLIC	?r@IReader@@QEAAXPEAXH@Z			; IReader::r
PUBLIC	?w@CMemoryWriter@@UEAAXPEBXI@Z			; CMemoryWriter::w
PUBLIC	??1CMemoryWriter@@UEAA@XZ			; CMemoryWriter::~CMemoryWriter
PUBLIC	??1CVirtualFileRW@@UEAA@XZ			; CVirtualFileRW::~CVirtualFileRW
EXTRN	??_ECTempReader@@UEAAPEAXI@Z:PROC		; CTempReader::`vector deleting destructor'
EXTRN	??_ECPackReader@@UEAAPEAXI@Z:PROC		; CPackReader::`vector deleting destructor'
EXTRN	??_ECFileReader@@UEAAPEAXI@Z:PROC		; CFileReader::`vector deleting destructor'
EXTRN	??_ECCompressedReader@@UEAAPEAXI@Z:PROC		; CCompressedReader::`vector deleting destructor'
EXTRN	??_ECVirtualFileReader@@UEAAPEAXI@Z:PROC	; CVirtualFileReader::`vector deleting destructor'
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+59
	DD	imagerel $unwind$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$00VIReader@@@@QEAAXAEAPEAVIReader@@@Z DD imagerel $LN29
	DD	imagerel $LN29+136
	DD	imagerel $unwind$??R?$xr_special_free@$00VIReader@@@@QEAAXAEAPEAVIReader@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z DD imagerel $LN32
	DD	imagerel $LN32+17
	DD	imagerel $unwind$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z DD imagerel $LN32+17
	DD	imagerel $LN32+144
	DD	imagerel $chain$1$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z DD imagerel $LN32+144
	DD	imagerel $LN32+150
	DD	imagerel $chain$2$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VIReader@@PEAXII@@YAPEAVIReader@@AEBQEAXAEBI1@Z DD imagerel $LN12
	DD	imagerel $LN12+114
	DD	imagerel $unwind$??$xr_new@VIReader@@PEAXII@@YAPEAVIReader@@AEBQEAXAEBI1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VCTempReader@@PEAEII@@YAPEAVCTempReader@@AEBQEAEAEBI1@Z DD imagerel $LN14
	DD	imagerel $LN14+114
	DD	imagerel $unwind$??$xr_new@VCTempReader@@PEAEII@@YAPEAVCTempReader@@AEBQEAEAEBI1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD imagerel $LN54
	DD	imagerel $LN54+153
	DD	imagerel $unwind$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA DD imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA+40
	DD	imagerel $unwind$?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD imagerel $LN47
	DD	imagerel $LN47+140
	DD	imagerel $unwind$?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z DD imagerel $LN69
	DD	imagerel $LN69+130
	DD	imagerel $unwind$?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??1CVirtualFileReader@@UEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+65
	DD	imagerel $unwind$??1CVirtualFileReader@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCVirtualFileReader@@UEAAPEAXI@Z DD imagerel $LN14
	DD	imagerel $LN14+99
	DD	imagerel $unwind$??_GCVirtualFileReader@@UEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0CVirtualFileReader@@QEAA@PEBD@Z DD imagerel $LN46
	DD	imagerel $LN46+684
	DD	imagerel $unwind$??0CVirtualFileReader@@QEAA@PEBD@Z
$pdata$??0CVirtualFileRW@@QEAA@PEBD@Z DD imagerel $LN46
	DD	imagerel $LN46+685
	DD	imagerel $unwind$??0CVirtualFileRW@@QEAA@PEBD@Z
$pdata$??1CCompressedReader@@UEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+51
	DD	imagerel $unwind$??1CCompressedReader@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCCompressedReader@@UEAAPEAXI@Z DD imagerel $LN19
	DD	imagerel $LN19+86
	DD	imagerel $unwind$??_GCCompressedReader@@UEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??1CFileReader@@UEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+51
	DD	imagerel $unwind$??1CFileReader@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCFileReader@@UEAAPEAXI@Z DD imagerel $LN19
	DD	imagerel $LN19+86
	DD	imagerel $unwind$??_GCFileReader@@UEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$??0CFileReader@@QEAA@PEBD@Z DD imagerel $LN8
	DD	imagerel $LN8+61
	DD	imagerel $unwind$??0CFileReader@@QEAA@PEBD@Z
$pdata$??1CPackReader@@UEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+45
	DD	imagerel $unwind$??1CPackReader@@UEAA@XZ
$pdata$??1CTempReader@@UEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+51
	DD	imagerel $unwind$??1CTempReader@@UEAA@XZ
$pdata$?r_stringZ@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z DD imagerel $LN15
	DD	imagerel $LN15+75
	DD	imagerel $unwind$?r_stringZ@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z
$pdata$?r_stringZ@IReader@@QEAAXAEAVshared_str@@@Z DD imagerel $LN18
	DD	imagerel $LN18+109
	DD	imagerel $unwind$?r_stringZ@IReader@@QEAAXAEAVshared_str@@@Z
$pdata$?r_stringZ@IReader@@QEAAXPEADI@Z DD imagerel $LN27
	DD	imagerel $LN27+202
	DD	imagerel $unwind$?r_stringZ@IReader@@QEAAXPEADI@Z
$pdata$?r_string@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$?r_string@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z
$pdata$?r_string@IReader@@QEAAXPEADI@Z DD imagerel $LN10
	DD	imagerel $LN10+179
	DD	imagerel $unwind$?r_string@IReader@@QEAAXPEADI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?advance_term_string@IReader@@IEAAIXZ DD imagerel $LN52
	DD	imagerel $LN52+137
	DD	imagerel $unwind$?advance_term_string@IReader@@IEAAIXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z DD imagerel $LN103
	DD	imagerel $LN103+139
	DD	imagerel $unwind$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z
$pdata$2$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z DD imagerel $LN103+139
	DD	imagerel $LN103+265
	DD	imagerel $chain$2$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z
$pdata$4$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z DD imagerel $LN103+265
	DD	imagerel $LN103+275
	DD	imagerel $chain$4$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z
$pdata$5$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z DD imagerel $LN103+275
	DD	imagerel $LN103+355
	DD	imagerel $chain$5$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z
$pdata$?close@IReader@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$?close@IReader@@QEAAXXZ
$pdata$?open_chunk@IReader@@QEAAPEAV1@I@Z DD imagerel $LN119
	DD	imagerel $LN119+146
	DD	imagerel $unwind$?open_chunk@IReader@@QEAAPEAV1@I@Z
$pdata$0$?open_chunk@IReader@@QEAAPEAV1@I@Z DD imagerel $LN119+146
	DD	imagerel $LN119+275
	DD	imagerel $chain$0$?open_chunk@IReader@@QEAAPEAV1@I@Z
$pdata$2$?open_chunk@IReader@@QEAAPEAV1@I@Z DD imagerel $LN119+275
	DD	imagerel $LN119+288
	DD	imagerel $chain$2$?open_chunk@IReader@@QEAAPEAV1@I@Z
$pdata$3$?open_chunk@IReader@@QEAAPEAV1@I@Z DD imagerel $LN119+288
	DD	imagerel $LN119+356
	DD	imagerel $chain$3$?open_chunk@IReader@@QEAAPEAV1@I@Z
$pdata$?w_printf@IWriter@@QEAAXPEBDZZ DD imagerel $LN7
	DD	imagerel $LN7+83
	DD	imagerel $unwind$?w_printf@IWriter@@QEAAXPEBDZZ
$pdata$?w_sdir@IWriter@@QEAAXAEBU?$_vector3@M@@@Z DD imagerel $LN22
	DD	imagerel $LN22+221
	DD	imagerel $unwind$?w_sdir@IWriter@@QEAAXAEBU?$_vector3@M@@@Z
$pdata$?w_chunk@IWriter@@QEAAXIPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+90
	DD	imagerel $unwind$?w_chunk@IWriter@@QEAAXIPEAXI@Z
$pdata$?w_compressed@IWriter@@QEAAXPEAXI@Z DD imagerel $LN42
	DD	imagerel $LN42+243
	DD	imagerel $unwind$?w_compressed@IWriter@@QEAAXPEAXI@Z
$pdata$?chunk_size@IWriter@@QEAAIXZ DD imagerel $LN33
	DD	imagerel $LN33+55
	DD	imagerel $unwind$?chunk_size@IWriter@@QEAAIXZ
$pdata$?close_chunk@IWriter@@QEAAXXZ DD imagerel $LN63
	DD	imagerel $LN63+106
	DD	imagerel $unwind$?close_chunk@IWriter@@QEAAXXZ
$pdata$?open_chunk@IWriter@@QEAAXI@Z DD imagerel $LN77
	DD	imagerel $LN77+204
	DD	imagerel $unwind$?open_chunk@IWriter@@QEAAXI@Z
$pdata$?save_to@CMemoryWriter@@QEAA_NPEBD@Z DD imagerel $LN26
	DD	imagerel $LN26+156
	DD	imagerel $unwind$?save_to@CMemoryWriter@@QEAA_NPEBD@Z
$pdata$?FileDownload@@YAPEAXPEBDPEAI@Z DD imagerel $LN19
	DD	imagerel $LN19+355
	DD	imagerel $unwind$?FileDownload@@YAPEAXPEBDPEAI@Z
$pdata$?VerifyPath@@YAXPEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+25
	DD	imagerel $unwind$?VerifyPath@@YAXPEBD@Z
$pdata$1$?VerifyPath@@YAXPEBD@Z DD imagerel $LN13+25
	DD	imagerel $LN13+115
	DD	imagerel $chain$1$?VerifyPath@@YAXPEBD@Z
$pdata$2$?VerifyPath@@YAXPEBD@Z DD imagerel $LN13+115
	DD	imagerel $LN13+132
	DD	imagerel $chain$2$?VerifyPath@@YAXPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCPackReader@@UEAAPEAXI@Z DD imagerel $LN14
	DD	imagerel $LN14+79
	DD	imagerel $unwind$??_GCPackReader@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GCTempReader@@UEAAPEAXI@Z DD imagerel $LN19
	DD	imagerel $LN19+86
	DD	imagerel $unwind$??_GCTempReader@@UEAAPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?r@IReader@@QEAAXPEAXH@Z DD imagerel $LN14
	DD	imagerel $LN14+52
	DD	imagerel $unwind$?r@IReader@@QEAAXPEAXH@Z
$pdata$?w@CMemoryWriter@@UEAAXPEBXI@Z DD imagerel $LN16
	DD	imagerel $LN16+151
	DD	imagerel $unwind$?w@CMemoryWriter@@UEAAXPEBXI@Z
$pdata$??1CMemoryWriter@@UEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$??1CMemoryWriter@@UEAA@XZ
$pdata$??1CVirtualFileRW@@UEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+65
	DD	imagerel $unwind$??1CVirtualFileRW@@UEAA@XZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCTempReader@@UEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCPackReader@@UEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?advance_term_string@IReader@@IEAAIXZ DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCFileReader@@UEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCCompressedReader@@UEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GCVirtualFileReader@@UEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
xdata	SEGMENT
$unwind$??1CVirtualFileReader@@UEAA@XZ DD 020601H
	DD	030023206H
$unwind$??0CVirtualFileReader@@QEAA@PEBD@Z DD 0a1801H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0f0149218H
	DD	07010e012H
$unwind$??0CVirtualFileRW@@QEAA@PEBD@Z DD 0a1801H
	DD	0106418H
	DD	0f5418H
	DD	0e3418H
	DD	0f0149218H
	DD	07010e012H
$unwind$??1CCompressedReader@@UEAA@XZ DD 020601H
	DD	030023206H
$unwind$??1CFileReader@@UEAA@XZ DD 020601H
	DD	030023206H
$unwind$??0CFileReader@@QEAA@PEBD@Z DD 020601H
	DD	030023206H
$unwind$??1CPackReader@@UEAA@XZ DD 020601H
	DD	030023206H
$unwind$??1CTempReader@@UEAA@XZ DD 020601H
	DD	030023206H
$unwind$?r_stringZ@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?r_stringZ@IReader@@QEAAXAEAVshared_str@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?r_stringZ@IReader@@QEAAXPEADI@Z DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
$unwind$?r_string@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?r_string@IReader@@QEAAXPEADI@Z DD 081401H
	DD	0e6414H
	DD	0d5414H
	DD	0c3414H
	DD	070109214H
$unwind$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z DD 085b01H
	DD	0b745bH
	DD	0a6456H
	DD	0f006320aH
	DD	03002e004H
$chain$2$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z DD 020521H
	DD	095405H
	DD	imagerel $LN103
	DD	imagerel $LN103+139
	DD	imagerel $unwind$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z
$chain$4$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z DD 020021H
	DD	095400H
	DD	imagerel $LN103
	DD	imagerel $LN103+139
	DD	imagerel $unwind$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z
$chain$5$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z DD 021H
	DD	imagerel $LN103
	DD	imagerel $LN103+139
	DD	imagerel $unwind$?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z
$unwind$?close@IReader@@QEAAXXZ DD 010901H
	DD	04209H
$unwind$?open_chunk@IReader@@QEAAPEAV1@I@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
$chain$0$?open_chunk@IReader@@QEAAPEAV1@I@Z DD 020521H
	DD	065405H
	DD	imagerel $LN119
	DD	imagerel $LN119+146
	DD	imagerel $unwind$?open_chunk@IReader@@QEAAPEAV1@I@Z
$chain$2$?open_chunk@IReader@@QEAAPEAV1@I@Z DD 020021H
	DD	065400H
	DD	imagerel $LN119
	DD	imagerel $LN119+146
	DD	imagerel $unwind$?open_chunk@IReader@@QEAAPEAV1@I@Z
$chain$3$?open_chunk@IReader@@QEAAPEAV1@I@Z DD 021H
	DD	imagerel $LN119
	DD	imagerel $LN119+146
	DD	imagerel $unwind$?open_chunk@IReader@@QEAAPEAV1@I@Z
$unwind$?w_printf@IWriter@@QEAAXPEBDZZ DD 031701H
	DD	0840117H
	DD	03010H
$unwind$?w_sdir@IWriter@@QEAAXAEBU?$_vector3@M@@@Z DD 041901H
	DD	036819H
	DD	030027206H
$unwind$?w_chunk@IWriter@@QEAAXIPEAXI@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$?w_compressed@IWriter@@QEAAXPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?chunk_size@IWriter@@QEAAIXZ DD 031a01H
	DD	04341aH
	DD	04204H
$unwind$?close_chunk@IWriter@@QEAAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
$unwind$?open_chunk@IWriter@@QEAAXI@Z DD 060f01H
	DD	08640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?save_to@CMemoryWriter@@QEAA_NPEBD@Z DD 030901H
	DD	0460109H
	DD	03002H
$unwind$?FileDownload@@YAPEAXPEBDPEAI@Z DD 0c1e01H
	DD	011741eH
	DD	010641eH
	DD	0f541eH
	DD	0e341eH
	DD	0e01a921eH
	DD	0c016d018H
$unwind$?VerifyPath@@YAXPEBD@Z DD 050f01H
	DD	088640fH
	DD	084010fH
	DD	07008H
$chain$1$?VerifyPath@@YAXPEBD@Z DD 040821H
	DD	087e408H
	DD	0863404H
	DD	imagerel $LN13
	DD	imagerel $LN13+25
	DD	imagerel $unwind$?VerifyPath@@YAXPEBD@Z
$chain$2$?VerifyPath@@YAXPEBD@Z DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+25
	DD	imagerel $unwind$?VerifyPath@@YAXPEBD@Z
$unwind$?r@IReader@@QEAAXPEAXH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?w@CMemoryWriter@@UEAAXPEBXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$??1CMemoryWriter@@UEAA@XZ DD 020601H
	DD	030023206H
$unwind$??1CVirtualFileRW@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD imagerel ?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
	DD	0ffffffffH
	DD	imagerel ?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z+62
	DD	00H
	DD	imagerel ?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z+78
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
	DD	01H
	DD	imagerel $tryMap$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
	DD	05H
	DD	imagerel $ip2state$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
	DD	030H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z DD 081e19H
	DD	0d741eH
	DD	0c6419H
	DD	0a3414H
	DD	0e0027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VCTempReader@@PEAEII@@YAPEAVCTempReader@@AEBQEAEAEBI1@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VIReader@@PEAXII@@YAPEAVIReader@@AEBQEAXAEBI1@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+17
	DD	imagerel $unwind$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN32
	DD	imagerel $LN32+17
	DD	imagerel $unwind$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$00VIReader@@@@QEAAXAEAPEAVIReader@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+51
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
??1CVirtualFileRW@@UEAA@XZ PROC				; CVirtualFileRW::~CVirtualFileRW

; 440  : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7CVirtualFileRW@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 441  : #ifdef DEBUG
; 442  : 	unregister_file_mapping	(data,Size);
; 443  : #endif // DEBUG
; 444  : 
; 445  : 	UnmapViewOfFile ((void*)data);

	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR __imp_UnmapViewOfFile

; 446  : 	CloseHandle		(hSrcMap);

	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_CloseHandle

; 447  : 	CloseHandle		(hSrcFile);

	mov	rcx, QWORD PTR [rbx+32]
	call	QWORD PTR __imp_CloseHandle
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 448  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1CVirtualFileRW@@UEAA@XZ ENDP				; CVirtualFileRW::~CVirtualFileRW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
??1CMemoryWriter@@UEAA@XZ PROC				; CMemoryWriter::~CMemoryWriter

; 165  : {	xr_free(data);	}

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7CMemoryWriter@@6B@
	mov	rbx, rcx
	add	rcx, 40					; 00000028H
	mov	QWORD PTR [rcx-40], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN3@CMemoryWri
	call	??$xr_free@E@@YAXAEAPEAE@Z		; xr_free<unsigned char>
$LN3@CMemoryWri:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 165  : {	xr_free(data);	}

	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	??1IWriter@@UEAA@XZ			; IWriter::~IWriter
??1CMemoryWriter@@UEAA@XZ ENDP				; CMemoryWriter::~CMemoryWriter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
ptr$ = 56
count$ = 64
?w@CMemoryWriter@@UEAAXPEBXI@Z PROC			; CMemoryWriter::w

; 168  : {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 169  : 	if (position+count > mem_size) {

	mov	ecx, DWORD PTR [rcx+48]
	mov	edi, r8d
	mov	eax, DWORD PTR [rbx+52]
	add	ecx, r8d
	mov	rsi, rdx
	cmp	ecx, eax
	jbe	SHORT $LN2@w

; 170  : 		// reallocate
; 171  : 		if (mem_size==0)	mem_size=128;

	test	eax, eax
	jne	SHORT $LN10@w
	mov	DWORD PTR [rbx+52], 128			; 00000080H
$LN10@w:

; 172  : 		while (mem_size <= (position+count)) mem_size*=2;

	mov	eax, DWORD PTR [rbx+52]
	cmp	eax, ecx
	ja	SHORT $LN4@w
$LL5@w:
	add	eax, eax
	cmp	eax, ecx
	jbe	SHORT $LL5@w
	mov	DWORD PTR [rbx+52], eax
$LN4@w:

; 173  : 		if (0==data)		data = (BYTE*)	Memory.mem_alloc	(mem_size

	mov	rdx, QWORD PTR [rbx+40]

; 174  : #ifdef DEBUG_MEMORY_NAME
; 175  : 			,		"CMemoryWriter - storage"
; 176  : #endif // DEBUG_MEMORY_NAME
; 177  : 			);

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	test	rdx, rdx
	jne	SHORT $LN3@w
	mov	edx, DWORD PTR [rbx+52]
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 178  : 		else				data = (BYTE*)	Memory.mem_realloc	(data,mem_size

	jmp	SHORT $LN14@w
$LN3@w:

; 179  : #ifdef DEBUG_MEMORY_NAME
; 180  : 			,	"CMemoryWriter - storage"
; 181  : #endif // DEBUG_MEMORY_NAME
; 182  : 			);

	mov	r8d, DWORD PTR [rbx+52]
	call	?mem_realloc@xrMemory@@QEAAPEAXPEAX_K@Z	; xrMemory::mem_realloc
$LN14@w:
	mov	QWORD PTR [rbx+40], rax
$LN2@w:

; 183  : 	}
; 184  : 	CopyMemory	(data+position,ptr,count);

	mov	ecx, DWORD PTR [rbx+48]
	mov	r8, rdi
	mov	rdx, rsi
	add	rcx, QWORD PTR [rbx+40]
	call	memcpy

; 185  : 	position		+=count;

	add	DWORD PTR [rbx+48], edi
	mov	eax, DWORD PTR [rbx+48]

; 186  : 	if (position>file_size) file_size=position;

	cmp	eax, DWORD PTR [rbx+56]
	jbe	SHORT $LN1@w
	mov	DWORD PTR [rbx+56], eax
$LN1@w:

; 187  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?w@CMemoryWriter@@UEAAXPEBXI@Z ENDP			; CMemoryWriter::w
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
p$ = 56
cnt$ = 64
?r@IReader@@QEAAXPEAXH@Z PROC				; IReader::r

; 316  : {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	movsxd	rdx, DWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 316  : {

	movsxd	rdi, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	rdx, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 316  : {

	mov	rbx, rcx

; 317  : 	VERIFY				(Pos+cnt<=Size);
; 318  : 	CopyMemory		(p,pointer(),cnt);

	mov	r8, rdi
	mov	rcx, rax
	call	memcpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	add	DWORD PTR [rbx+16], edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 328  : };

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?r@IReader@@QEAAXPEAXH@Z ENDP				; IReader::r
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h
;	COMDAT ??0CTempReader@@QEAA@PEAXHH@Z
_TEXT	SEGMENT
this$ = 8
_data$ = 16
_size$ = 24
_iterpos$ = 32
??0CTempReader@@QEAA@PEAXHH@Z PROC			; CTempReader::CTempReader, COMDAT

; 77   : 				CTempReader(void *_data, int _size, int _iterpos) : IReader(_data,_size,_iterpos)	{}

	lea	rax, OFFSET FLAT:??_7CTempReader@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 244  : 		data		= (char *)_data	;

	mov	QWORD PTR [rcx+8], rdx

; 245  : 		Size		= _size			;

	mov	DWORD PTR [rcx+20], r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h

; 77   : 				CTempReader(void *_data, int _size, int _iterpos) : IReader(_data,_size,_iterpos)	{}

	mov	QWORD PTR [rcx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 246  : 		Pos			= 0				;

	mov	DWORD PTR [rcx+16], 0

; 247  : 		iterpos		= _iterpos		;

	mov	DWORD PTR [rcx+24], r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h

; 77   : 				CTempReader(void *_data, int _size, int _iterpos) : IReader(_data,_size,_iterpos)	{}

	mov	rax, rcx
	ret	0
??0CTempReader@@QEAA@PEAXHH@Z ENDP			; CTempReader::CTempReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GCTempReader@@UEAAPEAXI@Z
_TEXT	SEGMENT
p$ = 48
this$ = 48
__flags$ = 56
??_GCTempReader@@UEAAPEAXI@Z PROC			; CTempReader::`scalar deleting destructor', COMDAT
$LN19:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 389  : {	xr_free(data);	};

	lea	rax, OFFSET FLAT:??_7CTempReader@@6B@
	mov	rbx, rcx
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rcx], 0
	mov	edi, edx
	je	SHORT $LN6@scalar
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN6@scalar:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
	test	dil, 1
	je	SHORT $LN17@scalar
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR p$[rsp], rbx
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN17@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GCTempReader@@UEAAPEAXI@Z ENDP			; CTempReader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GCPackReader@@UEAAPEAXI@Z
_TEXT	SEGMENT
p$ = 48
this$ = 48
__flags$ = 56
??_GCPackReader@@UEAAPEAXI@Z PROC			; CPackReader::`scalar deleting destructor', COMDAT
$LN14:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 393  : {

	lea	rax, OFFSET FLAT:??_7CPackReader@@6B@
	mov	rdi, rcx
	mov	ebx, edx
	mov	QWORD PTR [rcx], rax

; 394  : #ifdef DEBUG
; 395  : 	unregister_file_mapping	(base_address,Size);
; 396  : #endif // DEBUG
; 397  : 
; 398  : 	UnmapViewOfFile	(base_address);

	mov	rcx, QWORD PTR [rcx+32]
	call	QWORD PTR __imp_UnmapViewOfFile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rdi], rax
	test	bl, 1
	je	SHORT $LN12@scalar
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR p$[rsp], rdi
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN12@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GCPackReader@@UEAAPEAXI@Z ENDP			; CPackReader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
tmp$ = 32
path$ = 1072
?VerifyPath@@YAXPEBD@Z PROC				; VerifyPath

; 77   : {

$LN13:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 1056				; 00000420H

; 78   : 	string1024 tmp;
; 79   : 	for(int i=0;path[i];i++){

	xor	edi, edi
	mov	rsi, rcx
	cmp	BYTE PTR [rcx], dil
	je	SHORT $LN3@VerifyPath
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], r14
	lea	r14, QWORD PTR tmp$[rsp]
	sub	r14, rcx
	mov	rbx, rcx
	npad	4
$LL5@VerifyPath:

; 80   : 		if( path[i]!='\\' || i==0 )

	cmp	BYTE PTR [rbx], 92			; 0000005cH
	jne	SHORT $LN4@VerifyPath
	test	edi, edi
	je	SHORT $LN4@VerifyPath

; 81   : 			continue;
; 82   : 		CopyMemory( tmp, path, i );

	lea	rcx, QWORD PTR tmp$[rsp]
	movsxd	r8, edi
	mov	rdx, rsi
	call	memcpy

; 83   : 		tmp[i] = 0;
; 84   :         _mkdir(tmp);

	lea	rcx, QWORD PTR tmp$[rsp]
	mov	BYTE PTR [r14+rbx], 0
	call	QWORD PTR __imp__mkdir
$LN4@VerifyPath:

; 78   : 	string1024 tmp;
; 79   : 	for(int i=0;path[i];i++){

	inc	rbx
	inc	edi
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LL5@VerifyPath
	mov	r14, QWORD PTR [rsp+1080]
	mov	rbx, QWORD PTR [rsp+1072]
$LN3@VerifyPath:

; 85   : 	}
; 86   : }

	mov	rsi, QWORD PTR [rsp+1088]
	add	rsp, 1056				; 00000420H
	pop	rdi
	ret	0
?VerifyPath@@YAXPEBD@Z ENDP				; VerifyPath
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
fn$ = 112
pdwSize$ = 120
?FileDownload@@YAPEAXPEBDPEAI@Z PROC			; FileDownload

; 88   : {

$LN19:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r13
	push	r14
	sub	rsp, 80					; 00000050H
	mov	r14, rdx

; 89   : 	int		hFile;
; 90   : 	u32		size;
; 91   : 	void*	buf;
; 92   : 
; 93   : #ifdef _EDITOR
; 94   : 	hFile	= _open(fn,O_RDONLY|O_BINARY|O_SEQUENTIAL);
; 95   : #else
; 96   : 	hFile	= _open(fn,O_RDONLY|O_BINARY|O_SEQUENTIAL,_S_IREAD);

	mov	r8d, 256				; 00000100H
	mov	edx, 32800				; 00008020H
	mov	rdi, rcx
	call	QWORD PTR __imp_?_open@@YAHPEBDHH@Z
	mov	ebx, eax

; 97   : #endif
; 98   : 	if (hFile<=0)	{

	test	eax, eax
	jg	SHORT $LN9@FileDownlo

; 99   : 		Sleep	(1);

	mov	ecx, 1
	call	QWORD PTR __imp_Sleep

; 100  : #ifdef _EDITOR
; 101  : 		hFile	= _open(fn,O_RDONLY|O_BINARY|O_SEQUENTIAL);
; 102  : #else
; 103  : 		hFile	= _open(fn,O_RDONLY|O_BINARY|O_SEQUENTIAL,_S_IREAD);

	mov	edx, 32800				; 00008020H
	mov	r8d, 256				; 00000100H
	mov	rcx, rdi
	call	QWORD PTR __imp_?_open@@YAHPEBDHH@Z
	mov	ebx, eax
$LN9@FileDownlo:

; 104  : #endif
; 105  : 	}
; 106  : 	R_ASSERT2(hFile>0,fn);

	cmp	BYTE PTR ?ignore_always@?6??FileDownload@@YAPEAXPEBDPEAI@Z@4_NA, 0
	lea	r12, OFFSET FLAT:??_C@_0N@NDJPHIGH@FileDownload?$AA@
	lea	r13, OFFSET FLAT:??_C@_06ODPOMCLF@FS?4cpp?$AA@
	jne	SHORT $LN8@FileDownlo
	test	ebx, ebx
	jg	SHORT $LN8@FileDownlo
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?6??FileDownload@@YAPEAXPEBDPEAI@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_07DAHKOGFN@hFile?$DO0?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r12
	mov	DWORD PTR [rsp+48], 106			; 0000006aH
	xor	r9d, r9d
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN8@FileDownlo:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 110  : 	size	= _filelength(hFile);

	mov	ecx, ebx
	call	QWORD PTR __imp__filelength

; 111  : #endif
; 112  : 
; 113  : 	buf		= Memory.mem_alloc	(size
; 114  : #ifdef DEBUG_MEMORY_NAME
; 115  : 		,"FILE in memory"
; 116  : #endif // DEBUG_MEMORY_NAME
; 117  : 		);

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, eax
	mov	ebp, eax
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 118  : 	int r_bytes	= _read	(hFile,buf,size);

	mov	r8d, ebp
	mov	ecx, ebx
	mov	rdx, rax
	mov	rsi, rax
	call	QWORD PTR __imp__read

; 119  : 	R_ASSERT3(r_bytes==(int)size,"Can't read file data:",fn);

	cmp	BYTE PTR ?ignore_always@?L@??FileDownload@@YAPEAXPEBDPEAI@Z@4_NA, 0
	jne	SHORT $LN4@FileDownlo
	cmp	eax, ebp
	je	SHORT $LN4@FileDownlo
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?L@??FileDownload@@YAPEAXPEBDPEAI@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0BG@MHEELJOF@Can?8t?5read?5file?5data?3?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BD@OMBPCKBP@r_bytes?$DN?$DN?$CIint?$CJsize?$AA@
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r12
	mov	DWORD PTR [rsp+48], 119			; 00000077H
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	r9, rdi
	mov	QWORD PTR [rsp+40], r13
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN4@FileDownlo:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 120  : 	_close	(hFile);

	mov	ecx, ebx
	call	QWORD PTR __imp__close

; 122  : 	return buf;

	mov	rax, rsi
	test	r14, r14
	je	SHORT $LN1@FileDownlo

; 121  : 	if (pdwSize) *pdwSize = size;

	mov	DWORD PTR [r14], ebp
$LN1@FileDownlo:

; 123  : }

	lea	r11, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rdi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	r13
	pop	r12
	ret	0
?FileDownload@@YAPEAXPEBDPEAI@Z ENDP			; FileDownload
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
fname$1 = 32
this$ = 576
fn$ = 584
F$ = 592
?save_to@CMemoryWriter@@QEAA_NPEBD@Z PROC		; CMemoryWriter::save_to

; 191  : {

$LN26:
	push	rbx
	sub	rsp, 560				; 00000230H
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	mov	r8, rdx
	lea	rcx, QWORD PTR fname$1[rsp]
	mov	edx, 520				; 00000208H
	call	QWORD PTR __imp_strcpy_s
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 273  : {	return strlwr(S);				}

	lea	rcx, QWORD PTR fname$1[rsp]
	call	QWORD PTR __imp_strlwr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 48					; 00000030H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 81   : 	return new (ptr) T(p1,p2);

	test	rax, rax
	je	SHORT $LN17@save_to
	lea	rdx, QWORD PTR fname$1[rsp]
	xor	r8d, r8d
	mov	rcx, rax
	call	??0CFileWriter@@QEAA@PEBD_N@Z		; CFileWriter::CFileWriter
	mov	rcx, rax
	jmp	SHORT $LN18@save_to
$LN17@save_to:
	xor	ecx, ecx
$LN18@save_to:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 192  : 	IWriter* F 		= FS.w_open(fn);

	mov	QWORD PTR F$[rsp], rcx

; 193  :     if (F){

	test	rcx, rcx
	je	SHORT $LN1@save_to

; 194  : 	    F->w		(pointer(),size());

	mov	rax, QWORD PTR [rcx]
	mov	r8d, DWORD PTR [rbx+56]
	mov	rdx, QWORD PTR [rbx+40]
	call	QWORD PTR [rax+24]

; 195  :     	FS.w_close	(F);

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	lea	rdx, QWORD PTR F$[rsp]
	call	?w_close@CLocatorAPI@@QEAAXAEAPEAVIWriter@@@Z ; CLocatorAPI::w_close

; 196  :         return 		true;

	mov	al, 1

; 199  : }

	add	rsp, 560				; 00000230H
	pop	rbx
	ret	0
$LN1@save_to:

; 197  :     }
; 198  :     return false;

	xor	al, al

; 199  : }

	add	rsp, 560				; 00000230H
	pop	rbx
	ret	0
?save_to@CMemoryWriter@@QEAA_NPEBD@Z ENDP		; CMemoryWriter::save_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
d$ = 56
d$ = 56
$T1 = 56
type$ = 56
?open_chunk@IWriter@@QEAAXI@Z PROC			; IWriter::open_chunk

; 203  : {

$LN77:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	mov	rax, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 204  : 	w_u32(type);

	mov	DWORD PTR d$[rsp], edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	lea	rdx, QWORD PTR d$[rsp]
	mov	r8d, 4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 203  : {

	mov	rsi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	call	QWORD PTR [rax+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 205  : 	chunk_pos.push(tell());

	mov	rax, QWORD PTR [rsi]
	mov	rcx, rsi
	call	QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rdx, QWORD PTR [rsi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 205  : 	chunk_pos.push(tell());

	mov	edi, eax
	mov	DWORD PTR $T1[rsp], eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	lea	rax, QWORD PTR $T1[rsp]
	cmp	rax, rdx
	jae	SHORT $LN10@open_chunk
	mov	rcx, QWORD PTR [rsi+8]
	lea	rax, QWORD PTR $T1[rsp]
	cmp	rcx, rax
	ja	SHORT $LN10@open_chunk

; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	lea	rdi, QWORD PTR $T1[rsp]
	sub	rdi, rcx
	sar	rdi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rdx, QWORD PTR [rsi+24]
	jne	SHORT $LN9@open_chunk

; 1248 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+8]
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN9@open_chunk:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rsi+16]
	test	rdx, rdx
	je	SHORT $LN67@open_chunk
	mov	rax, QWORD PTR [rsi+8]
	mov	ecx, DWORD PTR [rax+rdi*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1254 : 		else

	jmp	SHORT $LN67@open_chunk
$LN10@open_chunk:

; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rdx, QWORD PTR [rsi+24]
	jne	SHORT $LN7@open_chunk

; 1257 : 				_Reserve(1);

	lea	rcx, QWORD PTR [rsi+8]
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN7@open_chunk:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rax, QWORD PTR [rsi+16]
	test	rax, rax
	je	SHORT $LN67@open_chunk
	mov	DWORD PTR [rax], edi
$LN67@open_chunk:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rsi+16], 4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR d$[rsp]
	mov	r8d, 4
	mov	rcx, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 206  : 	w_u32(0);	// the place for 'size'

	mov	DWORD PTR d$[rsp], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	call	QWORD PTR [rax+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 207  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?open_chunk@IWriter@@QEAAXI@Z ENDP			; IWriter::open_chunk
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
d$ = 48
this$ = 48
?close_chunk@IWriter@@QEAAXXZ PROC			; IWriter::close_chunk

; 209  : {

$LN63:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 210  : 	VERIFY(!chunk_pos.empty());
; 211  : 
; 212  : 	int pos			= tell();

	mov	rax, QWORD PTR [rcx]
	mov	rdi, rcx
	call	QWORD PTR [rax+16]

; 213  : 	seek			(chunk_pos.top());

	mov	rdx, QWORD PTR [rdi+16]
	mov	r8, QWORD PTR [rdi]
	mov	edx, DWORD PTR [rdx-4]
	mov	rcx, rdi
	mov	ebx, eax
	call	QWORD PTR [r8+8]

; 214  : 	w_u32			(pos-chunk_pos.top()-4);

	mov	rdx, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	mov	r9, QWORD PTR [rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 214  : 	w_u32			(pos-chunk_pos.top()-4);

	mov	r8d, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	mov	rcx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 214  : 	w_u32			(pos-chunk_pos.top()-4);

	sub	r8d, DWORD PTR [rdx-4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	lea	rdx, QWORD PTR d$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 214  : 	w_u32			(pos-chunk_pos.top()-4);

	sub	r8d, 4
	mov	DWORD PTR d$[rsp], r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 46   : 	IC void			w_u32	(u32 d)					{	w(&d,sizeof(u32));	}

	mov	r8d, 4
	call	QWORD PTR [r9+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 215  : 	seek			(pos);

	mov	rax, QWORD PTR [rdi]
	mov	edx, ebx
	mov	rcx, rdi
	call	QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

	add	QWORD PTR [rdi+16], -4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 217  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?close_chunk@IWriter@@QEAAXXZ ENDP			; IWriter::close_chunk
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
?chunk_size@IWriter@@QEAAIXZ PROC			; IWriter::chunk_size

; 219  : {

$LN33:
	sub	rsp, 40					; 00000028H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1158 : 		return (this->_Myfirst == this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	cmp	QWORD PTR [rcx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 220  : 	if (chunk_pos.empty())	return 0;

	jne	SHORT $LN1@chunk_size
	xor	eax, eax

; 222  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@chunk_size:
	mov	QWORD PTR [rsp+32], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rbx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 221  : 	return tell() - chunk_pos.top()-4;

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	mov	ecx, -4					; fffffffcH
	sub	ecx, DWORD PTR [rbx-4]
	mov	rbx, QWORD PTR [rsp+32]
	add	eax, ecx

; 222  : }

	add	rsp, 40					; 00000028H
	ret	0
?chunk_size@IWriter@@QEAAIXZ ENDP			; IWriter::chunk_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
ptr$ = 56
dest_sz$ = 64
count$ = 64
?w_compressed@IWriter@@QEAAXPEAXI@Z PROC		; IWriter::w_compressed

; 225  : {

$LN42:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 655  : 	fs.Init_Input(start,start+src_sz);

	mov	eax, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 225  : {

	mov	rbx, rcx

; 227  : 	unsigned	dest_sz	= 0;

	xor	ecx, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 655  : 	fs.Init_Input(start,start+src_sz);

	add	rax, rdx

; 85   : 		in_start	= _start;

	mov	QWORD PTR fs+16, rdx

; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;

	mov	QWORD PTR fs+32, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 227  : 	unsigned	dest_sz	= 0;

	mov	DWORD PTR dest_sz$[rsp], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	mov	QWORD PTR fs+8, rcx
	mov	QWORD PTR fs, rcx
	mov	QWORD PTR fs+24, rax

; 656  :     Encode();

	call	?Encode@@YAXXZ				; Encode

; 657  : 	*dest		= fs.OutPointer();

	mov	rdi, QWORD PTR fs+40

; 102  : 		return u32(out_iterator-out_start);

	mov	r8d, DWORD PTR fs+56
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 230  : 	if (g_dummy_stuff)

	mov	rax, QWORD PTR ?g_dummy_stuff@@3P6AXPEBXAEBIPEAX@ZEA ; g_dummy_stuff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 102  : 		return u32(out_iterator-out_start);

	sub	r8d, edi

; 658  : 	*dest_sz	= fs.OutSize();

	mov	DWORD PTR dest_sz$[rsp], r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 230  : 	if (g_dummy_stuff)

	test	rax, rax
	je	SHORT $LN2@w_compress

; 231  : 		g_dummy_stuff	(dest,dest_sz,dest);

	lea	rdx, QWORD PTR dest_sz$[rsp]
	mov	r8, rdi
	mov	rcx, rdi
	call	rax
	mov	r8d, DWORD PTR dest_sz$[rsp]
$LN2@w_compress:

; 232  : 
; 233  : 	if (dest && dest_sz)

	test	rdi, rdi
	je	SHORT $LN39@w_compress
	test	r8d, r8d
	je	SHORT $LN1@w_compress

; 234  : 		w(dest,dest_sz);

	mov	rax, QWORD PTR [rbx]
	mov	rdx, rdi
	mov	rcx, rbx
	call	QWORD PTR [rax+24]
$LN1@w_compress:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN18@w_compress
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN39@w_compress

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 236  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN18@w_compress:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN39@w_compress:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 236  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?w_compressed@IWriter@@QEAAXPEAXI@Z ENDP		; IWriter::w_compressed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
type$ = 56
data$ = 64
size$ = 72
?w_chunk@IWriter@@QEAAXIPEAXI@Z PROC			; IWriter::w_chunk

; 239  : {

$LN6:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	esi, r9d
	mov	rbp, r8
	mov	ebx, edx
	mov	rdi, rcx

; 240  : 	open_chunk	(type);

	call	?open_chunk@IWriter@@QEAAXI@Z		; IWriter::open_chunk

; 241  : 	if (type & CFS_CompressMark)	w_compressed(data,size);

	mov	r8d, esi
	mov	rdx, rbp
	mov	rcx, rdi
	test	ebx, ebx
	jns	SHORT $LN2@w_chunk
	call	?w_compressed@IWriter@@QEAAXPEAXI@Z	; IWriter::w_compressed
	jmp	SHORT $LN1@w_chunk
$LN2@w_chunk:

; 242  : 	else							w			(data,size);

	mov	rax, QWORD PTR [rdi]
	call	QWORD PTR [rax+24]
$LN1@w_chunk:

; 243  : 	close_chunk	();

	mov	rcx, rdi

; 244  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi

; 243  : 	close_chunk	();

	jmp	?close_chunk@IWriter@@QEAAXXZ		; IWriter::close_chunk
?w_chunk@IWriter@@QEAAXIPEAXI@Z ENDP			; IWriter::w_chunk
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
C$ = 32
d$ = 80
d$ = 80
this$ = 80
D$ = 88
?w_sdir@IWriter@@QEAAXAEBU?$_vector3@M@@@Z PROC		; IWriter::w_sdir

; 246  : {

$LN22:
	push	rbx
	sub	rsp, 64					; 00000040H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	movss	xmm3, DWORD PTR [rdx+4]
	movss	xmm4, DWORD PTR [rdx]
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	XMMWORD PTR [rsp+48], xmm6
	xorps	xmm6, xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 246  : {

	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 167  : 		return x*x + y*y + z*z;

	movaps	xmm2, xmm4
	movaps	xmm0, xmm3
	movaps	xmm1, xmm5
	mulss	xmm2, xmm4
	mulss	xmm0, xmm3
	mulss	xmm1, xmm5
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 99   : IC float	_sqrt	(float x)		{ return sqrtf(x); }

	sqrtss	xmm6, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 249  : 	if (mag>EPS_S)	{

	comiss	xmm6, DWORD PTR __real@33d6bf95
	jbe	SHORT $LN2@w_sdir
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 47   : 	ICF SelfRef	div(const Self &a, T s)					{ x=a.x/s;  y=a.y/s;	z=a.z/s;		return *this;	};

	movss	xmm2, DWORD PTR __real@3f800000
	divss	xmm2, xmm6
	movaps	xmm0, xmm2
	movaps	xmm1, xmm2
	mulss	xmm2, xmm5
	mulss	xmm0, xmm4
	mulss	xmm1, xmm3
	movss	DWORD PTR C$[rsp+8], xmm2
	movss	DWORD PTR C$[rsp], xmm0
	movss	DWORD PTR C$[rsp+4], xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 251  : 	} else {

	jmp	SHORT $LN1@w_sdir
$LN2@w_sdir:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 23   : 	ICF	SelfRef	set(T _x, T _y, T _z)					{ x = _x;		y = _y;		z = _z;		return *this;	};

	movss	xmm0, DWORD PTR __real@3f800000
	xorps	xmm6, xmm6
	mov	QWORD PTR C$[rsp], 0
	movss	DWORD PTR C$[rsp+8], xmm0
$LN1@w_sdir:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 82   : 	IC void 		w_dir		(const Fvector& D) 	{	w_u16(pvCompress(D));	}

	lea	rcx, QWORD PTR C$[rsp]
	call	?pvCompress@@YAGAEBU?$_vector3@M@@@Z	; pvCompress

; 47   : 	IC void			w_u16	(u16 d)					{	w(&d,sizeof(u16));	}

	lea	rdx, QWORD PTR d$[rsp]
	mov	r8d, 2

; 82   : 	IC void 		w_dir		(const Fvector& D) 	{	w_u16(pvCompress(D));	}

	mov	WORD PTR d$[rsp], ax

; 47   : 	IC void			w_u16	(u16 d)					{	w(&d,sizeof(u16));	}

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+24]

; 53   : 	IC void			w_float	(float d)				{	w(&d,sizeof(float));}

	mov	rax, QWORD PTR [rbx]
	lea	rdx, QWORD PTR d$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 256  : 	w_float (mag);

	movss	DWORD PTR d$[rsp], xmm6
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 53   : 	IC void			w_float	(float d)				{	w(&d,sizeof(float));}

	mov	r8d, 4
	mov	rcx, rbx
	call	QWORD PTR [rax+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 257  : }

	movaps	xmm6, XMMWORD PTR [rsp+48]
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
?w_sdir@IWriter@@QEAAXAEBU?$_vector3@M@@@Z ENDP		; IWriter::w_sdir
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
buf$ = 32
this$ = 1072
format$ = 1080
?w_printf@IWriter@@QEAAXPEBDZZ PROC			; IWriter::w_printf

; 259  : {

$LN7:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rdx
	mov	QWORD PTR [rax+24], r8
	mov	QWORD PTR [rax+32], r9
	push	rbx
	sub	rsp, 1056				; 00000420H
	mov	rbx, rcx

; 260  : 	va_list mark;
; 261  : 	char buf[1024];
; 262  : 	va_start( mark, format );

	lea	r8, QWORD PTR [rax+24]

; 263  : 	vsprintf( buf, format, mark );

	lea	rcx, QWORD PTR buf$[rsp]
	call	QWORD PTR __imp_vsprintf

; 264  : 	w		( buf, xr_strlen(buf) );

	mov	rax, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR buf$[rsp]
	or	r8, -1
$LL5@w_printf:
	inc	r8
	cmp	BYTE PTR [rcx+r8], 0
	jne	SHORT $LL5@w_printf
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 264  : 	w		( buf, xr_strlen(buf) );

	lea	rdx, QWORD PTR buf$[rsp]
	mov	rcx, rbx
	call	QWORD PTR [rax+24]

; 265  : }

	add	rsp, 1056				; 00000420H
	pop	rbx
	ret	0
?w_printf@IWriter@@QEAAXPEBDZZ ENDP			; IWriter::w_printf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
ID$ = 56
?open_chunk@IReader@@QEAAPEAV1@I@Z PROC			; IReader::open_chunk

; 270  : {

$LN119:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	r8d, DWORD PTR [rcx+20]

; 263  : 	IC void			seek		(int ptr)		{	Pos=ptr; VERIFY((Pos<=Size) && (Pos>=0));};

	xor	r14d, r14d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 270  : {

	mov	r10d, edx
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 263  : 	IC void			seek		(int ptr)		{	Pos=ptr; VERIFY((Pos<=Size) && (Pos>=0));};

	mov	DWORD PTR [rcx+16], r14d

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	r8d, r8d

; 141  : 	
; 142  : 	IC void			r			(void *p,int cnt) {impl().r(p,cnt);}
; 143  : 
; 144  : 	IC Fvector		r_vec3		()			{Fvector tmp;r(&tmp,3*sizeof(float));return tmp;	};
; 145  : 	IC Fvector4		r_vec4		()			{Fvector4 tmp;r(&tmp,4*sizeof(float));return tmp;	};
; 146  : 	IC u64			r_u64		()			{	u64 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 147  : 	IC u32			r_u32		()			{	u32 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 148  : 	IC u16			r_u16		()			{	u16 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 149  : 	IC u8			r_u8		()			{	u8 tmp;		r(&tmp,sizeof(tmp)); return tmp;	};
; 150  : 	IC s64			r_s64		()			{	s64 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 151  : 	IC s32			r_s32		()			{	s32 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 152  : 	IC s16			r_s16		()			{	s16 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 153  : 	IC s8			r_s8		()			{	s8 tmp;		r(&tmp,sizeof(tmp)); return tmp;	};
; 154  : 	IC float		r_float		()			{	float tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 155  : 	IC void			r_fvector4	(Fvector4 &v){	r(&v,sizeof(Fvector4));	}
; 156  : 	IC void			r_fvector3	(Fvector3 &v){	r(&v,sizeof(Fvector3));	}
; 157  : 	IC void			r_fvector2	(Fvector2 &v){	r(&v,sizeof(Fvector2));	}
; 158  : 	IC void			r_ivector4	(Ivector4 &v){	r(&v,sizeof(Ivector4));	}
; 159  : 	IC void			r_ivector4	(Ivector3 &v){	r(&v,sizeof(Ivector3));	}
; 160  : 	IC void			r_ivector4	(Ivector2 &v){	r(&v,sizeof(Ivector2));	}
; 161  : 	IC void			r_fcolor	(Fcolor &v)	{	r(&v,sizeof(Fcolor));	}
; 162  : 	
; 163  : 	IC float		r_float_q16	(float min, float max)
; 164  : 	{
; 165  : 		u16	val 	= r_u16();
; 166  : 		float A		= (float(val)*(max-min))/65535.f + min;		// floating-point-error possible
; 167  : 		VERIFY		((A >= min-EPS_S) && (A <= max+EPS_S));
; 168  :         return A;
; 169  : 	}
; 170  : 	IC float		r_float_q8	(float min, float max)
; 171  : 	{
; 172  : 		u8 val		= r_u8();
; 173  : 		float	A	= (float(val)/255.0001f) *(max-min) + min;	// floating-point-error possible
; 174  : 		VERIFY		((A >= min) && (A <= max));
; 175  :         return	A;
; 176  : 	}
; 177  : 	IC float		r_angle16	()			{ return r_float_q16(0,PI_MUL_2);	}
; 178  : 	IC float		r_angle8	()			{ return r_float_q8	(0,PI_MUL_2);	}
; 179  : 	IC void			r_dir		(Fvector& A){ u16 t=r_u16(); pvDecompress(A,t); }
; 180  : 	IC void			r_sdir		(Fvector& A)
; 181  : 	{
; 182  : 		u16	t		= r_u16();
; 183  : 		float s		= r_float();
; 184  : 		pvDecompress(A,t);
; 185  : 		A.mul		(s);
; 186  : 	}
; 187  : 	// Set file pointer to start of chunk data (0 for root chunk)
; 188  : 	IC	void		rewind		()			{	impl().seek(0); }
; 189  : 
; 190  : 	IC	u32 		find_chunk	(u32 ID, BOOL* bCompressed = 0)	
; 191  : 	{
; 192  : 		u32	dwSize,dwType;
; 193  : 
; 194  : 		rewind();
; 195  : 		while (!eof()) {

	jle	SHORT $LN4@open_chunk

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	r9, QWORD PTR [rcx+8]
	npad	1
$LL14@open_chunk:
	movsxd	rcx, DWORD PTR [rbx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 318  : 	CopyMemory		(p,pointer(),cnt);

	mov	edx, DWORD PTR [rcx+r9]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	add	ecx, 4

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	movsxd	rax, ecx

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	mov	DWORD PTR [rbx+16], ecx
	lea	esi, DWORD PTR [rcx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 318  : 	CopyMemory		(p,pointer(),cnt);

	mov	edi, DWORD PTR [rax+r9]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 198  : 			if ((dwType&(~CFS_CompressMark)) == ID) {

	mov	eax, edx

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	mov	DWORD PTR [rbx+16], esi

; 198  : 			if ((dwType&(~CFS_CompressMark)) == ID) {

	btr	eax, 31
	cmp	eax, r10d
	je	SHORT $LN117@open_chunk

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	lea	ecx, DWORD PTR [rsi+rdi]

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, r8d
	sub	eax, ecx

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	mov	DWORD PTR [rbx+16], ecx

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax

; 141  : 	
; 142  : 	IC void			r			(void *p,int cnt) {impl().r(p,cnt);}
; 143  : 
; 144  : 	IC Fvector		r_vec3		()			{Fvector tmp;r(&tmp,3*sizeof(float));return tmp;	};
; 145  : 	IC Fvector4		r_vec4		()			{Fvector4 tmp;r(&tmp,4*sizeof(float));return tmp;	};
; 146  : 	IC u64			r_u64		()			{	u64 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 147  : 	IC u32			r_u32		()			{	u32 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 148  : 	IC u16			r_u16		()			{	u16 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 149  : 	IC u8			r_u8		()			{	u8 tmp;		r(&tmp,sizeof(tmp)); return tmp;	};
; 150  : 	IC s64			r_s64		()			{	s64 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 151  : 	IC s32			r_s32		()			{	s32 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 152  : 	IC s16			r_s16		()			{	s16 tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 153  : 	IC s8			r_s8		()			{	s8 tmp;		r(&tmp,sizeof(tmp)); return tmp;	};
; 154  : 	IC float		r_float		()			{	float tmp;	r(&tmp,sizeof(tmp)); return tmp;	};
; 155  : 	IC void			r_fvector4	(Fvector4 &v){	r(&v,sizeof(Fvector4));	}
; 156  : 	IC void			r_fvector3	(Fvector3 &v){	r(&v,sizeof(Fvector3));	}
; 157  : 	IC void			r_fvector2	(Fvector2 &v){	r(&v,sizeof(Fvector2));	}
; 158  : 	IC void			r_ivector4	(Ivector4 &v){	r(&v,sizeof(Ivector4));	}
; 159  : 	IC void			r_ivector4	(Ivector3 &v){	r(&v,sizeof(Ivector3));	}
; 160  : 	IC void			r_ivector4	(Ivector2 &v){	r(&v,sizeof(Ivector2));	}
; 161  : 	IC void			r_fcolor	(Fcolor &v)	{	r(&v,sizeof(Fcolor));	}
; 162  : 	
; 163  : 	IC float		r_float_q16	(float min, float max)
; 164  : 	{
; 165  : 		u16	val 	= r_u16();
; 166  : 		float A		= (float(val)*(max-min))/65535.f + min;		// floating-point-error possible
; 167  : 		VERIFY		((A >= min-EPS_S) && (A <= max+EPS_S));
; 168  :         return A;
; 169  : 	}
; 170  : 	IC float		r_float_q8	(float min, float max)
; 171  : 	{
; 172  : 		u8 val		= r_u8();
; 173  : 		float	A	= (float(val)/255.0001f) *(max-min) + min;	// floating-point-error possible
; 174  : 		VERIFY		((A >= min) && (A <= max));
; 175  :         return	A;
; 176  : 	}
; 177  : 	IC float		r_angle16	()			{ return r_float_q16(0,PI_MUL_2);	}
; 178  : 	IC float		r_angle8	()			{ return r_float_q8	(0,PI_MUL_2);	}
; 179  : 	IC void			r_dir		(Fvector& A){ u16 t=r_u16(); pvDecompress(A,t); }
; 180  : 	IC void			r_sdir		(Fvector& A)
; 181  : 	{
; 182  : 		u16	t		= r_u16();
; 183  : 		float s		= r_float();
; 184  : 		pvDecompress(A,t);
; 185  : 		A.mul		(s);
; 186  : 	}
; 187  : 	// Set file pointer to start of chunk data (0 for root chunk)
; 188  : 	IC	void		rewind		()			{	impl().seek(0); }
; 189  : 
; 190  : 	IC	u32 		find_chunk	(u32 ID, BOOL* bCompressed = 0)	
; 191  : 	{
; 192  : 		u32	dwSize,dwType;
; 193  : 
; 194  : 		rewind();
; 195  : 		while (!eof()) {

	jg	SHORT $LL14@open_chunk
$LN4@open_chunk:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 282  : 	} else return 0;

	xor	eax, eax
$LN1@open_chunk:

; 283  : };

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
$LN117@open_chunk:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 201  : 				if (bCompressed) *bCompressed = dwType&CFS_CompressMark;

	and	edx, -2147483648			; ffffffff80000000H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 273  : 	if (dwSize!=0) {

	test	edi, edi
	je	SHORT $LN4@open_chunk

; 274  : 		if (bCompressed) {

	test	edx, edx
	je	$LN3@open_chunk
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	movsxd	rcx, esi
	mov	QWORD PTR [rsp+48], rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	mov	QWORD PTR fs+8, r14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	rcx, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	mov	QWORD PTR fs, r14

; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {
; 118  : 			if ((int)(i = _getb()) < 0) i = 0;
; 119  : 			getbuf |= i << (8 - getlen);
; 120  : 			getlen += 8;
; 121  : 		}
; 122  : 		i = getbuf;
; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;
; 125  : 		return (int)((i & 0x8000) >> 15);
; 126  : 	}
; 127  : 	
; 128  : 	IC int		GetByte(void)   /* get one byte */
; 129  : 	{
; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {
; 133  : 			if ((int)(i = _getb()) < 0) i = 0;
; 134  : 			getbuf |= i << (8 - getlen);
; 135  : 			getlen += 8;
; 136  : 		}
; 137  : 		i = getbuf;
; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;
; 140  : 		return (int)((i & 0xff00) >> 8);
; 141  : 	}
; 142  : 	
; 143  : 	IC void		PutCode(int l, unsigned c)     /* output c bits of code */
; 144  : 	{
; 145  : 		putbuf |= c >> putlen;
; 146  : 		if ((putlen += l) >= 8) {
; 147  : 			_putb(putbuf >> 8);
; 148  : 			if ((putlen -= 8) >= 8) {
; 149  : 				_putb(putbuf);
; 150  : 				codesize += 2;
; 151  : 				putlen -= 8;
; 152  : 				putbuf = c << (l - putlen);
; 153  : 			} else {
; 154  : 				putbuf <<= 8;
; 155  : 				codesize++;
; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 	IC void		PutFlush()
; 160  : 	{
; 161  : 		if (putlen) {
; 162  : 			_putb(putbuf >> 8);
; 163  : 			codesize++;
; 164  : 		}
; 165  : 	}
; 166  : };
; 167  : static LZfs fs;
; 168  : //************************** Internal FS
; 169  : IC void InitTree(void)  /* initialize trees */
; 170  : {
; 171  :     int  i;
; 172  : 	
; 173  :     for (i = N + 1; i <= N + 256; i++)	        rson[i] = NIL;        /* root */
; 174  :     for (i = 0; i < N; i++)						dad[i] = NIL;         /* node */
; 175  : }
; 176  : 
; 177  : void InsertNode(int r)  /* insert to tree */
; 178  : {
; 179  :     int				i, p, cmp;
; 180  :     u8			*key;
; 181  :     unsigned		c;
; 182  : 	
; 183  :     cmp = 1;
; 184  :     key = &text_buf[r];
; 185  :     p = N + 1 + key[0];
; 186  :     rson[r] = lson[r] = NIL;
; 187  :     match_length = 0;
; 188  :     for ( ; ; ) {
; 189  :         if (cmp >= 0) {
; 190  :             if (rson[p] != NIL)
; 191  :                 p = rson[p];
; 192  :             else {
; 193  :                 rson[p] = r;
; 194  :                 dad[r] = p;
; 195  :                 return;
; 196  :             }
; 197  :         } else {
; 198  :             if (lson[p] != NIL)
; 199  :                 p = lson[p];
; 200  :             else {
; 201  :                 lson[p] = r;
; 202  :                 dad[r] = p;
; 203  :                 return;
; 204  :             }
; 205  :         }
; 206  :         for (i = 1; i < F; i++)
; 207  :             if ((cmp = key[i] - text_buf[p + i]) != 0)
; 208  :                 break;
; 209  : 			if (i > THRESHOLD) {
; 210  : 				if (i > match_length) {
; 211  : 					match_position = ((r - p) & (N - 1)) - 1;
; 212  : 					if ((match_length = i) >= F)
; 213  : 						break;
; 214  : 				}
; 215  : 				if (i == match_length) {
; 216  : 					if ((c = ((r - p) & (N-1)) - 1) < (unsigned)match_position) {
; 217  : 						match_position = c;
; 218  : 					}
; 219  : 				}
; 220  : 			}
; 221  :     }
; 222  :     dad[r]  = dad[p];
; 223  :     lson[r] = lson[p];
; 224  :     rson[r] = rson[p];
; 225  :     dad[lson[p]] = r;
; 226  :     dad[rson[p]] = r;
; 227  :     if (rson[dad[p]] == p)
; 228  :         rson[dad[p]] = r;
; 229  :     else
; 230  :         lson[dad[p]] = r;
; 231  :     dad[p] = NIL; /* remove p */
; 232  : }
; 233  : 
; 234  : void DeleteNode(int p)  /* remove from tree */
; 235  : {
; 236  :     int  q;
; 237  : 	
; 238  :     if (dad[p] == NIL)	return;	/* not registered */
; 239  :     if (rson[p] == NIL)
; 240  : 		q = lson[p];
; 241  :     else 
; 242  : 	{
; 243  : 		if (lson[p] == NIL)
; 244  : 		{
; 245  : 			q = rson[p];
; 246  : 		}
; 247  : 		else 
; 248  : 		{
; 249  : 			q = lson[p];
; 250  : 			if (rson[q] != NIL) 
; 251  : 			{
; 252  : 				do { q = rson[q]; } while (rson[q] != NIL);
; 253  : 				
; 254  : 				rson[dad[q]]	= lson[q];
; 255  : 				dad[lson[q]]	= dad[q];
; 256  : 				lson[q]			= lson[p];
; 257  : 				dad[lson[p]]	= q;
; 258  : 			}
; 259  : 			rson[q]			= rson[p];
; 260  : 			dad[rson[p]]	= q;
; 261  : 		}
; 262  : 	}
; 263  : 	dad[q] = dad[p];
; 264  : 	if (rson[dad[p]] == p)
; 265  : 		rson[dad[p]] = q;
; 266  : 	else
; 267  : 		lson[dad[p]] = q;
; 268  : 	dad[p] = NIL;
; 269  : }
; 270  : 
; 271  : /* Huffman coding */
; 272  : 
; 273  : 
; 274  : /* table for encoding and decoding the upper 6 bits of position */
; 275  : /* for encoding */
; 276  : u8 p_len[64] = {
; 277  :     0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
; 278  : 	0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
; 279  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 280  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 281  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 282  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 283  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 284  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
; 285  : };
; 286  : 
; 287  : u8 p_code[64] = {
; 288  :     0x00, 0x20, 0x30, 0x40, 0x50, 0x58, 0x60, 0x68,
; 289  : 	0x70, 0x78, 0x80, 0x88, 0x90, 0x94, 0x98, 0x9C,
; 290  : 	0xA0, 0xA4, 0xA8, 0xAC, 0xB0, 0xB4, 0xB8, 0xBC,
; 291  : 	0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,
; 292  : 	0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,
; 293  : 	0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE,
; 294  : 	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
; 295  : 	0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
; 296  : };
; 297  : 
; 298  : /* for decoding */
; 299  : u8 d_code[256] = {
; 300  :     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 301  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 302  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 303  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 304  : 	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
; 305  : 	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
; 306  : 	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
; 307  : 	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
; 308  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 309  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 310  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 311  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 312  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 313  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 314  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 315  : 	0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
; 316  : 	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
; 317  : 	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
; 318  : 	0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
; 319  : 	0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
; 320  : 	0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
; 321  : 	0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
; 322  : 	0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
; 323  : 	0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
; 324  : 	0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,
; 325  : 	0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,
; 326  : 	0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,
; 327  : 	0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,
; 328  : 	0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,
; 329  : 	0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,
; 330  : 	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
; 331  : 	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
; 332  : };
; 333  : 
; 334  : u8 d_len[256] = {
; 335  :     0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 336  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 337  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 338  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 339  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 340  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 341  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 342  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 343  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 344  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 345  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 346  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 347  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 348  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 349  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 350  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 351  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 352  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 353  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 354  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 355  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 356  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 357  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 358  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 359  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 360  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 361  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 362  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 363  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 364  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 365  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 366  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 367  : };
; 368  : 
; 369  : 
; 370  : /* initialization of tree */
; 371  : 
; 372  : void StartHuff(void)
; 373  : {
; 374  :     int i, j;
; 375  : 	
; 376  :     for (i = 0; i < N_CHAR; i++) {
; 377  :         freq[i]		= 1;
; 378  :         son	[i]		= i + T;
; 379  :         prnt[i + T] = i;
; 380  :     }
; 381  :     i = 0; j = N_CHAR;
; 382  :     while (j <= R) {
; 383  :         freq[j]		= freq[i] + freq[i + 1];
; 384  :         son[j]		= i;
; 385  :         prnt[i]		= prnt[i + 1] = j;
; 386  :         i += 2; j++;
; 387  :     }
; 388  :     freq[T] = 0xffff;
; 389  :     prnt[R] = 0;
; 390  : }
; 391  : 
; 392  : 
; 393  : /* reconstruction of tree */
; 394  : void reconst(void)
; 395  : {
; 396  :     int			i, j, k;
; 397  :     unsigned	f, l;
; 398  : 	
; 399  :     /* collect leaf nodes in the first half of the table */
; 400  :     /* and replace the freq by (freq + 1) / 2. */
; 401  :     j = 0;
; 402  :     for (i = 0; i < T; i++) {
; 403  :         if (son[i] >= T) {
; 404  :             freq[j] = (freq[i] + 1) / 2;
; 405  :             son[j] = son[i];
; 406  :             j++;
; 407  :         }
; 408  :     }
; 409  :     /* begin constructing tree by connecting sons */
; 410  :     for (i = 0, j = N_CHAR; j < T; i += 2, j++) {
; 411  :         k = i + 1;
; 412  :         f = freq[j] = freq[i] + freq[k];
; 413  :         for (k = j - 1; f < freq[k]; k--);
; 414  :         k++;
; 415  :         l = (j - k) * sizeof(unsigned);
; 416  :         memmove	(&freq[k + 1], &freq[k], l);
; 417  :         freq[k] = f;
; 418  :         memmove	(&son[k + 1], &son[k], l);
; 419  :         son[k] = i;
; 420  :     }
; 421  :     /* connect prnt */
; 422  :     for (i = 0; i < T; i++) {
; 423  :         if ((k = son[i]) >= T) {
; 424  :             prnt[k] = i;
; 425  :         } else {
; 426  :             prnt[k] = prnt[k + 1] = i;
; 427  :         }
; 428  :     }
; 429  : }
; 430  : 
; 431  : 
; 432  : /* increment frequency of given code by one, and update tree */
; 433  : void update(int c)
; 434  : {
; 435  :     int i, j, k, l;
; 436  : 	
; 437  :     if (freq[R] == MAX_FREQ) {
; 438  :         reconst();
; 439  :     }
; 440  :     c = prnt[c + T];
; 441  :     do {
; 442  :         k = ++freq[c];
; 443  : 		
; 444  :         /* if the order is disturbed, exchange nodes */
; 445  :         if ((unsigned)k > freq[l = c + 1]) {
; 446  :             while ((unsigned)k > freq[++l]);
; 447  :             l--;
; 448  :             freq[c] = freq[l];
; 449  :             freq[l] = k;
; 450  : 			
; 451  :             i = son[c];
; 452  :             prnt[i] = l;
; 453  :             if (i < T) prnt[i + 1] = l;
; 454  : 			
; 455  :             j = son[l];
; 456  :             son[l] = i;
; 457  : 			
; 458  :             prnt[j] = c;
; 459  :             if (j < T) prnt[j + 1] = c;
; 460  :             son[c] = j;
; 461  : 			
; 462  :             c = l;
; 463  :         }
; 464  :     } while ((c = prnt[c]) != 0); /* repeat up to root */
; 465  : }
; 466  : 
; 467  : void EncodeChar(unsigned c)
; 468  : {
; 469  :     unsigned i;
; 470  :     int j, k;
; 471  : 	
; 472  :     i = 0;
; 473  :     j = 0;
; 474  :     k = prnt[c + T];
; 475  : 	
; 476  :     /* travel from leaf to root */
; 477  :     do {
; 478  :         i >>= 1;
; 479  : 		
; 480  :         /* if node's address is odd-numbered, choose bigger brother node */
; 481  :         if (k & 1) i += 0x8000;
; 482  : 		
; 483  :         j++;
; 484  : 		k = prnt[k];
; 485  :     } while (k != R);
; 486  :     fs.PutCode(j, i);
; 487  :     code = i;
; 488  :     len = j;
; 489  :     update(c);
; 490  : }
; 491  : 
; 492  : void EncodePosition(unsigned c)
; 493  : {
; 494  :     unsigned i;
; 495  : 	
; 496  :     /* output upper 6 bits by table lookup */
; 497  :     i = c >> 6;
; 498  :     fs.PutCode(p_len[i], (unsigned)p_code[i] << 8);
; 499  : 	
; 500  :     /* output lower 6 bits verbatim */
; 501  :     fs.PutCode(6, (c & 0x3f) << 10);
; 502  : }
; 503  : 
; 504  : int DecodeChar(void)
; 505  : {
; 506  :     unsigned c;
; 507  : 	
; 508  :     c = son[R];
; 509  : 	
; 510  :     /* travel from root to leaf, */
; 511  :     /* choosing the smaller child node (son[]) if the read bit is 0, */
; 512  :     /* the bigger (son[]+1} if 1 */
; 513  :     while (c < T) {
; 514  :         c += fs.GetBit();
; 515  :         c = son[c];
; 516  :     }
; 517  :     c -= T;
; 518  :     update(c);
; 519  :     return (int)c;
; 520  : }
; 521  : 
; 522  : int DecodePosition(void)
; 523  : {
; 524  :     unsigned i, j, c;
; 525  : 	
; 526  :     /* recover upper 6 bits from table */
; 527  :     i = fs.GetByte();
; 528  :     c = (unsigned)d_code[i] << 6;
; 529  :     j = d_len[i];
; 530  : 	
; 531  :     /* read lower 6 bits verbatim */
; 532  :     j -= 2;
; 533  :     while (j--) {
; 534  :         i = (i << 1) + fs.GetBit();
; 535  :     }
; 536  :     return (int)(c | (i & 0x3f));
; 537  : }
; 538  : 
; 539  : /* compression */
; 540  : void Encode(void)  /* compression */
; 541  : {
; 542  :     int  i, c, len, r, s, last_match_length;
; 543  : 	
; 544  :     textsize = fs.InputSize();
; 545  : 	fs.Init_Output(textsize);
; 546  : 	fs._putb((textsize & 0xff));
; 547  : 	fs._putb((textsize & 0xff00) >> 8);
; 548  : 	fs._putb((textsize & 0xff0000L) >> 16);
; 549  : 	fs._putb((textsize & 0xff000000L) >> 24);
; 550  :     if (textsize == 0)
; 551  :         return;
; 552  :     textsize = 0;           /* rewind and re-read */
; 553  :     StartHuff();
; 554  :     InitTree();
; 555  :     s = 0;
; 556  :     r = N - F;
; 557  :     for (i = s; i < r; i++)
; 558  :         text_buf[i] = 0x20;
; 559  :     for (len = 0; len < F && (c = fs._getb()) != EOF; len++)
; 560  :         text_buf[r + len] = (unsigned char)c;
; 561  :     textsize = len;
; 562  :     for (i = 1; i <= F; i++)
; 563  :         InsertNode(r - i);
; 564  :     InsertNode(r);
; 565  :     do {
; 566  :         if (match_length > len)
; 567  :             match_length = len;
; 568  :         if (match_length <= THRESHOLD) {
; 569  :             match_length = 1;
; 570  : 			// textsize==56158    - FATAL :(
; 571  :             EncodeChar(text_buf[r]);
; 572  :         } else {
; 573  :             EncodeChar(255 - THRESHOLD + match_length);
; 574  :             EncodePosition(match_position);
; 575  :         }
; 576  :         last_match_length = match_length;
; 577  :         for (i = 0; i < last_match_length &&
; 578  : 			(c = fs._getb()) != EOF; i++) {
; 579  :             DeleteNode(s);
; 580  :             text_buf[s] = (unsigned char)c;
; 581  :             if (s < F - 1)
; 582  :                 text_buf[s + N] = (unsigned char)c;
; 583  :             s = (s + 1) & (N - 1);
; 584  :             r = (r + 1) & (N - 1);
; 585  :             InsertNode(r);
; 586  :         }
; 587  : 		textsize += i;
; 588  :         while (i++ < last_match_length) {
; 589  :             DeleteNode(s);
; 590  :             s = (s + 1) & (N - 1);
; 591  :             r = (r + 1) & (N - 1);
; 592  :             if (--len) InsertNode(r);
; 593  :         }
; 594  :     } while (len > 0);
; 595  :     fs.PutFlush();
; 596  : 	tim_size = textsize;
; 597  : }
; 598  : 
; 599  : void Decode(void)  /* recover */
; 600  : {
; 601  :     int  i, j, k, r, c;
; 602  :     unsigned int  count;
; 603  : 	
; 604  :     textsize =  (fs._getb());
; 605  :     textsize |= (fs._getb() << 8);
; 606  :     textsize |= (fs._getb() << 16);
; 607  :     textsize |= (fs._getb() << 24);
; 608  :     if (textsize == 0) return;
; 609  : 	
; 610  : 	fs.Init_Output(textsize);
; 611  : 	
; 612  :     StartHuff();
; 613  :     for (i = 0; i < N - F; i++)
; 614  :         text_buf[i] = 0x20;
; 615  :     r = N - F;
; 616  :     for (count = 0; count < textsize; ) {
; 617  :         c = DecodeChar();
; 618  :         if (c < 256) {
; 619  :             fs._putb(c);
; 620  :             text_buf[r++] = (unsigned char)c;
; 621  :             r &= (N - 1);
; 622  :             count++;
; 623  :         } else {
; 624  :             i = (r - DecodePosition() - 1) & (N - 1);
; 625  :             j = c - 255 + THRESHOLD;
; 626  :             for (k = 0; k < j; k++) {
; 627  :                 c = text_buf[(i + k) & (N - 1)];
; 628  :                 fs._putb(c);
; 629  :                 text_buf[r++] = (unsigned char)c;
; 630  :                 r &= (N - 1);
; 631  :                 count++;
; 632  :             }
; 633  :         }
; 634  :     }
; 635  : 	tim_size = count;
; 636  : }
; 637  : 
; 638  : unsigned _writeLZ	(int hf, void* d, unsigned size)
; 639  : {
; 640  : 	u8*	start = (u8*) d;
; 641  : 	fs.Init_Input(start,start+size);
; 642  : 	
; 643  : 	// Actual compression
; 644  :     Encode			();
; 645  : 	// Flush cache
; 646  : 	int size_out = fs.OutSize();
; 647  : 	if (size_out) _write(hf,fs.OutPointer(),size_out);
; 648  : 	fs.OutRelease	();
; 649  : 	return size_out;
; 650  : }
; 651  : 
; 652  : void _compressLZ	(u8** dest, unsigned* dest_sz, void* src, unsigned src_sz)
; 653  : {
; 654  : 	u8*	start = (u8*) src;
; 655  : 	fs.Init_Input(start,start+src_sz);
; 656  :     Encode();
; 657  : 	*dest		= fs.OutPointer();
; 658  : 	*dest_sz	= fs.OutSize();
; 659  : }
; 660  : 
; 661  : void _decompressLZ	(u8** dest, unsigned* dest_sz, void* src, unsigned src_sz)
; 662  : {
; 663  : 	u8*	start = (u8*) src;
; 664  : 	fs.Init_Input(start,start+src_sz);

	lea	rax, QWORD PTR [rcx+rdi]

; 85   : 		in_start	= _start;

	mov	QWORD PTR fs+16, rcx

; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;

	mov	QWORD PTR fs+32, rcx
	mov	QWORD PTR fs+24, rax

; 665  :     Decode();

	call	?Decode@@YAXXZ				; Decode

; 666  : 	*dest		= fs.OutPointer();

	mov	rbp, QWORD PTR fs+40

; 102  : 		return u32(out_iterator-out_start);

	mov	esi, DWORD PTR fs+56
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 262  : 	IC int			tell		()	const		{	return Pos;				};

	mov	ebx, DWORD PTR [rbx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 102  : 		return u32(out_iterator-out_start);

	sub	esi, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 87   : 	return new (ptr) T(p1,p2,p3);

	test	rax, rax
	je	SHORT $LN89@open_chunk
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 278  : 			return xr_new<CTempReader>	(dest,		dest_sz,		tell()+dwSize);

	lea	ecx, DWORD PTR [rdi+rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 244  : 		data		= (char *)_data	;

	mov	QWORD PTR [rax+8], rbp
	mov	rbp, QWORD PTR [rsp+48]

; 247  : 		iterpos		= _iterpos		;

	mov	DWORD PTR [rax+24], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h

; 77   : 				CTempReader(void *_data, int _size, int _iterpos) : IReader(_data,_size,_iterpos)	{}

	lea	rcx, OFFSET FLAT:??_7CTempReader@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 245  : 		Size		= _size			;

	mov	DWORD PTR [rax+20], esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h

; 77   : 				CTempReader(void *_data, int _size, int _iterpos) : IReader(_data,_size,_iterpos)	{}

	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 246  : 		Pos			= 0				;

	mov	DWORD PTR [rax+16], r14d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 278  : 			return xr_new<CTempReader>	(dest,		dest_sz,		tell()+dwSize);

	jmp	$LN1@open_chunk
$LN89@open_chunk:
	mov	rbp, QWORD PTR [rsp+48]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	rax, r14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 278  : 			return xr_new<CTempReader>	(dest,		dest_sz,		tell()+dwSize);

	jmp	$LN1@open_chunk
$LN3@open_chunk:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	movsxd	rbx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edx, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	rbx, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 87   : 	return new (ptr) T(p1,p2,p3);

	test	rax, rax
	je	SHORT $LN105@open_chunk
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 242  : 	IC				IReader			(void *_data, int _size, int _iterpos=0)

	lea	rcx, OFFSET FLAT:??_7IReader@@6B@

; 244  : 		data		= (char *)_data	;

	mov	QWORD PTR [rax+8], rbx

; 245  : 		Size		= _size			;

	mov	DWORD PTR [rax+20], edi
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 280  : 			return xr_new<IReader>		(pointer(),	dwSize,			tell()+dwSize);

	lea	ecx, DWORD PTR [rsi+rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 246  : 		Pos			= 0				;

	mov	DWORD PTR [rax+16], r14d

; 247  : 		iterpos		= _iterpos		;

	mov	DWORD PTR [rax+24], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	jmp	$LN1@open_chunk
$LN105@open_chunk:
	mov	rax, r14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 280  : 			return xr_new<IReader>		(pointer(),	dwSize,			tell()+dwSize);

	jmp	$LN1@open_chunk
?open_chunk@IReader@@QEAAPEAV1@I@Z ENDP			; IReader::open_chunk
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
?close@IReader@@QEAAXXZ PROC				; IReader::close

; 285  : {	xr_delete((IReader*)this); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	lea	rcx, QWORD PTR this$[rsp]
	call	??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z ; xr_delete<IReader>
	add	rsp, 40					; 00000028H
	ret	0
?close@IReader@@QEAAXXZ ENDP				; IReader::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 64
this$ = 64
ID$ = 72
_prev$ = 80
?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z PROC ; IReader::open_chunk_iterator

; 288  : {

$LN103:
	push	rbx
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 289  : 	if (0==_prev)	{

	xor	r15d, r15d
	mov	r14, rdx
	mov	rbx, rcx
	test	r8, r8
	jne	SHORT $LN5@open_chunk
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 263  : 	IC void			seek		(int ptr)		{	Pos=ptr; VERIFY((Pos<=Size) && (Pos>=0));};

	mov	DWORD PTR [rcx+16], r15d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 292  : 	} else {

	jmp	SHORT $LN22@open_chunk
$LN5@open_chunk:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 263  : 	IC void			seek		(int ptr)		{	Pos=ptr; VERIFY((Pos<=Size) && (Pos>=0));};

	mov	eax, DWORD PTR [r8+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 295  : 		_prev->close();

	mov	QWORD PTR this$[rsp], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 263  : 	IC void			seek		(int ptr)		{	Pos=ptr; VERIFY((Pos<=Size) && (Pos>=0));};

	mov	DWORD PTR [rcx+16], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 285  : {	xr_delete((IReader*)this); }

	lea	rcx, QWORD PTR this$[rsp]
	call	??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z ; xr_delete<IReader>
$LN22@open_chunk:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	movsxd	rdx, DWORD PTR [rbx+16]
	mov	eax, DWORD PTR [rbx+20]
	sub	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 299  : 	if			(elapsed()<8)	return		NULL;

	cmp	eax, 8
	jge	SHORT $LN34@open_chunk
	xor	eax, eax

; 313  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rbx
	ret	0
$LN34@open_chunk:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	mov	rax, rdx
	mov	QWORD PTR [rsp+80], rsi
	mov	QWORD PTR [rsp+88], rdi
	add	rax, QWORD PTR [rbx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 318  : 	CopyMemory		(p,pointer(),cnt);

	mov	ecx, DWORD PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	lea	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rbx+16], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 300  : 	ID			= r_u32	()		;

	mov	DWORD PTR [r14], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	movsxd	rcx, DWORD PTR [rbx+16]
	mov	rdx, QWORD PTR [rbx+8]

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	lea	esi, DWORD PTR [rcx+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 318  : 	CopyMemory		(p,pointer(),cnt);

	mov	edi, DWORD PTR [rcx+rdx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 266  : 	IC void			advance		(int cnt)		{	Pos+=cnt;VERIFY((Pos<=Size) && (Pos>=0));};

	mov	DWORD PTR [rbx+16], esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 302  : 	if ( ID & CFS_CompressMark )

	test	DWORD PTR [r14], -2147483648		; 80000000H
	je	$LN2@open_chunk
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	movsxd	rcx, esi
	mov	QWORD PTR [rsp+72], rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	mov	QWORD PTR fs+8, r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	rcx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 90   : 		getbuf = getlen = putbuf = putlen = 0;

	mov	QWORD PTR fs, r15

; 103  : 	}
; 104  : 	IC u8*		OutPointer	() {
; 105  : 		return out_start;
; 106  : 	}
; 107  : 	IC void		OutRelease	() {
; 108  : 		xr_free		(out_start);
; 109  : 		out_start	= 0; 
; 110  : 		out_end		= 0; 
; 111  : 		out_iterator= 0;
; 112  : 	}
; 113  : 	IC int		GetBit(void)    /* get one bit */
; 114  : 	{
; 115  : 		unsigned i;
; 116  : 		
; 117  : 		while (getlen <= 8) {
; 118  : 			if ((int)(i = _getb()) < 0) i = 0;
; 119  : 			getbuf |= i << (8 - getlen);
; 120  : 			getlen += 8;
; 121  : 		}
; 122  : 		i = getbuf;
; 123  : 		getbuf <<= 1;
; 124  : 		getlen--;
; 125  : 		return (int)((i & 0x8000) >> 15);
; 126  : 	}
; 127  : 	
; 128  : 	IC int		GetByte(void)   /* get one byte */
; 129  : 	{
; 130  : 		unsigned i;
; 131  : 		
; 132  : 		while (getlen <= 8) {
; 133  : 			if ((int)(i = _getb()) < 0) i = 0;
; 134  : 			getbuf |= i << (8 - getlen);
; 135  : 			getlen += 8;
; 136  : 		}
; 137  : 		i = getbuf;
; 138  : 		getbuf <<= 8;
; 139  : 		getlen -= 8;
; 140  : 		return (int)((i & 0xff00) >> 8);
; 141  : 	}
; 142  : 	
; 143  : 	IC void		PutCode(int l, unsigned c)     /* output c bits of code */
; 144  : 	{
; 145  : 		putbuf |= c >> putlen;
; 146  : 		if ((putlen += l) >= 8) {
; 147  : 			_putb(putbuf >> 8);
; 148  : 			if ((putlen -= 8) >= 8) {
; 149  : 				_putb(putbuf);
; 150  : 				codesize += 2;
; 151  : 				putlen -= 8;
; 152  : 				putbuf = c << (l - putlen);
; 153  : 			} else {
; 154  : 				putbuf <<= 8;
; 155  : 				codesize++;
; 156  : 			}
; 157  : 		}
; 158  : 	}
; 159  : 	IC void		PutFlush()
; 160  : 	{
; 161  : 		if (putlen) {
; 162  : 			_putb(putbuf >> 8);
; 163  : 			codesize++;
; 164  : 		}
; 165  : 	}
; 166  : };
; 167  : static LZfs fs;
; 168  : //************************** Internal FS
; 169  : IC void InitTree(void)  /* initialize trees */
; 170  : {
; 171  :     int  i;
; 172  : 	
; 173  :     for (i = N + 1; i <= N + 256; i++)	        rson[i] = NIL;        /* root */
; 174  :     for (i = 0; i < N; i++)						dad[i] = NIL;         /* node */
; 175  : }
; 176  : 
; 177  : void InsertNode(int r)  /* insert to tree */
; 178  : {
; 179  :     int				i, p, cmp;
; 180  :     u8			*key;
; 181  :     unsigned		c;
; 182  : 	
; 183  :     cmp = 1;
; 184  :     key = &text_buf[r];
; 185  :     p = N + 1 + key[0];
; 186  :     rson[r] = lson[r] = NIL;
; 187  :     match_length = 0;
; 188  :     for ( ; ; ) {
; 189  :         if (cmp >= 0) {
; 190  :             if (rson[p] != NIL)
; 191  :                 p = rson[p];
; 192  :             else {
; 193  :                 rson[p] = r;
; 194  :                 dad[r] = p;
; 195  :                 return;
; 196  :             }
; 197  :         } else {
; 198  :             if (lson[p] != NIL)
; 199  :                 p = lson[p];
; 200  :             else {
; 201  :                 lson[p] = r;
; 202  :                 dad[r] = p;
; 203  :                 return;
; 204  :             }
; 205  :         }
; 206  :         for (i = 1; i < F; i++)
; 207  :             if ((cmp = key[i] - text_buf[p + i]) != 0)
; 208  :                 break;
; 209  : 			if (i > THRESHOLD) {
; 210  : 				if (i > match_length) {
; 211  : 					match_position = ((r - p) & (N - 1)) - 1;
; 212  : 					if ((match_length = i) >= F)
; 213  : 						break;
; 214  : 				}
; 215  : 				if (i == match_length) {
; 216  : 					if ((c = ((r - p) & (N-1)) - 1) < (unsigned)match_position) {
; 217  : 						match_position = c;
; 218  : 					}
; 219  : 				}
; 220  : 			}
; 221  :     }
; 222  :     dad[r]  = dad[p];
; 223  :     lson[r] = lson[p];
; 224  :     rson[r] = rson[p];
; 225  :     dad[lson[p]] = r;
; 226  :     dad[rson[p]] = r;
; 227  :     if (rson[dad[p]] == p)
; 228  :         rson[dad[p]] = r;
; 229  :     else
; 230  :         lson[dad[p]] = r;
; 231  :     dad[p] = NIL; /* remove p */
; 232  : }
; 233  : 
; 234  : void DeleteNode(int p)  /* remove from tree */
; 235  : {
; 236  :     int  q;
; 237  : 	
; 238  :     if (dad[p] == NIL)	return;	/* not registered */
; 239  :     if (rson[p] == NIL)
; 240  : 		q = lson[p];
; 241  :     else 
; 242  : 	{
; 243  : 		if (lson[p] == NIL)
; 244  : 		{
; 245  : 			q = rson[p];
; 246  : 		}
; 247  : 		else 
; 248  : 		{
; 249  : 			q = lson[p];
; 250  : 			if (rson[q] != NIL) 
; 251  : 			{
; 252  : 				do { q = rson[q]; } while (rson[q] != NIL);
; 253  : 				
; 254  : 				rson[dad[q]]	= lson[q];
; 255  : 				dad[lson[q]]	= dad[q];
; 256  : 				lson[q]			= lson[p];
; 257  : 				dad[lson[p]]	= q;
; 258  : 			}
; 259  : 			rson[q]			= rson[p];
; 260  : 			dad[rson[p]]	= q;
; 261  : 		}
; 262  : 	}
; 263  : 	dad[q] = dad[p];
; 264  : 	if (rson[dad[p]] == p)
; 265  : 		rson[dad[p]] = q;
; 266  : 	else
; 267  : 		lson[dad[p]] = q;
; 268  : 	dad[p] = NIL;
; 269  : }
; 270  : 
; 271  : /* Huffman coding */
; 272  : 
; 273  : 
; 274  : /* table for encoding and decoding the upper 6 bits of position */
; 275  : /* for encoding */
; 276  : u8 p_len[64] = {
; 277  :     0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
; 278  : 	0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
; 279  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 280  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 281  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 282  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 283  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 284  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
; 285  : };
; 286  : 
; 287  : u8 p_code[64] = {
; 288  :     0x00, 0x20, 0x30, 0x40, 0x50, 0x58, 0x60, 0x68,
; 289  : 	0x70, 0x78, 0x80, 0x88, 0x90, 0x94, 0x98, 0x9C,
; 290  : 	0xA0, 0xA4, 0xA8, 0xAC, 0xB0, 0xB4, 0xB8, 0xBC,
; 291  : 	0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,
; 292  : 	0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,
; 293  : 	0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE,
; 294  : 	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
; 295  : 	0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
; 296  : };
; 297  : 
; 298  : /* for decoding */
; 299  : u8 d_code[256] = {
; 300  :     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 301  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 302  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 303  : 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 304  : 	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
; 305  : 	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
; 306  : 	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
; 307  : 	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
; 308  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 309  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 310  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 311  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 312  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 313  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 314  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 315  : 	0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
; 316  : 	0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,
; 317  : 	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
; 318  : 	0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,
; 319  : 	0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,
; 320  : 	0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,
; 321  : 	0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
; 322  : 	0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,
; 323  : 	0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,
; 324  : 	0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,
; 325  : 	0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,
; 326  : 	0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,
; 327  : 	0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,
; 328  : 	0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,
; 329  : 	0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,
; 330  : 	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
; 331  : 	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
; 332  : };
; 333  : 
; 334  : u8 d_len[256] = {
; 335  :     0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 336  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 337  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 338  : 	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
; 339  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 340  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 341  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 342  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 343  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 344  : 	0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
; 345  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 346  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 347  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 348  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 349  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 350  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 351  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 352  : 	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
; 353  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 354  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 355  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 356  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 357  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 358  : 	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
; 359  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 360  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 361  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 362  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 363  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 364  : 	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
; 365  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 366  : 	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
; 367  : };
; 368  : 
; 369  : 
; 370  : /* initialization of tree */
; 371  : 
; 372  : void StartHuff(void)
; 373  : {
; 374  :     int i, j;
; 375  : 	
; 376  :     for (i = 0; i < N_CHAR; i++) {
; 377  :         freq[i]		= 1;
; 378  :         son	[i]		= i + T;
; 379  :         prnt[i + T] = i;
; 380  :     }
; 381  :     i = 0; j = N_CHAR;
; 382  :     while (j <= R) {
; 383  :         freq[j]		= freq[i] + freq[i + 1];
; 384  :         son[j]		= i;
; 385  :         prnt[i]		= prnt[i + 1] = j;
; 386  :         i += 2; j++;
; 387  :     }
; 388  :     freq[T] = 0xffff;
; 389  :     prnt[R] = 0;
; 390  : }
; 391  : 
; 392  : 
; 393  : /* reconstruction of tree */
; 394  : void reconst(void)
; 395  : {
; 396  :     int			i, j, k;
; 397  :     unsigned	f, l;
; 398  : 	
; 399  :     /* collect leaf nodes in the first half of the table */
; 400  :     /* and replace the freq by (freq + 1) / 2. */
; 401  :     j = 0;
; 402  :     for (i = 0; i < T; i++) {
; 403  :         if (son[i] >= T) {
; 404  :             freq[j] = (freq[i] + 1) / 2;
; 405  :             son[j] = son[i];
; 406  :             j++;
; 407  :         }
; 408  :     }
; 409  :     /* begin constructing tree by connecting sons */
; 410  :     for (i = 0, j = N_CHAR; j < T; i += 2, j++) {
; 411  :         k = i + 1;
; 412  :         f = freq[j] = freq[i] + freq[k];
; 413  :         for (k = j - 1; f < freq[k]; k--);
; 414  :         k++;
; 415  :         l = (j - k) * sizeof(unsigned);
; 416  :         memmove	(&freq[k + 1], &freq[k], l);
; 417  :         freq[k] = f;
; 418  :         memmove	(&son[k + 1], &son[k], l);
; 419  :         son[k] = i;
; 420  :     }
; 421  :     /* connect prnt */
; 422  :     for (i = 0; i < T; i++) {
; 423  :         if ((k = son[i]) >= T) {
; 424  :             prnt[k] = i;
; 425  :         } else {
; 426  :             prnt[k] = prnt[k + 1] = i;
; 427  :         }
; 428  :     }
; 429  : }
; 430  : 
; 431  : 
; 432  : /* increment frequency of given code by one, and update tree */
; 433  : void update(int c)
; 434  : {
; 435  :     int i, j, k, l;
; 436  : 	
; 437  :     if (freq[R] == MAX_FREQ) {
; 438  :         reconst();
; 439  :     }
; 440  :     c = prnt[c + T];
; 441  :     do {
; 442  :         k = ++freq[c];
; 443  : 		
; 444  :         /* if the order is disturbed, exchange nodes */
; 445  :         if ((unsigned)k > freq[l = c + 1]) {
; 446  :             while ((unsigned)k > freq[++l]);
; 447  :             l--;
; 448  :             freq[c] = freq[l];
; 449  :             freq[l] = k;
; 450  : 			
; 451  :             i = son[c];
; 452  :             prnt[i] = l;
; 453  :             if (i < T) prnt[i + 1] = l;
; 454  : 			
; 455  :             j = son[l];
; 456  :             son[l] = i;
; 457  : 			
; 458  :             prnt[j] = c;
; 459  :             if (j < T) prnt[j + 1] = c;
; 460  :             son[c] = j;
; 461  : 			
; 462  :             c = l;
; 463  :         }
; 464  :     } while ((c = prnt[c]) != 0); /* repeat up to root */
; 465  : }
; 466  : 
; 467  : void EncodeChar(unsigned c)
; 468  : {
; 469  :     unsigned i;
; 470  :     int j, k;
; 471  : 	
; 472  :     i = 0;
; 473  :     j = 0;
; 474  :     k = prnt[c + T];
; 475  : 	
; 476  :     /* travel from leaf to root */
; 477  :     do {
; 478  :         i >>= 1;
; 479  : 		
; 480  :         /* if node's address is odd-numbered, choose bigger brother node */
; 481  :         if (k & 1) i += 0x8000;
; 482  : 		
; 483  :         j++;
; 484  : 		k = prnt[k];
; 485  :     } while (k != R);
; 486  :     fs.PutCode(j, i);
; 487  :     code = i;
; 488  :     len = j;
; 489  :     update(c);
; 490  : }
; 491  : 
; 492  : void EncodePosition(unsigned c)
; 493  : {
; 494  :     unsigned i;
; 495  : 	
; 496  :     /* output upper 6 bits by table lookup */
; 497  :     i = c >> 6;
; 498  :     fs.PutCode(p_len[i], (unsigned)p_code[i] << 8);
; 499  : 	
; 500  :     /* output lower 6 bits verbatim */
; 501  :     fs.PutCode(6, (c & 0x3f) << 10);
; 502  : }
; 503  : 
; 504  : int DecodeChar(void)
; 505  : {
; 506  :     unsigned c;
; 507  : 	
; 508  :     c = son[R];
; 509  : 	
; 510  :     /* travel from root to leaf, */
; 511  :     /* choosing the smaller child node (son[]) if the read bit is 0, */
; 512  :     /* the bigger (son[]+1} if 1 */
; 513  :     while (c < T) {
; 514  :         c += fs.GetBit();
; 515  :         c = son[c];
; 516  :     }
; 517  :     c -= T;
; 518  :     update(c);
; 519  :     return (int)c;
; 520  : }
; 521  : 
; 522  : int DecodePosition(void)
; 523  : {
; 524  :     unsigned i, j, c;
; 525  : 	
; 526  :     /* recover upper 6 bits from table */
; 527  :     i = fs.GetByte();
; 528  :     c = (unsigned)d_code[i] << 6;
; 529  :     j = d_len[i];
; 530  : 	
; 531  :     /* read lower 6 bits verbatim */
; 532  :     j -= 2;
; 533  :     while (j--) {
; 534  :         i = (i << 1) + fs.GetBit();
; 535  :     }
; 536  :     return (int)(c | (i & 0x3f));
; 537  : }
; 538  : 
; 539  : /* compression */
; 540  : void Encode(void)  /* compression */
; 541  : {
; 542  :     int  i, c, len, r, s, last_match_length;
; 543  : 	
; 544  :     textsize = fs.InputSize();
; 545  : 	fs.Init_Output(textsize);
; 546  : 	fs._putb((textsize & 0xff));
; 547  : 	fs._putb((textsize & 0xff00) >> 8);
; 548  : 	fs._putb((textsize & 0xff0000L) >> 16);
; 549  : 	fs._putb((textsize & 0xff000000L) >> 24);
; 550  :     if (textsize == 0)
; 551  :         return;
; 552  :     textsize = 0;           /* rewind and re-read */
; 553  :     StartHuff();
; 554  :     InitTree();
; 555  :     s = 0;
; 556  :     r = N - F;
; 557  :     for (i = s; i < r; i++)
; 558  :         text_buf[i] = 0x20;
; 559  :     for (len = 0; len < F && (c = fs._getb()) != EOF; len++)
; 560  :         text_buf[r + len] = (unsigned char)c;
; 561  :     textsize = len;
; 562  :     for (i = 1; i <= F; i++)
; 563  :         InsertNode(r - i);
; 564  :     InsertNode(r);
; 565  :     do {
; 566  :         if (match_length > len)
; 567  :             match_length = len;
; 568  :         if (match_length <= THRESHOLD) {
; 569  :             match_length = 1;
; 570  : 			// textsize==56158    - FATAL :(
; 571  :             EncodeChar(text_buf[r]);
; 572  :         } else {
; 573  :             EncodeChar(255 - THRESHOLD + match_length);
; 574  :             EncodePosition(match_position);
; 575  :         }
; 576  :         last_match_length = match_length;
; 577  :         for (i = 0; i < last_match_length &&
; 578  : 			(c = fs._getb()) != EOF; i++) {
; 579  :             DeleteNode(s);
; 580  :             text_buf[s] = (unsigned char)c;
; 581  :             if (s < F - 1)
; 582  :                 text_buf[s + N] = (unsigned char)c;
; 583  :             s = (s + 1) & (N - 1);
; 584  :             r = (r + 1) & (N - 1);
; 585  :             InsertNode(r);
; 586  :         }
; 587  : 		textsize += i;
; 588  :         while (i++ < last_match_length) {
; 589  :             DeleteNode(s);
; 590  :             s = (s + 1) & (N - 1);
; 591  :             r = (r + 1) & (N - 1);
; 592  :             if (--len) InsertNode(r);
; 593  :         }
; 594  :     } while (len > 0);
; 595  :     fs.PutFlush();
; 596  : 	tim_size = textsize;
; 597  : }
; 598  : 
; 599  : void Decode(void)  /* recover */
; 600  : {
; 601  :     int  i, j, k, r, c;
; 602  :     unsigned int  count;
; 603  : 	
; 604  :     textsize =  (fs._getb());
; 605  :     textsize |= (fs._getb() << 8);
; 606  :     textsize |= (fs._getb() << 16);
; 607  :     textsize |= (fs._getb() << 24);
; 608  :     if (textsize == 0) return;
; 609  : 	
; 610  : 	fs.Init_Output(textsize);
; 611  : 	
; 612  :     StartHuff();
; 613  :     for (i = 0; i < N - F; i++)
; 614  :         text_buf[i] = 0x20;
; 615  :     r = N - F;
; 616  :     for (count = 0; count < textsize; ) {
; 617  :         c = DecodeChar();
; 618  :         if (c < 256) {
; 619  :             fs._putb(c);
; 620  :             text_buf[r++] = (unsigned char)c;
; 621  :             r &= (N - 1);
; 622  :             count++;
; 623  :         } else {
; 624  :             i = (r - DecodePosition() - 1) & (N - 1);
; 625  :             j = c - 255 + THRESHOLD;
; 626  :             for (k = 0; k < j; k++) {
; 627  :                 c = text_buf[(i + k) & (N - 1)];
; 628  :                 fs._putb(c);
; 629  :                 text_buf[r++] = (unsigned char)c;
; 630  :                 r &= (N - 1);
; 631  :                 count++;
; 632  :             }
; 633  :         }
; 634  :     }
; 635  : 	tim_size = count;
; 636  : }
; 637  : 
; 638  : unsigned _writeLZ	(int hf, void* d, unsigned size)
; 639  : {
; 640  : 	u8*	start = (u8*) d;
; 641  : 	fs.Init_Input(start,start+size);
; 642  : 	
; 643  : 	// Actual compression
; 644  :     Encode			();
; 645  : 	// Flush cache
; 646  : 	int size_out = fs.OutSize();
; 647  : 	if (size_out) _write(hf,fs.OutPointer(),size_out);
; 648  : 	fs.OutRelease	();
; 649  : 	return size_out;
; 650  : }
; 651  : 
; 652  : void _compressLZ	(u8** dest, unsigned* dest_sz, void* src, unsigned src_sz)
; 653  : {
; 654  : 	u8*	start = (u8*) src;
; 655  : 	fs.Init_Input(start,start+src_sz);
; 656  :     Encode();
; 657  : 	*dest		= fs.OutPointer();
; 658  : 	*dest_sz	= fs.OutSize();
; 659  : }
; 660  : 
; 661  : void _decompressLZ	(u8** dest, unsigned* dest_sz, void* src, unsigned src_sz)
; 662  : {
; 663  : 	u8*	start = (u8*) src;
; 664  : 	fs.Init_Input(start,start+src_sz);

	lea	rax, QWORD PTR [rcx+rdi]

; 85   : 		in_start	= _start;

	mov	QWORD PTR fs+16, rcx

; 86   : 		in_end		= _end;
; 87   : 		in_iterator	= in_start;

	mov	QWORD PTR fs+32, rcx
	mov	QWORD PTR fs+24, rax

; 665  :     Decode();

	call	?Decode@@YAXXZ				; Decode

; 666  : 	*dest		= fs.OutPointer();

	mov	rbp, QWORD PTR fs+40

; 102  : 		return u32(out_iterator-out_start);

	mov	esi, DWORD PTR fs+56
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 262  : 	IC int			tell		()	const		{	return Pos;				};

	mov	ebx, DWORD PTR [rbx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\lzhuf.cpp

; 102  : 		return u32(out_iterator-out_start);

	sub	esi, ebp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 87   : 	return new (ptr) T(p1,p2,p3);

	test	rax, rax
	je	SHORT $LN76@open_chunk
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 308  : 		return xr_new<CTempReader>	(dest,		dest_sz,	tell()+_size);

	lea	ecx, DWORD PTR [rbx+rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 244  : 		data		= (char *)_data	;

	mov	QWORD PTR [rax+8], rbp
	mov	rbp, QWORD PTR [rsp+72]

; 247  : 		iterpos		= _iterpos		;

	mov	DWORD PTR [rax+24], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h

; 77   : 				CTempReader(void *_data, int _size, int _iterpos) : IReader(_data,_size,_iterpos)	{}

	lea	rcx, OFFSET FLAT:??_7CTempReader@@6B@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 245  : 		Size		= _size			;

	mov	DWORD PTR [rax+20], esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h

; 77   : 				CTempReader(void *_data, int _size, int _iterpos) : IReader(_data,_size,_iterpos)	{}

	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 246  : 		Pos			= 0				;

	mov	DWORD PTR [rax+16], r15d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 308  : 		return xr_new<CTempReader>	(dest,		dest_sz,	tell()+_size);

	jmp	SHORT $LN93@open_chunk
$LN76@open_chunk:
	mov	rbp, QWORD PTR [rsp+72]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	mov	rax, r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 308  : 		return xr_new<CTempReader>	(dest,		dest_sz,	tell()+_size);

	jmp	SHORT $LN93@open_chunk
$LN2@open_chunk:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	movsxd	rbx, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 265  : 	IC void*		pointer		()	const		{	return &(data[Pos]);	};

	add	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	edx, 32					; 00000020H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 87   : 	return new (ptr) T(p1,p2,p3);

	test	rax, rax
	je	SHORT $LN92@open_chunk
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 242  : 	IC				IReader			(void *_data, int _size, int _iterpos=0)

	lea	rcx, OFFSET FLAT:??_7IReader@@6B@

; 244  : 		data		= (char *)_data	;

	mov	QWORD PTR [rax+8], rbx

; 245  : 		Size		= _size			;

	mov	DWORD PTR [rax+20], edi
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 311  : 		return xr_new<IReader>		(pointer(),	_size,		tell()+_size);

	lea	ecx, DWORD PTR [rsi+rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 246  : 		Pos			= 0				;

	mov	DWORD PTR [rax+16], r15d

; 247  : 		iterpos		= _iterpos		;

	mov	DWORD PTR [rax+24], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 87   : 	return new (ptr) T(p1,p2,p3);

	jmp	SHORT $LN93@open_chunk
$LN92@open_chunk:
	mov	rax, r15
$LN93@open_chunk:
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 313  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rbx
	ret	0
?open_chunk_iterator@IReader@@QEAAPEAV1@AEAIPEAV1@@Z ENDP ; IReader::open_chunk_iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
;	COMDAT ?is_term@@YAHD@Z
_TEXT	SEGMENT
a$ = 8
?is_term@@YAHD@Z PROC					; is_term, COMDAT

; 330  : IC BOOL			is_term		(char a) { return (a==13)||(a==10); };

	cmp	cl, 13
	je	SHORT $LN3@is_term
	cmp	cl, 10
	je	SHORT $LN3@is_term
	xor	eax, eax
	ret	0
$LN3@is_term:
	mov	eax, 1
	ret	0
?is_term@@YAHD@Z ENDP					; is_term
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
;	COMDAT ?advance_term_string@IReader@@IEAAIXZ
_TEXT	SEGMENT
this$ = 8
?advance_term_string@IReader@@IEAAIXZ PROC		; IReader::advance_term_string, COMDAT

; 332  : {

$LN52:
	mov	QWORD PTR [rsp+8], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	r11d, DWORD PTR [rcx+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 334  : 	char *src 	= (char *) data;

	mov	rbx, QWORD PTR [rcx+8]
	xor	r9d, r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, r11d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 332  : {

	mov	r8, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	sub	eax, DWORD PTR [rcx+16]

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 335  : 	while (!eof()) {

	jle	SHORT $LN46@advance_te
	npad	3
$LL5@advance_te:

; 336  :         Pos++;

	inc	DWORD PTR [r8+16]
	movsxd	rdx, DWORD PTR [r8+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	ecx, r11d
	sub	ecx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 337  :         sz++;

	inc	r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	ecx, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 338  : 		if (!eof()&&is_term(src[Pos])) {

	jle	SHORT $LN46@advance_te
	movzx	r10d, BYTE PTR [rdx+rbx]

; 330  : IC BOOL			is_term		(char a) { return (a==13)||(a==10); };

	cmp	r10b, 13
	je	SHORT $LN35@advance_te
	cmp	r10b, 10
	je	SHORT $LN35@advance_te
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	ecx, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 335  : 	while (!eof()) {

	jg	SHORT $LL5@advance_te

; 340  : 			break;
; 341  : 		}
; 342  : 	}
; 343  :     return sz;

	mov	eax, r9d

; 344  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
$LN35@advance_te:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, r11d
	sub	eax, edx

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 339  :         	while(!eof()&&is_term(src[Pos])) Pos++;

	jle	SHORT $LN46@advance_te
	npad	5
$LL2@advance_te:
	movsxd	rax, edx
	movzx	ecx, BYTE PTR [rax+rbx]

; 330  : IC BOOL			is_term		(char a) { return (a==13)||(a==10); };

	cmp	cl, 13
	je	SHORT $LN32@advance_te
	cmp	cl, 10
	jne	SHORT $LN46@advance_te
$LN32@advance_te:

; 339  :         	while(!eof()&&is_term(src[Pos])) Pos++;

	inc	edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, r11d
	sub	eax, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 339  :         	while(!eof()&&is_term(src[Pos])) Pos++;

	mov	DWORD PTR [r8+16], edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 339  :         	while(!eof()&&is_term(src[Pos])) Pos++;

	jg	SHORT $LL2@advance_te
$LN46@advance_te:

; 344  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	eax, r9d
	ret	0
?advance_term_string@IReader@@IEAAIXZ ENDP		; IReader::advance_term_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 96
dest$ = 104
tgt_sz$ = 112
?r_string@IReader@@QEAAXPEADI@Z PROC			; IReader::r_string

; 346  : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 80					; 00000050H

; 347  : 	char *src 	= (char *) data+Pos;

	movsxd	rsi, DWORD PTR [rcx+16]
	mov	ebp, r8d
	mov	rdi, rdx
	add	rsi, QWORD PTR [rcx+8]

; 348  : 	u32 sz 		= advance_term_string();

	call	?advance_term_string@IReader@@IEAAIXZ	; IReader::advance_term_string

; 349  :     R_ASSERT2(sz<(tgt_sz-1),"Dest string less than needed.");

	cmp	BYTE PTR ?ignore_always@?3??r_string@IReader@@QEAAXPEADI@Z@4_NA, 0
	mov	ebx, eax
	jne	SHORT $LN3@r_string
	lea	ecx, DWORD PTR [rbp-1]
	cmp	ebx, ecx
	jb	SHORT $LN3@r_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3??r_string@IReader@@QEAAXPEADI@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0BO@CBOGAODA@Dest?5string?5less?5than?5needed?4?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0O@CCNJDAAG@sz?$DM?$CItgt_sz?91?$CJ?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BC@LFPNBCKC@IReader?3?3r_string?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_06ODPOMCLF@FS?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 349			; 0000015dH
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN3@r_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 350  :     strncpy		(dest,src,sz);

	mov	r8, rbx
	mov	rdx, rsi
	mov	rcx, rdi
	call	QWORD PTR __imp_strncpy

; 351  :     dest[sz]	= 0;
; 352  : }

	mov	rbp, QWORD PTR [rsp+104]
	mov	rsi, QWORD PTR [rsp+112]
	mov	BYTE PTR [rbx+rdi], 0
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?r_string@IReader@@QEAAXPEADI@Z ENDP			; IReader::r_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
dest$ = 56
?r_string@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z PROC ; IReader::r_string

; 354  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 355  : 	char *src 	= (char *) data+Pos;

	movsxd	rbx, DWORD PTR [rcx+16]
	mov	rdi, rdx
	add	rbx, QWORD PTR [rcx+8]

; 356  : 	u32 sz 		= advance_term_string();

	call	?advance_term_string@IReader@@IEAAIXZ	; IReader::advance_term_string

; 357  :     dest.assign	(src,sz);

	mov	rdx, rbx
	mov	r8d, eax
	mov	rcx, rdi

; 358  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 357  :     dest.assign	(src,sz);

	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
?r_string@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z ENDP ; IReader::r_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 96
dest$ = 104
tgt_sz$ = 112
?r_stringZ@IReader@@QEAAXPEADI@Z PROC			; IReader::r_stringZ

; 360  : {

$LN27:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 80					; 00000050H

; 363  :     R_ASSERT2(sz<tgt_sz,"Dest string less than needed.");

	cmp	BYTE PTR ?ignore_always@?3??r_stringZ@IReader@@QEAAXPEADI@Z@4_NA, 0
	mov	rsi, QWORD PTR [rcx+8]
	mov	rdi, rdx
	mov	rbx, rcx
	jne	SHORT $LN5@r_stringZ
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
$LL23@r_stringZ:
	inc	rax
	cmp	BYTE PTR [rsi+rax], 0
	jne	SHORT $LL23@r_stringZ
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 363  :     R_ASSERT2(sz<tgt_sz,"Dest string less than needed.");

	cmp	eax, r8d
	jb	SHORT $LN5@r_stringZ
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3??r_stringZ@IReader@@QEAAXPEADI@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0BO@CBOGAODA@Dest?5string?5less?5than?5needed?4?$AA@
	lea	rdx, OFFSET FLAT:??_C@_09KHGJHDDP@sz?$DMtgt_sz?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BD@HIDJIKAI@IReader?3?3r_stringZ?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_06ODPOMCLF@FS?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 363			; 0000016bH
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN5@r_stringZ:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 364  : 	while ((src[Pos]!=0) && (!eof())) *dest++ = src[Pos++];

	movsxd	rax, DWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+rsi], 0
	je	SHORT $LN24@r_stringZ
$LL2@r_stringZ:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	movsxd	rcx, DWORD PTR [rbx+16]
	mov	eax, DWORD PTR [rbx+20]
	sub	eax, ecx

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 364  : 	while ((src[Pos]!=0) && (!eof())) *dest++ = src[Pos++];

	jle	SHORT $LN24@r_stringZ
	movzx	ecx, BYTE PTR [rcx+rsi]
	inc	rdi
	mov	BYTE PTR [rdi-1], cl
	inc	DWORD PTR [rbx+16]
	movsxd	rax, DWORD PTR [rbx+16]
	cmp	BYTE PTR [rax+rsi], 0
	jne	SHORT $LL2@r_stringZ
$LN24@r_stringZ:

; 365  : 	*dest		=	0;
; 366  : 	Pos++;
; 367  : }

	mov	rsi, QWORD PTR [rsp+104]
	mov	BYTE PTR [rdi], 0
	inc	DWORD PTR [rbx+16]
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?r_stringZ@IReader@@QEAAXPEADI@Z ENDP			; IReader::r_stringZ
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
dest$ = 56
?r_stringZ@IReader@@QEAAXAEAVshared_str@@@Z PROC	; IReader::r_stringZ

; 369  : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 370  : 	dest		= (char*)(data+Pos);

	movsxd	rdx, DWORD PTR [rcx+16]
	mov	rbx, rcx
	add	rdx, QWORD PTR [rcx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN5@r_stringZ
	inc	DWORD PTR [rax]
$LN5@r_stringZ:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rcx, QWORD PTR [rdi]
	xor	edx, edx
	test	rcx, rcx
	je	SHORT $LN8@r_stringZ
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rdi]
	cmp	DWORD PTR [rcx], edx
	jne	SHORT $LN8@r_stringZ
	mov	QWORD PTR [rdi], rdx
$LN8@r_stringZ:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR [rdi], rax

; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}

	test	rax, rax
	jne	SHORT $LN13@r_stringZ
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 371  :     Pos			+=(dest.size()+1);

	lea	eax, DWORD PTR [rdx+1]
	add	DWORD PTR [rbx+16], eax

; 372  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN13@r_stringZ:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}

	mov	eax, DWORD PTR [rax+4]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 371  :     Pos			+=(dest.size()+1);

	inc	eax
	add	DWORD PTR [rbx+16], eax

; 372  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?r_stringZ@IReader@@QEAAXAEAVshared_str@@@Z ENDP	; IReader::r_stringZ
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
dest$ = 56
?r_stringZ@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z PROC ; IReader::r_stringZ

; 374  : {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rdx

; 375  :     dest 		= (char*)(data+Pos);

	movsxd	rdx, DWORD PTR [rcx+16]
	mov	rbx, rcx
	add	rdx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rdx], 0
	jne	SHORT $LN9@r_stringZ
	xor	r8d, r8d
	jmp	SHORT $LN10@r_stringZ
$LN9@r_stringZ:
	or	r8, -1
$LL13@r_stringZ:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL13@r_stringZ
$LN10@r_stringZ:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 376  :     Pos			+=int(dest.size()+1);

	mov	eax, DWORD PTR [rdi+16]
	inc	eax
	add	DWORD PTR [rbx+16], eax

; 377  : };

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?r_stringZ@IReader@@QEAAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@Z ENDP ; IReader::r_stringZ
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 8
?skip_stringZ@IReader@@QEAAXXZ PROC			; IReader::skip_stringZ

; 381  : 	char *src = (char *) data;

	mov	r8, QWORD PTR [rcx+8]

; 382  : 	while ((src[Pos]!=0) && (!eof())) Pos++;

	movsxd	rax, DWORD PTR [rcx+16]
	cmp	BYTE PTR [rax+r8], 0
	je	SHORT $LN15@skip_strin
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	r9d, DWORD PTR [rcx+20]
$LL2@skip_strin:
	mov	edx, DWORD PTR [rcx+16]
	mov	eax, r9d
	sub	eax, edx

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 382  : 	while ((src[Pos]!=0) && (!eof())) Pos++;

	jle	SHORT $LN15@skip_strin
	lea	eax, DWORD PTR [rdx+1]
	mov	DWORD PTR [rcx+16], eax
	cdqe
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL2@skip_strin
$LN15@skip_strin:

; 383  : 	Pos		++;

	inc	DWORD PTR [rcx+16]

; 384  : };

	ret	0
?skip_stringZ@IReader@@QEAAXXZ ENDP			; IReader::skip_stringZ
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
??1CTempReader@@UEAA@XZ PROC				; CTempReader::~CTempReader

; 389  : {	xr_free(data);	};

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7CTempReader@@6B@
	mov	rbx, rcx
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN12@CTempReade
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN12@CTempReade:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 389  : {	xr_free(data);	};

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1CTempReader@@UEAA@XZ ENDP				; CTempReader::~CTempReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
??1CPackReader@@UEAA@XZ PROC				; CPackReader::~CPackReader

; 393  : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7CPackReader@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 394  : #ifdef DEBUG
; 395  : 	unregister_file_mapping	(base_address,Size);
; 396  : #endif // DEBUG
; 397  : 
; 398  : 	UnmapViewOfFile	(base_address);

	mov	rcx, QWORD PTR [rcx+32]
	call	QWORD PTR __imp_UnmapViewOfFile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 399  : };

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1CPackReader@@UEAA@XZ ENDP				; CPackReader::~CPackReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
name$ = 56
??0CFileReader@@QEAA@PEBD@Z PROC			; CFileReader::CFileReader

; 403  : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 239  : 		Pos			= 0;

	mov	DWORD PTR [rcx+16], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 403  : {

	mov	rax, rdx
	lea	rcx, OFFSET FLAT:??_7CFileReader@@6B@

; 404  :     data	= (char *)FileDownload(name,(u32 *)&Size);

	lea	rdx, QWORD PTR [rbx+20]
	mov	QWORD PTR [rbx], rcx
	mov	rcx, rax
	call	?FileDownload@@YAPEAXPEBDPEAI@Z		; FileDownload

; 405  :     Pos		= 0;

	mov	DWORD PTR [rbx+16], 0
	mov	QWORD PTR [rbx+8], rax

; 406  : };

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0CFileReader@@QEAA@PEBD@Z ENDP			; CFileReader::CFileReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GCFileReader@@UEAAPEAXI@Z
_TEXT	SEGMENT
p$ = 48
this$ = 48
__flags$ = 56
??_GCFileReader@@UEAAPEAXI@Z PROC			; CFileReader::`scalar deleting destructor', COMDAT
$LN19:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 408  : {	xr_free(data);	};

	lea	rax, OFFSET FLAT:??_7CFileReader@@6B@
	mov	rbx, rcx
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rcx], 0
	mov	edi, edx
	je	SHORT $LN6@scalar
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN6@scalar:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
	test	dil, 1
	je	SHORT $LN17@scalar
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR p$[rsp], rbx
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN17@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GCFileReader@@UEAAPEAXI@Z ENDP			; CFileReader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
??1CFileReader@@UEAA@XZ PROC				; CFileReader::~CFileReader

; 408  : {	xr_free(data);	};

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7CFileReader@@6B@
	mov	rbx, rcx
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN12@CFileReade
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN12@CFileReade:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 408  : {	xr_free(data);	};

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1CFileReader@@UEAA@XZ ENDP				; CFileReader::~CFileReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GCCompressedReader@@UEAAPEAXI@Z
_TEXT	SEGMENT
p$ = 48
this$ = 48
__flags$ = 56
??_GCCompressedReader@@UEAAPEAXI@Z PROC			; CCompressedReader::`scalar deleting destructor', COMDAT
$LN19:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 417  : {	xr_free(data);	};

	lea	rax, OFFSET FLAT:??_7CCompressedReader@@6B@
	mov	rbx, rcx
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rcx], 0
	mov	edi, edx
	je	SHORT $LN6@scalar
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN6@scalar:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
	test	dil, 1
	je	SHORT $LN17@scalar
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR p$[rsp], rbx
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN17@scalar:
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GCCompressedReader@@UEAAPEAXI@Z ENDP			; CCompressedReader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
??1CCompressedReader@@UEAA@XZ PROC			; CCompressedReader::~CCompressedReader

; 417  : {	xr_free(data);	};

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7CCompressedReader@@6B@
	mov	rbx, rcx
	add	rcx, 8
	mov	QWORD PTR [rcx-8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rcx], 0
	je	SHORT $LN12@CCompresse
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN12@CCompresse:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 417  : {	xr_free(data);	};

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1CCompressedReader@@UEAA@XZ ENDP			; CCompressedReader::~CCompressedReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 112
cFileName$ = 120
??0CVirtualFileRW@@QEAA@PEBD@Z PROC			; CVirtualFileRW::CVirtualFileRW

; 421  : {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 239  : 		Pos			= 0;

	xor	esi, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 421  : {

	mov	rdi, rdx
	lea	rax, OFFSET FLAT:??_7CVirtualFileRW@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 239  : 		Pos			= 0;

	mov	DWORD PTR [rcx+16], esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 423  : 	hSrcFile		= CreateFile(cFileName, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0);

	mov	QWORD PTR [rsp+48], rsi
	lea	r8d, QWORD PTR [rsi+1]
	mov	rcx, rdi
	xor	r9d, r9d
	mov	edx, -1073741824			; c0000000H
	mov	DWORD PTR [rsp+40], esi
	mov	DWORD PTR [rsp+32], 3
	call	QWORD PTR __imp_CreateFileA

; 424  : 	R_ASSERT3		(hSrcFile!=INVALID_HANDLE_VALUE,cFileName,Debug.error2string(GetLastError()));

	lea	rbp, OFFSET FLAT:?desc_storage@?1??error2string@xrDebug@@QEAAPEBDJ@Z@4PADA
	mov	QWORD PTR [rbx+32], rax
	cmp	BYTE PTR ?ignore_always@?3???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA, sil
	lea	r14, OFFSET FLAT:??_C@_0BP@JFCPEDIH@CVirtualFileRW?3?3CVirtualFileRW?$AA@
	lea	r15, OFFSET FLAT:??_C@_06ODPOMCLF@FS?4cpp?$AA@
	jne	SHORT $LN15@CVirtualFi
	cmp	rax, -1
	jne	SHORT $LN15@CVirtualFi
	call	QWORD PTR __imp_GetLastError
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 434  : 		FormatMessage	(FORMAT_MESSAGE_FROM_SYSTEM,0,code,0,desc_storage,sizeof(desc_storage)-1,0);

	mov	QWORD PTR [rsp+48], rsi
	xor	r9d, r9d
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	mov	r8d, eax
	mov	DWORD PTR [rsp+40], 1023		; 000003ffH
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_FormatMessageA

; 435  : 		result			= desc_storage;
; 436  : 	}
; 437  : 	return		result	;
; 438  : }
; 439  : 
; 440  : void xrDebug::error		(long hr, const char* expr, const char *file, int line, const char *function, bool &ignore_always)
; 441  : {
; 442  : 	backend		(error2string(hr),expr,0,0,file,line,function,ignore_always);
; 443  : }
; 444  : 
; 445  : void xrDebug::error		(long hr, const char* expr, const char* e2, const char *file, int line, const char *function, bool &ignore_always)
; 446  : {
; 447  : 	backend		(error2string(hr),expr,e2,0,file,line,function,ignore_always);
; 448  : }
; 449  : 
; 450  : void xrDebug::fail		(const char *e1, const char *file, int line, const char *function, bool &ignore_always)
; 451  : {
; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);
; 453  : }
; 454  : 
; 455  : void xrDebug::fail		(const char *e1, const std::string &e2, const char *file, int line, const char *function, bool &ignore_always)
; 456  : {
; 457  : 	backend		(e1,e2.c_str(),0,0,file,line,function,ignore_always);
; 458  : }
; 459  : 
; 460  : void xrDebug::fail		(const char *e1, const char *e2, const char *file, int line, const char *function, bool &ignore_always)
; 461  : {
; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);
; 463  : }
; 464  : 
; 465  : void xrDebug::fail		(const char *e1, const char *e2, const char *e3, const char *file, int line, const char *function, bool &ignore_always)
; 466  : {
; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_0BP@JJGNJHJF@hSrcFile?$CB?$DNINVALID_HANDLE_VALUE?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR [rsp+48], 424			; 000001a8H
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rsi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN15@CVirtualFi:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 425  : 	Size			= (int)GetFileSize(hSrcFile, NULL);

	mov	rcx, QWORD PTR [rbx+32]
	xor	edx, edx
	call	QWORD PTR __imp_GetFileSize
	mov	DWORD PTR [rbx+20], eax

; 426  : 	R_ASSERT3		(Size,cFileName,Debug.error2string(GetLastError()));

	cmp	BYTE PTR ?ignore_always@?7???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA, sil
	jne	SHORT $LN11@CVirtualFi
	test	eax, eax
	jne	SHORT $LN11@CVirtualFi
	call	QWORD PTR __imp_GetLastError
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 434  : 		FormatMessage	(FORMAT_MESSAGE_FROM_SYSTEM,0,code,0,desc_storage,sizeof(desc_storage)-1,0);

	mov	QWORD PTR [rsp+48], rsi
	xor	r9d, r9d
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	mov	r8d, eax
	mov	DWORD PTR [rsp+40], 1023		; 000003ffH
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_FormatMessageA

; 435  : 		result			= desc_storage;
; 436  : 	}
; 437  : 	return		result	;
; 438  : }
; 439  : 
; 440  : void xrDebug::error		(long hr, const char* expr, const char *file, int line, const char *function, bool &ignore_always)
; 441  : {
; 442  : 	backend		(error2string(hr),expr,0,0,file,line,function,ignore_always);
; 443  : }
; 444  : 
; 445  : void xrDebug::error		(long hr, const char* expr, const char* e2, const char *file, int line, const char *function, bool &ignore_always)
; 446  : {
; 447  : 	backend		(error2string(hr),expr,e2,0,file,line,function,ignore_always);
; 448  : }
; 449  : 
; 450  : void xrDebug::fail		(const char *e1, const char *file, int line, const char *function, bool &ignore_always)
; 451  : {
; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);
; 453  : }
; 454  : 
; 455  : void xrDebug::fail		(const char *e1, const std::string &e2, const char *file, int line, const char *function, bool &ignore_always)
; 456  : {
; 457  : 	backend		(e1,e2.c_str(),0,0,file,line,function,ignore_always);
; 458  : }
; 459  : 
; 460  : void xrDebug::fail		(const char *e1, const char *e2, const char *file, int line, const char *function, bool &ignore_always)
; 461  : {
; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);
; 463  : }
; 464  : 
; 465  : void xrDebug::fail		(const char *e1, const char *e2, const char *e3, const char *file, int line, const char *function, bool &ignore_always)
; 466  : {
; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?7???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_04EBKMHHBE@Size?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR [rsp+48], 426			; 000001aaH
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rsi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN11@CVirtualFi:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 428  : 	hSrcMap			= CreateFileMapping (hSrcFile, 0, PAGE_READWRITE, 0, 0, 0);

	mov	rcx, QWORD PTR [rbx+32]
	xor	r9d, r9d
	xor	edx, edx
	lea	r8d, QWORD PTR [r9+4]
	mov	QWORD PTR [rsp+40], rsi
	mov	DWORD PTR [rsp+32], esi
	call	QWORD PTR __imp_CreateFileMappingA
	mov	QWORD PTR [rbx+40], rax

; 429  : 	R_ASSERT3		(hSrcMap!=INVALID_HANDLE_VALUE,cFileName,Debug.error2string(GetLastError()));

	cmp	BYTE PTR ?ignore_always@?M@???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA, sil
	jne	SHORT $LN7@CVirtualFi
	cmp	rax, -1
	jne	SHORT $LN7@CVirtualFi
	call	QWORD PTR __imp_GetLastError
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 434  : 		FormatMessage	(FORMAT_MESSAGE_FROM_SYSTEM,0,code,0,desc_storage,sizeof(desc_storage)-1,0);

	mov	QWORD PTR [rsp+48], rsi
	xor	r9d, r9d
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	mov	r8d, eax
	mov	DWORD PTR [rsp+40], 1023		; 000003ffH
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_FormatMessageA

; 435  : 		result			= desc_storage;
; 436  : 	}
; 437  : 	return		result	;
; 438  : }
; 439  : 
; 440  : void xrDebug::error		(long hr, const char* expr, const char *file, int line, const char *function, bool &ignore_always)
; 441  : {
; 442  : 	backend		(error2string(hr),expr,0,0,file,line,function,ignore_always);
; 443  : }
; 444  : 
; 445  : void xrDebug::error		(long hr, const char* expr, const char* e2, const char *file, int line, const char *function, bool &ignore_always)
; 446  : {
; 447  : 	backend		(error2string(hr),expr,e2,0,file,line,function,ignore_always);
; 448  : }
; 449  : 
; 450  : void xrDebug::fail		(const char *e1, const char *file, int line, const char *function, bool &ignore_always)
; 451  : {
; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);
; 453  : }
; 454  : 
; 455  : void xrDebug::fail		(const char *e1, const std::string &e2, const char *file, int line, const char *function, bool &ignore_always)
; 456  : {
; 457  : 	backend		(e1,e2.c_str(),0,0,file,line,function,ignore_always);
; 458  : }
; 459  : 
; 460  : void xrDebug::fail		(const char *e1, const char *e2, const char *file, int line, const char *function, bool &ignore_always)
; 461  : {
; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);
; 463  : }
; 464  : 
; 465  : void xrDebug::fail		(const char *e1, const char *e2, const char *e3, const char *file, int line, const char *function, bool &ignore_always)
; 466  : {
; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?M@???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_0BO@DODFDMMA@hSrcMap?$CB?$DNINVALID_HANDLE_VALUE?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR [rsp+48], 429			; 000001adH
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rsi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN7@CVirtualFi:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 431  : 	data			= (char*)MapViewOfFile (hSrcMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);

	mov	rcx, QWORD PTR [rbx+40]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	edx, 983071				; 000f001fH
	mov	QWORD PTR [rsp+32], rsi
	call	QWORD PTR __imp_MapViewOfFile
	mov	QWORD PTR [rbx+8], rax

; 432  : 	R_ASSERT3		(data,cFileName,Debug.error2string(GetLastError()));

	cmp	BYTE PTR ?ignore_always@?BA@???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA, sil
	jne	SHORT $LN43@CVirtualFi
	test	rax, rax
	jne	SHORT $LN43@CVirtualFi
	call	QWORD PTR __imp_GetLastError
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 434  : 		FormatMessage	(FORMAT_MESSAGE_FROM_SYSTEM,0,code,0,desc_storage,sizeof(desc_storage)-1,0);

	mov	QWORD PTR [rsp+48], rsi
	xor	r9d, r9d
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	mov	r8d, eax
	mov	DWORD PTR [rsp+40], 1023		; 000003ffH
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_FormatMessageA

; 435  : 		result			= desc_storage;
; 436  : 	}
; 437  : 	return		result	;
; 438  : }
; 439  : 
; 440  : void xrDebug::error		(long hr, const char* expr, const char *file, int line, const char *function, bool &ignore_always)
; 441  : {
; 442  : 	backend		(error2string(hr),expr,0,0,file,line,function,ignore_always);
; 443  : }
; 444  : 
; 445  : void xrDebug::error		(long hr, const char* expr, const char* e2, const char *file, int line, const char *function, bool &ignore_always)
; 446  : {
; 447  : 	backend		(error2string(hr),expr,e2,0,file,line,function,ignore_always);
; 448  : }
; 449  : 
; 450  : void xrDebug::fail		(const char *e1, const char *file, int line, const char *function, bool &ignore_always)
; 451  : {
; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);
; 453  : }
; 454  : 
; 455  : void xrDebug::fail		(const char *e1, const std::string &e2, const char *file, int line, const char *function, bool &ignore_always)
; 456  : {
; 457  : 	backend		(e1,e2.c_str(),0,0,file,line,function,ignore_always);
; 458  : }
; 459  : 
; 460  : void xrDebug::fail		(const char *e1, const char *e2, const char *file, int line, const char *function, bool &ignore_always)
; 461  : {
; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);
; 463  : }
; 464  : 
; 465  : void xrDebug::fail		(const char *e1, const char *e2, const char *e3, const char *file, int line, const char *function, bool &ignore_always)
; 466  : {
; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?BA@???0CVirtualFileRW@@QEAA@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_04PJOLNDGD@data?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR [rsp+48], 432			; 000001b0H
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rsi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN43@CVirtualFi:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 437  : }

	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
??0CVirtualFileRW@@QEAA@PEBD@Z ENDP			; CVirtualFileRW::CVirtualFileRW
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 112
cFileName$ = 120
??0CVirtualFileReader@@QEAA@PEBD@Z PROC			; CVirtualFileReader::CVirtualFileReader

; 451  : {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 239  : 		Pos			= 0;

	xor	esi, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 451  : {

	mov	rdi, rdx
	lea	rax, OFFSET FLAT:??_7CVirtualFileReader@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 239  : 		Pos			= 0;

	mov	DWORD PTR [rcx+16], esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 453  : 	hSrcFile		= CreateFile(cFileName, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);

	mov	QWORD PTR [rsp+48], rsi
	lea	r8d, QWORD PTR [rsi+3]
	mov	rcx, rdi
	xor	r9d, r9d
	mov	edx, -2147483648			; 80000000H
	mov	DWORD PTR [rsp+40], esi
	mov	DWORD PTR [rsp+32], 3
	call	QWORD PTR __imp_CreateFileA

; 454  : 	R_ASSERT3		(hSrcFile!=INVALID_HANDLE_VALUE,cFileName,Debug.error2string(GetLastError()));

	lea	rbp, OFFSET FLAT:?desc_storage@?1??error2string@xrDebug@@QEAAPEBDJ@Z@4PADA
	mov	QWORD PTR [rbx+32], rax
	cmp	BYTE PTR ?ignore_always@?3???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA, sil
	lea	r14, OFFSET FLAT:??_C@_0CH@JKOJKKOC@CVirtualFileReader?3?3CVirtualFile@
	lea	r15, OFFSET FLAT:??_C@_06ODPOMCLF@FS?4cpp?$AA@
	jne	SHORT $LN15@CVirtualFi
	cmp	rax, -1
	jne	SHORT $LN15@CVirtualFi
	call	QWORD PTR __imp_GetLastError
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 434  : 		FormatMessage	(FORMAT_MESSAGE_FROM_SYSTEM,0,code,0,desc_storage,sizeof(desc_storage)-1,0);

	mov	QWORD PTR [rsp+48], rsi
	xor	r9d, r9d
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	mov	r8d, eax
	mov	DWORD PTR [rsp+40], 1023		; 000003ffH
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_FormatMessageA

; 435  : 		result			= desc_storage;
; 436  : 	}
; 437  : 	return		result	;
; 438  : }
; 439  : 
; 440  : void xrDebug::error		(long hr, const char* expr, const char *file, int line, const char *function, bool &ignore_always)
; 441  : {
; 442  : 	backend		(error2string(hr),expr,0,0,file,line,function,ignore_always);
; 443  : }
; 444  : 
; 445  : void xrDebug::error		(long hr, const char* expr, const char* e2, const char *file, int line, const char *function, bool &ignore_always)
; 446  : {
; 447  : 	backend		(error2string(hr),expr,e2,0,file,line,function,ignore_always);
; 448  : }
; 449  : 
; 450  : void xrDebug::fail		(const char *e1, const char *file, int line, const char *function, bool &ignore_always)
; 451  : {
; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);
; 453  : }
; 454  : 
; 455  : void xrDebug::fail		(const char *e1, const std::string &e2, const char *file, int line, const char *function, bool &ignore_always)
; 456  : {
; 457  : 	backend		(e1,e2.c_str(),0,0,file,line,function,ignore_always);
; 458  : }
; 459  : 
; 460  : void xrDebug::fail		(const char *e1, const char *e2, const char *file, int line, const char *function, bool &ignore_always)
; 461  : {
; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);
; 463  : }
; 464  : 
; 465  : void xrDebug::fail		(const char *e1, const char *e2, const char *e3, const char *file, int line, const char *function, bool &ignore_always)
; 466  : {
; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_0BP@JJGNJHJF@hSrcFile?$CB?$DNINVALID_HANDLE_VALUE?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR [rsp+48], 454			; 000001c6H
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rsi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN15@CVirtualFi:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 455  : 	Size			= (int)GetFileSize(hSrcFile, NULL);

	mov	rcx, QWORD PTR [rbx+32]
	xor	edx, edx
	call	QWORD PTR __imp_GetFileSize
	mov	DWORD PTR [rbx+20], eax

; 456  : 	R_ASSERT3		(Size,cFileName,Debug.error2string(GetLastError()));

	cmp	BYTE PTR ?ignore_always@?7???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA, sil
	jne	SHORT $LN11@CVirtualFi
	test	eax, eax
	jne	SHORT $LN11@CVirtualFi
	call	QWORD PTR __imp_GetLastError
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 434  : 		FormatMessage	(FORMAT_MESSAGE_FROM_SYSTEM,0,code,0,desc_storage,sizeof(desc_storage)-1,0);

	mov	QWORD PTR [rsp+48], rsi
	xor	r9d, r9d
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	mov	r8d, eax
	mov	DWORD PTR [rsp+40], 1023		; 000003ffH
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_FormatMessageA

; 435  : 		result			= desc_storage;
; 436  : 	}
; 437  : 	return		result	;
; 438  : }
; 439  : 
; 440  : void xrDebug::error		(long hr, const char* expr, const char *file, int line, const char *function, bool &ignore_always)
; 441  : {
; 442  : 	backend		(error2string(hr),expr,0,0,file,line,function,ignore_always);
; 443  : }
; 444  : 
; 445  : void xrDebug::error		(long hr, const char* expr, const char* e2, const char *file, int line, const char *function, bool &ignore_always)
; 446  : {
; 447  : 	backend		(error2string(hr),expr,e2,0,file,line,function,ignore_always);
; 448  : }
; 449  : 
; 450  : void xrDebug::fail		(const char *e1, const char *file, int line, const char *function, bool &ignore_always)
; 451  : {
; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);
; 453  : }
; 454  : 
; 455  : void xrDebug::fail		(const char *e1, const std::string &e2, const char *file, int line, const char *function, bool &ignore_always)
; 456  : {
; 457  : 	backend		(e1,e2.c_str(),0,0,file,line,function,ignore_always);
; 458  : }
; 459  : 
; 460  : void xrDebug::fail		(const char *e1, const char *e2, const char *file, int line, const char *function, bool &ignore_always)
; 461  : {
; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);
; 463  : }
; 464  : 
; 465  : void xrDebug::fail		(const char *e1, const char *e2, const char *e3, const char *file, int line, const char *function, bool &ignore_always)
; 466  : {
; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?7???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_04EBKMHHBE@Size?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR [rsp+48], 456			; 000001c8H
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rsi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN11@CVirtualFi:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 458  : 	hSrcMap			= CreateFileMapping (hSrcFile, 0, PAGE_READONLY, 0, 0, 0);

	mov	rcx, QWORD PTR [rbx+32]
	xor	r9d, r9d
	xor	edx, edx
	lea	r8d, QWORD PTR [r9+2]
	mov	QWORD PTR [rsp+40], rsi
	mov	DWORD PTR [rsp+32], esi
	call	QWORD PTR __imp_CreateFileMappingA
	mov	QWORD PTR [rbx+40], rax

; 459  : 	R_ASSERT3		(hSrcMap!=INVALID_HANDLE_VALUE,cFileName,Debug.error2string(GetLastError()));

	cmp	BYTE PTR ?ignore_always@?M@???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA, sil
	jne	SHORT $LN7@CVirtualFi
	cmp	rax, -1
	jne	SHORT $LN7@CVirtualFi
	call	QWORD PTR __imp_GetLastError
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 434  : 		FormatMessage	(FORMAT_MESSAGE_FROM_SYSTEM,0,code,0,desc_storage,sizeof(desc_storage)-1,0);

	mov	QWORD PTR [rsp+48], rsi
	xor	r9d, r9d
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	mov	r8d, eax
	mov	DWORD PTR [rsp+40], 1023		; 000003ffH
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_FormatMessageA

; 435  : 		result			= desc_storage;
; 436  : 	}
; 437  : 	return		result	;
; 438  : }
; 439  : 
; 440  : void xrDebug::error		(long hr, const char* expr, const char *file, int line, const char *function, bool &ignore_always)
; 441  : {
; 442  : 	backend		(error2string(hr),expr,0,0,file,line,function,ignore_always);
; 443  : }
; 444  : 
; 445  : void xrDebug::error		(long hr, const char* expr, const char* e2, const char *file, int line, const char *function, bool &ignore_always)
; 446  : {
; 447  : 	backend		(error2string(hr),expr,e2,0,file,line,function,ignore_always);
; 448  : }
; 449  : 
; 450  : void xrDebug::fail		(const char *e1, const char *file, int line, const char *function, bool &ignore_always)
; 451  : {
; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);
; 453  : }
; 454  : 
; 455  : void xrDebug::fail		(const char *e1, const std::string &e2, const char *file, int line, const char *function, bool &ignore_always)
; 456  : {
; 457  : 	backend		(e1,e2.c_str(),0,0,file,line,function,ignore_always);
; 458  : }
; 459  : 
; 460  : void xrDebug::fail		(const char *e1, const char *e2, const char *file, int line, const char *function, bool &ignore_always)
; 461  : {
; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);
; 463  : }
; 464  : 
; 465  : void xrDebug::fail		(const char *e1, const char *e2, const char *e3, const char *file, int line, const char *function, bool &ignore_always)
; 466  : {
; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?M@???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_0BO@DODFDMMA@hSrcMap?$CB?$DNINVALID_HANDLE_VALUE?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR [rsp+48], 459			; 000001cbH
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rsi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN7@CVirtualFi:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 461  : 	data			= (char*)MapViewOfFile (hSrcMap, FILE_MAP_READ, 0, 0, 0);

	mov	rcx, QWORD PTR [rbx+40]
	xor	r9d, r9d
	xor	r8d, r8d
	lea	edx, QWORD PTR [r9+4]
	mov	QWORD PTR [rsp+32], rsi
	call	QWORD PTR __imp_MapViewOfFile
	mov	QWORD PTR [rbx+8], rax

; 462  : 	R_ASSERT3		(data,cFileName,Debug.error2string(GetLastError()));

	cmp	BYTE PTR ?ignore_always@?BA@???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA, sil
	jne	SHORT $LN43@CVirtualFi
	test	rax, rax
	jne	SHORT $LN43@CVirtualFi
	call	QWORD PTR __imp_GetLastError
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 434  : 		FormatMessage	(FORMAT_MESSAGE_FROM_SYSTEM,0,code,0,desc_storage,sizeof(desc_storage)-1,0);

	mov	QWORD PTR [rsp+48], rsi
	xor	r9d, r9d
	xor	edx, edx
	mov	ecx, 4096				; 00001000H
	mov	r8d, eax
	mov	DWORD PTR [rsp+40], 1023		; 000003ffH
	mov	QWORD PTR [rsp+32], rbp
	call	QWORD PTR __imp_FormatMessageA

; 435  : 		result			= desc_storage;
; 436  : 	}
; 437  : 	return		result	;
; 438  : }
; 439  : 
; 440  : void xrDebug::error		(long hr, const char* expr, const char *file, int line, const char *function, bool &ignore_always)
; 441  : {
; 442  : 	backend		(error2string(hr),expr,0,0,file,line,function,ignore_always);
; 443  : }
; 444  : 
; 445  : void xrDebug::error		(long hr, const char* expr, const char* e2, const char *file, int line, const char *function, bool &ignore_always)
; 446  : {
; 447  : 	backend		(error2string(hr),expr,e2,0,file,line,function,ignore_always);
; 448  : }
; 449  : 
; 450  : void xrDebug::fail		(const char *e1, const char *file, int line, const char *function, bool &ignore_always)
; 451  : {
; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);
; 453  : }
; 454  : 
; 455  : void xrDebug::fail		(const char *e1, const std::string &e2, const char *file, int line, const char *function, bool &ignore_always)
; 456  : {
; 457  : 	backend		(e1,e2.c_str(),0,0,file,line,function,ignore_always);
; 458  : }
; 459  : 
; 460  : void xrDebug::fail		(const char *e1, const char *e2, const char *file, int line, const char *function, bool &ignore_always)
; 461  : {
; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);
; 463  : }
; 464  : 
; 465  : void xrDebug::fail		(const char *e1, const char *e2, const char *e3, const char *file, int line, const char *function, bool &ignore_always)
; 466  : {
; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?BA@???0CVirtualFileReader@@QEAA@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_04PJOLNDGD@data?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], r14
	mov	DWORD PTR [rsp+48], 462			; 000001ceH
	mov	r9, rbp
	mov	r8, rdi
	mov	QWORD PTR [rsp+40], r15
	mov	QWORD PTR [rsp+32], rsi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN43@CVirtualFi:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 467  : }

	mov	rbp, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+112]
	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	rdi
	ret	0
??0CVirtualFileReader@@QEAA@PEBD@Z ENDP			; CVirtualFileReader::CVirtualFileReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
;	COMDAT ??_GCVirtualFileReader@@UEAAPEAXI@Z
_TEXT	SEGMENT
p$ = 48
this$ = 48
__flags$ = 56
??_GCVirtualFileReader@@UEAAPEAXI@Z PROC		; CVirtualFileReader::`scalar deleting destructor', COMDAT
$LN14:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 470  : {

	lea	rax, OFFSET FLAT:??_7CVirtualFileReader@@6B@
	mov	rdi, rcx
	mov	ebx, edx
	mov	QWORD PTR [rcx], rax

; 471  : #ifdef DEBUG
; 472  : 	unregister_file_mapping	(data,Size);
; 473  : #endif // DEBUG
; 474  : 
; 475  : 	UnmapViewOfFile ((void*)data);

	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR __imp_UnmapViewOfFile

; 476  : 	CloseHandle		(hSrcMap);

	mov	rcx, QWORD PTR [rdi+40]
	call	QWORD PTR __imp_CloseHandle

; 477  : 	CloseHandle		(hSrcFile);

	mov	rcx, QWORD PTR [rdi+32]
	call	QWORD PTR __imp_CloseHandle
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rdi], rax
	test	bl, 1
	je	SHORT $LN12@scalar
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
	mov	QWORD PTR p$[rsp], rdi
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN12@scalar:
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_GCVirtualFileReader@@UEAAPEAXI@Z ENDP		; CVirtualFileReader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
_TEXT	SEGMENT
this$ = 48
??1CVirtualFileReader@@UEAA@XZ PROC			; CVirtualFileReader::~CVirtualFileReader

; 470  : {

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7CVirtualFileReader@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 471  : #ifdef DEBUG
; 472  : 	unregister_file_mapping	(data,Size);
; 473  : #endif // DEBUG
; 474  : 
; 475  : 	UnmapViewOfFile ((void*)data);

	mov	rcx, QWORD PTR [rcx+8]
	call	QWORD PTR __imp_UnmapViewOfFile

; 476  : 	CloseHandle		(hSrcMap);

	mov	rcx, QWORD PTR [rbx+40]
	call	QWORD PTR __imp_CloseHandle

; 477  : 	CloseHandle		(hSrcFile);

	mov	rcx, QWORD PTR [rbx+32]
	call	QWORD PTR __imp_CloseHandle
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 135  : 	virtual			~IReaderBase()				{}

	lea	rax, OFFSET FLAT:??_7?$IReaderBase@VIReader@@@@6B@
	mov	QWORD PTR [rbx], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 478  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1CVirtualFileReader@@UEAA@XZ ENDP			; CVirtualFileReader::~CVirtualFileReader
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?div@?$_vector3@M@@QEAAAEAU1@AEBU1@M@Z
_TEXT	SEGMENT
this$ = 8
a$ = 16
s$ = 24
?div@?$_vector3@M@@QEAAAEAU1@AEBU1@M@Z PROC		; _vector3<float>::div, COMDAT

; 47   : 	ICF SelfRef	div(const Self &a, T s)					{ x=a.x/s;  y=a.y/s;	z=a.z/s;		return *this;	};

	movss	xmm3, DWORD PTR __real@3f800000
	mov	rax, rcx
	divss	xmm3, xmm2
	movaps	xmm0, xmm3
	movaps	xmm1, xmm3
	mulss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx], xmm0
	mulss	xmm1, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+4], xmm1
	mulss	xmm3, DWORD PTR [rdx+8]
	movss	DWORD PTR [rcx+8], xmm3
	ret	0
?div@?$_vector3@M@@QEAAAEAU1@AEBU1@M@Z ENDP		; _vector3<float>::div
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h
;	COMDAT ?magnitude@?$_vector3@M@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?magnitude@?$_vector3@M@@QEBAMXZ PROC			; _vector3<float>::magnitude, COMDAT

; 167  : 		return x*x + y*y + z*z;

	movss	xmm0, DWORD PTR [rcx+4]
	movss	xmm2, DWORD PTR [rcx]
	movss	xmm1, DWORD PTR [rcx+8]
	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	addss	xmm2, xmm0
	addss	xmm2, xmm1
	xorps	xmm0, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 99   : IC float	_sqrt	(float x)		{ return sqrtf(x); }

	sqrtss	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_vector3d.h

; 173  : 	}

	ret	0
?magnitude@?$_vector3@M@@QEBAMXZ ENDP			; _vector3<float>::magnitude
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?top@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 8
?top@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAAEAIXZ PROC ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::top, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, 4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 184  : 	value_type&			top				()									{return (c.back()); }

	ret	0
?top@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAAEAIXZ ENDP ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::top
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?push@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAXAEBI@Z
_TEXT	SEGMENT
this$ = 8
_X$ = 16
?push@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAXAEBI@Z PROC ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::push, COMDAT

; 186  : 	void				push			(const value_type& _X)				{c.push_back(_X); }

	jmp	?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z ; std::vector<unsigned int,xalloc<unsigned int> >::push_back
?push@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAXAEBI@Z ENDP ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::push
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?pop@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAXXZ PROC ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::pop, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1282 : 		--this->_Mylast;

	add	QWORD PTR [rcx+8], -4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 187  : 	void				pop				()									{c.pop_back(); }

	ret	0
?pop@?$xr_stack@IV?$xr_vector@IV?$xalloc@I@@@@@@QEAAXXZ ENDP ; xr_stack<unsigned int,xr_vector<unsigned int,xalloc<unsigned int> > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?back@?$vector@IV?$xalloc@I@@@std@@QEAAAEAIXZ
_TEXT	SEGMENT
this$ = 8
?back@?$vector@IV?$xalloc@I@@@std@@QEAAAEAIXZ PROC	; std::vector<unsigned int,xalloc<unsigned int> >::back, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, 4

; 1234 : 		return (*(end() - 1));
; 1235 : 		}

	ret	0
?back@?$vector@IV?$xalloc@I@@@std@@QEAAAEAIXZ ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::push_back, COMDAT

; 1243 : 		{	// insert element at end

$LN69:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	mov	rax, QWORD PTR [rcx+8]

; 1243 : 		{	// insert element at end

	mov	rdi, rdx
	mov	rbx, rcx

; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1576 : 		if (_Capacity < _Count)
; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);
; 1579 : 		}
; 1580 : 
; 1581 : 	bool _Inside(const value_type *_Ptr) const
; 1582 : 		{	// test if _Ptr points inside vector
; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, rax
	jae	SHORT $LN4@push_back
	mov	rcx, QWORD PTR [rcx]
	cmp	rcx, rdx
	ja	SHORT $LN4@push_back

; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

	sub	rdi, rcx
	sar	rdi, 2

; 1247 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN3@push_back

; 1248 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN3@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	SHORT $LN61@push_back
	mov	rax, QWORD PTR [rbx]
	mov	ecx, DWORD PTR [rax+rdi*4]
	mov	DWORD PTR [rdx], ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 4

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@push_back:

; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)

	cmp	rax, QWORD PTR [rbx+16]
	jne	SHORT $LN1@push_back

; 1257 : 				_Reserve(1);

	mov	rcx, rbx
	call	?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	mov	rcx, QWORD PTR [rbx+8]
	test	rcx, rcx
	je	SHORT $LN61@push_back
	mov	eax, DWORD PTR [rdi]
	mov	DWORD PTR [rcx], eax
$LN61@push_back:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1261 : 			++this->_Mylast;

	add	QWORD PTR [rbx+8], 4

; 1262 : 			}
; 1263 : 		}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?push_back@?$vector@IV?$xalloc@I@@@std@@QEAAXAEBI@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?pop_back@?$vector@IV?$xalloc@I@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop_back@?$vector@IV?$xalloc@I@@@std@@QEAAXXZ PROC	; std::vector<unsigned int,xalloc<unsigned int> >::pop_back, COMDAT

; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;

	add	QWORD PTR [rcx+8], -4

; 1283 : 		}

	ret	0
?pop_back@?$vector@IV?$xalloc@I@@@std@@QEAAXXZ ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,xalloc<unsigned int> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@IV?$xalloc@I@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@IV?$xalloc@I@@@std@@IEBA_NPEBI@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@IV?$xalloc@I@@@std@@IEBA_NPEBI@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Inside, COMDAT

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	cmp	rdx, QWORD PTR [rcx+8]
	jae	SHORT $LN3@Inside
	cmp	QWORD PTR [rcx], rdx
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1584 : 		}

	ret	0
$LN3@Inside:

; 1583 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

	xor	al, al

; 1584 : 		}

	ret	0
?_Inside@?$vector@IV?$xalloc@I@@@std@@IEBA_NPEBI@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve, COMDAT

; 1612 : 		{	// ensure room for _Count new elements, grow exponentially

$LN47:
	sub	rsp, 40					; 00000028H

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rdx, QWORD PTR [rcx+16]
	mov	r8, QWORD PTR [rcx+8]
	mov	rax, rdx
	sub	rax, r8
	sar	rax, 2

; 1613 : 		if (_Unused_capacity() < _Count)

	cmp	rax, 1
	jae	SHORT $LN2@Reserve

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r10, QWORD PTR [rcx]

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	r9, 4611686018427387903			; 3fffffffffffffffH

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r8, r10

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	mov	rax, r9

; 1016 : 		}
; 1017 : 
; 1018 : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 1019 : 		{	// micro-optimization for capacity() != size()
; 1020 : 		return (this->_Myend != this->_Mylast);
; 1021 : 		}
; 1022 : 
; 1023 : 	iterator begin() _NOEXCEPT
; 1024 : 		{	// return iterator for beginning of mutable sequence
; 1025 : 		return (iterator(this->_Myfirst, this));
; 1026 : 		}
; 1027 : 
; 1028 : 	const_iterator begin() const _NOEXCEPT
; 1029 : 		{	// return iterator for beginning of nonmutable sequence
; 1030 : 		return (const_iterator(this->_Myfirst, this));
; 1031 : 		}
; 1032 : 
; 1033 : 	iterator end() _NOEXCEPT
; 1034 : 		{	// return iterator for end of mutable sequence
; 1035 : 		return (iterator(this->_Mylast, this));
; 1036 : 		}
; 1037 : 
; 1038 : 	const_iterator end() const _NOEXCEPT
; 1039 : 		{	// return iterator for end of nonmutable sequence
; 1040 : 		return (const_iterator(this->_Mylast, this));
; 1041 : 		}
; 1042 : 
; 1043 : 	iterator _Make_iter(const_iterator _Where) const
; 1044 : 		{	// make iterator from const_iterator
; 1045 : 		return (iterator(_Where._Ptr, this));
; 1046 : 		}
; 1047 : 
; 1048 : 	reverse_iterator rbegin() _NOEXCEPT
; 1049 : 		{	// return iterator for beginning of reversed mutable sequence
; 1050 : 		return (reverse_iterator(end()));
; 1051 : 		}
; 1052 : 
; 1053 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1054 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1055 : 		return (const_reverse_iterator(end()));
; 1056 : 		}
; 1057 : 
; 1058 : 	reverse_iterator rend() _NOEXCEPT
; 1059 : 		{	// return iterator for end of reversed mutable sequence
; 1060 : 		return (reverse_iterator(begin()));
; 1061 : 		}
; 1062 : 
; 1063 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1064 : 		{	// return iterator for end of reversed nonmutable sequence
; 1065 : 		return (const_reverse_iterator(begin()));
; 1066 : 		}
; 1067 : 
; 1068 : 	const_iterator cbegin() const _NOEXCEPT
; 1069 : 		{	// return iterator for beginning of nonmutable sequence
; 1070 : 		return (((const _Myt *)this)->begin());
; 1071 : 		}
; 1072 : 
; 1073 : 	const_iterator cend() const _NOEXCEPT
; 1074 : 		{	// return iterator for end of nonmutable sequence
; 1075 : 		return (((const _Myt *)this)->end());
; 1076 : 		}
; 1077 : 
; 1078 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1079 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1080 : 		return (((const _Myt *)this)->rbegin());
; 1081 : 		}
; 1082 : 
; 1083 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1084 : 		{	// return iterator for end of reversed nonmutable sequence
; 1085 : 		return (((const _Myt *)this)->rend());
; 1086 : 		}
; 1087 : 
; 1088 : 	void shrink_to_fit()
; 1089 : 		{	// reduce capacity
; 1090 : 		if (_Has_unused_capacity())
; 1091 : 			{	// worth shrinking, do it
; 1092 : 			if (empty())
; 1093 : 				_Tidy();
; 1094 : 			else
; 1095 : 				_Reallocate(size());
; 1096 : 			}
; 1097 : 		}
; 1098 : 
; 1099 : 	void resize(size_type _Newsize)
; 1100 : 		{	// determine new length, padding as needed
; 1101 : 		if (_Newsize < size())
; 1102 : 			_Pop_back_n(size() - _Newsize);
; 1103 : 		else if (size() < _Newsize)
; 1104 : 			{	// pad as needed
; 1105 : 			_Alty _Alval(this->_Getal());
; 1106 : 			_Reserve(_Newsize - size());
; 1107 : 			_TRY_BEGIN
; 1108 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1109 : 				_Alval);
; 1110 : 			_CATCH_ALL
; 1111 : 			_Tidy();
; 1112 : 			_RERAISE;
; 1113 : 			_CATCH_END
; 1114 : 			this->_Mylast += _Newsize - size();
; 1115 : 			}
; 1116 : 		}
; 1117 : 
; 1118 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1119 : 		{	// determine new length, padding with _Val elements as needed
; 1120 : 		if (_Newsize < size())
; 1121 : 			_Pop_back_n(size() - _Newsize);
; 1122 : 		else if (size() < _Newsize)
; 1123 : 			{	// pad as needed
; 1124 : 			const value_type *_Ptr = _STD addressof(_Val);
; 1125 : 
; 1126 : 			if (_Inside(_Ptr))
; 1127 : 				{	// padding is inside vector, recompute _Ptr after reserve
; 1128 : 				const difference_type _Idx = _Ptr
; 1129 : 					- _STD addressof(*this->_Myfirst);
; 1130 : 				_Reserve(_Newsize - size());
; 1131 : 				_Ptr = _STD addressof(*this->_Myfirst) + _Idx;
; 1132 : 				}
; 1133 : 			else
; 1134 : 				_Reserve(_Newsize - size());
; 1135 : 
; 1136 : 			_TRY_BEGIN
; 1137 : 			_Ufill(this->_Mylast, _Newsize - size(), _Ptr);
; 1138 : 			_CATCH_ALL
; 1139 : 			_Tidy();
; 1140 : 			_RERAISE;
; 1141 : 			_CATCH_END
; 1142 : 			this->_Mylast += _Newsize - size();
; 1143 : 			}
; 1144 : 		}
; 1145 : 
; 1146 : 	size_type size() const _NOEXCEPT
; 1147 : 		{	// return length of sequence
; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sar	r8, 2

; 1614 : 			{	// need more room, try to get it
; 1615 : 			if (max_size() - size() < _Count)

	sub	rax, r8
	cmp	rax, 1
	jae	SHORT $LN1@Reserve

; 1620 : 
; 1621 : 	void _Tidy()
; 1622 : 		{	// free all storage
; 1623 : 		if (this->_Myfirst != pointer())
; 1624 : 			{	// something to free, destroy and deallocate it
; 1625 : 			this->_Orphan_all();
; 1626 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1627 : 			this->_Getal().deallocate(this->_Myfirst,
; 1628 : 				this->_Myend - this->_Myfirst);
; 1629 : 			this->_Myfirst = pointer();
; 1630 : 			this->_Mylast = pointer();
; 1631 : 			this->_Myend = pointer();
; 1632 : 			}
; 1633 : 		}
; 1634 : 
; 1635 : 	template<class _Iter>
; 1636 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1637 : 		{	// copy initializing [_First, _Last), using allocator
; 1638 : 		_Alty _Alval(this->_Getal());
; 1639 : 		return (_Uninitialized_copy(_First, _Last,
; 1640 : 			_Ptr, _Alval));
; 1641 : 		}
; 1642 : 
; 1643 : 	template<class _Iter>
; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1645 : 		{	// move initializing [_First, _Last), using allocator
; 1646 : 		_Alty _Alval(this->_Getal());
; 1647 : 		return (_Uninitialized_move(_First, _Last,
; 1648 : 			_Ptr, _Alval));
; 1649 : 		}
; 1650 : 
; 1651 : 	iterator _Insert_n(const_iterator _Where,
; 1652 : 		size_type _Count, const value_type& _Val)
; 1653 : 		{	// insert _Count * _Val at _Where
; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)
; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)
; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1670 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff
; 1677 : 			++_Ncopied;
; 1678 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1679 : 				_Newvec);	// copy prefix
; 1680 : 			++_Ncopied;
; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();
; 1693 : 			if (this->_Myfirst != pointer())
; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1696 : 				this->_Getal().deallocate(this->_Myfirst,
; 1697 : 					this->_Myend - this->_Myfirst);
; 1698 : 				}
; 1699 : 
; 1700 : 			this->_Orphan_all();
; 1701 : 			this->_Myend = _Newvec + _Capacity;
; 1702 : 			this->_Mylast = _Newvec + _Count;
; 1703 : 			this->_Myfirst = _Newvec;
; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1706 : 			< _Count)
; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1712 : 
; 1713 : 			_TRY_BEGIN
; 1714 : 			_Ufill(this->_Mylast,
; 1715 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1717 : 			_CATCH_ALL
; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;
; 1721 : 			_CATCH_END
; 1722 : 
; 1723 : 			this->_Mylast += _Count;
; 1724 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1725 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1726 : 				_Tmp);	// insert up to old end
; 1727 : 			}
; 1728 : 		else
; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1731 : 
; 1732 : 			pointer _Oldend = this->_Mylast;
; 1733 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1734 : 				this->_Mylast);	// copy suffix
; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole
; 1739 : 			_STD fill(_VIPTR(_Where),
; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}
; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN1@Reserve:

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rdx, r10

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	inc	r8

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sar	rdx, 2

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rdx
	shr	rax, 1
	sub	r9, rax
	cmp	r9, rdx
	jae	SHORT $LN29@Reserve
	xor	edx, edx

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
$LN29@Reserve:

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	rdx, rax

; 1576 : 		if (_Capacity < _Count)

	cmp	rdx, r8
	cmovb	rdx, r8

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H

; 1616 : 				_Xlen();
; 1617 : 			_Reallocate(_Grow_to(size() + _Count));

	jmp	?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
$LN2@Reserve:

; 1618 : 			}
; 1619 : 		}

	add	rsp, 40					; 00000028H
	ret	0
$LN46@Reserve:
?_Reserve@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@IV?$xalloc@I@@@std@@IEBAXPEAI0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@IV?$xalloc@I@@@std@@IEBAXPEAI0@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@IV?$xalloc@I@@@std@@IEBAXPEAI0@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEAIXZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEAIXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEAIXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$dead$ = 24
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator-, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	sub	rax, 4

; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);

	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 379  : 		}

	ret	0
??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 2

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@IV?$xalloc@I@@@std@@QEBA_KXZ ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@IV?$xalloc@I@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@IV?$xalloc@I@@@std@@IEBA_K_K@Z PROC	; std::vector<unsigned int,xalloc<unsigned int> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 4611686018427387903		; 3fffffffffffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r8, QWORD PTR [rcx]
	sar	r8, 2

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to
	xor	r8d, r8d

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@IV?$xalloc@I@@@std@@IEBA_K_K@Z ENDP	; std::vector<unsigned int,xalloc<unsigned int> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
p$ = 88
p$ = 88
_Ptr$ = 88
_Count$ = 88
?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate, COMDAT

; 1587 : 		{	// move to array of exactly _Count elements

$LN54:
	push	r14
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+80], rbx
	mov	QWORD PTR [rsp+96], rsi
	mov	QWORD PTR [rsp+104], rdi
	mov	r14, rdx
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, edx
	shl	rdx, 2
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	rsi, rax
	mov	QWORD PTR _Ptr$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, rax
	mov	rdx, QWORD PTR [rbx+8]
	mov	rcx, QWORD PTR [rbx]
	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rbx]
	mov	rdi, QWORD PTR [rbx+8]
	sub	rdi, rax
	sar	rdi, 2

; 1588 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1589 : 
; 1590 : 		_TRY_BEGIN
; 1591 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1592 : 		_CATCH_ALL
; 1593 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1594 : 		_RERAISE;
; 1595 : 		_CATCH_END
; 1596 : 
; 1597 : 		size_type _Size = size();
; 1598 : 		if (this->_Myfirst != pointer())

	test	rax, rax
	je	SHORT $LN49@Reallocate
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rsp]
	call	??$xr_free@I@@YAXAEAPEAI@Z		; xr_free<unsigned int>
$LN49@Reallocate:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1606 : 		this->_Myend = _Ptr + _Count;

	lea	rax, QWORD PTR [rsi+r14*4]
	mov	QWORD PTR [rbx+16], rax

; 1607 : 		this->_Mylast = _Ptr + _Size;

	lea	rax, QWORD PTR [rsi+rdi*4]
	mov	QWORD PTR [rbx+8], rax

; 1608 : 		this->_Myfirst = _Ptr;

	mov	QWORD PTR [rbx], rsi

; 1609 : 		}

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+96]
	mov	rdi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	r14
	ret	0
$LN53@Reallocate:
?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
p$ = 88
p$ = 88
_Ptr$ = 88
_Count$ = 88
?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA PROC ; `std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate'::`1'::catch$0

; 1592 : 		_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR _Ptr$[rbp]
	mov	QWORD PTR p$[rbp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rbp]
	call	??$xr_free@I@@YAXAEAPEAI@Z		; xr_free<unsigned int>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1594 : 		_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Reallocate@?$vector@IV?$xalloc@I@@@std@@IEAAX_K@Z@4HA ENDP ; `std::vector<unsigned int,xalloc<unsigned int> >::_Reallocate'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEBIXZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEBIXZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEBAAEBIXZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator-=, COMDAT

; 170  : 		_Ptr += _Off;

	add	QWORD PTR [rcx], -4

; 372  : 		return (*this += -_Off);

	mov	rax, rcx

; 373  : 		}

	ret	0
??Z?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VCTempReader@@PEAEII@@YAPEAVCTempReader@@AEBQEAEAEBI1@Z
_TEXT	SEGMENT
p1$ = 48
p2$ = 56
p3$ = 64
??$xr_new@VCTempReader@@PEAEII@@YAPEAVCTempReader@@AEBQEAEAEBI1@Z PROC ; xr_new<CTempReader,unsigned char * __ptr64,unsigned int,unsigned int>, COMDAT

; 85   : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3) {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	rdi, rdx

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 32					; 00000020H
	mov	rbx, r8
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 87   : 	return new (ptr) T(p1,p2,p3);

	test	rax, rax
	je	SHORT $LN3@xr_new
	mov	r8d, DWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 244  : 		data		= (char *)_data	;

	mov	rcx, QWORD PTR [rsi]

; 245  : 		Size		= _size			;
; 246  : 		Pos			= 0				;

	mov	DWORD PTR [rax+16], 0
	mov	QWORD PTR [rax+8], rcx
	mov	ecx, DWORD PTR [rdi]

; 247  : 		iterpos		= _iterpos		;

	mov	DWORD PTR [rax+24], r8d
	mov	DWORD PTR [rax+20], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs_internal.h

; 77   : 				CTempReader(void *_data, int _size, int _iterpos) : IReader(_data,_size,_iterpos)	{}

	lea	rcx, OFFSET FLAT:??_7CTempReader@@6B@
	mov	QWORD PTR [rax], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 88   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@xr_new:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$xr_new@VCTempReader@@PEAEII@@YAPEAVCTempReader@@AEBQEAEAEBI1@Z ENDP ; xr_new<CTempReader,unsigned char * __ptr64,unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VIReader@@PEAXII@@YAPEAVIReader@@AEBQEAXAEBI1@Z
_TEXT	SEGMENT
p1$ = 48
p2$ = 56
p3$ = 64
??$xr_new@VIReader@@PEAXII@@YAPEAVIReader@@AEBQEAXAEBI1@Z PROC ; xr_new<IReader,void * __ptr64,unsigned int,unsigned int>, COMDAT

; 85   : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3) {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx
	mov	rdi, rdx

; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 32					; 00000020H
	mov	rbx, r8
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 87   : 	return new (ptr) T(p1,p2,p3);

	test	rax, rax
	je	SHORT $LN3@xr_new
	mov	rcx, QWORD PTR [rsi]
	mov	r8d, DWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 242  : 	IC				IReader			(void *_data, int _size, int _iterpos=0)

	lea	rdx, OFFSET FLAT:??_7IReader@@6B@

; 243  : 	{
; 244  : 		data		= (char *)_data	;

	mov	QWORD PTR [rax+8], rcx

; 245  : 		Size		= _size			;

	mov	ecx, DWORD PTR [rdi]
	mov	QWORD PTR [rax], rdx

; 246  : 		Pos			= 0				;

	mov	DWORD PTR [rax+16], 0

; 247  : 		iterpos		= _iterpos		;

	mov	DWORD PTR [rax+24], r8d
	mov	DWORD PTR [rax+20], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 88   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@xr_new:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$xr_new@VIReader@@PEAXII@@YAPEAVIReader@@AEBQEAXAEBI1@Z ENDP ; xr_new<IReader,void * __ptr64,unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z
_TEXT	SEGMENT
ptr$ = 48
??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z PROC	; xr_delete<IReader>, COMDAT

; 150  : {

$LN32:
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 151  : 	if (ptr) 

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN1@xr_delete
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rdi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR [rsi]
	xor	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rdi, QWORD PTR [rax-1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 133  : 		ptr->~T			();

	mov	r8, QWORD PTR [rcx]
	call	QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN8@xr_delete
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN29@xr_delete

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN29@xr_delete
$LN8@xr_delete:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN29@xr_delete:
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 154  : 		ptr = NULL;

	mov	QWORD PTR [rsi], 0
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$xr_delete@VIReader@@@@YAXAEAPEAVIReader@@@Z ENDP	; xr_delete<IReader>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBI@std@@YAPEBIAEBI@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBI@std@@YAPEBIAEBI@Z PROC		; std::addressof<unsigned int const >, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@$$CBI@std@@YAPEBIAEBI@Z ENDP		; std::addressof<unsigned int const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z PROC ; std::vector<unsigned int,xalloc<unsigned int> >::_Umove<unsigned int * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAI@?$vector@IV?$xalloc@I@@@std@@IEAAPEAIPEAI00@Z ENDP ; std::vector<unsigned int,xalloc<unsigned int> >::_Umove<unsigned int * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VIReader@@@@QEAAXAEAPEAVIReader@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$ = 56
??R?$xr_special_free@$00VIReader@@@@QEAAXAEAPEAVIReader@@@Z PROC ; xr_special_free<1,IReader>::operator(), COMDAT

; 131  : 	{

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR [rbx]
	xor	edx, edx
	mov	r8, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rdi, QWORD PTR [rax-1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 133  : 		ptr->~T			();

	call	QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN5@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN26@operator

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 135  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 303  : 	free((void *)ptr);

	rex_jmp	QWORD PTR __imp_free
$LN5@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN26@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 135  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$xr_special_free@$00VIReader@@@@QEAAXAEAPEAVIReader@@@Z ENDP ; xr_special_free<1,IReader>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z PROC ; std::_Uninitialized_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ENDP ; std::_Uninitialized_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z PROC ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAIPEAIU?$_Wrap_alloc@V?$xalloc@I@@@std@@@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@@Z ENDP ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,std::_Wrap_alloc<xalloc<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAI@std@@YAPEAIPEAI@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAI@std@@YAPEAIPEAI@Z PROC		; std::_Val_type<unsigned int * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAI@std@@YAPEAIPEAI@Z ENDP		; std::_Val_type<unsigned int * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>, COMDAT

; 459  : 	{	// move [_First, _Last) to raw _Dest, using _Al, scalar type

$LN4:
	sub	rsp, 56					; 00000038H

; 460  : 	return (_Uninit_move(_First, _Last, _Dest,
; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>

; 462  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r8], eax
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 4
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 4
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAIPEAIV?$xalloc@I@@I@std@@YAPEAIPEAI00AEAU?$_Wrap_alloc@V?$xalloc@I@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<unsigned int * __ptr64,unsigned int * __ptr64,xalloc<unsigned int>,unsigned int>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@II@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI$$QEAI@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@II@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI$$QEAI@Z PROC ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@II@?$_Wrap_alloc@V?$xalloc@I@@@std@@QEAAXPEAI$$QEAI@Z ENDP ; std::_Wrap_alloc<xalloc<unsigned int> >::construct<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@I@std@@YA$$QEAIAEAI@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@I@std@@YA$$QEAIAEAI@Z PROC			; std::forward<unsigned int>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@I@std@@YA$$QEAIAEAI@Z ENDP			; std::forward<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@II@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI$$QEAI@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@II@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI$$QEAI@Z PROC ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR [r8]
	mov	DWORD PTR [rdx], eax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@II@?$allocator_traits@V?$xalloc@I@@@std@@SAXAEAV?$xalloc@I@@PEAI$$QEAI@Z ENDP ; std::allocator_traits<xalloc<unsigned int> >::construct<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@I@@II@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAI$$QEAI@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@I@@II@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAI$$QEAI@Z PROC ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	eax, DWORD PTR [r9]
	mov	DWORD PTR [r8], eax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@I@@II@_Alloc_construct@std@@SAXHAEAV?$xalloc@I@@PEAI$$QEAI@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<unsigned int>,unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	add	QWORD PTR [rcx], -4

; 171  : 		return (*this);

	mov	rax, rcx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	add	QWORD PTR [rcx], -4

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QEAA@PEAIPEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
END
