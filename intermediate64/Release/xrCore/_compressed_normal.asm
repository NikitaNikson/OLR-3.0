; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?_sqrt@@YAMM@Z					; _sqrt
PUBLIC	?negative@@YA_NM@Z				; negative
PUBLIC	?set_positive@@YAXAEAM@Z			; set_positive
PUBLIC	fabsf
PUBLIC	?set_negative@@YAXAEAM@Z			; set_negative
PUBLIC	?pvUVAdjustment@@3PAMA				; pvUVAdjustment
?pvUVAdjustment@@3PAMA DD 02000H DUP (?)		; pvUVAdjustment
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ?_sqrt@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?_sqrt@@YAMM@Z PROC					; _sqrt, COMDAT

; 99   : IC float	_sqrt	(float x)		{ return sqrtf(x); }

	sqrtss	xmm0, xmm0
	ret	0
?_sqrt@@YAMM@Z ENDP					; _sqrt
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?negative@@YA_NM@Z
_TEXT	SEGMENT
f$ = 8
?negative@@YA_NM@Z PROC					; negative, COMDAT

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	comiss	xmm0, DWORD PTR __real@00000000
	jae	SHORT $LN3@negative
	mov	al, 1
	ret	0
$LN3@negative:
	xor	al, al
	ret	0
?negative@@YA_NM@Z ENDP					; negative
_TEXT	ENDS
PUBLIC	__mask@@AbsFloat@
;	COMDAT __mask@@AbsFloat@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__mask@@AbsFloat@ DB 0ffH, 0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 07fH, 0ffH, 0ffH, 0ffH, 07fH
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 8
fabsf	PROC						; COMDAT

; 395  :         {return ((float)fabs((double)_X)); }

	andps	xmm0, DWORD PTR __mask@@AbsFloat@
	ret	0
fabsf	ENDP
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
_TEXT	ENDS
;	COMDAT ?set_negative@@YAXAEAM@Z
_TEXT	SEGMENT
f$ = 8
?set_negative@@YAXAEAM@Z PROC				; set_negative, COMDAT

; 22   : 	IC void set_negative(float &f)		{ f = -fabsf(f); }

	movss	xmm0, DWORD PTR [rcx]
	andps	xmm0, DWORD PTR __mask@@AbsFloat@
	xorps	xmm0, DWORD PTR __mask@@NegFloat@
	movss	DWORD PTR [rcx], xmm0
	ret	0
?set_negative@@YAXAEAM@Z ENDP				; set_negative
_TEXT	ENDS
PUBLIC	?pvDecompress@@YAXAEAU?$_vector3@M@@G@Z		; pvDecompress
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
_TEXT	SEGMENT
vec$ = 8
mVec$ = 16
?pvDecompress@@YAXAEAU?$_vector3@M@@G@Z PROC		; pvDecompress

; 94   : 	// if we do a straightforward backward transform
; 95   : 	// we will get points on the plane X0,Y0,Z0
; 96   : 	// however we need points on a sphere that goes through these points.
; 97   : 	// therefore we need to adjust x,y,z so that x^2+y^2+z^2=1
; 98   : 	
; 99   : 	// by normalizing the vector3. We have already precalculated the amount
; 100  : 	// by which we need to scale, so all we do is a table lookup and a 
; 101  : 	// multiplication
; 102  : 	
; 103  : 	// get the x and y bits
; 104  : 	int xbits = (( mVec & pvTOP_MASK ) >> 7 );

	movzx	r10d, dx
	mov	r9, rcx
	mov	r8d, r10d

; 105  : 	int ybits = ( mVec & pvBOTTOM_MASK );

	and	r10d, 127				; 0000007fH
	shr	r8d, 7
	and	r8d, 63					; 0000003fH

; 106  : 	
; 107  : 	// map the numbers back to the triangle (0,0)-(0,126)-(126,0)
; 108  : 	if (( xbits + ybits ) >= 127 ) 

	lea	eax, DWORD PTR [r10+r8]
	cmp	eax, 127				; 0000007fH
	jl	SHORT $LN4@pvDecompre

; 109  : 	{ 
; 110  : 		xbits = 127 - xbits; 

	mov	ecx, 127				; 0000007fH
	mov	eax, ecx
	sub	eax, r8d

; 111  : 		ybits = 127 - ybits; 

	sub	ecx, r10d
	mov	r10d, ecx
	mov	r8d, eax
$LN4@pvDecompre:

; 112  : 	}
; 113  : 	
; 114  : 	// do the inverse transform and normalization
; 115  : 	// costs 3 extra multiplies and 2 subtracts. No big deal.         
; 116  : 	float uvadj = pvUVAdjustment[mVec & ~pvSIGN_MASK];
; 117  : 	vec.x = uvadj * float(xbits);
; 118  : 	vec.y = uvadj * float(ybits);

	movd	xmm0, r10d
	movzx	eax, dx
	lea	rcx, OFFSET FLAT:?pvUVAdjustment@@3PAMA	; pvUVAdjustment
	and	rax, -57345				; ffffffffffff1fffH
	movd	xmm2, r8d
	movss	xmm1, DWORD PTR [rcx+rax*4]

; 119  : 	vec.z = uvadj * float( 126 - xbits - ybits );

	mov	eax, 126				; 0000007eH
	cvtdq2ps xmm0, xmm0
	sub	eax, r10d
	sub	eax, r8d
	mulss	xmm0, xmm1
	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR [r9+4], xmm0
	movd	xmm0, eax
	mulss	xmm2, xmm1

; 120  : 	
; 121  : 	// set all the sign bits
; 122  : 	if ( mVec & pvXSIGN_MASK ) set_negative(vec.x);

	mov	eax, 32768				; 00008000H
	movss	DWORD PTR [r9], xmm2
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	DWORD PTR [r9+8], xmm0
	movss	xmm1, DWORD PTR __mask@@NegFloat@
	movss	xmm3, DWORD PTR __mask@@AbsFloat@
	test	dx, ax
	je	SHORT $LN7@pvDecompre
	andps	xmm2, xmm3
	xorps	xmm2, xmm1
	movss	DWORD PTR [r9], xmm2
$LN7@pvDecompre:

; 123  : 	if ( mVec & pvYSIGN_MASK ) set_negative(vec.y);

	mov	eax, 16384				; 00004000H
	test	dx, ax
	je	SHORT $LN11@pvDecompre
	movss	xmm0, DWORD PTR [r9+4]
	andps	xmm0, xmm3
	xorps	xmm0, xmm1
	movss	DWORD PTR [r9+4], xmm0
$LN11@pvDecompre:

; 124  : 	if ( mVec & pvZSIGN_MASK ) set_negative(vec.z);

	mov	eax, 8192				; 00002000H
	test	dx, ax
	je	SHORT $LN15@pvDecompre
	movss	xmm0, DWORD PTR [r9+8]
	andps	xmm0, xmm3
	xorps	xmm0, xmm1
	movss	DWORD PTR [r9+8], xmm0
$LN15@pvDecompre:

; 125  : }

	fatret	0
?pvDecompress@@YAXAEAU?$_vector3@M@@G@Z ENDP		; pvDecompress
_TEXT	ENDS
PUBLIC	?pvInitializeStatics@@YAXXZ			; pvInitializeStatics
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
?pvInitializeStatics@@YAXXZ PROC			; pvInitializeStatics

; 21   : 	for ( int idx = 0; idx < 0x2000; idx++ )

	movss	xmm3, DWORD PTR __real@3f800000
	xor	r8d, r8d
	lea	r9, OFFSET FLAT:?pvUVAdjustment@@3PAMA	; pvUVAdjustment
	npad	14
$LL4@pvInitiali@2:

; 22   : 	{
; 23   : 		long xbits = idx >> 7;

	mov	ecx, r8d

; 24   : 		long ybits = idx & pvBOTTOM_MASK;

	mov	edx, r8d
	sar	ecx, 7
	and	edx, 127				; 0000007fH

; 25   : 		
; 26   : 		// map the numbers back to the triangle (0,0)-(0,127)-(127,0)
; 27   : 		if (( xbits + ybits ) >= 127 ) 

	lea	eax, DWORD PTR [rdx+rcx]
	cmp	eax, 127				; 0000007fH
	jl	SHORT $LN1@pvInitiali@2

; 28   : 		{ 
; 29   : 			xbits = 127 - xbits; 

	mov	eax, 127				; 0000007fH
	sub	eax, ecx
	mov	ecx, eax

; 30   : 			ybits = 127 - ybits; 

	mov	eax, 127				; 0000007fH
	sub	eax, edx
	mov	edx, eax
$LN1@pvInitiali@2:

; 31   : 		}
; 32   : 		
; 33   : 		// convert to 3D vectors
; 34   : 		float x = float(xbits);
; 35   : 		float y = float(ybits);
; 36   : 		float z = float(126 - xbits - ybits );

	mov	eax, 126				; 0000007eH
	movd	xmm0, edx
	movd	xmm2, ecx
	sub	eax, edx
	inc	r8d
	add	r9, 4
	sub	eax, ecx
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm2, xmm2
	movd	xmm1, eax

; 37   : 		
; 38   : 		// calculate the amount of normalization required
; 39   : 		pvUVAdjustment[idx] = 1.0f / _sqrt( y*y + z*z + x*x );

	mulss	xmm0, xmm0
	mulss	xmm2, xmm2
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm1
	addss	xmm1, xmm0
	addss	xmm1, xmm2
	sqrtss	xmm0, xmm1
	movaps	xmm1, xmm3
	divss	xmm1, xmm0
	movss	DWORD PTR [r9-4], xmm1
	cmp	r8d, 8192				; 00002000H
	jl	SHORT $LL4@pvInitiali@2

; 40   : 	}
; 41   : }

	fatret	0
?pvInitializeStatics@@YAXXZ ENDP			; pvInitializeStatics
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?set_positive@@YAXAEAM@Z
_TEXT	SEGMENT
f$ = 8
?set_positive@@YAXAEAM@Z PROC				; set_positive, COMDAT

; 23   : 	IC void set_positive(float &f)		{ f = fabsf(f);	}

	movss	xmm0, DWORD PTR [rcx]
	andps	xmm0, DWORD PTR __mask@@AbsFloat@
	movss	DWORD PTR [rcx], xmm0
	ret	0
?set_positive@@YAXAEAM@Z ENDP				; set_positive
_TEXT	ENDS
PUBLIC	__real@42fc0000
PUBLIC	?pvCompress@@YAGAEBU?$_vector3@M@@@Z		; pvCompress
pdata	SEGMENT
$pdata$?pvCompress@@YAGAEBU?$_vector3@M@@@Z DD imagerel $LN38
	DD	imagerel $LN38+371
	DD	imagerel $unwind$?pvCompress@@YAGAEBU?$_vector3@M@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?pvCompress@@YAGAEBU?$_vector3@M@@@Z DD 040a01H
	DD	05340aH
	DD	07006120aH
xdata	ENDS
;	COMDAT __real@42fc0000
CONST	SEGMENT
__real@42fc0000 DD 042fc0000r			; 126
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
CONST	ENDS
_TEXT	SEGMENT
tmp$ = 0
a$178830 = 32
a$178822 = 32
vec$ = 32
?pvCompress@@YAGAEBU?$_vector3@M@@@Z PROC		; pvCompress

; 44   : {

$LN38:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 16

; 45   : 	// save copy
; 46   : 	Fvector tmp		= vec;

	mov	rax, QWORD PTR [rcx]

; 47   : 
; 48   : 	// input vector3 does not have to be unit length
; 49   : 	u16 mVec		= 0;
; 50   : 
; 51   : 	if ( negative(tmp.x) ) { mVec |= pvXSIGN_MASK; set_positive(tmp.x); }

	xorps	xmm0, xmm0
	movss	xmm4, DWORD PTR __mask@@AbsFloat@
	mov	QWORD PTR tmp$[rsp], rax
	mov	eax, DWORD PTR [rcx+8]
	xor	edi, edi
	movss	xmm3, DWORD PTR tmp$[rsp]
	mov	DWORD PTR tmp$[rsp+8], eax
	movzx	ebx, di
	comiss	xmm3, xmm0
	jae	SHORT $LN11@pvCompress
	mov	ebx, 32768				; 00008000H
	andps	xmm3, xmm4
$LN11@pvCompress:

; 52   : 	if ( negative(tmp.y) ) { mVec |= pvYSIGN_MASK; set_positive(tmp.y); }

	movss	xmm2, DWORD PTR tmp$[rsp+4]
	comiss	xmm2, xmm0
	jae	SHORT $LN19@pvCompress
	mov	eax, 16384				; 00004000H
	andps	xmm2, xmm4
	or	bx, ax
$LN19@pvCompress:

; 53   : 	if ( negative(tmp.z) ) { mVec |= pvZSIGN_MASK; set_positive(tmp.z); }

	movss	xmm1, DWORD PTR tmp$[rsp+8]
	comiss	xmm1, xmm0
	jae	SHORT $LN27@pvCompress
	mov	eax, 8192				; 00002000H
	andps	xmm1, xmm4
	or	bx, ax
$LN27@pvCompress:

; 54   : 
; 55   : 	// project the normal onto the plane that goes through
; 56   : 	// X0=(1,0,0),Y0=(0,1,0),Z0=(0,0,1).
; 57   : 
; 58   : 	// on that plane we choose an (projective!) coordinate system
; 59   : 	// such that X0->(0,0), Y0->(126,0), Z0->(0,126),(0,0,0)->Infinity
; 60   : 
; 61   : 	// a little slower... old pack was 4 multiplies and 2 adds. 
; 62   : 	// This is 2 multiplies, 2 adds, and a divide....
; 63   : 	float w = 126.0f / ( tmp.x + tmp.y + tmp.z );

	movaps	xmm0, xmm2

; 64   : 	int		xbits = iFloor( tmp.x * w );

	mov	r10d, 158				; 0000009eH
	mov	r9d, 1
	mov	edx, r10d
	addss	xmm0, xmm3
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@42fc0000
	divss	xmm1, xmm0
	movaps	xmm0, xmm1

; 65   : 	int		ybits = iFloor( tmp.y * w );

	mulss	xmm1, xmm2
	mulss	xmm0, xmm3
	movss	DWORD PTR a$178822[rsp], xmm0
	mov	r8d, DWORD PTR a$178822[rsp]
	movss	DWORD PTR a$178830[rsp], xmm1
	mov	eax, r8d
	mov	r11d, r8d
	sar	eax, 23
	or	r11d, -8388608				; ff800000H
	movzx	ecx, al
	shl	r11d, 8
	mov	eax, r9d
	sub	edx, ecx
	mov	ecx, edx
	shr	r11d, cl
	lea	ecx, DWORD PTR [rdx-96]
	shl	eax, cl
	dec	eax
	sar	eax, 8
	test	eax, r8d
	mov	eax, edi
	sete	al
	sar	r8d, 31
	and	eax, r8d
	sub	r11d, eax
	lea	eax, DWORD PTR [rdx-32]
	mov	edx, DWORD PTR a$178830[rsp]
	sar	eax, 31
	and	r11d, eax
	mov	eax, edx
	xor	r11d, r8d
	sar	eax, 23
	mov	r8d, edx
	or	r8d, -8388608				; ff800000H
	movzx	ecx, al
	shl	r8d, 8
	sub	r10d, ecx
	mov	ecx, r10d
	lea	eax, DWORD PTR [r10-32]
	shr	r8d, cl
	lea	ecx, DWORD PTR [r10-96]
	shl	r9d, cl
	dec	r9d
	sar	r9d, 8
	test	r9d, edx
	sete	dil
	sar	edx, 31
	sar	eax, 31
	and	edi, edx
	sub	r8d, edi
	and	r8d, eax
	xor	r8d, edx

; 66   : 
; 67   : 	/*
; 68   : 	VERIFY( xbits <  127 );
; 69   : 	VERIFY( xbits >= 0   );
; 70   : 	VERIFY( ybits <  127 );
; 71   : 	VERIFY( ybits >= 0   );
; 72   : 	*/
; 73   : 
; 74   : 	// Now we can be sure that 0<=xp<=126, 0<=yp<=126, 0<=xp+yp<=126
; 75   : 
; 76   : 	// however for the sampling we want to transform this triangle 
; 77   : 	// into a rectangle.
; 78   : 	if ( xbits >= 64 ) 

	cmp	r11d, 64				; 00000040H
	jl	SHORT $LN1@pvCompress

; 79   : 	{ 
; 80   : 		xbits = 127 - xbits; 

	mov	edx, 127				; 0000007fH
	mov	ecx, edx
	sub	ecx, r11d

; 81   : 		ybits = 127 - ybits; 

	sub	edx, r8d
	mov	r8d, edx
	mov	r11d, ecx
$LN1@pvCompress:

; 82   : 	}
; 83   : 
; 84   : 	// now we that have xp in the range (0,127) and yp in the range (0,63), 
; 85   : 	// we can pack all the bits together
; 86   : 	mVec |= ( xbits << 7 );           

	shl	r11w, 7

; 87   : 	mVec |= ybits;

	or	r11w, r8w
	or	r11w, bx

; 88   : 
; 89   : 	return mVec;
; 90   : }

	mov	rbx, QWORD PTR [rsp+40]
	movzx	eax, r11w
	add	rsp, 16
	pop	rdi
	ret	0
?pvCompress@@YAGAEBU?$_vector3@M@@@Z ENDP		; pvCompress
END
