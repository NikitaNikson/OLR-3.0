; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?pvUVAdjustment@@3PAMA				; pvUVAdjustment
?pvUVAdjustment@@3PAMA DD 02000H DUP (?)		; pvUVAdjustment
_BSS	ENDS
PUBLIC	?_sqrt@@YAMM@Z					; _sqrt
PUBLIC	?negative@@YA_NM@Z				; negative
PUBLIC	?set_positive@@YAXAEAM@Z			; set_positive
PUBLIC	fabsf
PUBLIC	?set_negative@@YAXAEAM@Z			; set_negative
PUBLIC	?pvInitializeStatics@@YAXXZ			; pvInitializeStatics
PUBLIC	?pvCompress@@YAGAEBU?$_vector3@M@@@Z		; pvCompress
PUBLIC	?pvDecompress@@YAXAEAU?$_vector3@M@@G@Z		; pvDecompress
pdata	SEGMENT
$pdata$?pvCompress@@YAGAEBU?$_vector3@M@@@Z DD imagerel $LN30
	DD	imagerel $LN30+373
	DD	imagerel $unwind$?pvCompress@@YAGAEBU?$_vector3@M@@@Z
xdata	SEGMENT
$unwind$?pvCompress@@YAGAEBU?$_vector3@M@@@Z DD 040a01H
	DD	05340aH
	DD	07006120aH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
_TEXT	SEGMENT
vec$ = 8
mVec$ = 16
?pvDecompress@@YAXAEAU?$_vector3@M@@G@Z PROC		; pvDecompress

; 94   : 	// if we do a straightforward backward transform
; 95   : 	// we will get points on the plane X0,Y0,Z0
; 96   : 	// however we need points on a sphere that goes through these points.
; 97   : 	// therefore we need to adjust x,y,z so that x^2+y^2+z^2=1
; 98   : 	
; 99   : 	// by normalizing the vector3. We have already precalculated the amount
; 100  : 	// by which we need to scale, so all we do is a table lookup and a 
; 101  : 	// multiplication
; 102  : 	
; 103  : 	// get the x and y bits
; 104  : 	int xbits = (( mVec & pvTOP_MASK ) >> 7 );

	movzx	r10d, dx
	mov	r9, rcx
	mov	r8d, r10d

; 105  : 	int ybits = ( mVec & pvBOTTOM_MASK );

	and	r10d, 127				; 0000007fH
	shr	r8d, 7
	and	r8d, 63					; 0000003fH

; 106  : 	
; 107  : 	// map the numbers back to the triangle (0,0)-(0,126)-(126,0)
; 108  : 	if (( xbits + ybits ) >= 127 ) 

	lea	eax, DWORD PTR [r10+r8]
	cmp	eax, 127				; 0000007fH
	jl	SHORT $LN4@pvDecompre

; 109  : 	{ 
; 110  : 		xbits = 127 - xbits; 

	mov	ecx, 127				; 0000007fH
	mov	eax, ecx
	sub	eax, r8d

; 111  : 		ybits = 127 - ybits; 

	sub	ecx, r10d
	mov	r10d, ecx
	mov	r8d, eax
$LN4@pvDecompre:

; 112  : 	}
; 113  : 	
; 114  : 	// do the inverse transform and normalization
; 115  : 	// costs 3 extra multiplies and 2 subtracts. No big deal.         
; 116  : 	float uvadj = pvUVAdjustment[mVec & ~pvSIGN_MASK];
; 117  : 	vec.x = uvadj * float(xbits);
; 118  : 	vec.y = uvadj * float(ybits);
; 119  : 	vec.z = uvadj * float( 126 - xbits - ybits );
; 120  : 	
; 121  : 	// set all the sign bits
; 122  : 	if ( mVec & pvXSIGN_MASK ) set_negative(vec.x);

	movss	xmm3, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movd	xmm0, r10d
	movzx	eax, dx
	and	rax, -57345				; ffffffffffff1fffH
	lea	rcx, OFFSET FLAT:?pvUVAdjustment@@3PAMA	; pvUVAdjustment
	movd	xmm2, r8d
	movss	xmm1, DWORD PTR [rcx+rax*4]
	mov	eax, 126				; 0000007eH
	cvtdq2ps xmm0, xmm0
	sub	eax, r10d
	sub	eax, r8d
	mulss	xmm0, xmm1
	cvtdq2ps xmm2, xmm2
	movss	DWORD PTR [r9+4], xmm0
	movd	xmm0, eax
	mulss	xmm2, xmm1
	mov	eax, 32768				; 00008000H
	movss	DWORD PTR [r9], xmm2
	cvtdq2ps xmm0, xmm0
	mulss	xmm0, xmm1
	movss	xmm1, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [r9+8], xmm0
	test	dx, ax
	je	SHORT $LN7@pvDecompre
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm2, xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 22   : 	IC void set_negative(float &f)		{ f = -fabsf(f); }

	xorps	xmm2, xmm1
	movss	DWORD PTR [r9], xmm2
$LN7@pvDecompre:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 123  : 	if ( mVec & pvYSIGN_MASK ) set_negative(vec.y);

	mov	eax, 16384				; 00004000H
	test	dx, ax
	je	SHORT $LN11@pvDecompre
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [r9+4]
	andps	xmm0, xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 22   : 	IC void set_negative(float &f)		{ f = -fabsf(f); }

	xorps	xmm0, xmm1
	movss	DWORD PTR [r9+4], xmm0
$LN11@pvDecompre:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 124  : 	if ( mVec & pvZSIGN_MASK ) set_negative(vec.z);

	mov	eax, 8192				; 00002000H
	test	dx, ax
	je	SHORT $LN15@pvDecompre
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [r9+8]
	andps	xmm0, xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 22   : 	IC void set_negative(float &f)		{ f = -fabsf(f); }

	xorps	xmm0, xmm1
	movss	DWORD PTR [r9+8], xmm0
$LN15@pvDecompre:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 125  : }

	ret	0
?pvDecompress@@YAXAEAU?$_vector3@M@@G@Z ENDP		; pvDecompress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
_TEXT	SEGMENT
tmp$ = 0
a$1 = 32
a$2 = 32
vec$ = 32
?pvCompress@@YAGAEBU?$_vector3@M@@@Z PROC		; pvCompress

; 44   : {

$LN30:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 16

; 45   : 	// save copy
; 46   : 	Fvector tmp		= vec;

	movsdx	xmm0, QWORD PTR [rcx]
	mov	eax, DWORD PTR [rcx+8]

; 49   : 	u16 mVec		= 0;

	xor	edi, edi
	movsdx	QWORD PTR tmp$[rsp], xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	movss	xmm3, DWORD PTR tmp$[rsp]
	movss	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	xorps	xmm4, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 49   : 	u16 mVec		= 0;

	movzx	ebx, di
	mov	DWORD PTR tmp$[rsp+8], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	comiss	xmm3, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 51   : 	if ( negative(tmp.x) ) { mVec |= pvXSIGN_MASK; set_positive(tmp.x); }

	jae	SHORT $LN9@pvCompress
	mov	ebx, 32768				; 00008000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm3, xmm0
$LN9@pvCompress:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	movss	xmm2, DWORD PTR tmp$[rsp+4]
	comiss	xmm2, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 52   : 	if ( negative(tmp.y) ) { mVec |= pvYSIGN_MASK; set_positive(tmp.y); }

	jae	SHORT $LN15@pvCompress
	mov	eax, 16384				; 00004000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm2, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 52   : 	if ( negative(tmp.y) ) { mVec |= pvYSIGN_MASK; set_positive(tmp.y); }

	or	bx, ax
$LN15@pvCompress:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	movss	xmm1, DWORD PTR tmp$[rsp+8]
	comiss	xmm1, xmm4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 53   : 	if ( negative(tmp.z) ) { mVec |= pvZSIGN_MASK; set_positive(tmp.z); }

	jae	SHORT $LN21@pvCompress
	mov	eax, 8192				; 00002000H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	andps	xmm1, xmm0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 53   : 	if ( negative(tmp.z) ) { mVec |= pvZSIGN_MASK; set_positive(tmp.z); }

	or	bx, ax
$LN21@pvCompress:

; 63   : 	float w = 126.0f / ( tmp.x + tmp.y + tmp.z );

	movaps	xmm0, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r10d, 158				; 0000009eH

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	r9d, 1
	mov	edx, r10d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 63   : 	float w = 126.0f / ( tmp.x + tmp.y + tmp.z );

	addss	xmm0, xmm3
	addss	xmm0, xmm1
	movss	xmm1, DWORD PTR __real@42fc0000
	divss	xmm1, xmm0

; 64   : 	int		xbits = iFloor( tmp.x * w );

	movaps	xmm0, xmm1

; 65   : 	int		ybits = iFloor( tmp.y * w );

	mulss	xmm1, xmm2
	mulss	xmm0, xmm3
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR a$2[rsp], xmm0

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	r8d, DWORD PTR a$2[rsp]

; 83   :     int a			= *(const int*)(&x);

	movss	DWORD PTR a$1[rsp], xmm1

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, r8d

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r11d, r8d
	sar	eax, 23
	or	r11d, -8388608				; ff800000H
	movzx	ecx, al
	shl	r11d, 8

; 86   :     exponent		+= 31-127;
; 87   :     {
; 88   :         int imask	=	(!(((( (1<<(exponent)))-1)>>8)&a));

	mov	eax, r9d
	sub	edx, ecx
	mov	ecx, edx
	shr	r11d, cl
	lea	ecx, DWORD PTR [rdx-96]
	shl	eax, cl
	dec	eax
	sar	eax, 8
	test	eax, r8d
	mov	eax, edi
	sete	al

; 91   :         a			>>=	31;

	sar	r8d, 31

; 92   :         r			-=	(imask&a);

	and	eax, r8d
	sub	r11d, eax
	lea	eax, DWORD PTR [rdx-32]

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	edx, DWORD PTR a$1[rsp]

; 90   :         exponent	>>=	31;

	sar	eax, 31

; 93   :         r			&=	exponent;

	and	r11d, eax

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	mov	eax, edx

; 94   :         r			^=	a;

	xor	r11d, r8d

; 84   :     int exponent	= (127 + 31) - ((a >> 23) & 0xFF);

	sar	eax, 23

; 85   :     int r			= (((u32)(a) << 8) | (1U << 31)) >> exponent;

	mov	r8d, edx
	or	r8d, -8388608				; ff800000H
	movzx	ecx, al
	shl	r8d, 8
	sub	r10d, ecx
	mov	ecx, r10d

; 89   :         exponent	-=	(31-127)+32;

	lea	eax, DWORD PTR [r10-32]
	shr	r8d, cl
	lea	ecx, DWORD PTR [r10-96]
	shl	r9d, cl
	dec	r9d
	sar	r9d, 8
	test	r9d, edx
	sete	dil

; 91   :         a			>>=	31;

	sar	edx, 31
	sar	eax, 31

; 92   :         r			-=	(imask&a);

	and	edi, edx
	sub	r8d, edi

; 93   :         r			&=	exponent;

	and	r8d, eax

; 94   :         r			^=	a;

	xor	r8d, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 78   : 	if ( xbits >= 64 ) 

	cmp	r11d, 64				; 00000040H
	jl	SHORT $LN1@pvCompress

; 79   : 	{ 
; 80   : 		xbits = 127 - xbits; 

	mov	edx, 127				; 0000007fH
	mov	ecx, edx
	sub	ecx, r11d

; 81   : 		ybits = 127 - ybits; 

	sub	edx, r8d
	mov	r8d, edx
	mov	r11d, ecx
$LN1@pvCompress:

; 82   : 	}
; 83   : 
; 84   : 	// now we that have xp in the range (0,127) and yp in the range (0,63), 
; 85   : 	// we can pack all the bits together
; 86   : 	mVec |= ( xbits << 7 );           

	shl	r11w, 7

; 87   : 	mVec |= ybits;

	or	r11w, r8w
	or	r11w, bx

; 88   : 
; 89   : 	return mVec;
; 90   : }

	mov	rbx, QWORD PTR [rsp+40]
	movzx	eax, r11w
	add	rsp, 16
	pop	rdi
	ret	0
?pvCompress@@YAGAEBU?$_vector3@M@@@Z ENDP		; pvCompress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp
_TEXT	SEGMENT
?pvInitializeStatics@@YAXXZ PROC			; pvInitializeStatics

; 21   : 	for ( int idx = 0; idx < 0x2000; idx++ )

	movss	xmm3, DWORD PTR __real@3f800000
	xor	r8d, r8d
	lea	r9, OFFSET FLAT:?pvUVAdjustment@@3PAMA	; pvUVAdjustment
	npad	14
$LL11@pvInitiali:

; 22   : 	{
; 23   : 		long xbits = idx >> 7;

	mov	ecx, r8d

; 24   : 		long ybits = idx & pvBOTTOM_MASK;

	mov	edx, r8d
	sar	ecx, 7
	and	edx, 127				; 0000007fH

; 25   : 		
; 26   : 		// map the numbers back to the triangle (0,0)-(0,127)-(127,0)
; 27   : 		if (( xbits + ybits ) >= 127 ) 

	lea	eax, DWORD PTR [rdx+rcx]
	cmp	eax, 127				; 0000007fH
	jl	SHORT $LN12@pvInitiali

; 28   : 		{ 
; 29   : 			xbits = 127 - xbits; 

	mov	eax, 127				; 0000007fH
	sub	eax, ecx
	mov	ecx, eax

; 30   : 			ybits = 127 - ybits; 

	mov	eax, 127				; 0000007fH
	sub	eax, edx
	mov	edx, eax
$LN12@pvInitiali:

; 31   : 		}
; 32   : 		
; 33   : 		// convert to 3D vectors
; 34   : 		float x = float(xbits);
; 35   : 		float y = float(ybits);
; 36   : 		float z = float(126 - xbits - ybits );

	mov	eax, 126				; 0000007eH
	movd	xmm0, edx
	movd	xmm2, ecx
	sub	eax, edx
	inc	r8d
	add	r9, 4
	sub	eax, ecx
	cvtdq2ps xmm0, xmm0
	cvtdq2ps xmm2, xmm2

; 39   : 		pvUVAdjustment[idx] = 1.0f / _sqrt( y*y + z*z + x*x );

	mulss	xmm0, xmm0
	movd	xmm1, eax
	mulss	xmm2, xmm2
	cvtdq2ps xmm1, xmm1
	mulss	xmm1, xmm1
	addss	xmm1, xmm0
	xorps	xmm0, xmm0
	addss	xmm1, xmm2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 99   : IC float	_sqrt	(float x)		{ return sqrtf(x); }

	sqrtss	xmm0, xmm1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_compressed_normal.cpp

; 39   : 		pvUVAdjustment[idx] = 1.0f / _sqrt( y*y + z*z + x*x );

	movaps	xmm1, xmm3
	divss	xmm1, xmm0
	movss	DWORD PTR [r9-4], xmm1
	cmp	r8d, 8192				; 00002000H
	jl	SHORT $LL11@pvInitiali

; 40   : 	}
; 41   : }

	ret	0
?pvInitializeStatics@@YAXXZ ENDP			; pvInitializeStatics
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?set_negative@@YAXAEAM@Z
_TEXT	SEGMENT
f$ = 8
?set_negative@@YAXAEAM@Z PROC				; set_negative, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rcx]
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 22   : 	IC void set_negative(float &f)		{ f = -fabsf(f); }

	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR [rcx], xmm0
	ret	0
?set_negative@@YAXAEAM@Z ENDP				; set_negative
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
;	COMDAT fabsf
_TEXT	SEGMENT
_X$ = 8
fabsf	PROC						; COMDAT

; 687  :     return (float)fabs(_X);

	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff

; 688  : }

	ret	0
fabsf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?set_positive@@YAXAEAM@Z
_TEXT	SEGMENT
f$ = 8
?set_positive@@YAXAEAM@Z PROC				; set_positive, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\math.h

; 687  :     return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rcx]
	andps	xmm0, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h

; 23   : 	IC void set_positive(float &f)		{ f = fabsf(f);	}

	movss	DWORD PTR [rcx], xmm0
	ret	0
?set_positive@@YAXAEAM@Z ENDP				; set_positive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_bitwise.h
;	COMDAT ?negative@@YA_NM@Z
_TEXT	SEGMENT
f$ = 8
?negative@@YA_NM@Z PROC					; negative, COMDAT

; 20   : 	IC bool negative(const float f)		{ return f<0;	}

	xorps	xmm1, xmm1
	comiss	xmm0, xmm1
	setb	al
	ret	0
?negative@@YA_NM@Z ENDP					; negative
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ?_sqrt@@YAMM@Z
_TEXT	SEGMENT
x$ = 8
?_sqrt@@YAMM@Z PROC					; _sqrt, COMDAT

; 99   : IC float	_sqrt	(float x)		{ return sqrtf(x); }

	sqrtss	xmm0, xmm0
	ret	0
?_sqrt@@YAMM@Z ENDP					; _sqrt
_TEXT	ENDS
END
