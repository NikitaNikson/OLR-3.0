; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?MoveUnitsUp@@YAPEAXPEAXI@Z			; MoveUnitsUp
PUBLIC	?ShrinkUnits@@YAPEAXPEAXII@Z			; ShrinkUnits
PUBLIC	?FreeUnits@@YAXPEAXI@Z				; FreeUnits
PUBLIC	?rcEncNormalize@ppmd@@YAXPEAVstream@1compression@@@Z ; ppmd::rcEncNormalize
PUBLIC	?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z		; PPM_CONTEXT::encodeBinSymbol
PUBLIC	?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z		; PPM_CONTEXT::encodeSymbol1
PUBLIC	?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z		; PPM_CONTEXT::encodeSymbol2
PUBLIC	?put_char@stream@ppmd@compression@@QEAAXAEBE@Z	; compression::ppmd::stream::put_char
PUBLIC	?rcDecNormalize@ppmd@@YAXPEAVstream@1compression@@@Z ; ppmd::rcDecNormalize
PUBLIC	?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ		; PPM_CONTEXT::decodeBinSymbol
PUBLIC	?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z	; PPM_CONTEXT::update1
PUBLIC	?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::decodeSymbol1
PUBLIC	?update@SEE2_CONTEXT@@QEAAXXZ			; SEE2_CONTEXT::update
PUBLIC	?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z	; PPM_CONTEXT::update2
PUBLIC	?PrefetchData@@YAXPEAX@Z			; PrefetchData
PUBLIC	?getMean@SEE2_CONTEXT@@QEAAIXZ			; SEE2_CONTEXT::getMean
PUBLIC	?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ ; PPM_CONTEXT::makeEscFreq2
PUBLIC	?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::decodeSymbol2
PUBLIC	?UnitsCpy@@YAXPEAX0I@Z				; UnitsCpy
PUBLIC	?ExpandUnits@@YAPEAXPEAXI@Z			; ExpandUnits
PUBLIC	?SWAP@@YAXAEAUSTATE@PPM_CONTEXT@@0@Z		; SWAP
PUBLIC	?SpecialFreeUnit@@YAXPEAX@Z			; SpecialFreeUnit
PUBLIC	?get_char@stream@ppmd@compression@@QEAAHXZ	; compression::ppmd::stream::get_char
PUBLIC	?AllocUnits@@YAPEAXI@Z				; AllocUnits
PUBLIC	?init@SEE2_CONTEXT@@QEAAXI@Z			; SEE2_CONTEXT::init
PUBLIC	?StateCpy@@YAXAEAUSTATE@PPM_CONTEXT@@AEBU12@@Z	; StateCpy
PUBLIC	?U2B@@YAII@Z					; U2B
PUBLIC	?SplitBlock@@YAXPEAXII@Z			; SplitBlock
PUBLIC	?avail@BLK_NODE@@QEBAHXZ			; BLK_NODE::avail
PUBLIC	?unlink@BLK_NODE@@QEAAXXZ			; BLK_NODE::unlink
PUBLIC	?remove@BLK_NODE@@QEAAPEAXXZ			; BLK_NODE::remove
PUBLIC	?link@BLK_NODE@@QEAAXPEAU1@@Z			; BLK_NODE::link
PUBLIC	?insert@BLK_NODE@@QEAAXPEAXH@Z			; BLK_NODE::insert
PUBLIC	?AllocContext@@YAPEAXXZ				; AllocContext
PUBLIC	?oneState@PPM_CONTEXT@@QEBAAEAUSTATE@1@XZ	; PPM_CONTEXT::oneState
PUBLIC	?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z	; ClearMask
PUBLIC	??0PPMD_STARTUP@@QEAA@XZ			; PPMD_STARTUP::PPMD_STARTUP
PUBLIC	?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A		; SEE2Cont
PUBLIC	?DummySEE2Cont@@3USEE2_CONTEXT@@A		; DummySEE2Cont
PUBLIC	?MaxContext@@3PEAUPPM_CONTEXT@@EA		; MaxContext
PUBLIC	?BList@@3PAUBLK_NODE@@A				; BList
PUBLIC	?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A DD 0300H DUP (?)	; SEE2Cont
?DummySEE2Cont@@3USEE2_CONTEXT@@A DD 01H DUP (?)	; DummySEE2Cont
?MaxContext@@3PEAUPPM_CONTEXT@@EA DQ 01H DUP (?)	; MaxContext
?BList@@3PAUBLK_NODE@@A DB 01c8H DUP (?)		; BList
SubRange DB	0cH DUP (?)
low	DD	01H DUP (?)
code	DD	01H DUP (?)
range	DD	01H DUP (?)
SubAllocatorSize DD 01H DUP (?)
	ALIGN	8

?trained_model@@3PEAVstream@ppmd@compression@@EA DQ 01H DUP (?) ; trained_model
;	COMDAT ?context@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4PEAUPPM_CONTEXT@@EA
_BSS	SEGMENT
?context@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4PEAUPPM_CONTEXT@@EA DQ 01H DUP (?) ; `StartModelRare'::`2'::context
;	COMDAT ?InitBinEsc@?8??StartModelRare@@YAXHW4MR_METHOD@@@Z@4QBGB
CONST	SEGMENT
?InitBinEsc@?8??StartModelRare@@YAXHW4MR_METHOD@@@Z@4QBGB DW 03cddH ; `StartModelRare'::`9'::InitBinEsc
	DW	01f3fH
	DW	059bfH
	DW	048f3H
	DW	064a1H
	DW	05abcH
	DW	06632H
	DW	06051H
CONST	ENDS
;	COMDAT ?first_time@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4_NA
_DATA	SEGMENT
?first_time@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4_NA DB 01H ; `StartModelRare'::`2'::first_time
ExpEscape DB	019H
	DB	0eH
	DB	09H
	DB	07H
	DB	05H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
QTable	DB	0104H DUP (?)
NS2BSIndx DB	0100H DUP (?)
Units2Indx DB	080H DUP (?)
Indx2Units DB	026H DUP (?)
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
pdata	SEGMENT
$pdata$??0PPMD_STARTUP@@QEAA@XZ DD imagerel $LN39
	DD	imagerel $LN39+336
	DD	imagerel $unwind$??0PPMD_STARTUP@@QEAA@XZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PPMD_STARTUP@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ??0PPMD_STARTUP@@QEAA@XZ
_TEXT	SEGMENT
??0PPMD_STARTUP@@QEAA@XZ PROC				; PPMD_STARTUP::PPMD_STARTUP, COMDAT

; 108  : {

$LN39:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;

	lea	r10, OFFSET FLAT:Indx2Units
	mov	edi, 1
	mov	edx, 4
	mov	rcx, r10
	mov	eax, edi
	mov	r8d, edx
$LL22@PPMD_START:
	mov	BYTE PTR [rcx], al
	inc	rcx
	inc	eax
	dec	r8
	jne	SHORT $LL22@PPMD_START

; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+4
	mov	r8, rdx
	npad	5
$LL19@PPMD_START:
	mov	BYTE PTR [rcx], al
	inc	rcx
	add	eax, 2
	dec	r8
	jne	SHORT $LL19@PPMD_START

; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+8
	npad	10
$LL16@PPMD_START:
	mov	BYTE PTR [rcx], al
	inc	rcx
	add	eax, 3
	dec	rdx
	jne	SHORT $LL16@PPMD_START

; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+12
	mov	edx, 26
	npad	5
$LL13@PPMD_START:
	mov	BYTE PTR [rcx], al
	inc	rcx
	add	eax, 4
	dec	rdx
	jne	SHORT $LL13@PPMD_START

; 114  :     for (k=i=0;k < 128;k++) {

	xor	ebx, ebx
	lea	r9, OFFSET FLAT:Units2Indx
	mov	edx, ebx
	mov	r8d, ebx
	npad	5
$LL10@PPMD_START:

; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;

	mov	eax, edx
	inc	r8d
	movzx	ecx, BYTE PTR [rax+r10]
	cmp	ecx, r8d
	adc	edx, ebx
	inc	r9
	mov	BYTE PTR [r9-1], dl
	cmp	r8d, 128				; 00000080H
	jb	SHORT $LL10@PPMD_START

; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);

	mov	rax, 289360691352306692			; 0404040404040404H
	lea	rcx, OFFSET FLAT:NS2BSIndx+11
	mov	edx, 6
	mov	r8d, 245				; 000000f5H
	mov	WORD PTR NS2BSIndx, 512			; 00000200H
	mov	QWORD PTR NS2BSIndx+2, rax
	mov	BYTE PTR NS2BSIndx+10, al
	call	memset
	lea	rax, OFFSET FLAT:QTable
	npad	3
$LL7@PPMD_START:

; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;

	mov	BYTE PTR [rax], bl
	inc	ebx
	inc	rax
	cmp	ebx, 5
	jb	SHORT $LL7@PPMD_START

; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {

	mov	eax, 5
	mov	ecx, edi
	lea	rdx, OFFSET FLAT:QTable+5
	mov	r8d, 255				; 000000ffH
$LL4@PPMD_START:

; 121  :         QTable[i]=m;
; 122  :         if ( !--k ) { k = ++Step;           m++; }

	dec	ecx
	mov	BYTE PTR [rdx], al
	jne	SHORT $LN3@PPMD_START
	inc	edi
	inc	eax
	mov	ecx, edi
$LN3@PPMD_START:

; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {

	inc	rdx
	dec	r8
	jne	SHORT $LL4@PPMD_START

; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;
; 125  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR ?DummySEE2Cont@@3USEE2_CONTEXT@@A, -2069057649 ; DummySEE2Cont, 84acaf8fH
	lea	rax, OFFSET FLAT:?PPMd_StartUp@@3UPPMD_STARTUP@@A ; PPMd_StartUp
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0PPMD_STARTUP@@QEAA@XZ ENDP				; PPMD_STARTUP::PPMD_STARTUP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?StateCpy@@YAXAEAUSTATE@PPM_CONTEXT@@AEBU12@@Z
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
?StateCpy@@YAXAEAUSTATE@PPM_CONTEXT@@AEBU12@@Z PROC	; StateCpy, COMDAT

; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax

; 104  :     s1.Successor=s2.Successor;

	mov	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR [rcx+2], rax

; 105  : }

	ret	0
?StateCpy@@YAXAEAUSTATE@PPM_CONTEXT@@AEBU12@@Z ENDP	; StateCpy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SWAP@@YAXAEAUSTATE@PPM_CONTEXT@@0@Z
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
?SWAP@@YAXAEAUSTATE@PPM_CONTEXT@@0@Z PROC		; SWAP, COMDAT

; 97   :     WORD t1=(WORD&) s1;                     PPM_CONTEXT* t2=s1.Successor;
; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	movzx	eax, WORD PTR [rdx]
	movzx	r9d, WORD PTR [rcx]
	mov	r8, QWORD PTR [rcx+2]
	mov	WORD PTR [rcx], ax
	mov	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR [rcx+2], rax

; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;

	mov	WORD PTR [rdx], r9w
	mov	QWORD PTR [rdx+2], r8

; 100  : }

	ret	0
?SWAP@@YAXAEAUSTATE@PPM_CONTEXT@@0@Z ENDP		; SWAP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?oneState@PPM_CONTEXT@@QEBAAEAUSTATE@1@XZ
_TEXT	SEGMENT
this$ = 8
?oneState@PPM_CONTEXT@@QEBAAEAUSTATE@1@XZ PROC		; PPM_CONTEXT::oneState, COMDAT

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	lea	rax, QWORD PTR [rcx+2]
	ret	0
?oneState@PPM_CONTEXT@@QEBAAEAUSTATE@1@XZ ENDP		; PPM_CONTEXT::oneState
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?update@SEE2_CONTEXT@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?update@SEE2_CONTEXT@@QEAAXXZ PROC			; SEE2_CONTEXT::update, COMDAT

; 41   :     void update() {

	mov	rdx, rcx

; 42   :         if (Shift < PERIOD_BITS && --Count == 0) {

	movzx	ecx, BYTE PTR [rcx+2]
	cmp	cl, 7
	jae	SHORT $LN1@update
	dec	BYTE PTR [rdx+3]
	jne	SHORT $LN1@update

; 43   :             Summ += Summ;                   Count=3 << Shift++;

	movzx	eax, WORD PTR [rdx]
	add	ax, ax
	mov	WORD PTR [rdx], ax
	mov	eax, 3
	shl	al, cl
	inc	cl
	mov	BYTE PTR [rdx+2], cl
	mov	BYTE PTR [rdx+3], al
$LN1@update:

; 44   :         }
; 45   :     }

	fatret	0
?update@SEE2_CONTEXT@@QEAAXXZ ENDP			; SEE2_CONTEXT::update
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?getMean@SEE2_CONTEXT@@QEAAIXZ
_TEXT	SEGMENT
this$ = 8
?getMean@SEE2_CONTEXT@@QEAAIXZ PROC			; SEE2_CONTEXT::getMean, COMDAT

; 38   :         UINT RetVal=(Summ >> Shift);        Summ -= RetVal;

	movzx	eax, WORD PTR [rcx]
	mov	rdx, rcx
	movzx	ecx, BYTE PTR [rcx+2]
	mov	r8d, eax
	shr	r8d, cl
	sub	ax, r8w
	mov	WORD PTR [rdx], ax

; 39   :         return RetVal+(RetVal == 0);

	xor	eax, eax
	test	r8d, r8d
	sete	al
	add	eax, r8d

; 40   :     }

	ret	0
?getMean@SEE2_CONTEXT@@QEAAIXZ ENDP			; SEE2_CONTEXT::getMean
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?init@SEE2_CONTEXT@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
InitVal$ = 16
?init@SEE2_CONTEXT@@QEAAXI@Z PROC			; SEE2_CONTEXT::init, COMDAT

; 36   :     void init(UINT InitVal) { Summ=InitVal << (Shift=PERIOD_BITS-4); Count=7; }

	shl	dx, 3
	mov	WORD PTR [rcx+2], 1795			; 00000703H
	mov	WORD PTR [rcx], dx
	ret	0
?init@SEE2_CONTEXT@@QEAAXI@Z ENDP			; SEE2_CONTEXT::init
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	ENDS
;	COMDAT ?UnitsCpy@@YAXPEAX0I@Z
_TEXT	SEGMENT
Dest$ = 8
Src$ = 16
NU$ = 24
?UnitsCpy@@YAXPEAX0I@Z PROC				; UnitsCpy, COMDAT

; 138  :     DWORD* p1=(DWORD*) Dest, * p2=(DWORD*) Src;

	lea	r9, QWORD PTR [rdx+8]

; 143  :     } while ( --NU );

	sub	rcx, rdx
	npad	9
$LL3@UnitsCpy:

; 139  :     do {
; 140  :         p1[0]=p2[0];                        p1[1]=p2[1];
; 141  :         p1[2]=p2[2];
; 142  :         p1 += 3;                            p2 += 3;

	mov	eax, DWORD PTR [r9-8]
	add	r9, 12

; 143  :     } while ( --NU );

	dec	r8d
	mov	DWORD PTR [rcx+r9-20], eax
	mov	eax, DWORD PTR [r9-16]
	mov	DWORD PTR [rcx+r9-16], eax
	mov	eax, DWORD PTR [r9-12]
	mov	DWORD PTR [rcx+r9-12], eax
	jne	SHORT $LL3@UnitsCpy

; 144  : }

	fatret	0
?UnitsCpy@@YAXPEAX0I@Z ENDP				; UnitsCpy
	ALIGN	8

LoUnit	DQ	01H DUP (?)
UnitsStart DQ	01H DUP (?)
GlueCount DD	01H DUP (?)
	ALIGN	8

pText	DQ	01H DUP (?)
HiUnit	DQ	01H DUP (?)
HeapStart DQ	01H DUP (?)
pdata	SEGMENT
$pdata$?InitSubAllocator@@YAXXZ DD imagerel ?InitSubAllocator@@YAXXZ
	DD	imagerel ?InitSubAllocator@@YAXXZ+105
	DD	imagerel $unwind$?InitSubAllocator@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?InitSubAllocator@@YAXXZ DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
?InitSubAllocator@@YAXXZ PROC				; InitSubAllocator

; 74   : {

	sub	rsp, 40					; 00000028H

; 75   :     memset(BList,0,sizeof(BList));

	lea	rcx, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A ; BList
	xor	edx, edx
	mov	r8d, 456				; 000001c8H
	call	memset

; 76   :     HiUnit=(pText=HeapStart)+SubAllocatorSize;

	mov	r11, QWORD PTR HeapStart
	mov	ecx, DWORD PTR SubAllocatorSize
	lea	r8, QWORD PTR [r11+rcx]

; 77   :     UINT Diff=UNIT_SIZE*(SubAllocatorSize/8/UNIT_SIZE*7);

	mov	eax, -1431655765			; aaaaaaabH
	shr	ecx, 3
	mov	QWORD PTR HiUnit, r8
	mov	QWORD PTR pText, r11

; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;

	mov	DWORD PTR GlueCount, 0
	mul	ecx
	shr	edx, 3
	imul	edx, 84					; 00000054H
	mov	eax, edx
	sub	r8, rax
	mov	QWORD PTR UnitsStart, r8
	mov	QWORD PTR LoUnit, r8

; 79   : }

	add	rsp, 40					; 00000028H
	ret	0
?InitSubAllocator@@YAXXZ ENDP				; InitSubAllocator
_TEXT	ENDS
PUBLIC	GetUsedMemory
; Function compile flags: /Ogtpy
_TEXT	SEGMENT
GetUsedMemory PROC

; 55   :     DWORD i, RetVal=SubAllocatorSize-(HiUnit-LoUnit)-(UnitsStart-pText);

	mov	eax, DWORD PTR LoUnit
	lea	rdx, OFFSET FLAT:Indx2Units+1
	lea	r8, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A+12
	sub	eax, DWORD PTR HiUnit
	sub	eax, DWORD PTR UnitsStart
	add	eax, DWORD PTR pText
	add	eax, DWORD PTR SubAllocatorSize

; 56   :     for (i=0;i < N_INDEXES;i++)

	xor	r9d, r9d
	lea	r10d, QWORD PTR [r9+19]
$LL3@GetUsedMem:

; 57   :             RetVal -= UNIT_SIZE*Indx2Units[i]*BList[i].Stamp;

	movzx	ecx, BYTE PTR [rdx-1]
	add	r8, 24
	add	rdx, 2
	imul	ecx, DWORD PTR [r8-36]
	imul	ecx, -12				; fffffff4H
	add	eax, ecx
	movzx	ecx, BYTE PTR [rdx-2]
	imul	ecx, DWORD PTR [r8-24]
	imul	ecx, -12				; fffffff4H
	add	r9d, ecx
	dec	r10
	jne	SHORT $LL3@GetUsedMem

; 56   :     for (i=0;i < N_INDEXES;i++)

	add	eax, r9d

; 58   :     return RetVal;
; 59   : }

	ret	0
GetUsedMemory ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?U2B@@YAII@Z
_TEXT	SEGMENT
NU$ = 8
?U2B@@YAII@Z PROC					; U2B, COMDAT

; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	lea	eax, DWORD PTR [rcx+rcx*2]
	shl	eax, 2
	ret	0
?U2B@@YAII@Z ENDP					; U2B
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?PrefetchData@@YAXPEAX@Z
_TEXT	SEGMENT
Addr$ = 8
?PrefetchData@@YAXPEAX@Z PROC				; PrefetchData, COMDAT

; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rcx]

; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }

	ret	0
?PrefetchData@@YAXPEAX@Z ENDP				; PrefetchData
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?unlink@BLK_NODE@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?unlink@BLK_NODE@@QEAAXXZ PROC				; BLK_NODE::unlink, COMDAT

; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rcx+4]
	mov	rdx, QWORD PTR [rax+4]
	mov	QWORD PTR [rcx+4], rdx
	ret	0
?unlink@BLK_NODE@@QEAAXXZ ENDP				; BLK_NODE::unlink
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?link@BLK_NODE@@QEAAXPEAU1@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?link@BLK_NODE@@QEAAXPEAU1@@Z PROC			; BLK_NODE::link, COMDAT

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [rdx+4], rax
	mov	QWORD PTR [rcx+4], rdx
	ret	0
?link@BLK_NODE@@QEAAXPEAU1@@Z ENDP			; BLK_NODE::link
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?avail@BLK_NODE@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?avail@BLK_NODE@@QEBAHXZ PROC				; BLK_NODE::avail, COMDAT

; 15   :     BOOL   avail()      const { return (next != NULL); }

	xor	eax, eax
	cmp	QWORD PTR [rcx+4], rax
	setne	al
	ret	0
?avail@BLK_NODE@@QEBAHXZ ENDP				; BLK_NODE::avail
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	ENDS
_TEXT	SEGMENT
tmp$ = 8
f1$ = 16
?rcBinCorrect1@ppmd@@YAXII@Z PROC			; ppmd::rcBinCorrect1

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	mov	eax, DWORD PTR range
	add	DWORD PTR low, ecx
	imul	eax, edx
	mov	DWORD PTR range, eax
	ret	0
?rcBinCorrect1@ppmd@@YAXII@Z ENDP			; ppmd::rcBinCorrect1
; Function compile flags: /Ogtpy
tmp$ = 8
?rcBinCorrect0@ppmd@@YAXI@Z PROC			; ppmd::rcBinCorrect0

; 147  : static inline void rcBinCorrect0(UINT tmp)         { range=tmp; }

	mov	DWORD PTR range, ecx
	ret	0
?rcBinCorrect0@ppmd@@YAXI@Z ENDP			; ppmd::rcBinCorrect0
; Function compile flags: /Ogtpy
tmp$ = 8
?rcBinDecode@ppmd@@YAII@Z PROC				; ppmd::rcBinDecode

; 146  : static inline UINT rcBinDecode  (UINT tmp)         { return (code-low >= tmp); }

	mov	edx, DWORD PTR code
	xor	eax, eax
	sub	edx, DWORD PTR low
	cmp	edx, ecx
	setae	al
	ret	0
?rcBinDecode@ppmd@@YAII@Z ENDP				; ppmd::rcBinDecode
; Function compile flags: /Ogtpy
f0$ = 8
?rcBinStart@ppmd@@YAIII@Z PROC				; ppmd::rcBinStart

; 145  : static inline UINT rcBinStart(UINT f0,UINT Shift)  { return f0*(range >>= Shift); }

	mov	eax, DWORD PTR range
	shr	eax, 14
	mov	DWORD PTR range, eax
	imul	eax, ecx
	ret	0
?rcBinStart@ppmd@@YAIII@Z ENDP				; ppmd::rcBinStart
; Function compile flags: /Ogtpy
?rcRemoveSubrange@ppmd@@YAXXZ PROC			; ppmd::rcRemoveSubrange

; 141  :     low     += range*SubRange.low;                 

	mov	edx, DWORD PTR range
	mov	ecx, DWORD PTR SubRange
	mov	eax, ecx
	imul	eax, edx
	add	DWORD PTR low, eax

; 142  :     range   *= SubRange.high-SubRange.low;

	mov	eax, DWORD PTR SubRange+4
	sub	eax, ecx
	imul	edx, eax
	mov	DWORD PTR range, edx

; 143  : }

	ret	0
?rcRemoveSubrange@ppmd@@YAXXZ ENDP			; ppmd::rcRemoveSubrange
; Function compile flags: /Ogtpy
?rcGetCurrentCount@ppmd@@YAIXZ PROC			; ppmd::rcGetCurrentCount

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	mov	eax, DWORD PTR range
	xor	edx, edx
	div	DWORD PTR SubRange+8
	xor	edx, edx
	mov	ecx, eax
	mov	DWORD PTR range, eax
	mov	eax, DWORD PTR code
	sub	eax, DWORD PTR low
	div	ecx
	ret	0
?rcGetCurrentCount@ppmd@@YAIXZ ENDP			; ppmd::rcGetCurrentCount
; Function compile flags: /Ogtpy
?rcEncodeSymbol@ppmd@@YAXXZ PROC			; ppmd::rcEncodeSymbol

; 98   :     low += SubRange.low*(range/=SubRange.scale);  range *= SubRange.high-SubRange.low;

	mov	eax, DWORD PTR range
	xor	edx, edx
	div	DWORD PTR SubRange+8
	mov	edx, DWORD PTR SubRange
	mov	ecx, eax
	imul	ecx, edx
	add	DWORD PTR low, ecx
	mov	ecx, DWORD PTR SubRange+4
	sub	ecx, edx
	imul	eax, ecx
	mov	DWORD PTR range, eax

; 99   : }

	ret	0
?rcEncodeSymbol@ppmd@@YAXXZ ENDP			; ppmd::rcEncodeSymbol
; Function compile flags: /Ogtpy
?rcInitEncoder@ppmd@@YAXXZ PROC			; ppmd::rcInitEncoder

; 86   : static inline void rcInitEncoder() { low=0; range=DWORD(-1); }

	mov	DWORD PTR low, 0
	mov	DWORD PTR range, -1			; ffffffffH
	ret	0
?rcInitEncoder@ppmd@@YAXXZ ENDP				; ppmd::rcInitEncoder
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
_TEXT	ENDS
;	COMDAT ?get_char@stream@ppmd@compression@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?get_char@stream@ppmd@compression@@QEAAHXZ PROC		; compression::ppmd::stream::get_char, COMDAT

; 23   : 	VERIFY			(m_pointer >= m_buffer);
; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+16]
	add	rax, QWORD PTR [rcx+8]
	cmp	rdx, rax
	jae	SHORT $LN1@get_char

; 25   : 		return		(*m_pointer++);

	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR [rcx+16], rdx

; 27   : }

	ret	0
$LN1@get_char:

; 26   : 	return			(EOF);

	or	eax, -1

; 27   : }

	ret	0
?get_char@stream@ppmd@compression@@QEAAHXZ ENDP		; compression::ppmd::stream::get_char
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?put_char@stream@ppmd@compression@@QEAAXAEBE@Z
_TEXT	SEGMENT
this$ = 8
object$ = 16
?put_char@stream@ppmd@compression@@QEAAXAEBE@Z PROC	; compression::ppmd::stream::put_char, COMDAT

; 15   : 	VERIFY			(m_pointer >= m_buffer);
; 16   : 	VERIFY			(m_pointer < (m_buffer + m_buffer_size));
; 17   : 	*m_pointer		= object;

	mov	r8, QWORD PTR [rcx+16]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [rcx+16]

; 19   : }

	ret	0
?put_char@stream@ppmd@compression@@QEAAXAEBE@Z ENDP	; compression::ppmd::stream::put_char
PrintCount DB	01H DUP (?)
	ALIGN	4

EscCount DB	01H DUP (?)
	ALIGN	4

CharMask DB	0100H DUP (?)
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\ppmd_compressor.cpp
pdata	SEGMENT
$pdata$?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z DD imagerel $LN6
	DD	imagerel $LN6+42
	DD	imagerel $unwind$?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
xdata	ENDS
;	COMDAT ?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z
_TEXT	SEGMENT
?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z PROC	; ClearMask, COMDAT

; 791  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 792  :     EscCount=1;                             memset(CharMask,0,sizeof(CharMask));

	lea	rcx, OFFSET FLAT:CharMask
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	mov	BYTE PTR EscCount, 1
	call	memset

; 793  :     if (++PrintCount == 0)                  PrintInfo(DecodedFile,EncodedFile);

	inc	BYTE PTR PrintCount

; 794  : }

	add	rsp, 40					; 00000028H
	ret	0
?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z ENDP	; ClearMask
NumMasked DB	01H DUP (?)
; Function compile flags: /Ogtpy
;	COMDAT ?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ
_TEXT	SEGMENT
this$ = 8
?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ PROC ; PPM_CONTEXT::makeEscFreq2, COMDAT

; 729  :     BYTE* pb=(BYTE*) Stats;                 UINT t=2*NumStats;

	movzx	edx, BYTE PTR [rcx]
	mov	r9, QWORD PTR [rcx+4]
	mov	r11, rcx

; 730  :     PrefetchData(pb);                       PrefetchData(pb+t);

	movzx	eax, BYTE PTR [r9]
	add	edx, edx
	movzx	eax, BYTE PTR [rdx+r9]
	mov	r8d, edx

; 731  :     PrefetchData(pb += 2*t);                PrefetchData(pb+t);

	add	edx, edx
	add	r9, rdx
	movzx	eax, BYTE PTR [r9]
	movzx	eax, BYTE PTR [r8+r9]

; 732  :     SEE2_CONTEXT* psee2c;
; 733  :     if (NumStats != 0xFF) {

	cmp	BYTE PTR [rcx], 255			; 000000ffH
	je	$LN2@makeEscFre

; 734  :         t=Suffix->NumStats;

	mov	rax, QWORD PTR [rcx+12]

; 735  :         psee2c=SEE2Cont[QTable[NumStats+2]-3]+(SummFreq > 11*(NumStats+1));
; 736  :         psee2c += 2*(2*NumStats < t+NumMasked)+Flags;

	movzx	r8d, BYTE PTR [rcx]
	xor	r10d, r10d
	movzx	edx, BYTE PTR [rax]
	movzx	eax, BYTE PTR NumMasked
	mov	ecx, r10d
	add	edx, eax
	lea	eax, DWORD PTR [r8+r8]
	cmp	eax, edx
	movzx	eax, BYTE PTR [r11+1]
	lea	edx, DWORD PTR [r8+1]
	setb	cl
	imul	edx, 11
	lea	ecx, DWORD PTR [rax+rcx*2]
	movzx	eax, WORD PTR [r11+2]
	cmp	eax, edx
	movzx	eax, BYTE PTR [r11]
	movsxd	r9, ecx
	mov	ecx, r10d
	setg	cl
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR QTable[rax+rdx+2]
	add	r9, rcx
	sub	eax, 3
	movsxd	rcx, eax
	shl	rcx, 5
	add	r9, rcx

; 737  :         SubRange.scale=psee2c->getMean();

	movzx	ecx, BYTE PTR ?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A[rdx+r9*4+2]
	lea	rax, QWORD PTR ?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A[rdx+r9*4]
	movzx	edx, WORD PTR ?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A[rdx+r9*4]
	mov	r8d, edx
	shr	r8d, cl
	sub	dx, r8w
	test	r8d, r8d
	sete	r10b
	mov	WORD PTR [rax], dx
	add	r10d, r8d
	mov	DWORD PTR SubRange+8, r10d

; 742  : }

	ret	0
$LN2@makeEscFre:

; 738  :     } else {
; 739  :         psee2c=&DummySEE2Cont;              SubRange.scale=1;

	mov	DWORD PTR SubRange+8, 1

; 740  :     }
; 741  :     return psee2c;

	lea	rax, OFFSET FLAT:?DummySEE2Cont@@3USEE2_CONTEXT@@A ; DummySEE2Cont

; 742  : }

	ret	0
?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ ENDP ; PPM_CONTEXT::makeEscFreq2
	ALIGN	4

InitEsc	DD	01H DUP (?)
FoundState DQ	01H DUP (?)
BinSumm	DW	0640H DUP (?)
PrevSuccess DB	01H DUP (?)
	ALIGN	4

RunLength DD	01H DUP (?)
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
pdata	SEGMENT
$pdata$?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ DD imagerel $LN15
	DD	imagerel $LN15+352
	DD	imagerel $unwind$?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
xdata	ENDS
;	COMDAT ?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ
_TEXT	SEGMENT
this$ = 8
?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ PROC		; PPM_CONTEXT::decodeBinSymbol, COMDAT

; 642  : {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	mov	rax, QWORD PTR [rcx+12]

; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];

	movzx	r8d, BYTE PTR [rcx+3]

; 647  :     UINT tmp=rcBinStart(bs,TOT_BITS);

	mov	r11d, DWORD PTR range
	movzx	edx, BYTE PTR [rax]

; 648  :     if ( !rcBinDecode(tmp) ) {

	mov	ebx, DWORD PTR low
	lea	r10, QWORD PTR [rcx+2]
	lea	rsi, OFFSET FLAT:__ImageBase
	shr	r11d, 14
	movzx	eax, BYTE PTR NS2BSIndx[rdx+rsi]
	mov	edx, DWORD PTR RunLength
	add	al, BYTE PTR [rcx+1]
	add	al, BYTE PTR PrevSuccess
	movzx	ecx, al
	mov	eax, edx
	sar	eax, 26
	and	eax, 32					; 00000020H
	add	ecx, eax
	movzx	eax, BYTE PTR QTable[r8+rsi-1]
	shl	rax, 6
	movsxd	r9, ecx
	add	r9, rax
	mov	eax, DWORD PTR code
	movzx	ecx, WORD PTR BinSumm[rsi+r9*2]
	sub	eax, ebx
	mov	edi, ecx
	imul	edi, r11d
	cmp	eax, edi
	jae	SHORT $LN2@decodeBinS

; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);

	cmp	r8b, 196				; 000000c4H
	mov	QWORD PTR FoundState, r10

; 650  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);

	mov	DWORD PTR range, edi
	adc	r8b, 0

; 651  :         PrevSuccess=1;                      RunLength++;

	mov	BYTE PTR PrevSuccess, 1
	mov	BYTE PTR [r10+1], r8b
	movzx	ecx, WORD PTR BinSumm[rsi+r9*2]
	lea	eax, DWORD PTR [rcx+32]
	sar	eax, 7
	sub	cx, ax
	mov	eax, 128				; 00000080H
	add	cx, ax
	inc	edx
	mov	DWORD PTR RunLength, edx
	mov	WORD PTR BinSumm[rsi+r9*2], cx

; 654  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 656  :     }
; 657  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
$LN2@decodeBinS:

; 652  :     } else {
; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);

	mov	eax, 16384				; 00004000H
	add	ebx, edi

; 654  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 656  :     }
; 657  : }

	mov	rdi, QWORD PTR [rsp+24]
	sub	eax, ecx
	mov	DWORD PTR low, ebx
	mov	rbx, QWORD PTR [rsp+8]
	imul	r11d, eax
	lea	eax, DWORD PTR [rcx+32]
	mov	BYTE PTR PrevSuccess, 0
	sar	eax, 7
	mov	DWORD PTR range, r11d
	mov	BYTE PTR NumMasked, 0
	sub	cx, ax
	mov	QWORD PTR FoundState, 0
	movzx	eax, cx
	mov	WORD PTR BinSumm[rsi+r9*2], ax
	movzx	ecx, BYTE PTR [r10]
	shr	rax, 10
	movzx	eax, BYTE PTR ExpEscape[rax+rsi]
	mov	DWORD PTR InitEsc, eax
	movzx	eax, BYTE PTR EscCount
	mov	BYTE PTR CharMask[rcx+rsi], al
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ ENDP		; PPM_CONTEXT::decodeBinSymbol
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
pdata	SEGMENT
$pdata$?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z DD imagerel $LN13
	DD	imagerel $LN13+341
	DD	imagerel $unwind$?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
xdata	ENDS
;	COMDAT ?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
symbol$ = 16
?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z PROC		; PPM_CONTEXT::encodeBinSymbol, COMDAT

; 626  : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	mov	rax, QWORD PTR [rcx+12]

; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];

	movzx	r9d, BYTE PTR [rcx+3]

; 630  :     UINT tmp=rcBinStart(bs,TOT_BITS);

	mov	ebx, DWORD PTR range
	movzx	r8d, BYTE PTR [rax]
	lea	r11, QWORD PTR [rcx+2]
	lea	rsi, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR NS2BSIndx[r8+rsi]
	mov	r8d, DWORD PTR RunLength
	shr	ebx, 14
	add	al, BYTE PTR [rcx+1]
	add	al, BYTE PTR PrevSuccess
	movzx	ecx, al
	mov	eax, r8d
	sar	eax, 26
	and	eax, 32					; 00000020H
	add	ecx, eax
	movzx	eax, BYTE PTR QTable[r9+rsi-1]
	shl	rax, 6
	movsxd	r10, ecx
	add	r10, rax

; 631  :     if (rs.Symbol == symbol) {

	movzx	eax, BYTE PTR [r11]
	movzx	ecx, WORD PTR BinSumm[rsi+r10*2]
	mov	edi, ecx
	imul	edi, ebx
	cmp	eax, edx
	jne	SHORT $LN2@encodeBinS

; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);

	cmp	r9b, 196				; 000000c4H
	mov	QWORD PTR FoundState, r11

; 633  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);

	mov	DWORD PTR range, edi
	adc	r9b, 0

; 634  :         PrevSuccess=1;                      RunLength++;

	mov	BYTE PTR PrevSuccess, 1
	mov	BYTE PTR [r11+1], r9b
	movzx	ecx, WORD PTR BinSumm[rsi+r10*2]
	lea	eax, DWORD PTR [rcx+32]
	sar	eax, 7
	sub	cx, ax
	mov	eax, 128				; 00000080H
	add	cx, ax
	inc	r8d
	mov	DWORD PTR RunLength, r8d
	mov	WORD PTR BinSumm[rsi+r10*2], cx

; 637  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 638  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 639  :     }
; 640  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
$LN2@encodeBinS:

; 635  :     } else {
; 636  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);

	add	DWORD PTR low, edi

; 637  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 638  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 639  :     }
; 640  : }

	mov	rdi, QWORD PTR [rsp+24]
	mov	eax, 16384				; 00004000H
	sub	eax, ecx
	mov	BYTE PTR PrevSuccess, 0
	mov	BYTE PTR NumMasked, 0
	mov	QWORD PTR FoundState, 0
	imul	ebx, eax
	lea	eax, DWORD PTR [rcx+32]
	mov	DWORD PTR range, ebx
	mov	rbx, QWORD PTR [rsp+8]
	sar	eax, 7
	sub	cx, ax
	movzx	eax, cx
	mov	WORD PTR BinSumm[rsi+r10*2], ax
	movzx	ecx, BYTE PTR [r11]
	shr	rax, 10
	movzx	eax, BYTE PTR ExpEscape[rax+rsi]
	mov	DWORD PTR InitEsc, eax
	movzx	eax, BYTE PTR EscCount
	mov	BYTE PTR CharMask[rcx+rsi], al
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z ENDP		; PPM_CONTEXT::encodeBinSymbol
_TEXT	ENDS
PUBLIC	?makeSuffix@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::makeSuffix
pdata	SEGMENT
$pdata$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN35
	DD	imagerel $LN35+86
	DD	imagerel $unwind$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
$pdata$0$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN35+86
	DD	imagerel $LN35+204
	DD	imagerel $chain$0$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
$pdata$1$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN35+204
	DD	imagerel $LN35+210
	DD	imagerel $chain$1$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD 020601H
	DD	030023206H
$chain$0$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN35
	DD	imagerel $LN35+86
	DD	imagerel $unwind$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
$chain$1$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+86
	DD	imagerel $unwind$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
?makeSuffix@PPM_CONTEXT@@QEAAXXZ PROC			; PPM_CONTEXT::makeSuffix

; 129  : {

$LN35:
	push	rbx
	sub	rsp, 32					; 00000020H

; 130  :     STATE* p, * p1;
; 131  :     if ( !NumStats ) 

	cmp	BYTE PTR [rcx], 0
	mov	rbx, rcx
	jne	SHORT $LN17@makeSuffix
	npad	2
$LL24@makeSuffix:

; 132  :     {
; 133  :         if ( !(p=&oneState())->Successor )  return;

	cmp	QWORD PTR [rbx+4], 0
	je	$LN7@makeSuffix

; 134  : 
; 135  :         if ( !Suffix->NumStats )            

	mov	rax, QWORD PTR [rbx+12]
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN15@makeSuffix

; 136  :         {
; 137  :             p1=&(Suffix->oneState());

	add	rax, 2

; 138  :         }
; 139  :         else

	jmp	SHORT $LN11@makeSuffix
$LN15@makeSuffix:

; 140  :         {
; 141  :             for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)

	mov	rax, QWORD PTR [rax+4]
	movzx	ecx, BYTE PTR [rbx+2]
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN11@makeSuffix
$LL13@makeSuffix:
	add	rax, 10
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LL13@makeSuffix
$LN11@makeSuffix:

; 142  :                 ;
; 143  :         }
; 144  :         
; 145  :         p->Successor->Suffix = p1->Successor; 

	mov	rcx, QWORD PTR [rbx+4]
	mov	rax, QWORD PTR [rax+2]
	mov	QWORD PTR [rcx+12], rax

; 146  :         p->Successor->makeSuffix();

	mov	rbx, QWORD PTR [rbx+4]
	cmp	BYTE PTR [rbx], 0
	je	SHORT $LL24@makeSuffix
$LN17@makeSuffix:

; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 

	movzx	eax, BYTE PTR [rbx]
	mov	QWORD PTR [rsp+48], rdi
	mov	rdi, QWORD PTR [rbx+4]
	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, QWORD PTR [rdi+rcx*2]
	cmp	rdi, rax
	ja	SHORT $LN34@makeSuffix
	add	rdi, 2
$LL9@makeSuffix:

; 151  :         {
; 152  :             if ( !p->Successor )            

	mov	rdx, QWORD PTR [rdi]
	test	rdx, rdx
	je	SHORT $LN8@makeSuffix

; 153  :                 continue;
; 154  : 
; 155  :             if ( !Suffix )                  

	mov	rax, QWORD PTR [rbx+12]
	test	rax, rax
	jne	SHORT $LN5@makeSuffix

; 156  :             {
; 157  :                 p->Successor->Suffix=this;

	mov	QWORD PTR [rdx+12], rbx

; 158  :             }
; 159  :             else 

	jmp	SHORT $LN4@makeSuffix
$LN5@makeSuffix:

; 160  :             {
; 161  :                 for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)

	mov	rax, QWORD PTR [rax+4]
	movzx	ecx, BYTE PTR [rdi-2]
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN1@makeSuffix
$LL3@makeSuffix:
	add	rax, 10
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LL3@makeSuffix
$LN1@makeSuffix:

; 162  :                     ;
; 163  :                 p->Successor->Suffix=p1->Successor;

	mov	rax, QWORD PTR [rax+2]
	mov	QWORD PTR [rdx+12], rax
$LN4@makeSuffix:

; 164  :             }
; 165  :             p->Successor->makeSuffix();

	mov	rcx, QWORD PTR [rdi]
	call	?makeSuffix@PPM_CONTEXT@@QEAAXXZ	; PPM_CONTEXT::makeSuffix
$LN8@makeSuffix:

; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 

	movzx	eax, BYTE PTR [rbx]
	add	rdi, 10
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	lea	rdx, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [rdi-2]
	cmp	rax, rdx
	jbe	SHORT $LL9@makeSuffix
$LN34@makeSuffix:
	mov	rdi, QWORD PTR [rsp+48]
$LN7@makeSuffix:

; 166  :         }
; 167  :     }
; 168  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?makeSuffix@PPM_CONTEXT@@QEAAXXZ ENDP			; PPM_CONTEXT::makeSuffix
_TEXT	ENDS
pdata	SEGMENT
$pdata$?ExpandTextArea@@YAXXZ DD imagerel ?ExpandTextArea@@YAXXZ
	DD	imagerel ?ExpandTextArea@@YAXXZ+228
	DD	imagerel $unwind$?ExpandTextArea@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?ExpandTextArea@@YAXXZ DD 030901H
	DD	0180109H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
xdata	ENDS
_TEXT	SEGMENT
Count$ = 32
?ExpandTextArea@@YAXXZ PROC				; ExpandTextArea

; 188  : {

	push	rbx
	sub	rsp, 192				; 000000c0H

; 189  :     BLK_NODE* p;
; 190  :     UINT Count[N_INDEXES];                  memset(Count,0,sizeof(Count));

	lea	rcx, QWORD PTR Count$[rsp]
	xor	edx, edx
	mov	r8d, 152				; 00000098H
	call	memset

; 191  :     while ((p=(BLK_NODE*) UnitsStart)->Stamp == ~0UL) {

	mov	r11, QWORD PTR UnitsStart
	cmp	DWORD PTR [r11], -1			; ffffffffH
	mov	rdx, r11
	jne	SHORT $LN10@ExpandText
	lea	r9, OFFSET FLAT:Units2Indx
	xor	r8d, r8d
	npad	11
$LL11@ExpandText:

; 192  :         MEM_BLK* pm=(MEM_BLK*) p;           UnitsStart=(BYTE*) (pm+pm->NU);

	mov	eax, DWORD PTR [r11+12]
	lea	rcx, QWORD PTR [r11+12]
	shl	rax, 4
	add	r11, rax

; 193  :         Count[Units2Indx[pm->NU-1]]++;      pm->Stamp=0;

	mov	eax, DWORD PTR [rcx]
	dec	eax
	movzx	eax, BYTE PTR [rax+r9]
	mov	DWORD PTR [rdx], r8d
	mov	rdx, r11
	inc	DWORD PTR Count$[rsp+rax*4]
	cmp	DWORD PTR [r11], -1			; ffffffffH
	je	SHORT $LL11@ExpandText

; 192  :         MEM_BLK* pm=(MEM_BLK*) p;           UnitsStart=(BYTE*) (pm+pm->NU);

	mov	QWORD PTR UnitsStart, r11
$LN10@ExpandText:

; 194  :     }
; 195  :     for (UINT i=0;i < N_INDEXES;i++)

	lea	r9, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A	; BList
	lea	r10, QWORD PTR Count$[rsp]
	mov	ebx, 38					; 00000026H
	mov	r11, r9
$LL9@ExpandText:

; 196  :         for (p=BList+i;Count[i] != 0;p=p->next)

	mov	r8d, DWORD PTR [r10]
	mov	rdx, r11
	test	r8d, r8d
	je	SHORT $LN8@ExpandText
	npad	2
$LL6@ExpandText:

; 197  :             while ( !p->next->Stamp ) {

	mov	rax, QWORD PTR [rdx+4]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN5@ExpandText
	npad	7
$LL3@ExpandText:

; 198  :                 p->unlink();                BList[i].Stamp--;

	mov	rax, QWORD PTR [rdx+4]
	mov	rcx, QWORD PTR [rax+4]
	mov	QWORD PTR [rdx+4], rcx
	dec	DWORD PTR [r9]

; 199  :                 if ( !--Count[i] )          break;

	dec	r8d
	mov	DWORD PTR [r10], r8d
	je	SHORT $LN5@ExpandText

; 197  :             while ( !p->next->Stamp ) {

	mov	rax, QWORD PTR [rdx+4]
	cmp	DWORD PTR [rax], 0
	je	SHORT $LL3@ExpandText
$LN5@ExpandText:

; 196  :         for (p=BList+i;Count[i] != 0;p=p->next)

	cmp	DWORD PTR [r10], 0
	mov	rdx, QWORD PTR [rdx+4]
	jne	SHORT $LL6@ExpandText
$LN8@ExpandText:

; 194  :     }
; 195  :     for (UINT i=0;i < N_INDEXES;i++)

	add	r11, 12
	add	r10, 4
	add	r9, 12
	dec	rbx
	jne	SHORT $LL9@ExpandText

; 200  :             }
; 201  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
?ExpandTextArea@@YAXXZ ENDP				; ExpandTextArea
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@BLK_NODE@@QEAAXPEAXH@Z
_TEXT	SEGMENT
this$ = 8
pv$ = 16
NU$ = 24
?insert@BLK_NODE@@QEAAXPEAXH@Z PROC			; BLK_NODE::insert, COMDAT

; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [rdx+4], rax
	mov	QWORD PTR [rcx+4], rdx

; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rdx], -1			; ffffffffH
	mov	DWORD PTR [rdx+12], r8d

; 40   :     Stamp++;

	inc	DWORD PTR [rcx]

; 41   : }

	ret	0
?insert@BLK_NODE@@QEAAXPEAXH@Z ENDP			; BLK_NODE::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?remove@BLK_NODE@@QEAAPEAXXZ
_TEXT	SEGMENT
this$ = 8
?remove@BLK_NODE@@QEAAPEAXXZ PROC			; BLK_NODE::remove, COMDAT

; 19   :         BLK_NODE* p=next;                   unlink();

	mov	rax, QWORD PTR [rcx+4]
	mov	rdx, QWORD PTR [rax+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR [rcx]
	mov	QWORD PTR [rcx+4], rdx

; 21   :     }

	ret	0
?remove@BLK_NODE@@QEAAPEAXXZ ENDP			; BLK_NODE::remove
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	ENDS
;	COMDAT ?rcDecNormalize@ppmd@@YAXPEAVstream@1compression@@@Z
_TEXT	SEGMENT
stream$ = 8
?rcDecNormalize@ppmd@@YAXPEAVstream@1compression@@@Z PROC ; ppmd::rcDecNormalize, COMDAT

; 116  : {

	mov	r8d, DWORD PTR low
	mov	edx, DWORD PTR range
	mov	r11d, DWORD PTR code
	mov	r10, rcx
	npad	9
$LL3@rcDecNorma:

; 117  :     while(      (low ^ (low+range)) < TOP 
; 118  :             ||  range < BOT 
; 119  :             &&  ((range= -low & (BOT-1)),1) 
; 120  :          ) 

	lea	eax, DWORD PTR [rdx+r8]
	xor	eax, r8d
	cmp	eax, 16777216				; 01000000H
	jb	SHORT $LN1@rcDecNorma
	cmp	edx, 32768				; 00008000H
	jae	SHORT $LN2@rcDecNorma
	mov	edx, r8d
	neg	edx
	and	edx, 32767				; 00007fffH
$LN1@rcDecNorma:

; 121  :     {
; 122  :         code    = (code << 8) | _PPMD_D_GETC(stream);

	mov	eax, DWORD PTR [r10]
	mov	rcx, QWORD PTR [r10+16]
	add	rax, QWORD PTR [r10+8]
	cmp	rcx, rax
	jae	SHORT $LN6@rcDecNorma
	movzx	r9d, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [r10+16], rax
	jmp	SHORT $LN7@rcDecNorma
$LN6@rcDecNorma:
	or	r9d, -1
$LN7@rcDecNorma:
	shl	r11d, 8

; 123  :         range <<= 8;                        

	shl	edx, 8
	or	r11d, r9d
	mov	DWORD PTR range, edx

; 124  :         low   <<= 8;

	shl	r8d, 8
	mov	DWORD PTR code, r11d

; 125  :     }

	jmp	SHORT $LL3@rcDecNorma
$LN2@rcDecNorma:

; 124  :         low   <<= 8;

	mov	DWORD PTR low, r8d

; 126  : }

	ret	0
?rcDecNormalize@ppmd@@YAXPEAVstream@1compression@@@Z ENDP ; ppmd::rcDecNormalize
; Function compile flags: /Ogtpy
_TEXT	ENDS
_TEXT	SEGMENT
stream$ = 8
?rcInitDecoder@ppmd@@YAXPEAVstream@1compression@@@Z PROC ; ppmd::rcInitDecoder

; 109  :     low=code=0;                             range=DWORD(-1);
; 110  :     for (UINT i=0;i < 4;i++)

	mov	edx, DWORD PTR [rcx]
	mov	r9, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rcx+16]
	xor	r8d, r8d
	add	r9, rdx
	mov	r10, rcx
	lea	edx, QWORD PTR [r8+4]
	mov	DWORD PTR low, r8d
	mov	DWORD PTR range, -1			; ffffffffH
$LL3@rcInitDeco:

; 111  :             code=(code << 8) | _PPMD_D_GETC(stream);

	cmp	rax, r9
	jae	SHORT $LN6@rcInitDeco
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [r10+16], rax
	jmp	SHORT $LN7@rcInitDeco
$LN6@rcInitDeco:
	or	ecx, -1
$LN7@rcInitDeco:
	shl	r8d, 8
	or	r8d, ecx
	dec	rdx
	jne	SHORT $LL3@rcInitDeco
	mov	DWORD PTR code, r8d

; 112  : }

	ret	0
?rcInitDecoder@ppmd@@YAXPEAVstream@1compression@@@Z ENDP ; ppmd::rcInitDecoder
; Function compile flags: /Ogtpy
stream$ = 8
?rcFlushEncoder@ppmd@@YAXPEAVstream@1compression@@@Z PROC ; ppmd::rcFlushEncoder

; 103  :     for (UINT i=0;i < 4;i++) {
; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	rax, QWORD PTR [rcx+16]
	mov	r8d, DWORD PTR low
	mov	r9, rcx
	mov	edx, r8d
	shl	r8d, 8
	shr	edx, 24
	mov	BYTE PTR [rax], dl
	inc	QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rcx+16]
	mov	eax, r8d
	shl	r8d, 8
	shr	eax, 24
	mov	BYTE PTR [rdx], al
	inc	QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR [rcx+16]
	mov	eax, r8d
	shl	r8d, 8
	shr	eax, 24
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [r9+16]
	mov	rcx, QWORD PTR [r9+16]
	mov	eax, r8d
	shl	r8d, 8
	shr	eax, 24
	mov	DWORD PTR low, r8d
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [r9+16]

; 105  :     }
; 106  : }

	ret	0
?rcFlushEncoder@ppmd@@YAXPEAVstream@1compression@@@Z ENDP ; ppmd::rcFlushEncoder
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?rcEncNormalize@ppmd@@YAXPEAVstream@1compression@@@Z
_TEXT	SEGMENT
stream$ = 8
?rcEncNormalize@ppmd@@YAXPEAVstream@1compression@@@Z PROC ; ppmd::rcEncNormalize, COMDAT

; 74   : {

	mov	r8d, DWORD PTR low
	mov	edx, DWORD PTR range
	mov	r9, rcx
$LL3@rcEncNorma:

; 75   :     while(      (low ^ (low+range)) < TOP 
; 76   :             ||  range < BOT 
; 77   :             &&  ((range= -low & (BOT-1)),1)
; 78   :          ) 

	lea	eax, DWORD PTR [rdx+r8]
	xor	eax, r8d
	cmp	eax, 16777216				; 01000000H
	jb	SHORT $LN1@rcEncNorma
	cmp	edx, 32768				; 00008000H
	jae	SHORT $LN2@rcEncNorma
	mov	edx, r8d
	neg	edx
	and	edx, 32767				; 00007fffH
$LN1@rcEncNorma:

; 79   :     {
; 80   :         _PPMD_E_PUTC( low >> 24, stream );

	mov	rax, QWORD PTR [r9+16]
	mov	ecx, r8d

; 81   :         range   <<= 8;                        

	shl	edx, 8
	shr	ecx, 24
	mov	DWORD PTR range, edx
	mov	BYTE PTR [rax], cl
	inc	QWORD PTR [r9+16]

; 82   :         low     <<= 8;

	shl	r8d, 8

; 83   :     }

	jmp	SHORT $LL3@rcEncNorma
$LN2@rcEncNorma:

; 82   :         low     <<= 8;

	mov	DWORD PTR low, r8d

; 84   : }

	ret	0
?rcEncNormalize@ppmd@@YAXPEAVstream@1compression@@@Z ENDP ; ppmd::rcEncNormalize
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
pdata	SEGMENT
$pdata$?MoveUnitsUp@@YAPEAXPEAXI@Z DD imagerel $LN23
	DD	imagerel $LN23+73
	DD	imagerel $unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?MoveUnitsUp@@YAPEAXPEAXI@Z DD imagerel $LN23+73
	DD	imagerel $LN23+227
	DD	imagerel $chain$0$?MoveUnitsUp@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?MoveUnitsUp@@YAPEAXPEAXI@Z DD imagerel $LN23+227
	DD	imagerel $LN23+258
	DD	imagerel $chain$2$?MoveUnitsUp@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?MoveUnitsUp@@YAPEAXPEAXI@Z DD imagerel $LN23+258
	DD	imagerel $LN23+268
	DD	imagerel $chain$3$?MoveUnitsUp@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?MoveUnitsUp@@YAPEAXPEAXI@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+73
	DD	imagerel $unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?MoveUnitsUp@@YAPEAXPEAXI@Z DD 020021H
	DD	027400H
	DD	imagerel $LN23
	DD	imagerel $LN23+73
	DD	imagerel $unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?MoveUnitsUp@@YAPEAXPEAXI@Z DD 020521H
	DD	027405H
	DD	imagerel $LN23
	DD	imagerel $LN23+73
	DD	imagerel $unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z DD 030601H
	DD	033406H
	DD	06006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?MoveUnitsUp@@YAPEAXPEAXI@Z
_TEXT	SEGMENT
OldPtr$ = 16
NU$ = 24
?MoveUnitsUp@@YAPEAXPEAXI@Z PROC			; MoveUnitsUp, COMDAT

; 177  : {

$LN23:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi

; 178  :     UINT indx=Units2Indx[NU-1];
; 179  :     if ((BYTE*) OldPtr > UnitsStart+16*1024 || (BLK_NODE*) OldPtr > BList[indx].next)

	mov	r10, QWORD PTR UnitsStart
	lea	eax, DWORD PTR [rdx-1]
	mov	r9, rcx
	lea	rsi, OFFSET FLAT:__ImageBase
	mov	r11d, edx
	movzx	ecx, BYTE PTR Units2Indx[rax+rsi]
	lea	rax, QWORD PTR [r10+16384]
	cmp	r9, rax
	ja	$LN3@MoveUnitsU
	lea	rdx, QWORD PTR [rcx+rcx*2]
	mov	ebx, ecx
	cmp	r9, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rsi+rdx*4+4]
	ja	$LN3@MoveUnitsU

; 181  :     void* ptr=BList[indx].remove();

	mov	QWORD PTR [rsp+16], rdi
	mov	rdi, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rsi+rdx*4+4]
	lea	rcx, QWORD PTR [r9+8]
	mov	rax, QWORD PTR [rdi+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rsi+rdx*4]

; 182  :     UnitsCpy(ptr,OldPtr,NU);                NU=Indx2Units[indx];

	mov	r8, rdi
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rsi+rdx*4+4], rax
	sub	r8, r9
	npad	13
$LL13@MoveUnitsU:
	mov	eax, DWORD PTR [rcx-8]
	add	rcx, 12
	dec	r11d
	mov	DWORD PTR [r8+rcx-20], eax
	mov	eax, DWORD PTR [rcx-16]
	mov	DWORD PTR [r8+rcx-16], eax
	mov	eax, DWORD PTR [rcx-12]
	mov	DWORD PTR [r8+rcx-12], eax
	jne	SHORT $LL13@MoveUnitsU
	movzx	ecx, BYTE PTR Indx2Units[rbx+rsi]

; 183  :     if ((BYTE*) OldPtr != UnitsStart)       BList[indx].insert(OldPtr,NU);

	cmp	r9, r10
	je	SHORT $LN2@MoveUnitsU
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rsi+rdx*4+4]
	mov	QWORD PTR [r9+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rsi+rdx*4+4], r9
	mov	DWORD PTR [r9], -1			; ffffffffH
	mov	DWORD PTR [r9+12], ecx
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rsi+rdx*4]

; 185  :     return ptr;

	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+16]

; 186  : }

	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
$LN2@MoveUnitsU:

; 184  :     else                                    UnitsStart += U2B(NU);

	lea	ecx, DWORD PTR [rcx+rcx*2]

; 185  :     return ptr;

	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+16]
	shl	ecx, 2
	add	r10, rcx
	mov	QWORD PTR UnitsStart, r10

; 186  : }

	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
$LN3@MoveUnitsU:

; 180  :             return OldPtr;

	mov	rax, r9

; 186  : }

	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
?MoveUnitsUp@@YAPEAXPEAXI@Z ENDP			; MoveUnitsUp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SpecialFreeUnit@@YAXPEAX@Z
_TEXT	SEGMENT
ptr$ = 8
?SpecialFreeUnit@@YAXPEAX@Z PROC			; SpecialFreeUnit, COMDAT

; 173  :     if ((BYTE*) ptr != UnitsStart)          BList->insert(ptr,1);

	mov	rax, QWORD PTR UnitsStart
	cmp	rcx, rax
	je	SHORT $LN2@SpecialFre
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	mov	QWORD PTR [rcx+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rcx
	mov	DWORD PTR [rcx], -1			; ffffffffH
	mov	DWORD PTR [rcx+12], 1
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A

; 175  : }

	ret	0
$LN2@SpecialFre:

; 174  :     else { *(DWORD*) ptr=~0UL;              UnitsStart += UNIT_SIZE; }

	add	rax, 12
	mov	DWORD PTR [rcx], -1			; ffffffffH
	mov	QWORD PTR UnitsStart, rax

; 175  : }

	ret	0
?SpecialFreeUnit@@YAXPEAX@Z ENDP			; SpecialFreeUnit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?FreeUnits@@YAXPEAXI@Z
_TEXT	SEGMENT
ptr$ = 8
NU$ = 16
?FreeUnits@@YAXPEAXI@Z PROC				; FreeUnits, COMDAT

; 168  :     UINT indx=Units2Indx[NU-1];

	lea	r10, OFFSET FLAT:__ImageBase
	lea	eax, DWORD PTR [rdx-1]
	movzx	eax, BYTE PTR Units2Indx[rax+r10]

; 169  :     BList[indx].insert(ptr,Indx2Units[indx]);

	movzx	r8d, BYTE PTR Indx2Units[rax+r10]
	lea	r9, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+r9*4+4]
	mov	QWORD PTR [rcx+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+r9*4+4], rcx
	mov	DWORD PTR [rcx], -1			; ffffffffH
	mov	DWORD PTR [rcx+12], r8d
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+r9*4]

; 170  : }

	ret	0
?FreeUnits@@YAXPEAXI@Z ENDP				; FreeUnits
_TEXT	ENDS
pdata	SEGMENT
$pdata$?GlueFreeBlocks@@YAXXZ DD imagerel ?GlueFreeBlocks@@YAXXZ
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+181
	DD	imagerel $unwind$?GlueFreeBlocks@@YAXXZ
$pdata$3$?GlueFreeBlocks@@YAXXZ DD imagerel ?GlueFreeBlocks@@YAXXZ+181
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+497
	DD	imagerel $chain$3$?GlueFreeBlocks@@YAXXZ
$pdata$4$?GlueFreeBlocks@@YAXXZ DD imagerel ?GlueFreeBlocks@@YAXXZ+497
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+514
	DD	imagerel $chain$4$?GlueFreeBlocks@@YAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?GlueFreeBlocks@@YAXXZ DD 020601H
	DD	0c0021206H
$chain$3$?GlueFreeBlocks@@YAXXZ DD 081e21H
	DD	07741eH
	DD	043412H
	DD	06640aH
	DD	055405H
	DD	imagerel ?GlueFreeBlocks@@YAXXZ
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+181
	DD	imagerel $unwind$?GlueFreeBlocks@@YAXXZ
$chain$4$?GlueFreeBlocks@@YAXXZ DD 021H
	DD	imagerel ?GlueFreeBlocks@@YAXXZ
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+181
	DD	imagerel $unwind$?GlueFreeBlocks@@YAXXZ
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
s0$ = 0
?GlueFreeBlocks@@YAXXZ PROC				; GlueFreeBlocks

; 81   : {

	push	r12
	sub	rsp, 16

; 82   :     UINT i, k, sz;
; 83   :     MEM_BLK s0, * p, * p0, * p1;
; 84   :     if (LoUnit != HiUnit)                   *LoUnit=0;

	mov	rax, QWORD PTR LoUnit
	cmp	rax, QWORD PTR HiUnit
	je	SHORT $LN16@GlueFreeBl
	mov	BYTE PTR [rax], 0
$LN16@GlueFreeBl:

; 85   :     for (i=0, (p0=&s0)->next=NULL;i < N_INDEXES;i++)

	xor	r11d, r11d
	lea	r12, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A ; BList
	lea	r9, QWORD PTR s0$[rsp]
	mov	r8, r12
	mov	QWORD PTR s0$[rsp+4], r11
	lea	r10d, QWORD PTR [r11+38]
$LL15@GlueFreeBl:

; 86   :             while ( BList[i].avail() ) {

	cmp	QWORD PTR [r8+4], r11
	je	SHORT $LN14@GlueFreeBl
	npad	7
$LL12@GlueFreeBl:

; 87   :                 p=(MEM_BLK*) BList[i].remove();

	mov	rdx, QWORD PTR [r8+4]
	mov	rax, QWORD PTR [rdx+4]
	dec	DWORD PTR [r8]
	mov	QWORD PTR [r8+4], rax

; 88   :                 if ( !p->NU )               continue;

	mov	eax, DWORD PTR [rdx+12]
	test	eax, eax
	je	SHORT $LN53@GlueFreeBl

; 89   :                 while ((p1=p+p->NU)->Stamp == ~0UL) {

	mov	ecx, eax
	shl	rcx, 4
	add	rcx, rdx
	cmp	DWORD PTR [rcx], -1			; ffffffffH
	jne	SHORT $LN8@GlueFreeBl
	npad	12
$LL9@GlueFreeBl:

; 90   :                     p->NU += p1->NU;        p1->NU=0;

	mov	eax, DWORD PTR [rcx+12]
	add	DWORD PTR [rdx+12], eax
	mov	DWORD PTR [rcx+12], r11d
	mov	ecx, DWORD PTR [rdx+12]
	shl	rcx, 4
	add	rcx, rdx
	cmp	DWORD PTR [rcx], -1			; ffffffffH
	je	SHORT $LL9@GlueFreeBl
$LN8@GlueFreeBl:

; 91   :                 }
; 92   :                 p0->link(p);                p0=p;

	mov	rax, QWORD PTR [r9+4]
	mov	QWORD PTR [rdx+4], rax
	mov	QWORD PTR [r9+4], rdx
	mov	r9, rdx
$LN53@GlueFreeBl:

; 86   :             while ( BList[i].avail() ) {

	cmp	QWORD PTR [r8+4], r11
	jne	SHORT $LL12@GlueFreeBl
$LN14@GlueFreeBl:

; 85   :     for (i=0, (p0=&s0)->next=NULL;i < N_INDEXES;i++)

	add	r8, 12
	dec	r10
	jne	SHORT $LL15@GlueFreeBl

; 93   :             }
; 94   :     while ( s0.avail() ) {

	mov	r11, QWORD PTR s0$[rsp+4]
	test	r11, r11
	je	$LN57@GlueFreeBl
	mov	QWORD PTR [rsp+40], rbp
	mov	QWORD PTR [rsp+48], rsi
	mov	esi, DWORD PTR s0$[rsp]
	mov	QWORD PTR [rsp+32], rbx
	lea	rbp, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+56], rdi
	npad	13
$LL7@GlueFreeBl:

; 95   :         p=(MEM_BLK*) s0.remove();           sz=p->NU;

	mov	r9, r11
	mov	r11, QWORD PTR [r11+4]
	dec	esi
	mov	r10d, DWORD PTR [r9+12]

; 96   :         if ( !sz )                          continue;

	test	r10d, r10d
	je	$LN56@GlueFreeBl

; 97   :         for ( ;sz > 128;sz -= 128, p += 128)

	cmp	r10d, 128				; 00000080H
	jbe	SHORT $LN2@GlueFreeBl
	lea	ecx, DWORD PTR [r10-129]
	shr	ecx, 7
	inc	ecx
	npad	5
$LL4@GlueFreeBl:

; 98   :                 BList[N_INDEXES-1].insert(p,128);

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+448
	add	r10d, -128				; ffffff80H
	mov	QWORD PTR [r9+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+448, r9
	mov	DWORD PTR [r9], -1			; ffffffffH
	mov	DWORD PTR [r9+12], 128			; 00000080H
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A+444
	add	r9, 2048				; 00000800H
	dec	rcx
	jne	SHORT $LL4@GlueFreeBl
$LN2@GlueFreeBl:

; 99   :         if (Indx2Units[i=Units2Indx[sz-1]] != sz) {

	lea	eax, DWORD PTR [r10-1]
	movzx	edx, BYTE PTR Units2Indx[rax+rbp]
	movzx	eax, BYTE PTR Indx2Units[rdx+rbp]
	lea	rdi, QWORD PTR Indx2Units[rdx+rbp]
	mov	ebx, edx
	cmp	eax, r10d
	je	SHORT $LN37@GlueFreeBl

; 100  :             k=sz-Indx2Units[--i];           BList[k-1].insert(p+(sz-k),k);

	dec	edx
	mov	r8d, r10d
	lea	rdi, QWORD PTR Indx2Units[rdx+rbp]
	mov	ebx, edx
	movzx	eax, BYTE PTR [rdi]
	sub	r8d, eax
	sub	r10d, r8d
	lea	eax, DWORD PTR [r8-1]
	mov	ecx, r10d
	lea	rdx, QWORD PTR [rax+rax*2]
	shl	rcx, 4
	mov	rax, QWORD PTR [r12+rdx*4+4]
	add	rcx, r9
	mov	QWORD PTR [rcx+4], rax
	mov	QWORD PTR [r12+rdx*4+4], rcx
	mov	DWORD PTR [rcx], -1			; ffffffffH
	mov	DWORD PTR [rcx+12], r8d
	inc	DWORD PTR [r12+rdx*4]
$LN37@GlueFreeBl:

; 101  :         }
; 102  :         BList[i].insert(p,Indx2Units[i]);

	movzx	ecx, BYTE PTR [rdi]
	lea	rdx, QWORD PTR [rbx+rbx*2]
	mov	rax, QWORD PTR [r12+rdx*4+4]
	mov	QWORD PTR [r9+4], rax
	mov	QWORD PTR [r12+rdx*4+4], r9
	mov	DWORD PTR [r9], -1			; ffffffffH
	mov	DWORD PTR [r9+12], ecx
	inc	DWORD PTR [r12+rdx*4]
$LN56@GlueFreeBl:

; 93   :             }
; 94   :     while ( s0.avail() ) {

	test	r11, r11
	jne	$LL7@GlueFreeBl
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+32]
$LN57@GlueFreeBl:

; 103  :     }
; 104  :     GlueCount=1 << 13;

	mov	DWORD PTR GlueCount, 8192		; 00002000H

; 105  : }

	add	rsp, 16
	pop	r12
	ret	0
?GlueFreeBlocks@@YAXXZ ENDP				; GlueFreeBlocks
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SplitBlock@@YAXPEAXII@Z
_TEXT	SEGMENT
pv$ = 8
OldIndx$ = 16
NewIndx$ = 24
?SplitBlock@@YAXPEAXII@Z PROC				; SplitBlock, COMDAT

; 45   :     UINT i, k, UDiff=Indx2Units[OldIndx]-Indx2Units[NewIndx];

	mov	eax, r8d
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	r8d, BYTE PTR Indx2Units[rax+r10]
	mov	eax, edx
	movzx	r9d, BYTE PTR Indx2Units[rax+r10]
	sub	r9d, r8d

; 46   :     BYTE* p=((BYTE*) pv)+U2B(Indx2Units[NewIndx]);

	lea	r8d, DWORD PTR [r8+r8*2]

; 47   :     if (Indx2Units[i=Units2Indx[UDiff-1]] != UDiff) {

	lea	eax, DWORD PTR [r9-1]
	shl	r8d, 2
	movzx	edx, BYTE PTR Units2Indx[rax+r10]
	add	r8, rcx
	movzx	eax, BYTE PTR Indx2Units[rdx+r10]
	cmp	eax, r9d
	je	SHORT $LN1@SplitBlock

; 48   :         k=Indx2Units[--i];                  BList[i].insert(p,k);

	dec	edx
	mov	eax, edx
	movzx	edx, BYTE PTR Indx2Units[rdx+r10]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4+4]
	mov	QWORD PTR [r8+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4+4], r8

; 49   :         p += U2B(k);                        UDiff -= k;

	lea	eax, DWORD PTR [rdx+rdx*2]
	shl	eax, 2
	mov	DWORD PTR [r8], -1			; ffffffffH
	mov	DWORD PTR [r8+12], edx
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4]
	add	r8, rax
	sub	r9d, edx
$LN1@SplitBlock:

; 50   :     }
; 51   :     BList[Units2Indx[UDiff-1]].insert(p,UDiff);

	lea	eax, DWORD PTR [r9-1]
	movzx	eax, BYTE PTR Units2Indx[rax+r10]
	lea	rcx, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4+4]
	mov	QWORD PTR [r8+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4+4], r8
	mov	DWORD PTR [r8], -1			; ffffffffH
	mov	DWORD PTR [r8+12], r9d
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4]

; 52   : }

	ret	0
?SplitBlock@@YAXPEAXII@Z ENDP				; SplitBlock
PUBLIC	?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z	; PPM_CONTEXT::removeBinConts
MaxOrder DD	01H DUP (?)
pdata	SEGMENT
$pdata$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN30
	DD	imagerel $LN30+202
	DD	imagerel $unwind$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$0$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN30+202
	DD	imagerel $LN30+285
	DD	imagerel $chain$0$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$1$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN30+285
	DD	imagerel $LN30+304
	DD	imagerel $chain$1$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
$chain$0$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 020521H
	DD	063405H
	DD	imagerel $LN30
	DD	imagerel $LN30+202
	DD	imagerel $unwind$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
$chain$1$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+202
	DD	imagerel $unwind$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
Order$ = 56
?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z PROC		; PPM_CONTEXT::removeBinConts

; 300  : {

$LN30:
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 301  :     STATE* p;
; 302  :     if ( !NumStats ) {

	cmp	BYTE PTR [rcx], 0

; 303  :         p=&oneState();
; 304  :         if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)

	mov	rax, QWORD PTR [rcx+4]
	mov	esi, edx
	mov	rdi, rcx
	jne	$LN6@removeBinC
	cmp	rax, QWORD PTR UnitsStart
	jb	SHORT $LN10@removeBinC
	cmp	edx, DWORD PTR MaxOrder
	jge	SHORT $LN10@removeBinC

; 305  :                 P_CALL(removeBinConts);

	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR [rcx+4]
	inc	edx
	call	?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z ; PPM_CONTEXT::removeBinConts
	mov	QWORD PTR [rdi+4], rax
	jmp	SHORT $LN9@removeBinC
$LN10@removeBinC:

; 306  :         else                                p->Successor=NULL;

	xor	ebp, ebp
	mov	QWORD PTR [rcx+4], rbp
$LN9@removeBinC:

; 307  :         if (!p->Successor && (!Suffix->NumStats || Suffix->Flags == 0xFF)) {

	cmp	QWORD PTR [rdi+4], 0
	jne	$LN8@removeBinC
	mov	rax, QWORD PTR [rdi+12]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN7@removeBinC
	cmp	BYTE PTR [rax+1], 255			; 000000ffH
	jne	$LN8@removeBinC
$LN7@removeBinC:

; 308  :             FreeUnits(this,1);              return NULL;

	movzx	eax, BYTE PTR Units2Indx
	lea	r9, OFFSET FLAT:__ImageBase
	movzx	edx, BYTE PTR Indx2Units[rax+r9]
	lea	r8, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4+4]
	mov	QWORD PTR [rdi+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4+4], rdi
	mov	DWORD PTR [rdi], -1			; ffffffffH
	mov	DWORD PTR [rdi+12], edx
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4]
	xor	eax, eax

; 316  :     return this;
; 317  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@removeBinC:

; 309  :         } else                              return this;
; 310  :     }
; 311  :     PrefetchData(Stats);

	movzx	ecx, BYTE PTR [rax]

; 312  :     for (p=Stats+NumStats;p >= Stats;p--)

	mov	rdx, QWORD PTR [rdi+4]
	movzx	eax, BYTE PTR [rdi]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rdx+rcx*2]
	cmp	rbx, rdx
	jb	SHORT $LN3@removeBinC
	xor	ebp, ebp
	npad	6
$LL5@removeBinC:

; 313  :             if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)

	mov	rax, QWORD PTR [rbx+2]
	cmp	rax, QWORD PTR UnitsStart
	jb	SHORT $LN2@removeBinC
	cmp	esi, DWORD PTR MaxOrder
	jge	SHORT $LN2@removeBinC

; 314  :                     P_CALL(removeBinConts);

	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR [rbx+2]
	lea	edx, DWORD PTR [rsi+1]
	call	?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z ; PPM_CONTEXT::removeBinConts
	mov	QWORD PTR [rbx+2], rax
	jmp	SHORT $LN4@removeBinC
$LN2@removeBinC:

; 315  :             else                            p->Successor=NULL;

	mov	QWORD PTR [rbx+2], rbp
$LN4@removeBinC:

; 312  :     for (p=Stats+NumStats;p >= Stats;p--)

	sub	rbx, 10
	cmp	rbx, QWORD PTR [rdi+4]
	jae	SHORT $LL5@removeBinC
$LN3@removeBinC:
	mov	rbx, QWORD PTR [rsp+48]
$LN8@removeBinC:

; 316  :     return this;
; 317  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z ENDP		; PPM_CONTEXT::removeBinConts
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
pdata	SEGMENT
$pdata$?ShrinkUnits@@YAPEAXPEAXII@Z DD imagerel $LN23
	DD	imagerel $LN23+224
	DD	imagerel $unwind$?ShrinkUnits@@YAPEAXPEAXII@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ShrinkUnits@@YAPEAXPEAXII@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?ShrinkUnits@@YAPEAXPEAXII@Z
_TEXT	SEGMENT
OldPtr$ = 48
OldNU$ = 56
NewNU$ = 64
?ShrinkUnits@@YAPEAXPEAXII@Z PROC			; ShrinkUnits, COMDAT

; 156  : {

$LN23:
	push	rbx
	sub	rsp, 32					; 00000020H

; 157  :     UINT i0=Units2Indx[OldNU-1], i1=Units2Indx[NewNU-1];

	lea	eax, DWORD PTR [rdx-1]
	lea	r11, OFFSET FLAT:__ImageBase
	mov	rbx, rcx
	movzx	r9d, BYTE PTR Units2Indx[rax+r11]
	lea	eax, DWORD PTR [r8-1]
	movzx	ecx, BYTE PTR Units2Indx[rax+r11]

; 158  :     if (i0 == i1)                           return OldPtr;

	cmp	r9d, ecx
	je	$LN22@ShrinkUnit

; 159  :     if ( BList[i1].avail() ) {

	lea	rdx, QWORD PTR [rcx+rcx*2]
	cmp	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+rdx*4+4], 0
	je	$LN2@ShrinkUnit

; 160  :         void* ptr=BList[i1].remove();       UnitsCpy(ptr,OldPtr,NewNU);

	mov	r10, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+rdx*4+4]
	lea	rcx, QWORD PTR [rbx+8]
	mov	rax, QWORD PTR [r10+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+rdx*4]
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+rdx*4+4], rax
	mov	rdx, r10
	sub	rdx, rbx
	npad	5
$LL14@ShrinkUnit:
	mov	eax, DWORD PTR [rcx-8]
	add	rcx, 12
	dec	r8d
	mov	DWORD PTR [rdx+rcx-20], eax
	mov	eax, DWORD PTR [rcx-16]
	mov	DWORD PTR [rdx+rcx-16], eax
	mov	eax, DWORD PTR [rcx-12]
	mov	DWORD PTR [rdx+rcx-12], eax
	jne	SHORT $LL14@ShrinkUnit

; 161  :         BList[i0].insert(OldPtr,Indx2Units[i0]);

	movzx	edx, BYTE PTR Indx2Units[r9+r11]
	lea	r8, QWORD PTR [r9+r9*2]

; 162  :         return ptr;

	mov	rax, r10
	mov	rcx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+r8*4+4]
	mov	QWORD PTR [rbx+4], rcx
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+r8*4+4], rbx
	mov	DWORD PTR [rbx], -1			; ffffffffH
	mov	DWORD PTR [rbx+12], edx
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+r8*4]

; 165  :     }
; 166  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@ShrinkUnit:

; 163  :     } else {
; 164  :         SplitBlock(OldPtr,i0,i1);           return OldPtr;

	mov	r8d, ecx
	mov	edx, r9d
	mov	rcx, rbx
	call	?SplitBlock@@YAXPEAXII@Z		; SplitBlock
$LN22@ShrinkUnit:
	mov	rax, rbx

; 165  :     }
; 166  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ShrinkUnits@@YAPEAXPEAXII@Z ENDP			; ShrinkUnits
_TEXT	ENDS
pdata	SEGMENT
$pdata$?AllocUnitsRare@@YAPEAXI@Z DD imagerel ?AllocUnitsRare@@YAPEAXI@Z
	DD	imagerel ?AllocUnitsRare@@YAPEAXI@Z+149
	DD	imagerel $unwind$?AllocUnitsRare@@YAPEAXI@Z
$pdata$0$?AllocUnitsRare@@YAPEAXI@Z DD imagerel ?AllocUnitsRare@@YAPEAXI@Z+149
	DD	imagerel ?AllocUnitsRare@@YAPEAXI@Z+219
	DD	imagerel $chain$0$?AllocUnitsRare@@YAPEAXI@Z
$pdata$1$?AllocUnitsRare@@YAPEAXI@Z DD imagerel ?AllocUnitsRare@@YAPEAXI@Z+219
	DD	imagerel ?AllocUnitsRare@@YAPEAXI@Z+312
	DD	imagerel $chain$1$?AllocUnitsRare@@YAPEAXI@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?AllocUnitsRare@@YAPEAXI@Z DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
$chain$0$?AllocUnitsRare@@YAPEAXI@Z DD 020521H
	DD	063405H
	DD	imagerel ?AllocUnitsRare@@YAPEAXI@Z
	DD	imagerel ?AllocUnitsRare@@YAPEAXI@Z+149
	DD	imagerel $unwind$?AllocUnitsRare@@YAPEAXI@Z
$chain$1$?AllocUnitsRare@@YAPEAXI@Z DD 021H
	DD	imagerel ?AllocUnitsRare@@YAPEAXI@Z
	DD	imagerel ?AllocUnitsRare@@YAPEAXI@Z+149
	DD	imagerel $unwind$?AllocUnitsRare@@YAPEAXI@Z
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
indx$ = 48
?AllocUnitsRare@@YAPEAXI@Z PROC				; AllocUnitsRare

; 107  : {

	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 109  :     if ( !GlueCount ) {

	mov	edx, DWORD PTR GlueCount
	mov	esi, ecx
	mov	edi, ecx
	lea	rbp, OFFSET FLAT:__ImageBase
	test	edx, edx
	jne	SHORT $LN25@AllocUnits

; 110  :         GlueFreeBlocks();

	call	?GlueFreeBlocks@@YAXXZ			; GlueFreeBlocks

; 111  :         if ( BList[i].avail() )             return BList[i].remove();

	lea	rdx, QWORD PTR [rsi+rsi*2]
	cmp	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rdx*4+4], 0
	je	SHORT $LN28@AllocUnits
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rdx*4+4]
	mov	rcx, QWORD PTR [rax+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rdx*4]
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rdx*4+4], rcx

; 121  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN28@AllocUnits:

; 111  :         if ( BList[i].avail() )             return BList[i].remove();

	mov	edx, DWORD PTR GlueCount
$LN25@AllocUnits:

; 108  :     UINT i=indx;

	movsxd	rax, esi
	lea	rcx, QWORD PTR [rax+rax*2]
	lea	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rcx*4+4]
	npad	8
$LL4@AllocUnits:

; 112  :     }
; 113  :     do {
; 114  :         if (++i == N_INDEXES) {

	inc	edi
	add	rax, 12
	cmp	edi, 38					; 00000026H
	je	SHORT $LN26@AllocUnits

; 117  :         }
; 118  :     } while ( !BList[i].avail() );

	cmp	QWORD PTR [rax], 0
	je	SHORT $LL4@AllocUnits

; 119  :     void* RetVal=BList[i].remove();         SplitBlock(RetVal,i,indx);

	lea	r8, QWORD PTR [rdi+rdi*2]
	mov	QWORD PTR [rsp+48], rbx
	mov	edx, edi
	mov	rbx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+r8*4+4]
	mov	rcx, QWORD PTR [rbx+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+r8*4]
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+r8*4+4], rcx
	mov	r8d, esi
	mov	rcx, rbx
	call	?SplitBlock@@YAXPEAXII@Z		; SplitBlock

; 120  :     return RetVal;

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]

; 121  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN26@AllocUnits:

; 115  :             GlueCount--;                    i=U2B(Indx2Units[indx]);

	movzx	eax, BYTE PTR Indx2Units[rsi+rbp]

; 116  :             return (UnitsStart-pText > i)?(UnitsStart -= i):(NULL);

	mov	rcx, QWORD PTR UnitsStart
	dec	edx
	mov	DWORD PTR GlueCount, edx
	lea	edx, DWORD PTR [rax+rax*2]
	mov	rax, rcx
	sub	rax, QWORD PTR pText
	shl	edx, 2
	cmp	rax, rdx
	jle	SHORT $LN9@AllocUnits
	sub	rcx, rdx
	mov	QWORD PTR UnitsStart, rcx
	mov	rax, rcx

; 121  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@AllocUnits:
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	xor	ecx, ecx
	mov	eax, ecx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?AllocUnitsRare@@YAPEAXI@Z ENDP				; AllocUnitsRare
_TEXT	ENDS
PUBLIC	StopSubAllocator
pdata	SEGMENT
$pdata$StopSubAllocator DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$StopSubAllocator
pdata	ENDS
xdata	SEGMENT
$unwind$StopSubAllocator DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
$T199164 = 48
StopSubAllocator PROC

; 60   : void _STDCALL StopSubAllocator() {

$LN6:
	sub	rsp, 40					; 00000028H

; 61   :     if ( SubAllocatorSize ) {

	cmp	DWORD PTR SubAllocatorSize, 0
	je	SHORT $LN4@StopSubAll

; 62   :         SubAllocatorSize=0;                 delete[] HeapStart;

	mov	rax, QWORD PTR HeapStart
	lea	rcx, QWORD PTR $T199164[rsp]
	mov	DWORD PTR SubAllocatorSize, 0
	mov	QWORD PTR $T199164[rsp], rax
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN4@StopSubAll:

; 63   :     }
; 64   : }

	add	rsp, 40					; 00000028H
	ret	0
StopSubAllocator ENDP
PUBLIC	?rescale@PPM_CONTEXT@@QEAAXXZ			; PPM_CONTEXT::rescale
MRMethod DD	01H DUP (?)
OrderFall DD	01H DUP (?)
pdata	SEGMENT
$pdata$?rescale@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN52
	DD	imagerel $LN52+26
	DD	imagerel $unwind$?rescale@PPM_CONTEXT@@QEAAXXZ
$pdata$1$?rescale@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN52+26
	DD	imagerel $LN52+304
	DD	imagerel $chain$1$?rescale@PPM_CONTEXT@@QEAAXXZ
$pdata$2$?rescale@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN52+304
	DD	imagerel $LN52+629
	DD	imagerel $chain$2$?rescale@PPM_CONTEXT@@QEAAXXZ
pdata	ENDS
xdata	SEGMENT
$unwind$?rescale@PPM_CONTEXT@@QEAAXXZ DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
$chain$1$?rescale@PPM_CONTEXT@@QEAAXXZ DD 048221H
	DD	085482H
	DD	09c405H
	DD	imagerel $LN52
	DD	imagerel $LN52+26
	DD	imagerel $unwind$?rescale@PPM_CONTEXT@@QEAAXXZ
$chain$2$?rescale@PPM_CONTEXT@@QEAAXXZ DD 020021H
	DD	085400H
	DD	imagerel $LN52
	DD	imagerel $LN52+26
	DD	imagerel $unwind$?rescale@PPM_CONTEXT@@QEAAXXZ
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
xdata	ENDS
_TEXT	SEGMENT
tmp$ = 32
this$ = 64
?rescale@PPM_CONTEXT@@QEAAXXZ PROC			; PPM_CONTEXT::rescale

; 398  : {

$LN52:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);

	mov	r10, QWORD PTR FoundState
	movzx	r11d, BYTE PTR [rcx]
	mov	QWORD PTR [rsp+72], r12
	mov	rbx, rcx
	cmp	r10, QWORD PTR [rcx+4]
	je	SHORT $LN17@rescale
	npad	8
$LL19@rescale:
	movzx	eax, WORD PTR [r10-10]
	movzx	r9d, WORD PTR [r10]
	mov	rdx, QWORD PTR [r10+2]
	mov	WORD PTR [r10], ax
	mov	rax, QWORD PTR [r10-8]
	lea	r8, QWORD PTR [r10-10]
	mov	QWORD PTR [r10+2], rax
	mov	QWORD PTR [r10-8], rdx
	mov	WORD PTR [r8], r9w
	mov	r10, r8
	cmp	r8, QWORD PTR [rcx+4]
	jne	SHORT $LL19@rescale
$LN17@rescale:

; 402  :     p->Freq += 4;                           SummFreq += 4;

	add	BYTE PTR [r10+1], 4
	add	WORD PTR [rcx+2], 4
	movzx	edi, WORD PTR [rcx+2]

; 403  :     EscFreq=SummFreq-p->Freq;

	movzx	eax, BYTE PTR [r10+1]
	lea	rsi, QWORD PTR [rcx+2]
	sub	edi, eax

; 404  :     Adder=(OrderFall != 0 || MRMethod > MRM_FREEZE);

	cmp	DWORD PTR OrderFall, 0
	jne	SHORT $LN22@rescale
	cmp	DWORD PTR MRMethod, 2
	jg	SHORT $LN22@rescale
	xor	r12d, r12d
	jmp	SHORT $LN23@rescale
$LN22@rescale:
	mov	r12d, 1
$LN23@rescale:

; 405  :     SummFreq = (p->Freq=(p->Freq+Adder) >> 1);

	add	eax, r12d
	mov	QWORD PTR [rsp+64], rbp
	shr	eax, 1
	mov	BYTE PTR [r10+1], al
	movzx	eax, al
	mov	WORD PTR [rsi], ax
	npad	8
$LL16@rescale:

; 406  :     do {
; 407  :         EscFreq -= (++p)->Freq;

	movzx	eax, BYTE PTR [r10+11]
	add	r10, 10

; 408  :         SummFreq += (p->Freq=(p->Freq+Adder) >> 1);

	lea	ecx, DWORD PTR [rax+r12]
	sub	edi, eax
	shr	ecx, 1
	movzx	eax, cl
	mov	BYTE PTR [r10+1], cl
	add	WORD PTR [rsi], ax

; 409  :         if (p[0].Freq > p[-1].Freq) {

	movzx	eax, BYTE PTR [r10-9]
	cmp	BYTE PTR [r10+1], al
	jbe	SHORT $LN15@rescale

; 410  :             StateCpy(tmp,*(p1=p));

	movzx	r9d, WORD PTR [r10]
	mov	rbp, QWORD PTR [r10+2]
	mov	rdx, r10
	mov	WORD PTR tmp$[rsp], r9w
	movzx	r8d, BYTE PTR tmp$[rsp+1]
	npad	3
$LL12@rescale:

; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);

	movzx	eax, WORD PTR [rdx-10]
	lea	rcx, QWORD PTR [rdx-10]
	mov	WORD PTR [rdx], ax
	mov	rax, QWORD PTR [rdx-8]
	mov	QWORD PTR [rdx+2], rax
	mov	rdx, rcx
	cmp	r8b, BYTE PTR [rcx-9]
	ja	SHORT $LL12@rescale

; 412  :             StateCpy(*p1,tmp);

	mov	WORD PTR [rcx], r9w
	mov	QWORD PTR [rcx+2], rbp
$LN15@rescale:

; 413  :         }
; 414  :     } while ( --i );

	dec	r11d
	jne	SHORT $LL16@rescale

; 415  :     if (p->Freq == 0) {

	mov	r12, QWORD PTR [rsp+72]
	inc	r10
	cmp	BYTE PTR [r10], r11b
	jne	$LN1@rescale
	npad	6
$LL8@rescale:

; 416  :         do { i++; } while ((--p)->Freq == 0);

	sub	r10, 10
	inc	r11d
	cmp	BYTE PTR [r10], 0
	je	SHORT $LL8@rescale

; 417  :         EscFreq += i;                       OldNU=(NumStats+2) >> 1;

	movzx	eax, BYTE PTR [rbx]
	add	edi, r11d
	lea	ebp, DWORD PTR [rax+2]
	sar	ebp, 1

; 418  :         if ((NumStats -= i) == 0) {

	sub	al, r11b
	mov	BYTE PTR [rbx], al
	jne	$LN5@rescale

; 419  :             StateCpy(tmp,*Stats);

	mov	r10, QWORD PTR [rbx+4]

; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;

	xor	edx, edx

; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;
; 422  :             FreeUnits(Stats,OldNU);         StateCpy(oneState(),tmp);

	lea	r11, OFFSET FLAT:__ImageBase
	movzx	eax, WORD PTR [r10]
	mov	r9, QWORD PTR [r10+2]

; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);
; 424  :             FoundState=&oneState();         return;

	mov	QWORD PTR FoundState, rsi
	mov	WORD PTR tmp$[rsp], ax
	shr	ax, 8
	movzx	eax, al
	lea	eax, DWORD PTR [rdi+rax*2-1]
	div	edi
	mov	edx, 41					; 00000029H
	cmp	al, dl
	movzx	ecx, al
	lea	eax, DWORD PTR [rbp-1]
	movzx	eax, BYTE PTR Units2Indx[rax+r11]
	cmova	ecx, edx
	movzx	edx, BYTE PTR Indx2Units[rax+r11]
	lea	r8, QWORD PTR [rax+rax*2]
	mov	BYTE PTR tmp$[rsp+1], cl
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+r8*4+4]
	mov	QWORD PTR [r10+4], rax
	movzx	eax, WORD PTR tmp$[rsp]
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+r8*4+4], r10
	mov	DWORD PTR [r10], -1			; ffffffffH
	mov	DWORD PTR [r10+12], edx
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+r8*4]
	cmp	al, 64					; 00000040H
	mov	WORD PTR [rsi], ax
	mov	QWORD PTR [rsi+2], r9
	movzx	eax, BYTE PTR [rbx+1]
	setae	cl
	and	al, 16
	shl	cl, 3
	add	cl, al
	mov	BYTE PTR [rbx+1], cl
	jmp	SHORT $LN20@rescale
$LN5@rescale:

; 425  :         }
; 426  :         Stats = (STATE*) ShrinkUnits(Stats,OldNU,(NumStats+2) >> 1);

	mov	rcx, QWORD PTR [rbx+4]
	movzx	r8d, al
	mov	edx, ebp
	add	r8d, 2
	sar	r8d, 1
	call	?ShrinkUnits@@YAPEAXPEAXII@Z		; ShrinkUnits

; 427  :         Flags &= ~0x08;                     i=NumStats;

	and	BYTE PTR [rbx+1], 247			; 000000f7H
	movzx	edx, BYTE PTR [rbx]
	mov	QWORD PTR [rbx+4], rax

; 428  :         Flags |= 0x08*((p=Stats)->Symbol >= 0x40);

	cmp	BYTE PTR [rax], 64			; 00000040H
	mov	r11, rax
	setae	cl
	shl	cl, 3
	or	cl, BYTE PTR [rbx+1]
	mov	BYTE PTR [rbx+1], cl
	npad	10
$LL3@rescale:

; 429  :         do { Flags |= 0x08*((++p)->Symbol >= 0x40); } while ( --i );

	add	r11, 10
	cmp	BYTE PTR [r11], 64			; 00000040H
	setae	al
	shl	al, 3
	or	cl, al
	dec	edx
	mov	BYTE PTR [rbx+1], cl
	jne	SHORT $LL3@rescale
$LN1@rescale:

; 430  :     }
; 431  :     SummFreq += (EscFreq -= (EscFreq >> 1));

	mov	eax, edi
	shr	eax, 1
	sub	di, ax

; 432  :     Flags |= 0x04;                          FoundState=Stats;

	mov	rax, QWORD PTR [rbx+4]
	add	WORD PTR [rsi], di
	or	BYTE PTR [rbx+1], 4
	mov	QWORD PTR FoundState, rax
$LN20@rescale:

; 433  : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?rescale@PPM_CONTEXT@@QEAAXXZ ENDP			; PPM_CONTEXT::rescale
_TEXT	ENDS
PUBLIC	?refresh@PPM_CONTEXT@@QEAAXHH@Z			; PPM_CONTEXT::refresh
pdata	SEGMENT
$pdata$?refresh@PPM_CONTEXT@@QEAAXHH@Z DD imagerel $LN7
	DD	imagerel $LN7+196
	DD	imagerel $unwind$?refresh@PPM_CONTEXT@@QEAAXHH@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?refresh@PPM_CONTEXT@@QEAAXHH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
OldNU$ = 56
Scale$ = 64
?refresh@PPM_CONTEXT@@QEAAXHH@Z PROC			; PPM_CONTEXT::refresh

; 251  : {

$LN7:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 252  :     int i=NumStats, EscFreq;

	movzx	esi, BYTE PTR [rcx]
	mov	edi, r8d
	mov	rbx, rcx

; 253  :     STATE* p = Stats = (STATE*) ShrinkUnits(Stats,OldNU,(i+2) >> 1);

	mov	rcx, QWORD PTR [rcx+4]
	lea	r8d, DWORD PTR [rsi+2]
	sar	r8d, 1
	call	?ShrinkUnits@@YAPEAXPEAXII@Z		; ShrinkUnits

; 254  :     Flags=(Flags & (0x10+0x04*Scale))+0x08*(p->Symbol >= 0x40);
; 255  :     EscFreq=SummFreq-p->Freq;

	movzx	r9d, WORD PTR [rbx+2]
	lea	edx, DWORD PTR [rdi+4]
	shl	dl, 2
	mov	QWORD PTR [rbx+4], rax
	mov	r11, rax
	and	dl, BYTE PTR [rbx+1]
	cmp	BYTE PTR [rax], 64			; 00000040H
	setae	cl
	shl	cl, 3
	add	dl, cl

; 256  :     SummFreq = (p->Freq=(p->Freq+Scale) >> Scale);

	mov	ecx, edi
	mov	BYTE PTR [rbx+1], dl
	movzx	eax, BYTE PTR [rax+1]
	lea	edx, DWORD PTR [rax+rdi]
	sub	r9d, eax
	sar	edx, cl
	movzx	eax, dl
	mov	BYTE PTR [r11+1], dl
	mov	WORD PTR [rbx+2], ax
	npad	12
$LL3@refresh:

; 257  :     do {
; 258  :         EscFreq -= (++p)->Freq;

	movzx	eax, BYTE PTR [r11+11]
	add	r11, 10

; 259  :         SummFreq += (p->Freq=(p->Freq+Scale) >> Scale);

	mov	ecx, edi
	sub	r9d, eax
	lea	edx, DWORD PTR [rax+rdi]
	sar	edx, cl
	mov	BYTE PTR [r11+1], dl
	movzx	r8d, dl
	add	r8w, WORD PTR [rbx+2]
	mov	WORD PTR [rbx+2], r8w

; 260  :         Flags |= 0x08*(p->Symbol >= 0x40);

	cmp	BYTE PTR [r11], 64			; 00000040H
	setae	al
	shl	al, 3
	or	BYTE PTR [rbx+1], al

; 261  :     } while ( --i );

	dec	esi
	jne	SHORT $LL3@refresh

; 262  :     SummFreq += (EscFreq=(EscFreq+Scale) >> Scale);
; 263  : }

	mov	rsi, QWORD PTR [rsp+56]
	lea	eax, DWORD PTR [r9+rdi]
	sar	eax, cl
	add	ax, r8w
	mov	WORD PTR [rbx+2], ax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?refresh@PPM_CONTEXT@@QEAAXHH@Z ENDP			; PPM_CONTEXT::refresh
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	ENDS
;	COMDAT ?AllocContext@@YAPEAXXZ
_TEXT	SEGMENT
?AllocContext@@YAPEAXXZ PROC				; AllocContext, COMDAT

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	mov	rax, QWORD PTR HiUnit
	cmp	rax, QWORD PTR LoUnit
	je	SHORT $LN4@AllocConte
	sub	rax, 12
	mov	QWORD PTR HiUnit, rax

; 135  : }

	ret	0
$LN4@AllocConte:

; 133  :     else if ( BList->avail() )              return BList->remove();

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rax, rax
	je	SHORT $LN2@AllocConte
	mov	rcx, QWORD PTR [rax+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rcx

; 135  : }

	ret	0
$LN2@AllocConte:

; 134  :     else                                    return AllocUnitsRare(0);

	xor	ecx, ecx

; 135  : }

	jmp	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
?AllocContext@@YAPEAXXZ ENDP				; AllocContext
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AllocUnits@@YAPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+138
	DD	imagerel $unwind$?AllocUnits@@YAPEAXI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AllocUnits@@YAPEAXI@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?AllocUnits@@YAPEAXI@Z
_TEXT	SEGMENT
NU$ = 48
?AllocUnits@@YAPEAXI@Z PROC				; AllocUnits, COMDAT

; 123  : {

$LN15:
	sub	rsp, 40					; 00000028H

; 124  :     UINT indx=Units2Indx[NU-1];

	lea	r10, OFFSET FLAT:__ImageBase
	lea	eax, DWORD PTR [rcx-1]
	movzx	r9d, BYTE PTR Units2Indx[rax+r10]

; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();

	lea	rdx, QWORD PTR [r9+r9*2]
	cmp	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rdx*4+4], 0
	je	SHORT $LN2@AllocUnits@2
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rdx*4+4]
	mov	rcx, QWORD PTR [rax+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rdx*4]
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rdx*4+4], rcx

; 129  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@AllocUnits@2:

; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);

	mov	r8, QWORD PTR LoUnit
	movzx	ecx, BYTE PTR Indx2Units[r9+r10]
	lea	ecx, DWORD PTR [rcx+rcx*2]
	mov	rax, r8
	shl	ecx, 2
	add	r8, rcx

; 127  :     if (LoUnit <= HiUnit)                   return RetVal;

	cmp	r8, QWORD PTR HiUnit
	mov	QWORD PTR LoUnit, r8
	jbe	SHORT $LN3@AllocUnits@2

; 128  :     LoUnit -= U2B(Indx2Units[indx]);        return AllocUnitsRare(indx);

	sub	r8, rcx
	mov	ecx, r9d
	mov	QWORD PTR LoUnit, r8
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
$LN3@AllocUnits@2:

; 129  : }

	add	rsp, 40					; 00000028H
	ret	0
?AllocUnits@@YAPEAXI@Z ENDP				; AllocUnits
InitRL	DD	01H DUP (?)
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
pdata	SEGMENT
$pdata$?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z
_TEXT	SEGMENT
this$ = 48
p$ = 56
?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z PROC		; PPM_CONTEXT::update2, COMDAT

; 718  : {

$LN5:
	sub	rsp, 40					; 00000028H

; 719  : /*
; 720  :     ++EscCount;
; 721  :     RunLength = InitRL;
; 722  : */
; 723  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	add	BYTE PTR [rdx+1], 4
	add	WORD PTR [rcx+2], 4

; 724  :     if (p->Freq > MAX_FREQ)                 rescale();

	cmp	BYTE PTR [rdx+1], 124			; 0000007cH
	mov	QWORD PTR FoundState, rdx
	jbe	SHORT $LN4@update2
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN4@update2:

; 725  :     EscCount++;                             RunLength=InitRL;

	mov	eax, DWORD PTR InitRL
	inc	BYTE PTR EscCount
	mov	DWORD PTR RunLength, eax

; 726  : }

	add	rsp, 40					; 00000028H
	ret	0
?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z ENDP		; PPM_CONTEXT::update2
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z DD imagerel $LN7
	DD	imagerel $LN7+92
	DD	imagerel $unwind$?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z
_TEXT	SEGMENT
this$ = 48
p$ = 56
?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z PROC		; PPM_CONTEXT::update1, COMDAT

; 659  : {

$LN7:
	sub	rsp, 40					; 00000028H

; 660  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	add	BYTE PTR [rdx+1], 4
	add	WORD PTR [rcx+2], 4

; 661  :     if (p[0].Freq > p[-1].Freq) {

	movzx	eax, BYTE PTR [rdx-9]
	mov	r10, rdx
	mov	QWORD PTR FoundState, rdx
	cmp	BYTE PTR [rdx+1], al
	jbe	SHORT $LN1@update1

; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;

	movzx	eax, WORD PTR [rdx-10]
	movzx	r8d, WORD PTR [rdx]
	lea	r9, QWORD PTR [rdx-10]
	mov	rdx, QWORD PTR [rdx+2]
	mov	WORD PTR [r10], ax
	mov	rax, QWORD PTR [r9+2]
	mov	QWORD PTR [r10+2], rax
	mov	WORD PTR [r9], r8w
	mov	QWORD PTR [r9+2], rdx

; 663  :         if (p->Freq > MAX_FREQ)             rescale();

	cmp	BYTE PTR [r9+1], 124			; 0000007cH
	mov	QWORD PTR FoundState, r9
	jbe	SHORT $LN1@update1
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN1@update1:

; 664  :     }
; 665  : }

	add	rsp, 40					; 00000028H
	ret	0
?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z ENDP		; PPM_CONTEXT::update1
_TEXT	ENDS
pdata	SEGMENT
$pdata$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z DD imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
	DD	imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z+253
	DD	imagerel $unwind$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
$pdata$3$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z DD imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z+253
	DD	imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z+568
	DD	imagerel $chain$3$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z DD 06eb01H
	DD	01c54ebH
	DD	019010aH
	DD	030026003H
$chain$3$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z DD 061b21H
	DD	018d41bH
	DD	01ec410H
	DD	01d7408H
	DD	imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
	DD	imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z+253
	DD	imagerel $unwind$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
ct$ = 32
ps$ = 64
Skip$ = 224
p$ = 232
pc$ = 240
?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z PROC ; CreateSuccessors

; 436  : {

	push	rbx
	push	rsi
	sub	rsp, 200				; 000000c8H

; 437  : 
; 438  :     PPM_CONTEXT ct, * UpBranch=FoundState->Successor;

	mov	rax, QWORD PTR FoundState
	mov	rbx, r8
	mov	r9, rdx
	mov	r10, QWORD PTR [rax+2]

; 439  :     PPM_CONTEXT::STATE* ps[MAX_O], ** pps=ps;
; 440  :     UINT cf, s0;
; 441  :     BYTE tmp, sym=FoundState->Symbol;

	movzx	r8d, BYTE PTR [rax]
	lea	rsi, QWORD PTR ps$[rsp]

; 442  :     if ( !Skip ) {

	test	ecx, ecx
	jne	SHORT $LN25@CreateSucc

; 443  :         *pps++ = FoundState;
; 444  :         if ( !pc->Suffix )                  goto NO_LOOP;

	cmp	QWORD PTR [rbx+12], 0
	mov	QWORD PTR ps$[rsp], rax
	lea	rsi, QWORD PTR ps$[rsp+8]
	je	$LN11@CreateSucc
$LN25@CreateSucc:

; 445  :     }
; 446  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }

	test	rdx, rdx
	je	SHORT $LN21@CreateSucc
	mov	rbx, QWORD PTR [rbx+12]
	jmp	SHORT $LOOP_ENTRY$68023
$LN21@CreateSucc:

; 447  :     do {
; 448  :         pc=pc->Suffix;

	mov	rbx, QWORD PTR [rbx+12]

; 449  :         if ( pc->NumStats ) {

	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN18@CreateSucc

; 450  :             if ((p=pc->Stats)->Symbol != sym)

	mov	r9, QWORD PTR [rbx+4]
	cmp	BYTE PTR [r9], r8b
	je	SHORT $LN14@CreateSucc
	npad	6
$LL16@CreateSucc:

; 451  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);

	add	r9, 10
	cmp	BYTE PTR [r9], r8b
	jne	SHORT $LL16@CreateSucc
$LN14@CreateSucc:

; 452  :             tmp=(p->Freq < MAX_FREQ-9);

	movzx	ecx, BYTE PTR [r9+1]
	cmp	cl, 115					; 00000073H
	setb	al

; 453  :             p->Freq += tmp;                 pc->SummFreq += tmp;

	add	cl, al
	movzx	eax, al
	mov	BYTE PTR [r9+1], cl
	add	WORD PTR [rbx+2], ax

; 454  :         } else {

	jmp	SHORT $LOOP_ENTRY$68023
$LN18@CreateSucc:

; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));

	mov	rax, QWORD PTR [rbx+12]
	movzx	edx, BYTE PTR [rbx+3]
	lea	r9, QWORD PTR [rbx+2]
	cmp	BYTE PTR [rax], 0
	sete	cl
	cmp	dl, 24
	setb	al
	and	cl, al
	add	cl, dl
	mov	BYTE PTR [r9+1], cl
$LOOP_ENTRY$68023:

; 457  :         }
; 458  : LOOP_ENTRY:
; 459  :         if (p->Successor != UpBranch) {

	cmp	QWORD PTR [r9+2], r10
	jne	SHORT $LN58@CreateSucc

; 461  :         }
; 462  :         *pps++ = p;

	mov	QWORD PTR [rsi], r9
	add	rsi, 8

; 463  :     } while ( pc->Suffix );

	cmp	QWORD PTR [rbx+12], 0
	jne	SHORT $LN21@CreateSucc
	jmp	SHORT $LN19@CreateSucc
$LN58@CreateSucc:

; 460  :             pc=p->Successor;                break;

	mov	rbx, QWORD PTR [r9+2]
$LN19@CreateSucc:

; 464  : NO_LOOP:
; 465  :     if (pps == ps)                          return pc;

	lea	rax, QWORD PTR ps$[rsp]
$NO_LOOP$68020:
	cmp	rsi, rax
	jne	SHORT $LN11@CreateSucc
	mov	rax, rbx

; 485  : }

	add	rsp, 200				; 000000c8H
	pop	rsi
	pop	rbx
	ret	0
$LN11@CreateSucc:

; 466  :     ct.NumStats=0;                          ct.Flags=0x10*(sym >= 0x40);
; 467  :     ct.oneState().Symbol=sym=*(BYTE*) UpBranch;

	movzx	edx, BYTE PTR [r10]

; 468  :     ct.oneState().Successor=(PPM_CONTEXT*) (((BYTE*) UpBranch)+1);
; 469  :     ct.Flags |= 0x08*(sym >= 0x40);
; 470  :     if ( pc->NumStats ) {

	movzx	r9d, BYTE PTR [rbx]
	cmp	r8b, 64					; 00000040H
	setae	cl
	mov	QWORD PTR [rsp+224], rbp
	lea	rax, QWORD PTR [r10+1]
	shl	cl, 4
	cmp	dl, 64					; 00000040H
	mov	QWORD PTR ct$[rsp+4], rax
	setae	al
	mov	QWORD PTR [rsp+232], rdi
	mov	QWORD PTR [rsp+240], r12
	shl	al, 3
	mov	QWORD PTR [rsp+192], r13
	mov	BYTE PTR ct$[rsp], 0
	or	cl, al
	mov	BYTE PTR ct$[rsp+2], dl
	mov	BYTE PTR ct$[rsp+1], cl
	test	r9b, r9b
	je	SHORT $LN10@CreateSucc

; 471  :         if ((p=pc->Stats)->Symbol != sym)

	mov	rax, QWORD PTR [rbx+4]
	cmp	BYTE PTR [rax], dl
	je	SHORT $LN6@CreateSucc
$LL8@CreateSucc:

; 472  :                 do { tmp=p[1].Symbol;       p++; } while (tmp != sym);

	add	rax, 10
	cmp	BYTE PTR [rax], dl
	jne	SHORT $LL8@CreateSucc
$LN6@CreateSucc:

; 473  :         s0=pc->SummFreq-pc->NumStats-(cf=p->Freq-1);

	movzx	ecx, BYTE PTR [rax+1]
	movzx	r8d, WORD PTR [rbx+2]
	movzx	eax, r9b
	dec	ecx
	sub	r8d, eax

; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));

	lea	eax, DWORD PTR [rcx+rcx]
	sub	r8d, ecx
	cmp	eax, r8d
	ja	SHORT $LN29@CreateSucc
	lea	eax, DWORD PTR [rcx+rcx*4]
	xor	ecx, ecx
	cmp	eax, r8d
	seta	cl
	inc	cl
	mov	BYTE PTR ct$[rsp+3], cl

; 475  :     } else

	jmp	SHORT $LN62@CreateSucc
$LN29@CreateSucc:

; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));

	lea	eax, DWORD PTR [rcx+r8*2-3]
	xor	edx, edx
	div	r8d
	mov	ecx, eax
	inc	cl
	mov	BYTE PTR ct$[rsp+3], cl

; 475  :     } else

	jmp	SHORT $LN62@CreateSucc
$LN10@CreateSucc:

; 476  :             ct.oneState().Freq=pc->oneState().Freq;

	movzx	eax, BYTE PTR [rbx+3]
	mov	BYTE PTR ct$[rsp+3], al
$LN62@CreateSucc:
	mov	r12d, DWORD PTR ct$[rsp+4]
	mov	r13d, DWORD PTR ct$[rsp]
	mov	rbp, QWORD PTR LoUnit
	mov	rdi, QWORD PTR HiUnit
$LL4@CreateSucc:

; 477  :     do {
; 478  :         PPM_CONTEXT* pc1 = (PPM_CONTEXT*) AllocContext();

	cmp	rdi, rbp
	je	SHORT $LN46@CreateSucc
	sub	rdi, 12
	mov	QWORD PTR HiUnit, rdi
	mov	rdx, rdi
	jmp	SHORT $LN43@CreateSucc
$LN46@CreateSucc:
	mov	rdx, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rdx, rdx
	je	SHORT $LN44@CreateSucc
	mov	rax, QWORD PTR [rdx+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rax
	jmp	SHORT $LN43@CreateSucc
$LN44@CreateSucc:
	xor	ecx, ecx
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
	mov	rdx, rax
$LN43@CreateSucc:

; 479  :         if ( !pc1 )                         return NULL;

	test	rdx, rdx
	je	SHORT $LN59@CreateSucc

; 480  :         ((DWORD*) pc1)[0] = ((DWORD*) &ct)[0];
; 481  :         ((DWORD*) pc1)[1] = ((DWORD*) &ct)[1];
; 482  :         pc1->Suffix=pc;                     (*--pps)->Successor=pc=pc1;

	mov	rcx, QWORD PTR [rsi-8]
	sub	rsi, 8
	mov	QWORD PTR [rdx+12], rbx

; 483  :     } while (pps != ps);

	lea	rax, QWORD PTR ps$[rsp]
	mov	DWORD PTR [rdx], r13d
	mov	DWORD PTR [rdx+4], r12d
	mov	QWORD PTR [rcx+2], rdx
	mov	rbx, rdx
	cmp	rsi, rax
	jne	SHORT $LL4@CreateSucc

; 484  :     return pc;

	mov	rax, rdx
	jmp	SHORT $LN66@CreateSucc
$LN59@CreateSucc:

; 479  :         if ( !pc1 )                         return NULL;

	xor	eax, eax
$LN66@CreateSucc:
	mov	r12, QWORD PTR [rsp+240]
	mov	rdi, QWORD PTR [rsp+232]
	mov	rbp, QWORD PTR [rsp+224]
	mov	r13, QWORD PTR [rsp+192]

; 485  : }

	add	rsp, 200				; 000000c8H
	pop	rsi
	pop	rbx
	ret	0
?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z ENDP ; CreateSuccessors
_TEXT	ENDS
pdata	SEGMENT
$pdata$?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z DD imagerel ?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z
	DD	imagerel ?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z+386
	DD	imagerel $unwind$?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z DD 0b1d01H
	DD	019741dH
	DD	018641dH
	DD	017541dH
	DD	016341dH
	DD	014011dH
	DD	0c016H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
ps$ = 32
p$ = 176
pc$ = 184
?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z PROC ; ReduceOrder

; 358  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	sub	rsp, 160				; 000000a0H

; 359  :     PPM_CONTEXT::STATE* p1,  * ps[MAX_O], ** pps=ps;
; 360  :     PPM_CONTEXT* pc1=pc, * UpBranch = (PPM_CONTEXT*) pText;
; 361  :     BYTE tmp, sym=FoundState->Symbol;

	mov	rbp, QWORD PTR FoundState

; 362  :     *pps++ = FoundState;                    FoundState->Successor=UpBranch;
; 363  :     OrderFall++;

	mov	edi, DWORD PTR OrderFall
	mov	rsi, QWORD PTR pText
	movzx	r9d, BYTE PTR [rbp]
	inc	edi
	mov	rbx, rcx
	mov	r12, rdx
	mov	QWORD PTR ps$[rsp], rbp
	lea	r8, QWORD PTR ps$[rsp+8]
	mov	DWORD PTR OrderFall, edi
	mov	QWORD PTR [rbp+2], rsi

; 364  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }

	test	rcx, rcx
	je	SHORT $LN18@ReduceOrde@2
	mov	rdx, QWORD PTR [rdx+12]
	jmp	SHORT $LOOP_ENTRY$67953
$LN18@ReduceOrde@2:

; 365  :     for ( ; ; ) {
; 366  :         if ( !pc->Suffix ) {

	mov	rax, QWORD PTR [rdx+12]
	test	rax, rax
	je	$LN28@ReduceOrde@2

; 372  :         }
; 373  :         pc=pc->Suffix;
; 374  :         if ( pc->NumStats ) {

	cmp	BYTE PTR [rax], 0
	mov	rdx, rax
	je	SHORT $LN11@ReduceOrde@2

; 375  :             if ((p=pc->Stats)->Symbol != sym)

	mov	rbx, QWORD PTR [rax+4]
	cmp	BYTE PTR [rbx], r9b
	je	SHORT $LN7@ReduceOrde@2
	npad	5
$LL9@ReduceOrde@2:

; 376  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);

	add	rbx, 10
	cmp	BYTE PTR [rbx], r9b
	jne	SHORT $LL9@ReduceOrde@2
$LN7@ReduceOrde@2:

; 377  :             tmp=2*(p->Freq < MAX_FREQ-9);

	movzx	ecx, BYTE PTR [rbx+1]
	cmp	cl, 115					; 00000073H
	setb	al
	add	al, al

; 378  :             p->Freq += tmp;                 pc->SummFreq += tmp;

	add	cl, al
	movzx	eax, al
	mov	BYTE PTR [rbx+1], cl
	add	WORD PTR [rdx+2], ax

; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }

	jmp	SHORT $LOOP_ENTRY$67953
$LN11@ReduceOrde@2:
	lea	rbx, QWORD PTR [rax+2]
	movzx	eax, BYTE PTR [rax+3]
	cmp	al, 32					; 00000020H
	adc	al, 0
	mov	BYTE PTR [rbx+1], al
$LOOP_ENTRY$67953:

; 380  : LOOP_ENTRY:
; 381  :         if ( p->Successor )                 break;

	cmp	QWORD PTR [rbx+2], 0
	jne	SHORT $LN29@ReduceOrde@2

; 382  :         *pps++ = p;                         p->Successor=UpBranch;

	mov	QWORD PTR [r8], rbx
	add	r8, 8

; 383  :         OrderFall++;

	inc	edi
	mov	DWORD PTR OrderFall, edi
	mov	QWORD PTR [rbx+2], rsi

; 384  :     }

	jmp	SHORT $LN18@ReduceOrde@2
$LN29@ReduceOrde@2:

; 385  :     if (MRMethod > MRM_FREEZE) {

	cmp	DWORD PTR MRMethod, 2
	jle	SHORT $LN4@ReduceOrde@2

; 386  :         pc = p->Successor;                  goto FROZEN;

	mov	rdx, QWORD PTR [rbx+2]
	jmp	SHORT $FROZEN$67960
$LN4@ReduceOrde@2:

; 387  :     } else if (p->Successor <= UpBranch) {

	cmp	QWORD PTR [rbx+2], rsi
	ja	SHORT $LN2@ReduceOrde@2

; 388  :         p1=FoundState;                      FoundState=p;
; 389  :         p->Successor=CreateSuccessors(FALSE,NULL,pc);

	mov	r8, rdx
	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR FoundState, rbx
	call	?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z ; CreateSuccessors

; 390  :         FoundState=p1;

	mov	QWORD PTR FoundState, rbp
	mov	QWORD PTR [rbx+2], rax
$LN2@ReduceOrde@2:

; 391  :     }
; 392  :     if (OrderFall == 1 && pc1 == MaxContext) {

	cmp	edi, 1
	jne	SHORT $LN1@ReduceOrde@2
	cmp	r12, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	jne	SHORT $LN1@ReduceOrde@2

; 393  :         FoundState->Successor=p->Successor; pText--;

	mov	rax, QWORD PTR [rbx+2]
	dec	rsi
	mov	QWORD PTR [rbp+2], rax
	mov	QWORD PTR pText, rsi
$LN1@ReduceOrde@2:

; 394  :     }
; 395  :     return p->Successor;

	mov	rax, QWORD PTR [rbx+2]
	jmp	SHORT $LN21@ReduceOrde@2
$LN28@ReduceOrde@2:

; 367  :             if (MRMethod > MRM_FREEZE) {

	cmp	DWORD PTR MRMethod, 2
	jle	SHORT $LN15@ReduceOrde@2
$FROZEN$67960:

; 368  : FROZEN:         do { (*--pps)->Successor = pc; } while (pps != ps);

	mov	rax, QWORD PTR [r8-8]
	sub	r8, 8
	mov	QWORD PTR [rax+2], rdx
	lea	rax, QWORD PTR ps$[rsp]
	cmp	r8, rax
	jne	SHORT $FROZEN$67960

; 369  :                 pText=HeapStart+1;          OrderFall=1;

	mov	rax, QWORD PTR HeapStart
	mov	DWORD PTR OrderFall, 1
	inc	rax
	mov	QWORD PTR pText, rax
$LN15@ReduceOrde@2:

; 370  :             }
; 371  :             return pc;

	mov	rax, rdx
$LN21@ReduceOrde@2:

; 396  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r12
	ret	0
?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z ENDP ; ReduceOrder
_TEXT	ENDS
PUBLIC	?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z		; PPM_CONTEXT::cutOff
pdata	SEGMENT
$pdata$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN64
	DD	imagerel $LN64+118
	DD	imagerel $unwind$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$0$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN64+118
	DD	imagerel $LN64+285
	DD	imagerel $chain$0$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$1$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN64+285
	DD	imagerel $LN64+644
	DD	imagerel $chain$1$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 040b01H
	DD	07007320bH
	DD	050056006H
$chain$0$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN64
	DD	imagerel $LN64+118
	DD	imagerel $unwind$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
$chain$1$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+118
	DD	imagerel $unwind$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
tmp$1$ = 64
this$ = 64
Order$ = 72
?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z PROC			; PPM_CONTEXT::cutOff

; 267  : {

$LN64:
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 268  :     int i, tmp;
; 269  :     STATE* p;
; 270  :     if ( !NumStats ) {

	cmp	BYTE PTR [rcx], 0

; 271  :         if ((BYTE*) (p=&oneState())->Successor >= UnitsStart) {

	mov	rax, QWORD PTR [rcx+4]
	mov	rdi, rcx
	jne	SHORT $LN13@cutOff
	cmp	rax, QWORD PTR UnitsStart
	jb	$REMOVE$67867

; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);

	cmp	edx, DWORD PTR MaxOrder
	jge	SHORT $LN17@cutOff
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR [rcx+4]
	inc	edx
	call	?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z	; PPM_CONTEXT::cutOff
	mov	edx, DWORD PTR Order$[rsp]
	mov	QWORD PTR [rdi+4], rax
	jmp	SHORT $LN16@cutOff
$LN17@cutOff:

; 273  :             else                            p->Successor=NULL;

	xor	ebp, ebp
	mov	QWORD PTR [rcx+4], rbp
$LN16@cutOff:

; 274  :             if (!p->Successor && Order > O_BOUND)

	cmp	QWORD PTR [rdi+4], 0
	jne	$LN1@cutOff
	cmp	edx, 9
	jg	$REMOVE$67867

; 296  :     }
; 297  :     return this;

	mov	rax, rdi

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN13@cutOff:

; 279  :         }
; 280  :     }
; 281  :     PrefetchData(Stats);

	movzx	ecx, BYTE PTR [rax]

; 282  :     Stats = (STATE*) MoveUnitsUp(Stats,tmp=(NumStats+2) >> 1);

	movzx	eax, BYTE PTR [rdi]
	mov	rcx, QWORD PTR [rdi+4]
	add	eax, 2
	mov	QWORD PTR [rsp+80], rbx
	sar	eax, 1
	mov	edx, eax
	mov	DWORD PTR tmp$1$[rsp], eax
	call	?MoveUnitsUp@@YAPEAXPEAXI@Z		; MoveUnitsUp

; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)

	movzx	esi, BYTE PTR [rdi]
	xor	ebp, ebp
	lea	rdx, QWORD PTR [rsi+rsi*4]
	mov	QWORD PTR [rdi+4], rax
	lea	rbx, QWORD PTR [rax+rdx*2]
	cmp	rbx, rax
	jb	SHORT $LN62@cutOff
	npad	2
$LL12@cutOff:

; 284  :             if ((BYTE*) p->Successor < UnitsStart) {

	mov	rax, QWORD PTR [rbx+2]
	cmp	rax, QWORD PTR UnitsStart
	jae	SHORT $LN9@cutOff

; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);

	movzx	ecx, WORD PTR [rbx]
	mov	QWORD PTR [rbx+2], rbp
	mov	rdx, QWORD PTR [rdi+4]
	movsxd	rax, esi
	dec	esi
	lea	r8, QWORD PTR [rax+rax*4]
	movzx	eax, WORD PTR [rdx+r8*2]
	mov	WORD PTR [rbx], ax
	mov	rax, QWORD PTR [rdx+r8*2+2]
	mov	QWORD PTR [rbx+2], rax
	mov	WORD PTR [rdx+r8*2], cx
	mov	QWORD PTR [rdx+r8*2+2], rbp
	jmp	SHORT $LN11@cutOff
$LN9@cutOff:

; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);

	mov	ecx, DWORD PTR Order$[rsp]
	cmp	ecx, DWORD PTR MaxOrder
	jge	SHORT $LN7@cutOff
	movzx	eax, BYTE PTR [rax]
	lea	edx, DWORD PTR [rcx+1]
	mov	rcx, QWORD PTR [rbx+2]
	call	?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z	; PPM_CONTEXT::cutOff
	mov	QWORD PTR [rbx+2], rax
	jmp	SHORT $LN11@cutOff
$LN7@cutOff:

; 287  :             else                            p->Successor=NULL;

	mov	QWORD PTR [rbx+2], rbp
$LN11@cutOff:

; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)

	sub	rbx, 10
	cmp	rbx, QWORD PTR [rdi+4]
	jae	SHORT $LL12@cutOff
$LN62@cutOff:

; 288  :     if (i != NumStats && Order) {

	movzx	eax, BYTE PTR [rdi]
	mov	rbx, QWORD PTR [rsp+80]
	cmp	esi, eax
	je	$LN1@cutOff
	cmp	DWORD PTR Order$[rsp], ebp
	je	$LN1@cutOff

; 289  :         NumStats=i;                         p=Stats;

	mov	r10, QWORD PTR [rdi+4]
	mov	BYTE PTR [rdi], sil

; 290  :         if (i < 0) { FreeUnits(p,tmp);      goto REMOVE; }

	test	esi, esi
	jns	$LN63@cutOff
	mov	eax, DWORD PTR tmp$1$[rsp]
	lea	r9, OFFSET FLAT:__ImageBase
	dec	eax
	movzx	eax, BYTE PTR Units2Indx[rax+r9]
	movzx	edx, BYTE PTR Indx2Units[rax+r9]
	lea	r8, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4+4]
	mov	QWORD PTR [r10+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4+4], r10
	mov	DWORD PTR [r10], -1			; ffffffffH
	mov	DWORD PTR [r10+12], edx
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4]
$REMOVE$67867:

; 275  :                     goto REMOVE;
; 276  :             return this;
; 277  :         } else {
; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;

	cmp	rdi, QWORD PTR UnitsStart
	je	SHORT $LN27@cutOff
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	mov	QWORD PTR [rdi+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rdi
	mov	DWORD PTR [rdi], -1			; ffffffffH
	mov	DWORD PTR [rdi+12], 1
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A
	xor	eax, eax

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0

; 275  :                     goto REMOVE;
; 276  :             return this;
; 277  :         } else {
; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;

$LN27@cutOff:
	add	QWORD PTR UnitsStart, 12
	mov	DWORD PTR [rdi], -1			; ffffffffH
	xor	eax, eax

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN63@cutOff:

; 291  :         else if (i == 0) {

	jne	$LN2@cutOff

; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);

	movzx	eax, BYTE PTR [rdi+1]
	cmp	BYTE PTR [r10], 64			; 00000040H

; 293  :             StateCpy(oneState(),*p);        FreeUnits(p,tmp);

	lea	r9, OFFSET FLAT:__ImageBase
	setae	cl
	and	al, 16
	shl	cl, 3
	add	cl, al
	mov	BYTE PTR [rdi+1], cl
	movzx	eax, WORD PTR [r10]
	mov	WORD PTR [rdi+2], ax
	mov	rax, QWORD PTR [r10+2]
	mov	QWORD PTR [rdi+4], rax
	mov	eax, DWORD PTR tmp$1$[rsp]
	dec	eax
	movzx	eax, BYTE PTR Units2Indx[rax+r9]
	movzx	edx, BYTE PTR Indx2Units[rax+r9]
	lea	r8, QWORD PTR [rax+rax*2]
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4+4]
	mov	QWORD PTR [r10+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4+4], r10
	mov	DWORD PTR [r10], -1			; ffffffffH
	mov	DWORD PTR [r10+12], edx
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r9+r8*4]

; 294  :             oneState().Freq=(oneState().Freq+11) >> 3;

	movzx	eax, BYTE PTR [rdi+3]
	add	eax, 11
	sar	eax, 3
	mov	BYTE PTR [rdi+3], al

; 296  :     }
; 297  :     return this;

	mov	rax, rdi

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN2@cutOff:

; 295  :         } else                              refresh(tmp,SummFreq > 16*i);

	movzx	eax, WORD PTR [rdi+2]
	mov	edx, DWORD PTR tmp$1$[rsp]
	shl	esi, 4
	cmp	eax, esi
	mov	rcx, rdi
	setg	bpl
	mov	r8d, ebp
	call	?refresh@PPM_CONTEXT@@QEAAXHH@Z		; PPM_CONTEXT::refresh
$LN1@cutOff:

; 296  :     }
; 297  :     return this;

	mov	rax, rdi

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z ENDP			; PPM_CONTEXT::cutOff
_TEXT	ENDS
PUBLIC	?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z ; PPM_CONTEXT::read
pdata	SEGMENT
$pdata$?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z DD imagerel $LN71
	DD	imagerel $LN71+824
	DD	imagerel $unwind$?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z DD 082101H
	DD	065421H
	DD	09640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
this$ = 48
fp$ = 56
EscFreq$1$ = 64
PrevSym$ = 64
?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z PROC ; PPM_CONTEXT::read

; 171  : {

$LN71:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, QWORD PTR HiUnit
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR [rsp+48], rbp
$LL63@read:

; 172  :     STATE* p;                               Suffix=NULL;

	mov	QWORD PTR [rbx+12], 0

; 173  :     NumStats=_PPMD_E_GETC(fp);                     Flags=0x10*(PrevSym >= 0x40);

	mov	eax, DWORD PTR [rdi]
	mov	rdx, QWORD PTR [rdi+16]
	add	rax, QWORD PTR [rdi+8]
	cmp	rdx, rax
	jae	SHORT $LN22@read
	movzx	ecx, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN23@read
$LN22@read:
	or	ecx, -1
$LN23@read:
	cmp	r8d, 64					; 00000040H
	mov	BYTE PTR [rbx], cl
	setae	al
	shl	al, 4
	mov	BYTE PTR [rbx+1], al

; 174  :     if ( !NumStats ) {

	test	cl, cl
	jne	$LN15@read

; 175  :         p=&oneState();                      p->Freq=_PPMD_E_GETC(fp);

	mov	eax, DWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+16]
	lea	rbp, QWORD PTR [rbx+2]
	add	rax, QWORD PTR [rdi+8]
	cmp	rcx, rax
	jae	SHORT $LN27@read
	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN28@read
$LN27@read:
	or	edx, -1
$LN28@read:
	mov	BYTE PTR [rbp+1], dl

; 176  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);

	mov	eax, DWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+16]
	add	rax, QWORD PTR [rdi+8]
	cmp	rcx, rax
	jae	SHORT $LN30@read
	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN31@read
$LN30@read:
	or	edx, -1
$LN31@read:
	cmp	dl, 64					; 00000040H
	mov	BYTE PTR [rbp], dl
	setae	al
	shl	al, 3
	or	BYTE PTR [rbx+1], al

; 177  :         if ((p->Freq & 0x80) != 0) {

	movzx	eax, BYTE PTR [rbp+1]
	test	al, al
	jns	SHORT $LN14@read

; 178  :             p->Freq &= ~0x80;

	and	al, 127					; 0000007fH

; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();

	cmp	rsi, QWORD PTR LoUnit
	mov	BYTE PTR [rbp+1], al
	je	SHORT $LN36@read

; 180  :             p->Successor->read(fp,p->Symbol);

	movzx	r8d, BYTE PTR [rbp]
	sub	rsi, 12
	mov	rbx, rsi
	mov	QWORD PTR HiUnit, rsi
	mov	QWORD PTR [rbp+2], rbx
	jmp	$LL63@read

; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();

$LN36@read:
	mov	rbx, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rbx, rbx
	je	SHORT $LN34@read
	mov	rax, QWORD PTR [rbx+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rax

; 180  :             p->Successor->read(fp,p->Symbol);

	movzx	r8d, BYTE PTR [rbp]
	mov	QWORD PTR [rbp+2], rbx
	jmp	$LL63@read

; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();

$LN34@read:
	xor	ecx, ecx
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare

; 180  :             p->Successor->read(fp,p->Symbol);

	movzx	r8d, BYTE PTR [rbp]
	mov	rbx, rax
	mov	QWORD PTR [rbp+2], rax
	jmp	$LL63@read
$LN14@read:

; 181  :         } else                              p->Successor=NULL;

	mov	QWORD PTR [rbp+2], 0

; 182  :         return;

	jmp	$LN1@read
$LN15@read:

; 183  :     }
; 184  :     Stats = (PPM_CONTEXT::STATE*) AllocUnits((NumStats+2) >> 1);

	movzx	ecx, cl
	add	ecx, 2
	sar	ecx, 1
	call	?AllocUnits@@YAPEAXI@Z			; AllocUnits

; 185  :     for (p=Stats;p <= Stats+NumStats;p++) {

	movzx	ecx, BYTE PTR [rbx]
	lea	rdx, QWORD PTR [rcx+rcx*4]
	mov	r11, rax
	mov	QWORD PTR [rbx+4], rax
	lea	rcx, QWORD PTR [rax+rdx*2]
	cmp	rax, rcx
	ja	SHORT $LN10@read
	npad	7
$LL12@read:

; 186  :         p->Freq=_PPMD_E_GETC(fp);

	mov	eax, DWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+16]
	add	rax, QWORD PTR [rdi+8]
	cmp	rcx, rax
	jae	SHORT $LN45@read
	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN46@read
$LN45@read:
	or	edx, -1
$LN46@read:
	mov	BYTE PTR [r11+1], dl

; 187  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);

	mov	eax, DWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+16]
	add	rax, QWORD PTR [rdi+8]
	cmp	rcx, rax
	jae	SHORT $LN48@read
	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN49@read
$LN48@read:
	or	edx, -1
$LN49@read:
	mov	BYTE PTR [r11], dl
	cmp	dl, 64					; 00000040H
	setae	al
	add	r11, 10
	shl	al, 3
	or	BYTE PTR [rbx+1], al
	movzx	eax, BYTE PTR [rbx]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	lea	rcx, QWORD PTR [rax+rcx*2]
	cmp	r11, rcx
	jbe	SHORT $LL12@read
$LN10@read:

; 188  :     }
; 189  :     int EscFreq=SummFreq=(Stats->Freq & ~0x80);

	mov	rbp, QWORD PTR [rbx+4]

; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);

	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbp+1]
	btr	eax, 7
	movzx	edx, ax
	mov	WORD PTR [rbx+2], ax
	mov	DWORD PTR EscFreq$1$[rsp], edx
	cmp	edx, ecx
	jge	SHORT $LN18@read
	cmp	edx, 127				; 0000007fH
	jge	SHORT $LN18@read
	mov	eax, 1
	jmp	SHORT $LN19@read
$LN18@read:
	xor	eax, eax
$LN19@read:
	shl	al, 2

; 191  :     for (p=Stats;p <= Stats+NumStats;p++) {

	lea	rcx, QWORD PTR [rcx+rcx*4]
	or	BYTE PTR [rbx+1], al
	lea	rax, QWORD PTR [rbp+rcx*2]
	cmp	rbp, rax
	ja	$LN7@read

; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);

	inc	rbp
$LL9@read:

; 192  :         if ((p->Freq & 0x80) != 0) {

	movzx	eax, BYTE PTR [rbp]
	test	al, al
	jns	SHORT $LN6@read

; 193  :             p->Freq &= ~0x80;

	and	al, 127					; 0000007fH

; 194  :             p->Successor = (PPM_CONTEXT*) AllocContext();

	cmp	rsi, QWORD PTR LoUnit
	mov	BYTE PTR [rbp], al
	je	SHORT $LN54@read
	sub	rsi, 12
	mov	QWORD PTR HiUnit, rsi
	jmp	SHORT $LN51@read
$LN54@read:
	mov	rsi, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rsi, rsi
	je	SHORT $LN52@read
	mov	rax, QWORD PTR [rsi+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rax
	jmp	SHORT $LN51@read
$LN52@read:
	xor	ecx, ecx
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
	mov	rsi, rax
$LN51@read:

; 195  :             p->Successor->read(fp,p->Symbol);

	movzx	r8d, BYTE PTR [rbp-1]
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rbp+1], rsi
	call	?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z ; PPM_CONTEXT::read
	mov	rsi, QWORD PTR HiUnit
	jmp	SHORT $LN5@read
$LN6@read:

; 196  :         } else                              p->Successor=NULL;

	mov	QWORD PTR [rbp+1], 0
$LN5@read:

; 197  :         p->Freq=(p == Stats)?(64):(p[-1].Freq-p[0].Freq);

	lea	rax, QWORD PTR [rbp-1]
	cmp	rax, QWORD PTR [rbx+4]
	jne	SHORT $LN20@read
	mov	ecx, 64					; 00000040H
	jmp	SHORT $LN21@read
$LN20@read:
	movzx	ecx, BYTE PTR [rbp-10]
	movzx	eax, BYTE PTR [rbp]
	sub	ecx, eax
$LN21@read:
	mov	BYTE PTR [rbp], cl

; 198  :         SummFreq += p->Freq;

	movzx	eax, cl
	add	rbp, 10
	add	WORD PTR [rbx+2], ax
	movzx	eax, BYTE PTR [rbx]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	lea	rdx, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [rbp-1]
	cmp	rax, rdx
	jbe	$LL9@read
	mov	edx, DWORD PTR EscFreq$1$[rsp]
$LN7@read:

; 199  :     }
; 200  :     if (EscFreq > 32) {

	cmp	edx, 32					; 00000020H
	jle	SHORT $LN1@read

; 202  :         for (p=Stats;p <= Stats+NumStats;p++)

	movzx	eax, BYTE PTR [rbx]
	mov	r8, QWORD PTR [rbx+4]
	sar	edx, 1
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	WORD PTR [rbx+2], dx
	lea	rax, QWORD PTR [r8+rcx*2]
	cmp	r8, rax
	ja	SHORT $LN1@read

; 201  :         SummFreq=(EscFreq >> 1);

	inc	r8
	npad	4
$LL3@read:

; 203  :                 SummFreq += (p->Freq -= (3*p->Freq) >> 2);

	movzx	ecx, BYTE PTR [r8]
	add	r8, 10
	lea	eax, DWORD PTR [rcx+rcx*2]
	sar	eax, 2
	sub	ecx, eax
	mov	BYTE PTR [r8-10], cl
	movzx	eax, cl
	add	WORD PTR [rbx+2], ax
	movzx	eax, BYTE PTR [rbx]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	lea	rdx, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [r8-1]
	cmp	rax, rdx
	jbe	SHORT $LL3@read
$LN1@read:
	mov	rbp, QWORD PTR [rsp+48]

; 204  :     }
; 205  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z ENDP ; PPM_CONTEXT::read
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
pdata	SEGMENT
$pdata$?ExpandUnits@@YAPEAXPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+190
	DD	imagerel $unwind$?ExpandUnits@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ExpandUnits@@YAPEAXPEAXI@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?ExpandUnits@@YAPEAXPEAXI@Z
_TEXT	SEGMENT
OldPtr$ = 48
OldNU$ = 56
?ExpandUnits@@YAPEAXPEAXI@Z PROC			; ExpandUnits, COMDAT

; 146  : {

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx

; 147  :     UINT i0=Units2Indx[OldNU-1], i1=Units2Indx[OldNU-1+1];

	lea	rbp, OFFSET FLAT:__ImageBase
	mov	rbx, rcx
	lea	eax, DWORD PTR [rdi-1]
	movzx	esi, BYTE PTR Units2Indx[rax+rbp]

; 148  :     if (i0 == i1)                           return OldPtr;

	movzx	eax, BYTE PTR Units2Indx[rdi+rbp]
	cmp	esi, eax
	jne	SHORT $LN2@ExpandUnit
	mov	rax, rcx
	jmp	SHORT $LN3@ExpandUnit
$LN2@ExpandUnit:

; 149  :     void* ptr=AllocUnits(OldNU+1);

	lea	ecx, DWORD PTR [rdi+1]
	call	?AllocUnits@@YAPEAXI@Z			; AllocUnits
	mov	r11, rax

; 150  :     if ( ptr ) {

	test	rax, rax
	je	SHORT $LN10@ExpandUnit

; 151  :         UnitsCpy(ptr,OldPtr,OldNU);         BList[i0].insert(OldPtr,OldNU);

	mov	rdx, rax
	mov	r8d, edi
	lea	rcx, QWORD PTR [rbx+8]
	sub	rdx, rbx
	npad	7
$LL7@ExpandUnit:
	mov	eax, DWORD PTR [rcx-8]
	add	rcx, 12
	dec	r8d
	mov	DWORD PTR [rdx+rcx-20], eax
	mov	eax, DWORD PTR [rcx-16]
	mov	DWORD PTR [rdx+rcx-16], eax
	mov	eax, DWORD PTR [rcx-12]
	mov	DWORD PTR [rdx+rcx-12], eax
	jne	SHORT $LL7@ExpandUnit
	lea	rcx, QWORD PTR [rsi+rsi*2]
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rcx*4+4]
	mov	QWORD PTR [rbx+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rcx*4+4], rbx
	mov	DWORD PTR [rbx], -1			; ffffffffH
	mov	DWORD PTR [rbx+12], edi
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rcx*4]
$LN10@ExpandUnit:

; 152  :     }
; 153  :     return ptr;

	mov	rax, r11
$LN3@ExpandUnit:

; 154  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ExpandUnits@@YAPEAXPEAXI@Z ENDP			; ExpandUnits
pdata	SEGMENT
$pdata$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel $unwind$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$pdata$0$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+120
	DD	imagerel $chain$0$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$pdata$5$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+120
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+640
	DD	imagerel $chain$5$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$pdata$6$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+640
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+1096
	DD	imagerel $chain$6$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$pdata$7$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+1096
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+1104
	DD	imagerel $chain$7$?StartModelRare@@YAXHW4MR_METHOD@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 030801H
	DD	0c0046208H
	DD	03002H
$chain$0$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 020521H
	DD	0a5405H
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel $unwind$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$chain$5$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 0a2f21H
	DD	04f42fH
	DD	05e423H
	DD	06d40fH
	DD	0c740aH
	DD	0b6405H
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+120
	DD	imagerel $chain$0$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$chain$6$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 080021H
	DD	04f400H
	DD	05e400H
	DD	06d400H
	DD	0c7400H
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+120
	DD	imagerel $chain$0$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$chain$7$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 021H
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel $unwind$?StartModelRare@@YAXHW4MR_METHOD@@@Z
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
xdata	ENDS
_TEXT	SEGMENT
MaxOrder$ = 80
MRMethod$ = 88
?StartModelRare@@YAXHW4MR_METHOD@@@Z PROC		; StartModelRare

; 909  : {

	push	rbx
	push	r12
	sub	rsp, 56					; 00000038H
	mov	r12d, ecx
	mov	ebx, edx

; 910  :     static bool         first_time  = true;
; 911  :     static PPM_CONTEXT* context     = 0;
; 912  : 
; 913  :     if( first_time )
; 914  :     {
; 915  :         UINT i, k, m;
; 916  : 
; 917  :         memset( CharMask, 0, sizeof(CharMask) );

	lea	rcx, OFFSET FLAT:CharMask
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	call	memset

; 918  :         EscCount=PrintCount=1;

	mov	BYTE PTR PrintCount, 1
	mov	BYTE PTR EscCount, 1

; 919  :         if( MaxOrder < 2 ) // we are in solid mode

	cmp	r12d, 2
	jge	SHORT $LN30@StartModel

; 920  :         {                     
; 921  :             OrderFall = ::MaxOrder;
; 922  :             for( PPM_CONTEXT* pc=MaxContext; pc&&pc->Suffix; pc=pc->Suffix )

	mov	rax, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	mov	ecx, DWORD PTR MaxOrder
	mov	DWORD PTR OrderFall, ecx
	test	rax, rax
	je	$LN1@StartModel
$LL29@StartModel:
	mov	rax, QWORD PTR [rax+12]
	test	rax, rax
	je	$LN1@StartModel

; 923  :                 OrderFall--;

	dec	ecx
	mov	DWORD PTR OrderFall, ecx
	test	rax, rax
	jne	SHORT $LL29@StartModel

; 975  :     }
; 976  :     else
; 977  :     {    
; 978  :     
; 979  :         UINT i, k, m;
; 980  : 
; 981  :         memset( CharMask, 0, sizeof(CharMask) );
; 982  :         EscCount=PrintCount=1;
; 983  :         ::OrderFall = ::MaxOrder = MaxOrder;          
; 984  :         ::MRMethod  = MRMethod;
; 985  :         
; 986  : ///        InitSubAllocator();
; 987  :         RunLength = InitRL = -((MaxOrder < 12) ? MaxOrder : 12) - 1;
; 988  : ///        MaxContext = (PPM_CONTEXT*) AllocContext();
; 989  : ///        MaxContext->Suffix = NULL;
; 990  : 
; 991  :         MaxContext  = context;
; 992  :         FoundState  = 0;
; 993  : 
; 994  : /*
; 995  :         if( !trained_model || _PPMD_E_GETC(trained_model) > MaxOrder ) 
; 996  :         {
; 997  :             MaxContext->SummFreq=(MaxContext->NumStats=255)+2;
; 998  :             MaxContext->Stats = (PPM_CONTEXT::STATE*) AllocUnits(256/2);
; 999  :             for( PrevSuccess=i=0;i < 256;i++) 
; 1000 :             {
; 1001 :                 MaxContext->Stats[i].Symbol=i;  MaxContext->Stats[i].Freq=1;
; 1002 :                 MaxContext->Stats[i].Successor=NULL;
; 1003 :             }
; 1004 :         } 
; 1005 :         else 
; 1006 :         {
; 1007 :             MaxContext->read(trained_model,0xFF);
; 1008 :             MaxContext->makeSuffix();
; 1009 :         }
; 1010 : */
; 1011 :     }
; 1012 : }

	add	rsp, 56					; 00000038H
	pop	r12
	pop	rbx
	ret	0
$LN30@StartModel:
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+48], r13

; 924  :             return;
; 925  :         }
; 926  : 
; 927  :         ::OrderFall = ::MaxOrder = MaxOrder;          
; 928  :         ::MRMethod  = MRMethod;
; 929  :         
; 930  :         InitSubAllocator();

	lea	rcx, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A ; BList
	xor	edx, edx
	mov	r8d, 456				; 000001c8H
	mov	QWORD PTR [rsp+40], r14
	mov	DWORD PTR MaxOrder, r12d
	mov	QWORD PTR [rsp+32], r15
	mov	DWORD PTR OrderFall, r12d
	mov	DWORD PTR MRMethod, ebx
	call	memset
	mov	r11, QWORD PTR HeapStart
	mov	ecx, DWORD PTR SubAllocatorSize
	lea	rbp, QWORD PTR [r11+rcx]
	shr	ecx, 3
	xor	r15d, r15d
	mov	eax, -1431655765			; aaaaaaabH
	mov	rdi, rbp
	mov	QWORD PTR pText, r11

; 944  :         }
; 945  :         for( i=m=0; m<24; m++ ) 

	movzx	r11d, BYTE PTR QTable
	mov	QWORD PTR HiUnit, rbp
	mov	DWORD PTR GlueCount, r15d
	mul	ecx
	shr	edx, 3
	mov	ecx, 12
	mov	ebx, r15d
	mov	r9d, r15d
	lea	r10, OFFSET FLAT:BinSumm+16
	lea	rsi, OFFSET FLAT:BinSumm+2
	imul	edx, 84					; 00000054H
	mov	eax, edx
	lea	r14, OFFSET FLAT:__ImageBase
	sub	rdi, rax
	cmp	r12d, ecx
	cmovl	ecx, r12d
	or	r13d, -1
	mov	QWORD PTR UnitsStart, rdi
	mov	eax, r13d
	mov	QWORD PTR LoUnit, rdi
	sub	eax, ecx
	mov	DWORD PTR InitRL, eax
	mov	DWORD PTR RunLength, eax
	npad	4
$LL26@StartModel:

; 936  :         {
; 937  :             while( QTable[i] == m )              

	cmp	r11d, ebx
	jne	SHORT $LN22@StartModel
	npad	11
$LL23@StartModel:

; 938  :                 i++;

	inc	r9d
	movzx	r11d, BYTE PTR QTable[r9+r14]
	cmp	r11d, ebx
	je	SHORT $LL23@StartModel
$LN22@StartModel:

; 939  :                 
; 940  :             for( k=0; k<8; k++ )
; 941  :                 BinSumm[m][k] = BIN_SCALE - InitBinEsc[k]/(i+1);

	xor	edx, edx
	lea	r8d, DWORD PTR [r9+1]
	mov	ecx, 16384				; 00004000H
	mov	eax, 15581				; 00003cddH
	div	r8d
	xor	edx, edx
	sub	cx, ax
	mov	eax, 7999				; 00001f3fH
	div	r8d
	mov	WORD PTR [rsi-2], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 22975				; 000059bfH
	div	r8d
	mov	WORD PTR [rsi], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 18675				; 000048f3H
	div	r8d
	mov	WORD PTR [rsi+2], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 25761				; 000064a1H
	div	r8d
	mov	WORD PTR [rsi+4], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 23228				; 00005abcH
	div	r8d
	mov	WORD PTR [rsi+6], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 26162				; 00006632H
	div	r8d
	mov	WORD PTR [rsi+8], cx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	xor	edx, edx
	mov	eax, 24657				; 00006051H
	div	r8d
	mov	WORD PTR [rsi+10], cx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	edx, 7
	mov	WORD PTR [rsi+12], cx
	mov	rcx, r10
	npad	4
$LL18@StartModel:

; 942  :             for( k=8; k<64; k+=8 )
; 943  :                 memcpy( BinSumm[m]+k, BinSumm[m], 8*sizeof(WORD) );

	mov	rax, QWORD PTR [r10-16]
	add	rcx, 16
	dec	rdx
	mov	QWORD PTR [rcx-16], rax
	mov	rax, QWORD PTR [r10-8]
	mov	QWORD PTR [rcx-8], rax
	jne	SHORT $LL18@StartModel

; 931  :         RunLength = InitRL = -((MaxOrder < 12) ? MaxOrder : 12) - 1;
; 932  : 
; 933  :         static const WORD InitBinEsc[] = {0x3CDD,0x1F3F,0x59BF,0x48F3,0x64A1,0x5ABC,0x6632,0x6051};
; 934  : 
; 935  :         for( i=m=0; m<25; m++ ) 

	inc	ebx
	sub	rsi, -128				; ffffffffffffff80H
	sub	r10, -128				; ffffffffffffff80H
	cmp	ebx, 25
	jb	$LL26@StartModel

; 944  :         }
; 945  :         for( i=m=0; m<24; m++ ) 

	mov	rsi, QWORD PTR [rsp+88]
	lea	r10d, QWORD PTR [rdx+3]
	mov	r8d, r15d
	lea	r11d, QWORD PTR [r10+21]
	lea	rdx, OFFSET FLAT:?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A ; SEE2Cont
	npad	13
$LL15@StartModel:

; 946  :         {
; 947  :             while( QTable[i+3] == m+3 )          

	lea	ecx, DWORD PTR [r8+3]
	movzx	eax, BYTE PTR QTable[rcx+r14]
	cmp	eax, r10d
	jne	SHORT $LN11@StartModel
$LL12@StartModel:

; 948  :                 i++;

	inc	ecx
	inc	r8d
	movzx	eax, BYTE PTR QTable[rcx+r14]
	cmp	eax, r10d
	je	SHORT $LL12@StartModel
$LN11@StartModel:

; 949  :             SEE2Cont[m][0].init(2*i+5);

	movzx	eax, r8w
	mov	WORD PTR [rdx+2], 1795			; 00000703H
	lea	rcx, QWORD PTR [rdx+4]
	shl	ax, 4
	mov	r9d, 31
	add	ax, 40					; 00000028H
	mov	WORD PTR [rdx], ax
	npad	12
$LL10@StartModel:

; 950  :             for( k=1; k<32; k++ )
; 951  :                 SEE2Cont[m][k] = SEE2Cont[m][0];

	mov	eax, DWORD PTR [rdx]
	add	rcx, 4
	dec	r9
	mov	DWORD PTR [rcx-4], eax
	jne	SHORT $LL10@StartModel

; 944  :         }
; 945  :         for( i=m=0; m<24; m++ ) 

	inc	r10d
	sub	rdx, -128				; ffffffffffffff80H
	dec	r11
	jne	SHORT $LL15@StartModel

; 952  :         }
; 953  :         
; 954  :         MaxContext = (PPM_CONTEXT*) AllocContext();

	cmp	rbp, rdi
	je	SHORT $LN41@StartModel
	sub	rbp, 12
	mov	QWORD PTR HiUnit, rbp
	mov	rbx, rbp
	jmp	SHORT $LN38@StartModel
$LN41@StartModel:
	mov	rbx, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rbx, rbx
	je	SHORT $LN39@StartModel
	mov	rax, QWORD PTR [rbx+4]
	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rax
	jmp	SHORT $LN38@StartModel
$LN39@StartModel:
	xor	ecx, ecx
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
	mov	rbx, rax
$LN38@StartModel:

; 955  :         MaxContext->Suffix = NULL;

	mov	QWORD PTR [rbx+12], r15

; 956  : 
; 957  :         if( !trained_model || _PPMD_E_GETC(trained_model) > MaxOrder ) 

	mov	rdx, QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rbx ; MaxContext
	test	rdx, rdx
	je	SHORT $LN6@StartModel
	mov	ecx, DWORD PTR [rdx]
	mov	rax, QWORD PTR [rdx+16]
	add	rcx, QWORD PTR [rdx+8]
	cmp	rax, rcx
	jae	SHORT $LN50@StartModel
	movzx	r13d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdx+16], rax
	mov	rdx, QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
$LN50@StartModel:
	cmp	r13d, r12d
	jg	SHORT $LN6@StartModel

; 965  :             }
; 966  :         } 
; 967  :         else 
; 968  :         {
; 969  :             MaxContext->read(trained_model,0xFF);

	mov	r8d, 255				; 000000ffH
	mov	rcx, rbx
	call	?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z ; PPM_CONTEXT::read

; 970  :             MaxContext->makeSuffix();

	mov	rcx, rbx
	call	?makeSuffix@PPM_CONTEXT@@QEAAXXZ	; PPM_CONTEXT::makeSuffix
	jmp	$LN3@StartModel
$LN6@StartModel:

; 958  :         {
; 959  :             MaxContext->SummFreq=(MaxContext->NumStats=255)+2;

	mov	BYTE PTR [rbx], 255			; 000000ffH
	mov	eax, 257				; 00000101H

; 960  :             MaxContext->Stats = (PPM_CONTEXT::STATE*) AllocUnits(256/2);

	lea	r9, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A	; BList
	mov	WORD PTR [rbx+2], ax
	movzx	r8d, BYTE PTR Units2Indx+127
	lea	rcx, QWORD PTR [r8+r8*2]
	cmp	QWORD PTR [r9+rcx*4+4], r15
	je	SHORT $LN54@StartModel
	mov	rdx, QWORD PTR [r9+rcx*4+4]
	mov	rax, QWORD PTR [rdx+4]
	dec	DWORD PTR [r9+rcx*4]
	mov	QWORD PTR [r9+rcx*4+4], rax
	jmp	SHORT $LN55@StartModel
$LN54@StartModel:
	movzx	eax, BYTE PTR Indx2Units[r8+r14]
	mov	rdx, rdi
	lea	eax, DWORD PTR [rax+rax*2]
	shl	eax, 2
	add	rdi, rax
	mov	QWORD PTR LoUnit, rdi
	cmp	rdi, rbp
	jbe	SHORT $LN55@StartModel
	sub	rdi, rax
	mov	ecx, r8d
	mov	QWORD PTR LoUnit, rdi
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
	mov	rdx, rax
$LN55@StartModel:
	mov	QWORD PTR [rbx+4], rdx

; 961  :             for (PrevSuccess=i=0;i < 256;i++) 

	mov	edx, r15d
	mov	rcx, r15
	mov	BYTE PTR PrevSuccess, dl
$LL5@StartModel:

; 962  :             {
; 963  :                 MaxContext->Stats[i].Symbol=i;  MaxContext->Stats[i].Freq=1;

	mov	rax, QWORD PTR [rbx+4]
	add	rcx, 10
	mov	BYTE PTR [rcx+rax-10], dl
	mov	rax, QWORD PTR [rbx+4]
	inc	edx
	mov	BYTE PTR [rax+rcx-9], 1

; 964  :                 MaxContext->Stats[i].Successor=NULL;

	mov	rax, QWORD PTR [rbx+4]
	mov	QWORD PTR [rax+rcx-8], r15
	cmp	edx, 256				; 00000100H
	jb	SHORT $LL5@StartModel
$LN3@StartModel:
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+48]
	mov	rdi, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+80]

; 971  :         }
; 972  : 
; 973  : //        first_time  = false;
; 974  :         context     = MaxContext;

	mov	QWORD PTR ?context@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4PEAUPPM_CONTEXT@@EA, rbx
$LN1@StartModel:

; 975  :     }
; 976  :     else
; 977  :     {    
; 978  :     
; 979  :         UINT i, k, m;
; 980  : 
; 981  :         memset( CharMask, 0, sizeof(CharMask) );
; 982  :         EscCount=PrintCount=1;
; 983  :         ::OrderFall = ::MaxOrder = MaxOrder;          
; 984  :         ::MRMethod  = MRMethod;
; 985  :         
; 986  : ///        InitSubAllocator();
; 987  :         RunLength = InitRL = -((MaxOrder < 12) ? MaxOrder : 12) - 1;
; 988  : ///        MaxContext = (PPM_CONTEXT*) AllocContext();
; 989  : ///        MaxContext->Suffix = NULL;
; 990  : 
; 991  :         MaxContext  = context;
; 992  :         FoundState  = 0;
; 993  : 
; 994  : /*
; 995  :         if( !trained_model || _PPMD_E_GETC(trained_model) > MaxOrder ) 
; 996  :         {
; 997  :             MaxContext->SummFreq=(MaxContext->NumStats=255)+2;
; 998  :             MaxContext->Stats = (PPM_CONTEXT::STATE*) AllocUnits(256/2);
; 999  :             for( PrevSuccess=i=0;i < 256;i++) 
; 1000 :             {
; 1001 :                 MaxContext->Stats[i].Symbol=i;  MaxContext->Stats[i].Freq=1;
; 1002 :                 MaxContext->Stats[i].Successor=NULL;
; 1003 :             }
; 1004 :         } 
; 1005 :         else 
; 1006 :         {
; 1007 :             MaxContext->read(trained_model,0xFF);
; 1008 :             MaxContext->makeSuffix();
; 1009 :         }
; 1010 : */
; 1011 :     }
; 1012 : }

	add	rsp, 56					; 00000038H
	pop	r12
	pop	rbx
	ret	0
?StartModelRare@@YAXHW4MR_METHOD@@@Z ENDP		; StartModelRare
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN29
	DD	imagerel $LN29+427
	DD	imagerel $unwind$?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ DD 0b1b01H
	DD	010a641bH
	DD	0109541bH
	DD	0108341bH
	DD	0104011bH
	DD	0c012d014H
	DD	07010H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ
_TEXT	SEGMENT
ps$ = 32
this$ = 2112
?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ PROC		; PPM_CONTEXT::decodeSymbol2, COMDAT

; 767  : {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 2080				; 00000820H
	mov	rbp, rcx

; 768  :     SEE2_CONTEXT* psee2c=makeEscFreq2();

	call	?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ ; PPM_CONTEXT::makeEscFreq2

; 769  :     UINT Sym, count, HiCnt=0, i=NumStats-NumMasked;

	movzx	edx, BYTE PTR NumMasked
	movzx	r12d, BYTE PTR [rbp]

; 770  :     STATE* ps[256], ** pps=ps, * p=Stats-1;

	movzx	ebx, BYTE PTR EscCount
	xor	edi, edi
	mov	r10d, r12d
	mov	r11, rax
	lea	r8, QWORD PTR ps$[rsp]
	sub	r10d, edx
	mov	rdx, QWORD PTR [rbp+4]
	lea	r13, OFFSET FLAT:CharMask
	sub	rdx, 10
	mov	r9d, r10d
	npad	8
$LL10@decodeSymb:

; 771  :     do {
; 772  :         do { Sym=p[1].Symbol;   p++; } while (CharMask[Sym] == EscCount);

	movzx	eax, BYTE PTR [rdx+10]
	add	rdx, 10
	cmp	BYTE PTR [rax+r13], bl
	je	SHORT $LL10@decodeSymb

; 773  :         HiCnt += p->Freq;                   *pps++ = p;

	movzx	eax, BYTE PTR [rdx+1]
	mov	QWORD PTR [r8], rdx
	add	r8, 8
	add	edi, eax

; 774  :     } while ( --i );

	dec	r9d
	jne	SHORT $LL10@decodeSymb

; 775  :     SubRange.scale += HiCnt;                   count=rcGetCurrentCount();

	mov	esi, DWORD PTR SubRange+8
	mov	eax, DWORD PTR range

; 776  :     p=*(pps=ps);

	mov	r8, QWORD PTR ps$[rsp]
	xor	edx, edx
	add	esi, edi
	div	esi
	xor	edx, edx
	mov	DWORD PTR SubRange+8, esi
	mov	ecx, eax
	mov	DWORD PTR range, eax
	mov	eax, DWORD PTR code
	sub	eax, DWORD PTR low
	div	ecx
	lea	rdx, QWORD PTR ps$[rsp]
	mov	r9d, eax

; 777  :     if (count < HiCnt) {

	cmp	eax, edi
	jae	$LN7@decodeSymb

; 778  :         HiCnt=0;
; 779  :         while ((HiCnt += p->Freq) <= count) p=*++pps;

	movzx	ecx, BYTE PTR [r8+1]
	cmp	ecx, eax
	ja	SHORT $LN5@decodeSymb
	npad	2
$LL6@decodeSymb:
	mov	r8, QWORD PTR [rdx+8]
	add	rdx, 8
	movzx	eax, BYTE PTR [r8+1]
	add	ecx, eax
	cmp	ecx, r9d
	jbe	SHORT $LL6@decodeSymb
$LN5@decodeSymb:

; 780  :         SubRange.low = (SubRange.high=HiCnt)-p->Freq;

	movzx	eax, BYTE PTR [r8+1]
	mov	DWORD PTR SubRange+4, ecx
	sub	ecx, eax
	mov	DWORD PTR SubRange, ecx

; 781  :         psee2c->update();                   

	movzx	ecx, BYTE PTR [r11+2]
	cmp	cl, 7
	jae	SHORT $LN18@decodeSymb
	dec	BYTE PTR [r11+3]
	jne	SHORT $LN18@decodeSymb
	movzx	eax, WORD PTR [r11]
	add	ax, ax
	mov	WORD PTR [r11], ax
	mov	eax, 3
	shl	al, cl
	inc	cl
	mov	BYTE PTR [r11+2], cl
	mov	BYTE PTR [r11+3], al
$LN18@decodeSymb:

; 782  :         update2(p);

	add	BYTE PTR [r8+1], 4
	add	WORD PTR [rbp+2], 4
	cmp	BYTE PTR [r8+1], 124			; 0000007cH
	mov	QWORD PTR FoundState, r8
	jbe	SHORT $LN21@decodeSymb
	mov	rcx, rbp
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN21@decodeSymb:
	mov	eax, DWORD PTR InitRL
	inc	bl
	mov	DWORD PTR RunLength, eax
	mov	BYTE PTR EscCount, bl

; 783  :     } else {

	jmp	SHORT $LN4@decodeSymb
$LN7@decodeSymb:

; 784  :         SubRange.low=HiCnt;                    SubRange.high=SubRange.scale;

	mov	DWORD PTR SubRange, edi
	mov	DWORD PTR SubRange+4, esi

; 785  :         i=NumStats-NumMasked;               NumMasked = NumStats;

	mov	BYTE PTR NumMasked, r12b
	npad	4
$LL3@decodeSymb:

; 786  :         do { CharMask[(*pps)->Symbol]=EscCount; pps++; } while ( --i );

	mov	rax, QWORD PTR [rdx]
	add	rdx, 8
	dec	r10d
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rcx+r13], bl
	jne	SHORT $LL3@decodeSymb

; 787  :         psee2c->Summ += SubRange.scale;

	movzx	eax, WORD PTR SubRange+8
	add	WORD PTR [r11], ax
$LN4@decodeSymb:

; 788  :     }
; 789  : }

	lea	r11, QWORD PTR [rsp+2080]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r13
	pop	r12
	pop	rdi
	ret	0
?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ ENDP		; PPM_CONTEXT::decodeSymbol2
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z DD imagerel $LN29
	DD	imagerel $LN29+343
	DD	imagerel $unwind$?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
symbol$ = 56
?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z PROC		; PPM_CONTEXT::encodeSymbol2, COMDAT

; 744  : {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rsi, rcx

; 745  :     SEE2_CONTEXT* psee2c=makeEscFreq2();

	call	?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ ; PPM_CONTEXT::makeEscFreq2

; 746  :     UINT Sym, LoCnt=0, i=NumStats-NumMasked;

	movzx	r8d, BYTE PTR NumMasked
	movzx	r10d, BYTE PTR [rsi]

; 747  :     STATE* p1, * p=Stats-1;

	movzx	ebx, BYTE PTR EscCount
	sub	r10d, r8d
	mov	r8, QWORD PTR [rsi+4]
	xor	r9d, r9d
	mov	r11, rax
	lea	rbp, OFFSET FLAT:CharMask
	sub	r8, 10
	npad	7
$LL10@encodeSymb:

; 748  :     do {
; 749  :         do { Sym=p[1].Symbol;   p++; } while (CharMask[Sym] == EscCount);

	movzx	ecx, BYTE PTR [r8+10]
	add	r8, 10
	cmp	BYTE PTR [rcx+rbp], bl
	je	SHORT $LL10@encodeSymb

; 750  :         CharMask[Sym]=EscCount;

	mov	BYTE PTR [rcx+rbp], bl

; 751  :         if (Sym == symbol)                  goto SYMBOL_FOUND;
; 752  :         LoCnt += p->Freq;

	movzx	eax, BYTE PTR [r8+1]
	cmp	ecx, edi
	je	SHORT $SYMBOL_FOUND$68204
	add	r9d, eax

; 753  :     } while ( --i );

	dec	r10d
	jne	SHORT $LL10@encodeSymb

; 754  :     SubRange.high=(SubRange.scale += (SubRange.low=LoCnt));

	mov	eax, DWORD PTR SubRange+8
	mov	DWORD PTR SubRange, r9d
	add	eax, r9d

; 755  :     psee2c->Summ += SubRange.scale;            NumMasked = NumStats;

	add	WORD PTR [r11], ax
	mov	DWORD PTR SubRange+8, eax
	mov	DWORD PTR SubRange+4, eax
	movzx	eax, BYTE PTR [rsi]
	mov	BYTE PTR NumMasked, al
	jmp	$LN20@encodeSymb
$SYMBOL_FOUND$68204:

; 756  :     return;
; 757  : SYMBOL_FOUND:
; 758  :     SubRange.low=LoCnt;                        SubRange.high=(LoCnt += p->Freq);

	mov	DWORD PTR SubRange, r9d
	add	r9d, eax

; 759  :     for (p1=p; --i ; ) {

	dec	r10d
	mov	DWORD PTR SubRange+4, r9d
	mov	rdx, r8
	je	SHORT $LN4@encodeSymb
	npad	7
$LL3@encodeSymb:

; 760  :         do { Sym=p1[1].Symbol;  p1++; } while (CharMask[Sym] == EscCount);

	movzx	eax, BYTE PTR [rdx+10]
	add	rdx, 10
	mov	ecx, eax
	cmp	BYTE PTR [rax+rbp], bl
	je	SHORT $LL3@encodeSymb

; 761  :         LoCnt += p1->Freq;

	movzx	eax, BYTE PTR [rdx+1]
	add	r9d, eax
	dec	r10d
	jne	SHORT $LL3@encodeSymb
$LN4@encodeSymb:

; 762  :     }
; 763  :     SubRange.scale += LoCnt;
; 764  :     psee2c->update();                       update2(p);

	movzx	ecx, BYTE PTR [r11+2]
	add	DWORD PTR SubRange+8, r9d
	cmp	cl, 7
	jae	SHORT $LN16@encodeSymb
	dec	BYTE PTR [r11+3]
	jne	SHORT $LN16@encodeSymb
	movzx	eax, WORD PTR [r11]
	add	ax, ax
	mov	WORD PTR [r11], ax
	mov	eax, 3
	shl	al, cl
	inc	cl
	mov	BYTE PTR [r11+2], cl
	mov	BYTE PTR [r11+3], al
$LN16@encodeSymb:
	add	BYTE PTR [r8+1], 4
	add	WORD PTR [rsi+2], 4
	cmp	BYTE PTR [r8+1], 124			; 0000007cH
	mov	QWORD PTR FoundState, r8
	jbe	SHORT $LN19@encodeSymb
	mov	rcx, rsi
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN19@encodeSymb:
	mov	eax, DWORD PTR InitRL
	inc	bl
	mov	DWORD PTR RunLength, eax
	mov	BYTE PTR EscCount, bl
$LN20@encodeSymb:

; 765  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z ENDP		; PPM_CONTEXT::encodeSymbol2
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
pdata	SEGMENT
$pdata$?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN19
	DD	imagerel $LN19+349
	DD	imagerel $unwind$?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
xdata	ENDS
;	COMDAT ?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ PROC		; PPM_CONTEXT::decodeSymbol1, COMDAT

; 692  : {

$LN19:
	push	rbx
	sub	rsp, 32					; 00000020H

; 693  :     UINT i, count, HiCnt=Stats->Freq;
; 694  :     STATE* p=Stats;                         SubRange.scale=SummFreq;

	movzx	ebx, WORD PTR [rcx+2]

; 695  :     if ((count=rcGetCurrentCount()) < HiCnt) {

	mov	eax, DWORD PTR range
	mov	r9, QWORD PTR [rcx+4]
	movzx	r10d, BYTE PTR [r9+1]
	xor	edx, edx
	mov	r11, rcx
	div	ebx
	xor	edx, edx
	mov	DWORD PTR SubRange+8, ebx
	mov	r8d, eax
	mov	DWORD PTR range, eax
	mov	eax, DWORD PTR code
	sub	eax, DWORD PTR low
	div	r8d
	mov	r8d, eax
	cmp	eax, r10d
	jae	SHORT $LN9@decodeSymb@2

; 696  :         PrevSuccess=(2*(SubRange.high=HiCnt) >= SubRange.scale);

	lea	eax, DWORD PTR [r10+r10]
	mov	DWORD PTR SubRange+4, r10d

; 697  : 
; 698  :         (FoundState=p)->Freq=(HiCnt += 4);  

	mov	QWORD PTR FoundState, r9
	cmp	eax, ebx
	setae	al
	add	r10d, 4
	mov	BYTE PTR PrevSuccess, al

; 699  :         SummFreq += 4;
; 700  : 
; 701  :         RunLength += PrevSuccess;

	movzx	eax, al
	mov	BYTE PTR [r9+1], r10b
	add	DWORD PTR RunLength, eax
	add	WORD PTR [rcx+2], 4

; 702  :         if (HiCnt > MAX_FREQ)               rescale();

	cmp	r10d, 124				; 0000007cH
	jbe	SHORT $LN8@decodeSymb@2
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN8@decodeSymb@2:

; 703  :         SubRange.low=0;                        return;

	mov	DWORD PTR SubRange, 0

; 716  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@decodeSymb@2:

; 704  :     }
; 705  :     i=NumStats;                             PrevSuccess=0;
; 706  :     while ((HiCnt += (++p)->Freq) <= count)

	movzx	eax, BYTE PTR [r9+11]
	movzx	ecx, BYTE PTR [rcx]
	add	r9, 10
	add	r10d, eax
	mov	BYTE PTR PrevSuccess, 0
	cmp	r10d, r8d
	ja	SHORT $LN6@decodeSymb@2
$LL7@decodeSymb@2:

; 707  :         if (--i == 0) {

	dec	ecx
	je	SHORT $LN18@decodeSymb@2

; 704  :     }
; 705  :     i=NumStats;                             PrevSuccess=0;
; 706  :     while ((HiCnt += (++p)->Freq) <= count)

	movzx	eax, BYTE PTR [r9+11]
	add	r9, 10
	add	r10d, eax
	cmp	r10d, r8d
	jbe	SHORT $LL7@decodeSymb@2
$LN6@decodeSymb@2:

; 713  :         }
; 714  :     SubRange.low=(SubRange.high=HiCnt)-p->Freq;   

	movzx	eax, BYTE PTR [r9+1]
	mov	DWORD PTR SubRange+4, r10d

; 715  :     ((PPM_CONTEXT*)this)->update1(p);

	mov	rdx, r9
	sub	r10d, eax
	mov	rcx, r11
	mov	DWORD PTR SubRange, r10d

; 716  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	jmp	?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z ; PPM_CONTEXT::update1
$LN18@decodeSymb@2:

; 708  :             if ( Suffix )                   PrefetchData(Suffix);

	mov	rax, QWORD PTR [r11+12]
	test	rax, rax
	je	SHORT $LN14@decodeSymb@2
	movzx	eax, BYTE PTR [rax]
	mov	ebx, DWORD PTR SubRange+8
$LN14@decodeSymb@2:

; 709  :             SubRange.low=HiCnt;                CharMask[p->Symbol]=EscCount;

	movzx	eax, BYTE PTR [r9]
	movzx	edx, BYTE PTR EscCount
	lea	r8, OFFSET FLAT:CharMask
	mov	BYTE PTR [rax+r8], dl

; 710  :             i=NumMasked=NumStats;           FoundState=NULL;

	movzx	eax, BYTE PTR [r11]
	mov	DWORD PTR SubRange, r10d
	mov	BYTE PTR NumMasked, al
	mov	ecx, eax
	mov	QWORD PTR FoundState, 0
	npad	14
$LL3@decodeSymb@2:

; 711  :             do { CharMask[(--p)->Symbol]=EscCount; } while ( --i );

	movzx	eax, BYTE PTR [r9-10]
	sub	r9, 10
	dec	ecx
	mov	BYTE PTR [rax+r8], dl
	jne	SHORT $LL3@decodeSymb@2

; 712  :             SubRange.high=SubRange.scale;         return;

	mov	DWORD PTR SubRange+4, ebx

; 716  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ ENDP		; PPM_CONTEXT::decodeSymbol1
_TEXT	ENDS
;	COMDAT pdata
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
pdata	SEGMENT
$pdata$?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z DD imagerel $LN17
	DD	imagerel $LN17+317
	DD	imagerel $unwind$?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
xdata	ENDS
;	COMDAT ?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
symbol$ = 56
?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z PROC		; PPM_CONTEXT::encodeSymbol1, COMDAT

; 667  : {

$LN17:
	sub	rsp, 40					; 00000028H

; 668  :     UINT LoCnt, i=Stats->Symbol;
; 669  :     STATE* p=Stats;                         SubRange.scale=SummFreq;

	mov	r8, QWORD PTR [rcx+4]
	movzx	r11d, WORD PTR [rcx+2]
	mov	r10d, edx

; 670  :     if (i == symbol) {

	movzx	eax, BYTE PTR [r8]
	mov	r9, rcx
	mov	DWORD PTR SubRange+8, r11d
	cmp	eax, edx
	jne	SHORT $LN9@encodeSymb@2

; 671  :         PrevSuccess=(2*(SubRange.high=p->Freq) >= SubRange.scale);

	movzx	edx, BYTE PTR [r8+1]

; 672  :         (FoundState=p)->Freq += 4;          SummFreq += 4;

	mov	QWORD PTR FoundState, r8
	lea	eax, DWORD PTR [rdx+rdx]
	mov	DWORD PTR SubRange+4, edx
	cmp	eax, r11d
	setae	al
	add	dl, 4
	mov	BYTE PTR [r8+1], dl
	add	WORD PTR [rcx+2], 4
	mov	BYTE PTR PrevSuccess, al

; 673  :         RunLength += PrevSuccess;

	movzx	eax, al
	add	DWORD PTR RunLength, eax

; 674  :         if (p->Freq > MAX_FREQ)             rescale();

	cmp	BYTE PTR [r8+1], 124			; 0000007cH
	jbe	SHORT $LN8@encodeSymb@2
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN8@encodeSymb@2:

; 675  :         SubRange.low=0;                        return;

	mov	DWORD PTR SubRange, 0

; 690  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN9@encodeSymb@2:

; 676  :     }
; 677  :     LoCnt=p->Freq;

	movzx	ecx, BYTE PTR [r8+1]

; 678  :     i=NumStats;                             PrevSuccess=0;
; 679  :     while ((++p)->Symbol != symbol) {

	movzx	eax, BYTE PTR [r8+10]
	movzx	edx, BYTE PTR [r9]
	add	r8, 10
	mov	BYTE PTR PrevSuccess, 0
	cmp	eax, r10d
	je	SHORT $LN6@encodeSymb@2
$LL7@encodeSymb@2:

; 680  :         LoCnt += p->Freq;

	movzx	eax, BYTE PTR [r8+1]
	add	ecx, eax

; 681  :         if (--i == 0) {

	dec	edx
	je	SHORT $LN16@encodeSymb@2

; 678  :     i=NumStats;                             PrevSuccess=0;
; 679  :     while ((++p)->Symbol != symbol) {

	movzx	eax, BYTE PTR [r8+10]
	add	r8, 10
	cmp	eax, r10d
	jne	SHORT $LL7@encodeSymb@2
$LN6@encodeSymb@2:

; 687  :         }
; 688  :     }
; 689  :     SubRange.high=(SubRange.low=LoCnt)+p->Freq;   update1(p);

	movzx	eax, BYTE PTR [r8+1]
	mov	DWORD PTR SubRange, ecx
	mov	rdx, r8
	add	eax, ecx
	mov	rcx, r9
	mov	DWORD PTR SubRange+4, eax

; 690  : }

	add	rsp, 40					; 00000028H
	jmp	?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z ; PPM_CONTEXT::update1
$LN16@encodeSymb@2:

; 682  :             if ( Suffix )                   PrefetchData(Suffix);

	mov	rax, QWORD PTR [r9+12]
	test	rax, rax
	je	SHORT $LN12@encodeSymb@2
	movzx	eax, BYTE PTR [rax]
	mov	r11d, DWORD PTR SubRange+8
$LN12@encodeSymb@2:

; 683  :             SubRange.low=LoCnt;                CharMask[p->Symbol]=EscCount;

	movzx	eax, BYTE PTR [r8]
	movzx	edx, BYTE PTR EscCount
	lea	r10, OFFSET FLAT:CharMask
	mov	BYTE PTR [rax+r10], dl

; 684  :             i=NumMasked=NumStats;           FoundState=NULL;

	movzx	eax, BYTE PTR [r9]
	mov	DWORD PTR SubRange, ecx
	mov	BYTE PTR NumMasked, al
	mov	ecx, eax
	mov	QWORD PTR FoundState, 0
	npad	14
$LL3@encodeSymb@2:

; 685  :             do { CharMask[(--p)->Symbol]=EscCount; } while ( --i );

	movzx	eax, BYTE PTR [r8-10]
	sub	r8, 10
	dec	ecx
	mov	BYTE PTR [rax+r10], dl
	jne	SHORT $LL3@encodeSymb@2

; 686  :             SubRange.high=SubRange.scale;         return;

	mov	DWORD PTR SubRange+4, r11d

; 690  : }

	add	rsp, 40					; 00000028H
	ret	0
?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z ENDP		; PPM_CONTEXT::encodeSymbol1
_TEXT	ENDS
pdata	SEGMENT
$pdata$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+34
	DD	imagerel $unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$0$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+34
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+39
	DD	imagerel $chain$0$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$2$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+39
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+256
	DD	imagerel $chain$2$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$3$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+256
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+353
	DD	imagerel $chain$3$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$4$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+353
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+702
	DD	imagerel $chain$4$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 060d01H
	DD	0b540dH
	DD	0e009320dH
	DD	060067007H
$chain$0$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 020521H
	DD	083405H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+34
	DD	imagerel $unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$chain$2$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 040a21H
	DD	0ad40aH
	DD	09c405H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+34
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+39
	DD	imagerel $chain$0$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$chain$3$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 020021H
	DD	0ad400H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+34
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+39
	DD	imagerel $chain$0$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$chain$4$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 021H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+34
	DD	imagerel $unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
pc1$ = 64
MinContext$ = 72
FSuccessor$ = 80
?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z PROC	; RestoreModelRare

; 321  : {

	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)

	mov	rdi, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	mov	rbp, QWORD PTR HeapStart
	mov	rsi, QWORD PTR UnitsStart
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], r12
	mov	QWORD PTR [rsp+80], r13
	mov	r14, r8
	mov	r13, rdx
	mov	r12, rcx
	mov	rbx, rdi
	mov	QWORD PTR pText, rbp
	cmp	rdi, rcx
	je	$LN23@RestoreMod
	npad	3
$LL25@RestoreMod:

; 325  :             if (--(pc->NumStats) == 0) {

	dec	BYTE PTR [rbx]
	jne	SHORT $LN22@RestoreMod

; 326  :                 pc->Flags=(pc->Flags & 0x10)+0x08*(pc->Stats->Symbol >= 0x40);

	mov	rdx, QWORD PTR [rbx+4]
	movzx	eax, BYTE PTR [rbx+1]
	cmp	BYTE PTR [rdx], 64			; 00000040H
	setae	cl
	and	al, 16
	shl	cl, 3
	add	cl, al
	mov	BYTE PTR [rbx+1], cl

; 327  :                 p=pc->Stats;                StateCpy(pc->oneState(),*p);

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rbx+2], ax
	mov	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR [rbx+4], rax

; 328  :                 SpecialFreeUnit(p);

	cmp	rdx, rsi
	je	SHORT $LN33@RestoreMod
	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	mov	QWORD PTR [rdx+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rdx
	mov	DWORD PTR [rdx], -1			; ffffffffH
	mov	DWORD PTR [rdx+12], 1
	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A

; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;

	movzx	eax, BYTE PTR [rbx+3]
	add	eax, 11
	sar	eax, 3
	mov	BYTE PTR [rbx+3], al

; 330  :             } else

	jmp	SHORT $LN24@RestoreMod

; 328  :                 SpecialFreeUnit(p);

$LN33@RestoreMod:
	mov	DWORD PTR [rdx], -1			; ffffffffH

; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;

	movzx	eax, BYTE PTR [rbx+3]
	add	rsi, 12
	add	eax, 11
	sar	eax, 3
	mov	BYTE PTR [rbx+3], al

; 330  :             } else

	jmp	SHORT $LN24@RestoreMod
$LN22@RestoreMod:

; 331  :                     pc->refresh((pc->NumStats+3) >> 1,FALSE);

	movzx	edx, BYTE PTR [rbx]
	xor	r8d, r8d
	mov	rcx, rbx
	add	edx, 3
	sar	edx, 1
	call	?refresh@PPM_CONTEXT@@QEAAXHH@Z		; PPM_CONTEXT::refresh
$LN24@RestoreMod:

; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)

	mov	rbx, QWORD PTR [rbx+12]
	cmp	rbx, r12
	jne	$LL25@RestoreMod

; 328  :                 SpecialFreeUnit(p);

	mov	QWORD PTR UnitsStart, rsi
$LN23@RestoreMod:
	mov	r12, QWORD PTR [rsp+72]

; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)

	cmp	rbx, r13
	je	SHORT $LN18@RestoreMod
	npad	2
$LL20@RestoreMod:

; 333  :             if ( !pc->NumStats )

	movzx	ecx, BYTE PTR [rbx]
	test	cl, cl
	jne	SHORT $LN17@RestoreMod

; 334  :                     pc->oneState().Freq -= pc->oneState().Freq >> 1;

	movzx	eax, BYTE PTR [rbx+3]
	shr	al, 1
	sub	BYTE PTR [rbx+3], al
	jmp	SHORT $LN19@RestoreMod
$LN17@RestoreMod:

; 335  :             else if ((pc->SummFreq += 4) > 128+4*pc->NumStats)

	movzx	eax, WORD PTR [rbx+2]
	movzx	edx, cl
	add	eax, 4
	lea	ecx, DWORD PTR [rdx*4+128]
	mov	WORD PTR [rbx+2], ax
	movzx	eax, ax
	cmp	eax, ecx
	jle	SHORT $LN19@RestoreMod

; 336  :                     pc->refresh((pc->NumStats+2) >> 1,TRUE);

	add	edx, 2
	mov	r8d, 1
	mov	rcx, rbx
	sar	edx, 1
	call	?refresh@PPM_CONTEXT@@QEAAXHH@Z		; PPM_CONTEXT::refresh
$LN19@RestoreMod:

; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)

	mov	rbx, QWORD PTR [rbx+12]
	cmp	rbx, r13
	jne	SHORT $LL20@RestoreMod
$LN18@RestoreMod:

; 337  :     if (MRMethod > MRM_FREEZE) {

	mov	r8d, DWORD PTR MRMethod
	mov	r13, QWORD PTR [rsp+80]
	mov	rbx, QWORD PTR [rsp+64]
	cmp	r8d, 2
	jle	SHORT $LN74@RestoreMod

; 338  :         MaxContext=FSuccessor;              GlueCount += !(BList[1].Stamp & 1);

	mov	eax, DWORD PTR ?BList@@3PAUBLK_NODE@@A+12
	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, r14 ; MaxContext
	not	eax
	and	eax, 1
	add	DWORD PTR GlueCount, eax

; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }

	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN74@RestoreMod:

; 339  :     } else if (MRMethod == MRM_FREEZE) {

	jne	SHORT $LN12@RestoreMod

; 340  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;

	mov	rax, QWORD PTR [rdi+12]
	test	rax, rax
	je	SHORT $LN10@RestoreMod
$LL11@RestoreMod:
	mov	rdi, rax
	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext
	mov	rax, QWORD PTR [rax+12]
	test	rax, rax
	jne	SHORT $LL11@RestoreMod
$LN10@RestoreMod:

; 341  :         MaxContext->removeBinConts(0);      MRMethod=MR_METHOD(MRMethod+1);

	xor	edx, edx
	mov	rcx, rdi
	call	?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z ; PPM_CONTEXT::removeBinConts
	inc	DWORD PTR MRMethod
$LN72@RestoreMod:

; 342  :         GlueCount=0;                        OrderFall=MaxOrder;

	mov	eax, DWORD PTR MaxOrder
	mov	DWORD PTR GlueCount, 0
	mov	DWORD PTR OrderFall, eax

; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }

	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN12@RestoreMod:

; 343  : 	} else if (MRMethod == MRM_RESTART || GetUsedMemory() < (SubAllocatorSize >> 1)) {

	test	r8d, r8d
	je	$LN7@RestoreMod
	mov	r11d, DWORD PTR SubAllocatorSize
	sub	ebp, esi
	lea	rcx, OFFSET FLAT:Indx2Units+1
	sub	ebp, DWORD PTR HiUnit
	lea	rdx, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A+12
	add	ebp, DWORD PTR LoUnit
	add	ebp, r11d
	xor	r9d, r9d
	lea	r10d, QWORD PTR [r9+19]
	npad	1
$LL50@RestoreMod:
	movzx	eax, BYTE PTR [rcx-1]
	add	rdx, 24
	add	rcx, 2
	imul	eax, DWORD PTR [rdx-36]
	imul	eax, -12				; fffffff4H
	add	ebp, eax
	movzx	eax, BYTE PTR [rcx-2]
	imul	eax, DWORD PTR [rdx-24]
	imul	eax, -12				; fffffff4H
	add	r9d, eax
	dec	r10
	jne	SHORT $LL50@RestoreMod
	add	ebp, r9d
	shr	r11d, 1
	cmp	ebp, r11d
	jb	SHORT $LN7@RestoreMod

; 345  :         EscCount=0;                         PrintCount=0xFF;
; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;

	mov	rax, QWORD PTR [rdi+12]
	test	rax, rax
	je	SHORT $LL3@RestoreMod
	npad	4
$LL5@RestoreMod:
	mov	rdi, rax
	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext
	mov	rax, QWORD PTR [rax+12]
	test	rax, rax
	jne	SHORT $LL5@RestoreMod
$LL3@RestoreMod:

; 348  :         do {
; 349  :             MaxContext->cutOff(0);          ExpandTextArea();

	xor	edx, edx
	mov	rcx, rdi
	call	?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z	; PPM_CONTEXT::cutOff
	call	?ExpandTextArea@@YAXXZ			; ExpandTextArea

; 350  : 		} while (GetUsedMemory() > 3*(SubAllocatorSize >> 2));

	call	GetUsedMemory
	mov	ecx, DWORD PTR SubAllocatorSize
	shr	ecx, 2
	lea	ecx, DWORD PTR [rcx+rcx*2]
	cmp	eax, ecx
	jbe	$LN72@RestoreMod

; 345  :         EscCount=0;                         PrintCount=0xFF;
; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;

	mov	rdi, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	jmp	SHORT $LL3@RestoreMod
$LN7@RestoreMod:

; 344  :         StartModelRare(MaxOrder,MRMethod);

	mov	ecx, DWORD PTR MaxOrder
	mov	edx, r8d
	call	?StartModelRare@@YAXHW4MR_METHOD@@@Z	; StartModelRare

; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }

	mov	rbp, QWORD PTR [rsp+88]
	mov	BYTE PTR EscCount, 0
	mov	BYTE PTR PrintCount, 255		; 000000ffH
	add	rsp, 32					; 00000020H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z ENDP	; RestoreModelRare
pdata	SEGMENT
$pdata$?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z DD imagerel ?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z
	DD	imagerel ?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z+827
	DD	imagerel $unwind$?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z DD 0bc501H
	DD	04f4c5H
	DD	0ee4c0H
	DD	0d009420dH
	DD	07005c007H
	DD	050036004H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
FFreq$1$ = 96
MinContext$ = 96
Successor$1$ = 104
?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z PROC		; UpdateModel

; 489  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	sub	rsp, 40					; 00000028H

; 490  :     PPM_CONTEXT::STATE* p           = NULL;
; 491  :     PPM_CONTEXT*        FSuccessor  = FoundState->Successor;

	mov	rdi, QWORD PTR FoundState

; 492  :     PPM_CONTEXT*        pc          = MinContext->Suffix;

	mov	r10, QWORD PTR [rcx+12]

; 493  :     PPM_CONTEXT*        pc1         = MaxContext;

	mov	rbx, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext

; 494  :     
; 495  :     UINT ns1, ns, cf, sf, s0, FFreq=FoundState->Freq;

	movzx	r11d, BYTE PTR [rdi+1]
	mov	r12, QWORD PTR [rdi+2]

; 496  :     BYTE Flag, sym, FSymbol=FoundState->Symbol;

	movzx	r13d, BYTE PTR [rdi]
	xor	r9d, r9d
	mov	rbp, rcx
	mov	DWORD PTR FFreq$1$[rsp], r11d

; 497  : 
; 498  : 
; 499  :     if( FFreq < MAX_FREQ/4  &&  pc ) 

	cmp	r11d, 31
	jae	SHORT $LN28@UpdateMode
	test	r10, r10
	je	SHORT $LN28@UpdateMode

; 500  :     {
; 501  :         if ( pc->NumStats ) 

	cmp	BYTE PTR [r10], r9b
	je	SHORT $LN34@UpdateMode

; 502  :         {
; 503  :             if ((p=pc->Stats)->Symbol != FSymbol) 

	mov	r9, QWORD PTR [r10+4]
	cmp	BYTE PTR [r9], r13b
	je	SHORT $LN29@UpdateMode
$LL32@UpdateMode:

; 504  :             {
; 505  :                 do { sym=p[1].Symbol;       p++; } while (sym != FSymbol);

	add	r9, 10
	cmp	BYTE PTR [r9], r13b
	jne	SHORT $LL32@UpdateMode

; 506  :                 if (p[0].Freq >= p[-1].Freq) 

	movzx	eax, BYTE PTR [r9-9]
	cmp	BYTE PTR [r9+1], al
	jb	SHORT $LN29@UpdateMode

; 507  :                 {
; 508  :                     SWAP(p[0],p[-1]);       

	movzx	eax, WORD PTR [r9-10]
	movzx	edx, WORD PTR [r9]
	mov	rcx, QWORD PTR [r9+2]
	mov	WORD PTR [r9], ax
	mov	rax, QWORD PTR [r9-8]

; 509  :                     p--;

	add	r9, -10
	mov	QWORD PTR [r9+12], rax
	mov	WORD PTR [r9], dx
	mov	QWORD PTR [r9+2], rcx
$LN29@UpdateMode:

; 510  :                 }
; 511  :             }
; 512  :             cf=2*(p->Freq < MAX_FREQ-9);

	movzx	eax, BYTE PTR [r9+1]
	xor	ecx, ecx
	cmp	al, 115					; 00000073H
	setb	cl
	add	ecx, ecx

; 513  :             p->Freq      += cf;                  

	add	al, cl
	mov	BYTE PTR [r9+1], al

; 514  :             pc->SummFreq += cf;

	add	WORD PTR [r10+2], cx

; 515  :         } 
; 516  :         else 

	jmp	SHORT $LN28@UpdateMode
$LN34@UpdateMode:

; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 

	movzx	eax, BYTE PTR [r10+3]
	lea	r9, QWORD PTR [r10+2]
	cmp	al, 32					; 00000020H
	adc	al, 0
	mov	BYTE PTR [r9+1], al
$LN28@UpdateMode:

; 520  :         }
; 521  :     }
; 522  :     
; 523  :     if( !OrderFall && FSuccessor) 

	mov	esi, DWORD PTR OrderFall
	mov	QWORD PTR [rsp+112], r14
	mov	QWORD PTR [rsp+32], r15
	test	esi, esi
	jne	SHORT $LN27@UpdateMode
	test	r12, r12
	je	SHORT $LN27@UpdateMode

; 524  :     {
; 525  :         FoundState->Successor=CreateSuccessors(TRUE,p,MinContext);

	lea	ecx, QWORD PTR [rsi+1]
	mov	r8, rbp
	mov	rdx, r9
	call	?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z ; CreateSuccessors
	mov	QWORD PTR [rdi+2], rax

; 526  :         if ( !FoundState->Successor )       

	test	rax, rax
	je	$RESTART_MODEL$68081

; 527  :             goto RESTART_MODEL;
; 528  :         MaxContext=FoundState->Successor;   

	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext

; 529  :         return;

	jmp	$LN36@UpdateMode
$LN27@UpdateMode:

; 530  :     }
; 531  : 
; 532  :     *pText++ = FSymbol;                     

	mov	rdi, QWORD PTR pText

; 533  : 
; 534  :     PPM_CONTEXT*    Successor = (PPM_CONTEXT*) pText;
; 535  :     
; 536  :     if (pText >= UnitsStart)                

	mov	rax, QWORD PTR UnitsStart
	inc	rdi
	mov	BYTE PTR [rdi-1], r13b
	mov	QWORD PTR pText, rdi
	mov	QWORD PTR Successor$1$[rsp], rdi
	cmp	rdi, rax
	jae	$RESTART_MODEL$68081

; 537  :         goto RESTART_MODEL;
; 538  : 
; 539  : 
; 540  :     if( FSuccessor ) 

	test	r12, r12
	je	SHORT $LN22@UpdateMode

; 541  :     {
; 542  :         if ((BYTE*) FSuccessor < UnitsStart)

	cmp	r12, rax
	jae	SHORT $LN20@UpdateMode

; 543  :             FSuccessor=CreateSuccessors(FALSE,p,MinContext);

	mov	r8, rbp
	mov	rdx, r9
	xor	ecx, ecx
	call	?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z ; CreateSuccessors

; 544  :     } 
; 545  :     else

	jmp	SHORT $LN51@UpdateMode
$LN22@UpdateMode:

; 546  :     {
; 547  :         FSuccessor=ReduceOrder(p,MinContext);

	mov	rdx, rbp
	mov	rcx, r9
	call	?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z ; ReduceOrder
	mov	esi, DWORD PTR OrderFall
	mov	rdi, QWORD PTR pText
$LN51@UpdateMode:
	mov	r11d, DWORD PTR FFreq$1$[rsp]
	mov	r12, rax
$LN20@UpdateMode:

; 548  :     }
; 549  :     
; 550  :     if( !FSuccessor )                          

	test	r12, r12
	je	$RESTART_MODEL$68081

; 551  :         goto RESTART_MODEL;
; 552  : 
; 553  : 
; 554  :     if( !--OrderFall ) 

	dec	esi
	mov	DWORD PTR OrderFall, esi
	jne	SHORT $LN17@UpdateMode

; 555  :     {
; 556  :         Successor=FSuccessor;               
; 557  :         pText -= (MaxContext != MinContext);

	xor	eax, eax
	cmp	rbx, rbp
	setne	al
	sub	rdi, rax
	mov	QWORD PTR pText, rdi
	jmp	SHORT $LN52@UpdateMode
$LN17@UpdateMode:

; 558  :     } 
; 559  :     else if( MRMethod > MRM_FREEZE) 

	cmp	DWORD PTR MRMethod, 2
	jle	SHORT $LN15@UpdateMode

; 562  :         pText=HeapStart;

	mov	rax, QWORD PTR HeapStart

; 563  :         OrderFall=0;

	mov	DWORD PTR OrderFall, 0
	mov	QWORD PTR pText, rax
$LN52@UpdateMode:

; 560  :     {
; 561  :         Successor=FSuccessor;               

	mov	QWORD PTR Successor$1$[rsp], r12
$LN15@UpdateMode:

; 564  :     }
; 565  :     
; 566  :     s0=MinContext->SummFreq-(ns=MinContext->NumStats)-FFreq;

	movzx	esi, BYTE PTR [rbp]
	movzx	r14d, WORD PTR [rbp+2]
	sub	r14d, esi
	sub	r14d, r11d

; 567  :     for (Flag=0x08*(FSymbol >= 0x40);pc1 != MinContext;pc1=pc1->Suffix) 

	cmp	r13b, 64				; 00000040H
	setae	r15b
	shl	r15b, 3
	cmp	rbx, rbp
	je	$LN12@UpdateMode
	npad	7
$LL14@UpdateMode:

; 568  :     {
; 569  :         if ((ns1=pc1->NumStats) != 0) 

	movzx	edi, BYTE PTR [rbx]
	test	edi, edi
	je	SHORT $LN11@UpdateMode

; 570  :         {
; 571  :             if ((ns1 & 1) != 0) 

	test	dil, 1
	je	SHORT $LN10@UpdateMode

; 572  :             {
; 573  :                 p=(PPM_CONTEXT::STATE*) ExpandUnits(pc1->Stats,(ns1+1) >> 1);

	mov	rcx, QWORD PTR [rbx+4]
	lea	edx, DWORD PTR [rdi+1]
	shr	edx, 1
	call	?ExpandUnits@@YAPEAXPEAXI@Z		; ExpandUnits

; 574  :                 if ( !p )                   

	test	rax, rax
	je	$RESTART_MODEL$68081

; 575  :                     goto RESTART_MODEL;
; 576  :                 pc1->Stats=p;

	mov	r11d, DWORD PTR FFreq$1$[rsp]
	mov	QWORD PTR [rbx+4], rax
$LN10@UpdateMode:

; 577  :             }
; 578  :             pc1->SummFreq += (3*ns1+1 < ns);

	lea	eax, DWORD PTR [rdi+rdi*2+1]
	cmp	eax, esi
	adc	WORD PTR [rbx+2], 0

; 579  :         } 
; 580  :         else 

	jmp	SHORT $LN7@UpdateMode
$LN11@UpdateMode:

; 581  :         {
; 582  :             p=(PPM_CONTEXT::STATE*) AllocUnits(1);

	mov	ecx, 1
	call	?AllocUnits@@YAPEAXI@Z			; AllocUnits

; 583  :             if ( !p )                       

	test	rax, rax
	je	$RESTART_MODEL$68081

; 584  :                 goto RESTART_MODEL;
; 585  :                 
; 586  :             StateCpy(*p,pc1->oneState());   

	movzx	ecx, WORD PTR [rbx+2]
	mov	WORD PTR [rax], cx
	mov	rcx, QWORD PTR [rbx+4]
	mov	QWORD PTR [rax+2], rcx

; 587  :             pc1->Stats=p;

	mov	QWORD PTR [rbx+4], rax

; 588  :             
; 589  :             if (p->Freq < MAX_FREQ/4-1)     p->Freq += p->Freq;

	movzx	ecx, BYTE PTR [rax+1]
	cmp	cl, 30
	jae	SHORT $LN4@UpdateMode
	add	cl, cl
	mov	BYTE PTR [rax+1], cl
	jmp	SHORT $LN3@UpdateMode
$LN4@UpdateMode:

; 590  :             else                            p->Freq  = MAX_FREQ-4;

	mov	BYTE PTR [rax+1], 120			; 00000078H
$LN3@UpdateMode:

; 591  :             
; 592  :             pc1->SummFreq=p->Freq+InitEsc+(ns > 2);

	movzx	eax, BYTE PTR [rax+1]
	mov	r11d, DWORD PTR FFreq$1$[rsp]
	xor	ecx, ecx
	cmp	esi, 2
	seta	cl
	add	cx, ax
	add	cx, WORD PTR InitEsc
	mov	WORD PTR [rbx+2], cx
$LN7@UpdateMode:

; 593  :         }
; 594  : 
; 595  :         cf=2*FFreq*(pc1->SummFreq+6);       

	movzx	r9d, WORD PTR [rbx+2]

; 596  :         sf=s0+pc1->SummFreq;

	lea	r10d, DWORD PTR [r9+r14]
	lea	r8d, DWORD PTR [r9+6]

; 597  : 
; 598  :         if (cf < 6*sf) 

	lea	eax, DWORD PTR [r10+r10*2]
	add	eax, eax
	imul	r8d, r11d
	add	r8d, r8d
	cmp	r8d, eax
	jae	SHORT $LN2@UpdateMode

; 599  :         {
; 600  :             cf=1+(cf > sf)+(cf >= 4*sf);

	xor	ecx, ecx
	lea	eax, DWORD PTR [r10*4]
	cmp	r8d, eax
	setae	cl
	xor	eax, eax
	cmp	r8d, r10d
	seta	al

; 601  :             pc1->SummFreq += 4;

	add	r9w, 4
	lea	edx, DWORD PTR [rcx+rax+1]

; 602  :         } 
; 603  :         else 

	jmp	SHORT $LN53@UpdateMode
$LN2@UpdateMode:

; 604  :         {
; 605  :             cf=4+(cf > 9*sf)+(cf > 12*sf)+(cf > 15*sf);

	xor	edx, edx
	mov	eax, r10d
	imul	eax, 15
	cmp	r8d, eax
	lea	eax, DWORD PTR [r10+r10*2]
	seta	dl
	xor	ecx, ecx
	shl	eax, 2
	cmp	r8d, eax
	lea	eax, DWORD PTR [r10+r10*8]
	seta	cl
	add	edx, ecx
	xor	ecx, ecx
	cmp	r8d, eax
	seta	cl
	lea	edx, DWORD PTR [rdx+rcx+4]

; 606  :             pc1->SummFreq += cf;

	add	r9w, dx
$LN53@UpdateMode:

; 607  :         }
; 608  :         p=pc1->Stats+(++pc1->NumStats);     

	inc	BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx]

; 609  :         p->Successor=Successor;

	mov	r8, QWORD PTR Successor$1$[rsp]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	mov	WORD PTR [rbx+2], r9w
	mov	QWORD PTR [rax+rcx*2+2], r8

; 610  :         p->Symbol = FSymbol;                

	mov	BYTE PTR [rax+rcx*2], r13b

; 611  :         p->Freq = cf;

	mov	BYTE PTR [rax+rcx*2+1], dl

; 612  :         pc1->Flags |= Flag;

	or	BYTE PTR [rbx+1], r15b
	mov	rbx, QWORD PTR [rbx+12]
	cmp	rbx, rbp
	jne	$LL14@UpdateMode
$LN12@UpdateMode:

; 613  :     }
; 614  : 
; 615  :     MaxContext=FSuccessor;

	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, r12 ; MaxContext
	jmp	SHORT $LN36@UpdateMode
$RESTART_MODEL$68081:

; 616  :     return;
; 617  : 
; 618  : RESTART_MODEL:
; 619  :     RestoreModelRare(pc1,MinContext,FSuccessor);

	mov	r8, r12
	mov	rdx, rbp
	mov	rcx, rbx
	call	?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z ; RestoreModelRare
$LN36@UpdateMode:
	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+112]

; 620  : 
; 621  : }

	add	rsp, 40					; 00000028H
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z ENDP		; UpdateModel
PUBLIC	DecodeFile
pdata	SEGMENT
$pdata$DecodeFile DD imagerel $LN83
	DD	imagerel $LN83+734
	DD	imagerel $unwind$DecodeFile
pdata	ENDS
xdata	SEGMENT
$unwind$DecodeFile DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
DecodedFile$ = 48
EncodedFile$ = 56
DecodeFile PROC

; 856  : {

$LN83:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 861  :     for( BYTE ns=MinContext->NumStats; ; )

	mov	r9d, DWORD PTR [rdx]
	mov	rax, QWORD PTR [rdx+16]
	xor	edi, edi
	add	r9, QWORD PTR [rdx+8]
	mov	rsi, rdx
	mov	rbp, rcx
	mov	DWORD PTR low, edi
	mov	DWORD PTR range, -1			; ffffffffH
	lea	r8d, QWORD PTR [rdi+4]
	npad	5
$LL19@DecodeFile:

; 857  :     rcInitDecoder(EncodedFile);

	cmp	rax, r9
	jae	SHORT $LN22@DecodeFile
	movzx	ecx, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdx+16], rax
	jmp	SHORT $LN23@DecodeFile
$LN22@DecodeFile:
	or	ecx, -1
$LN23@DecodeFile:
	shl	edi, 8
	or	edi, ecx
	dec	r8
	jne	SHORT $LL19@DecodeFile

; 858  :     StartModelRare(MaxOrder,MRMethod);

	xor	edx, edx
	mov	DWORD PTR code, edi
	lea	ecx, QWORD PTR [rdx+8]
	call	?StartModelRare@@YAXHW4MR_METHOD@@@Z	; StartModelRare

; 859  :     
; 860  :     PPM_CONTEXT* MinContext=MaxContext;

	mov	rbx, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext

; 861  :     for( BYTE ns=MinContext->NumStats; ; )

	movzx	r10d, BYTE PTR [rbx]
	npad	7
$LL14@DecodeFile:

; 862  :     {
; 863  :         if( ns )
; 864  :         {
; 865  :             MinContext->decodeSymbol1();    

	mov	rcx, rbx
	test	r10b, r10b
	je	SHORT $LN12@DecodeFile
	call	?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ	; PPM_CONTEXT::decodeSymbol1

; 866  :             rcRemoveSubrange();

	mov	ecx, DWORD PTR range
	mov	r11d, DWORD PTR SubRange
	mov	r8d, DWORD PTR low

; 867  :         } 
; 868  :         else                             

	mov	edi, DWORD PTR code
	mov	eax, r11d
	imul	eax, ecx
	add	r8d, eax
	mov	eax, DWORD PTR SubRange+4
	sub	eax, r11d
	mov	DWORD PTR low, r8d
	imul	ecx, eax
	mov	DWORD PTR range, ecx
	jmp	SHORT $LN61@DecodeFile
$LN12@DecodeFile:

; 869  :         {
; 870  :             MinContext->decodeBinSymbol();

	call	?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ	; PPM_CONTEXT::decodeBinSymbol
	mov	r8d, DWORD PTR low
	mov	ecx, DWORD PTR range
$LN61@DecodeFile:

; 871  :         }
; 872  :         
; 873  :         while( !FoundState ) 

	mov	rdx, QWORD PTR FoundState
	test	rdx, rdx
	jne	$LN82@DecodeFile
	npad	3

; 874  :         {
; 875  :             rcDecNormalize(EncodedFile);

$LL29@DecodeFile:
	lea	eax, DWORD PTR [rcx+r8]
	xor	eax, r8d
	cmp	eax, 16777216				; 01000000H
	jb	SHORT $LN27@DecodeFile
	cmp	ecx, 32768				; 00008000H
	jae	SHORT $LN72@DecodeFile
	mov	ecx, r8d
	neg	ecx
	and	ecx, 32767				; 00007fffH
$LN27@DecodeFile:
	mov	eax, DWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
	add	rax, QWORD PTR [rsi+8]
	cmp	rdx, rax
	jae	SHORT $LN32@DecodeFile
	movzx	r9d, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rsi+16], rax
	jmp	SHORT $LN33@DecodeFile
$LN32@DecodeFile:
	or	r9d, -1
$LN33@DecodeFile:
	shl	edi, 8
	shl	ecx, 8
	or	edi, r9d
	mov	DWORD PTR range, ecx
	shl	r8d, 8
	mov	DWORD PTR code, edi
	jmp	SHORT $LL29@DecodeFile
$LN72@DecodeFile:
	movzx	ecx, BYTE PTR NumMasked
	mov	eax, DWORD PTR OrderFall
	mov	DWORD PTR low, r8d
$LL8@DecodeFile:

; 876  :             do 
; 877  :             {
; 878  :                 OrderFall++;                
; 879  :                 MinContext=MinContext->Suffix;

	mov	rbx, QWORD PTR [rbx+12]
	inc	eax
	mov	DWORD PTR OrderFall, eax

; 880  :                 if( !MinContext )          

	test	rbx, rbx
	je	$STOP_DECODING$68289

; 881  :                     goto STOP_DECODING;
; 882  :             } 
; 883  :             while( MinContext->NumStats == NumMasked );

	cmp	BYTE PTR [rbx], cl
	je	SHORT $LL8@DecodeFile

; 884  : 
; 885  :             MinContext->decodeSymbol2();    

	mov	rcx, rbx
	call	?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ	; PPM_CONTEXT::decodeSymbol2

; 886  :             rcRemoveSubrange();

	mov	ecx, DWORD PTR range
	mov	r11d, DWORD PTR SubRange
	mov	r8d, DWORD PTR low
	mov	rdx, QWORD PTR FoundState
	mov	eax, r11d
	imul	eax, ecx
	add	r8d, eax
	mov	eax, DWORD PTR SubRange+4
	sub	eax, r11d
	mov	DWORD PTR low, r8d
	imul	ecx, eax
	mov	DWORD PTR range, ecx
	test	rdx, rdx
	jne	SHORT $LN82@DecodeFile

; 871  :         }
; 872  :         
; 873  :         while( !FoundState ) 

	mov	edi, DWORD PTR code

; 874  :         {
; 875  :             rcDecNormalize(EncodedFile);

	jmp	$LL29@DecodeFile
$LN82@DecodeFile:

; 887  :         }
; 888  :         _PPMD_D_PUTC(FoundState->Symbol,DecodedFile);

	mov	rcx, QWORD PTR [rbp+16]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rbp+16]

; 889  :         if (!OrderFall && (BYTE*) FoundState->Successor >= UnitsStart)

	cmp	DWORD PTR OrderFall, 0
	jne	SHORT $LN3@DecodeFile
	mov	rax, QWORD PTR [rdx+2]
	cmp	rax, QWORD PTR UnitsStart
	jb	SHORT $LN3@DecodeFile

; 890  :         {
; 891  :             PrefetchData(MaxContext=FoundState->Successor);

	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext
	movzx	eax, BYTE PTR [rax]

; 892  :         }
; 893  :         else 

	jmp	SHORT $LN46@DecodeFile
$LN3@DecodeFile:

; 894  :         {
; 895  :             UpdateModel(MinContext);

	mov	rcx, rbx
	call	?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z	; UpdateModel

; 896  :             PrefetchData(MaxContext);

	mov	r11, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	movzx	eax, BYTE PTR [r11]

; 897  :             if (EscCount == 0)              

	cmp	BYTE PTR EscCount, 0
	jne	SHORT $LN46@DecodeFile

; 898  :                 ClearMask(EncodedFile,DecodedFile);

	lea	rcx, OFFSET FLAT:CharMask
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	mov	BYTE PTR EscCount, 1
	call	memset
	inc	BYTE PTR PrintCount
$LN46@DecodeFile:

; 899  :         }
; 900  :         ns=(MinContext=MaxContext)->NumStats;

	mov	rbx, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	mov	r9d, DWORD PTR low
	mov	edi, DWORD PTR code
	movzx	r10d, BYTE PTR [rbx]
	mov	ecx, DWORD PTR range
	npad	7

; 901  :         rcDecNormalize(EncodedFile);

$LL50@DecodeFile:
	lea	eax, DWORD PTR [rcx+r9]
	xor	eax, r9d
	cmp	eax, 16777216				; 01000000H
	jb	SHORT $LN48@DecodeFile
	cmp	ecx, 32768				; 00008000H
	jae	SHORT $LN74@DecodeFile
	mov	ecx, r9d
	neg	ecx
	and	ecx, 32767				; 00007fffH
$LN48@DecodeFile:
	mov	eax, DWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
	add	rax, QWORD PTR [rsi+8]
	cmp	rdx, rax
	jae	SHORT $LN53@DecodeFile
	movzx	r8d, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rsi+16], rax
	jmp	SHORT $LN54@DecodeFile
$LN53@DecodeFile:
	or	r8d, -1
$LN54@DecodeFile:
	shl	edi, 8
	shl	ecx, 8
	or	edi, r8d
	mov	DWORD PTR range, ecx
	shl	r9d, 8
	mov	DWORD PTR code, edi
	jmp	SHORT $LL50@DecodeFile
$LN74@DecodeFile:
	mov	DWORD PTR low, r9d

; 874  :         {
; 875  :             rcDecNormalize(EncodedFile);

	jmp	$LL14@DecodeFile
$STOP_DECODING$68289:

; 902  :     }
; 903  :     
; 904  : STOP_DECODING:
; 905  :     PrintInfo(DecodedFile,EncodedFile);
; 906  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
DecodeFile ENDP
_TEXT	ENDS
PUBLIC	EncodeFile
pdata	SEGMENT
$pdata$EncodeFile DD imagerel $LN85
	DD	imagerel $LN85+728
	DD	imagerel $unwind$EncodeFile
pdata	ENDS
xdata	SEGMENT
$unwind$EncodeFile DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
_TEXT	SEGMENT
EncodedFile$ = 48
DecodedFile$ = 56
EncodeFile PROC

; 799  : {

$LN85:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx

; 800  :     rcInitEncoder();
; 801  :     StartModelRare(MaxOrder,MRMethod);

	xor	edx, edx
	mov	rdi, rcx
	lea	ecx, QWORD PTR [rdx+8]
	mov	DWORD PTR low, 0
	mov	DWORD PTR range, -1			; ffffffffH
	call	?StartModelRare@@YAXHW4MR_METHOD@@@Z	; StartModelRare
	npad	8
$LL14@EncodeFile:

; 802  : 
; 803  :     for (PPM_CONTEXT* MinContext; ; ) 
; 804  :     {
; 805  :         BYTE    ns  =(MinContext=MaxContext)->NumStats;
; 806  :         int     c   = _PPMD_E_GETC(DecodedFile);

	mov	eax, DWORD PTR [rbp]
	mov	rbx, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	mov	rcx, QWORD PTR [rbp+16]
	add	rax, QWORD PTR [rbp+8]
	movzx	edx, BYTE PTR [rbx]
	cmp	rcx, rax
	jae	SHORT $LN19@EncodeFile
	movzx	esi, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbp+16], rax
	jmp	SHORT $LN20@EncodeFile
$LN19@EncodeFile:
	or	esi, -1
$LN20@EncodeFile:

; 807  : 
; 808  :         if( ns ) 

	test	dl, dl

; 809  :         {
; 810  :             MinContext->encodeSymbol1(c);   

	mov	rcx, rbx
	mov	edx, esi
	je	SHORT $LN12@EncodeFile
	call	?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z	; PPM_CONTEXT::encodeSymbol1

; 811  :             rcEncodeSymbol();

	mov	eax, DWORD PTR range
	mov	r9d, DWORD PTR low
	xor	edx, edx
	div	DWORD PTR SubRange+8
	mov	edx, DWORD PTR SubRange
	mov	ecx, edx
	mov	r8d, eax
	imul	ecx, eax
	add	r9d, ecx
	mov	ecx, DWORD PTR SubRange+4
	sub	ecx, edx
	mov	DWORD PTR low, r9d
	imul	r8d, ecx
	mov	DWORD PTR range, r8d

; 812  :         } 
; 813  :         else

	jmp	SHORT $LN60@EncodeFile
$LN12@EncodeFile:

; 814  :         {
; 815  :             MinContext->encodeBinSymbol(c);

	call	?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z	; PPM_CONTEXT::encodeBinSymbol
	mov	r9d, DWORD PTR low
	mov	r8d, DWORD PTR range
$LN60@EncodeFile:

; 816  :         }
; 817  :         
; 818  :         while( !FoundState ) 

	mov	rax, QWORD PTR FoundState
	test	rax, rax
	jne	$LN84@EncodeFile
	npad	3

; 819  :         {
; 820  :             rcEncNormalize(EncodedFile);

$LL26@EncodeFile:
	lea	eax, DWORD PTR [r8+r9]
	xor	eax, r9d
	cmp	eax, 16777216				; 01000000H
	jb	SHORT $LN24@EncodeFile
	cmp	r8d, 32768				; 00008000H
	jae	SHORT $LN79@EncodeFile
	mov	r8d, r9d
	neg	r8d
	and	r8d, 32767				; 00007fffH
$LN24@EncodeFile:
	mov	rax, QWORD PTR [rdi+16]
	mov	ecx, r9d
	shl	r8d, 8
	shr	ecx, 24
	mov	DWORD PTR range, r8d
	mov	BYTE PTR [rax], cl
	inc	QWORD PTR [rdi+16]
	shl	r9d, 8
	mov	DWORD PTR low, r9d
	jmp	SHORT $LL26@EncodeFile
$LN79@EncodeFile:
	movzx	ecx, BYTE PTR NumMasked
	mov	eax, DWORD PTR OrderFall
	npad	7
$LL8@EncodeFile:

; 821  :             do
; 822  :             {
; 823  :                 OrderFall++;                
; 824  :                 MinContext=MinContext->Suffix;

	mov	rbx, QWORD PTR [rbx+12]
	inc	eax
	mov	DWORD PTR OrderFall, eax

; 825  : 
; 826  :                 if( !MinContext )          

	test	rbx, rbx
	je	$STOP_ENCODING$68263

; 827  :                     goto STOP_ENCODING;
; 828  :             } while (MinContext->NumStats == NumMasked);

	cmp	BYTE PTR [rbx], cl
	je	SHORT $LL8@EncodeFile

; 829  : 
; 830  :             MinContext->encodeSymbol2(c);   

	mov	edx, esi
	mov	rcx, rbx
	call	?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z	; PPM_CONTEXT::encodeSymbol2

; 831  :             rcEncodeSymbol();

	mov	eax, DWORD PTR range
	mov	ecx, DWORD PTR SubRange
	mov	r9d, DWORD PTR low
	xor	edx, edx
	div	DWORD PTR SubRange+8
	mov	r8d, eax
	mov	eax, ecx
	imul	eax, r8d
	add	r9d, eax
	mov	eax, DWORD PTR SubRange+4
	sub	eax, ecx
	mov	DWORD PTR low, r9d
	imul	r8d, eax
	mov	rax, QWORD PTR FoundState
	mov	DWORD PTR range, r8d
	test	rax, rax
	je	$LL26@EncodeFile
$LN84@EncodeFile:

; 832  :         }
; 833  :         
; 834  :         if (!OrderFall && (BYTE*) FoundState->Successor >= UnitsStart)

	cmp	DWORD PTR OrderFall, 0
	jne	SHORT $LN3@EncodeFile
	mov	rax, QWORD PTR [rax+2]
	cmp	rax, QWORD PTR UnitsStart
	jb	SHORT $LN3@EncodeFile

; 835  :         {
; 836  :             PrefetchData(MaxContext=FoundState->Successor);

	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext
	movzx	eax, BYTE PTR [rax]

; 837  :         }
; 838  :         else 

	jmp	SHORT $LN80@EncodeFile
$LN3@EncodeFile:

; 839  :         {
; 840  :             UpdateModel(MinContext);        

	mov	rcx, rbx
	call	?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z	; UpdateModel

; 841  :             PrefetchData(MaxContext);

	mov	r11, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	movzx	eax, BYTE PTR [r11]

; 842  : 
; 843  :             if (EscCount == 0 )

	cmp	BYTE PTR EscCount, 0
	jne	SHORT $LN80@EncodeFile

; 844  :                 ClearMask(EncodedFile,DecodedFile);

	lea	rcx, OFFSET FLAT:CharMask
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	mov	BYTE PTR EscCount, 1
	call	memset
	inc	BYTE PTR PrintCount
$LN80@EncodeFile:
	mov	r8d, DWORD PTR low
	mov	edx, DWORD PTR range

; 845  :         }
; 846  :         rcEncNormalize(EncodedFile);

$LL44@EncodeFile:
	lea	eax, DWORD PTR [rdx+r8]
	xor	eax, r8d
	cmp	eax, 16777216				; 01000000H
	jb	SHORT $LN42@EncodeFile
	cmp	edx, 32768				; 00008000H
	jae	SHORT $LN81@EncodeFile
	mov	edx, r8d
	neg	edx
	and	edx, 32767				; 00007fffH
$LN42@EncodeFile:
	mov	rax, QWORD PTR [rdi+16]
	mov	ecx, r8d
	shl	edx, 8
	shr	ecx, 24
	mov	DWORD PTR range, edx
	mov	BYTE PTR [rax], cl
	inc	QWORD PTR [rdi+16]
	shl	r8d, 8
	jmp	SHORT $LL44@EncodeFile
$LN81@EncodeFile:
	mov	DWORD PTR low, r8d

; 819  :         {
; 820  :             rcEncNormalize(EncodedFile);

	jmp	$LL14@EncodeFile
$STOP_ENCODING$68263:

; 847  :     } // for (PPM_CONTEXT* MinContext; ; )
; 848  :     
; 849  : STOP_ENCODING:
; 850  :     rcFlushEncoder(EncodedFile);            

	mov	rax, QWORD PTR [rdi+16]

; 851  :     PrintInfo(DecodedFile,EncodedFile);
; 852  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	ecx, r9d
	shl	r9d, 8
	shr	ecx, 24
	mov	BYTE PTR [rax], cl
	inc	QWORD PTR [rdi+16]
	mov	rcx, QWORD PTR [rdi+16]
	mov	eax, r9d
	shl	r9d, 8
	shr	eax, 24
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rdi+16]
	mov	rcx, QWORD PTR [rdi+16]
	mov	eax, r9d
	shl	r9d, 8
	shr	eax, 24
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rdi+16]
	mov	rcx, QWORD PTR [rdi+16]
	mov	eax, r9d
	shr	eax, 24
	mov	BYTE PTR [rcx], al
	inc	QWORD PTR [rdi+16]
	shl	r9d, 8
	mov	DWORD PTR low, r9d
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
EncodeFile ENDP
PUBLIC	StartSubAllocator
pdata	SEGMENT
$pdata$StartSubAllocator DD imagerel $LN13
	DD	imagerel $LN13+107
	DD	imagerel $unwind$StartSubAllocator
pdata	ENDS
xdata	SEGMENT
$unwind$StartSubAllocator DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
xdata	ENDS
_TEXT	SEGMENT
$T292534 = 48
StartSubAllocator PROC

; 66   : {

$LN13:
	sub	rsp, 40					; 00000028H

; 67   :     DWORD t=SASize << 20U;
; 68   :     if (SubAllocatorSize == t)              return TRUE;

	mov	eax, DWORD PTR SubAllocatorSize
	cmp	eax, 33554432				; 02000000H
	je	SHORT $LN12@StartSubAl

; 69   :     StopSubAllocator();

	test	eax, eax
	je	SHORT $LN8@StartSubAl
	mov	rax, QWORD PTR HeapStart
	lea	rcx, QWORD PTR $T292534[rsp]
	mov	DWORD PTR SubAllocatorSize, 0
	mov	QWORD PTR $T292534[rsp], rax
	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN8@StartSubAl:

; 70   :     if ((HeapStart=new BYTE[t]) == NULL)    return FALSE;

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 33554432				; 02000000H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	QWORD PTR HeapStart, rax
	test	rax, rax
	jne	SHORT $LN1@StartSubAl

; 72   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@StartSubAl:

; 71   :     SubAllocatorSize=t;                     return TRUE;

	mov	DWORD PTR SubAllocatorSize, 33554432	; 02000000H
$LN12@StartSubAl:
	mov	eax, 1

; 72   : }

	add	rsp, 40					; 00000028H
	ret	0
StartSubAllocator ENDP
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ??__EPPMd_StartUp@@YAXXZ
text$yc	SEGMENT
??__EPPMd_StartUp@@YAXXZ PROC				; `dynamic initializer for 'PPMd_StartUp'', COMDAT

; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;

	jmp	??0PPMD_STARTUP@@QEAA@XZ		; PPMD_STARTUP::PPMD_STARTUP
??__EPPMd_StartUp@@YAXXZ ENDP				; `dynamic initializer for 'PPMd_StartUp''
PUBLIC	?PPMd_StartUp@@3UPPMD_STARTUP@@A		; PPMd_StartUp
	ALIGN	4

?PPMd_StartUp@@3UPPMD_STARTUP@@A DB 01H DUP (?)		; PPMd_StartUp
PPMd_StartUp$initializer$ DQ FLAT:??__EPPMd_StartUp@@YAXXZ
END
