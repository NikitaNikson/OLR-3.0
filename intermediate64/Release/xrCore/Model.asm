; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?BList@@3PAUBLK_NODE@@A				; BList
PUBLIC	?MaxContext@@3PEAUPPM_CONTEXT@@EA		; MaxContext
PUBLIC	?DummySEE2Cont@@3USEE2_CONTEXT@@A		; DummySEE2Cont
PUBLIC	?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A		; SEE2Cont
PUBLIC	?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
low	DD	01H DUP (?)
range	DD	01H DUP (?)
SubRange DB	0cH DUP (?)
code	DD	01H DUP (?)
?BList@@3PAUBLK_NODE@@A DB 01c8H DUP (?)		; BList
SubAllocatorSize DD 01H DUP (?)
?MaxContext@@3PEAUPPM_CONTEXT@@EA DQ 01H DUP (?)	; MaxContext
_BSS	ENDS
;	COMDAT ?context@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4PEAUPPM_CONTEXT@@EA
_BSS	SEGMENT
?context@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4PEAUPPM_CONTEXT@@EA DQ 01H DUP (?) ; `StartModelRare'::`2'::context
?DummySEE2Cont@@3USEE2_CONTEXT@@A DD 01H DUP (?)	; DummySEE2Cont
?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A DD 0300H DUP (?)	; SEE2Cont
	ALIGN	8

?trained_model@@3PEAVstream@ppmd@compression@@EA DQ 01H DUP (?) ; trained_model
_BSS	ENDS
;	COMDAT ?first_time@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4_NA
CONST	SEGMENT
?first_time@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4_NA DB 01H ; `StartModelRare'::`2'::first_time
CONST	ENDS
;	COMDAT ?InitBinEsc@?8??StartModelRare@@YAXHW4MR_METHOD@@@Z@4QBGB
CONST	SEGMENT
?InitBinEsc@?8??StartModelRare@@YAXHW4MR_METHOD@@@Z@4QBGB DW 03cddH ; `StartModelRare'::`9'::InitBinEsc
	DW	01f3fH
	DW	059bfH
	DW	048f3H
	DW	064a1H
	DW	05abcH
	DW	06632H
	DW	06051H
ExpEscape DB	019H
	DB	0eH
	DB	09H
	DB	07H
	DB	05H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
PUBLIC	?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z	; ClearMask
PUBLIC	?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::decodeSymbol2
PUBLIC	?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z		; PPM_CONTEXT::encodeSymbol2
PUBLIC	?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ ; PPM_CONTEXT::makeEscFreq2
PUBLIC	?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z	; PPM_CONTEXT::update2
PUBLIC	?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::decodeSymbol1
PUBLIC	?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z		; PPM_CONTEXT::encodeSymbol1
PUBLIC	?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z	; PPM_CONTEXT::update1
PUBLIC	?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ		; PPM_CONTEXT::decodeBinSymbol
PUBLIC	?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z		; PPM_CONTEXT::encodeBinSymbol
PUBLIC	?rescale@PPM_CONTEXT@@QEAAXXZ			; PPM_CONTEXT::rescale
PUBLIC	?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z	; PPM_CONTEXT::removeBinConts
PUBLIC	?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z		; PPM_CONTEXT::cutOff
PUBLIC	?refresh@PPM_CONTEXT@@QEAAXHH@Z			; PPM_CONTEXT::refresh
PUBLIC	?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z ; PPM_CONTEXT::read
PUBLIC	?makeSuffix@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::makeSuffix
PUBLIC	??0PPMD_STARTUP@@QEAA@XZ			; PPMD_STARTUP::PPMD_STARTUP
PUBLIC	?StateCpy@@YAXAEAUSTATE@PPM_CONTEXT@@AEBU12@@Z	; StateCpy
PUBLIC	?SWAP@@YAXAEAUSTATE@PPM_CONTEXT@@0@Z		; SWAP
PUBLIC	?oneState@PPM_CONTEXT@@QEBAAEAUSTATE@1@XZ	; PPM_CONTEXT::oneState
PUBLIC	?update@SEE2_CONTEXT@@QEAAXXZ			; SEE2_CONTEXT::update
PUBLIC	?getMean@SEE2_CONTEXT@@QEAAIXZ			; SEE2_CONTEXT::getMean
PUBLIC	?init@SEE2_CONTEXT@@QEAAXI@Z			; SEE2_CONTEXT::init
PUBLIC	?MoveUnitsUp@@YAPEAXPEAXI@Z			; MoveUnitsUp
PUBLIC	?SpecialFreeUnit@@YAXPEAX@Z			; SpecialFreeUnit
PUBLIC	?FreeUnits@@YAXPEAXI@Z				; FreeUnits
PUBLIC	?ShrinkUnits@@YAPEAXPEAXII@Z			; ShrinkUnits
PUBLIC	?ExpandUnits@@YAPEAXPEAXI@Z			; ExpandUnits
PUBLIC	?UnitsCpy@@YAXPEAX0I@Z				; UnitsCpy
PUBLIC	?AllocContext@@YAPEAXXZ				; AllocContext
PUBLIC	?AllocUnits@@YAPEAXI@Z				; AllocUnits
PUBLIC	StopSubAllocator
PUBLIC	GetUsedMemory
PUBLIC	?SplitBlock@@YAXPEAXII@Z			; SplitBlock
PUBLIC	?U2B@@YAII@Z					; U2B
PUBLIC	?insert@BLK_NODE@@QEAAXPEAXH@Z			; BLK_NODE::insert
PUBLIC	?PrefetchData@@YAXPEAX@Z			; PrefetchData
PUBLIC	?remove@BLK_NODE@@QEAAPEAXXZ			; BLK_NODE::remove
PUBLIC	?unlink@BLK_NODE@@QEAAXXZ			; BLK_NODE::unlink
PUBLIC	?link@BLK_NODE@@QEAAXPEAU1@@Z			; BLK_NODE::link
PUBLIC	?avail@BLK_NODE@@QEBAHXZ			; BLK_NODE::avail
PUBLIC	?rcDecNormalize@ppmd@@YAXPEAVstream@1compression@@@Z ; ppmd::rcDecNormalize
PUBLIC	?rcEncNormalize@ppmd@@YAXPEAVstream@1compression@@@Z ; ppmd::rcEncNormalize
PUBLIC	?get_char@stream@ppmd@compression@@QEAAHXZ	; compression::ppmd::stream::get_char
PUBLIC	?put_char@stream@ppmd@compression@@QEAAXAEBE@Z	; compression::ppmd::stream::put_char
PUBLIC	StartSubAllocator
PUBLIC	EncodeFile
PUBLIC	DecodeFile
PUBLIC	?PPMd_StartUp@@3UPPMD_STARTUP@@A		; PPMd_StartUp
	ALIGN	4

Units2Indx DB	080H DUP (?)
MRMethod DD	01H DUP (?)
Indx2Units DB	026H DUP (?)
	ALIGN	8

UnitsStart DQ	01H DUP (?)
MaxOrder DD	01H DUP (?)
PrintCount DB	01H DUP (?)
	ALIGN	4

NS2BSIndx DB	0100H DUP (?)
RunLength DD	01H DUP (?)
NumMasked DB	01H DUP (?)
	ALIGN	8

FoundState DQ	01H DUP (?)
QTable	DB	0104H DUP (?)
	ALIGN	8

LoUnit	DQ	01H DUP (?)
InitRL	DD	01H DUP (?)
BinSumm	DW	0640H DUP (?)
CharMask DB	0100H DUP (?)
PrevSuccess DB	01H DUP (?)
	ALIGN	8

HiUnit	DQ	01H DUP (?)
GlueCount DD	01H DUP (?)
	ALIGN	8

HeapStart DQ	01H DUP (?)
EscCount DB	01H DUP (?)
	ALIGN	8

pText	DQ	01H DUP (?)
InitEsc	DD	01H DUP (?)
OrderFall DD	01H DUP (?)
?PPMd_StartUp@@3UPPMD_STARTUP@@A DB 01H DUP (?)		; PPMd_StartUp
_BSS	ENDS
pdata	SEGMENT
$pdata$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel $unwind$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$pdata$1$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+125
	DD	imagerel $chain$1$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$pdata$5$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+125
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+624
	DD	imagerel $chain$5$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$pdata$6$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+624
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+1112
	DD	imagerel $chain$6$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$pdata$7$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+1112
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+1120
	DD	imagerel $chain$7$?StartModelRare@@YAXHW4MR_METHOD@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z DD imagerel $LN7
	DD	imagerel $LN7+42
	DD	imagerel $unwind$?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN40
	DD	imagerel $LN40+426
	DD	imagerel $unwind$?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z DD imagerel $LN38
	DD	imagerel $LN38+343
	DD	imagerel $unwind$?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+54
	DD	imagerel $unwind$?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+429
	DD	imagerel $unwind$?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z DD imagerel $LN29
	DD	imagerel $LN29+396
	DD	imagerel $unwind$?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ DD imagerel $LN16
	DD	imagerel $LN16+352
	DD	imagerel $unwind$?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z DD imagerel $LN14
	DD	imagerel $LN14+341
	DD	imagerel $unwind$?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z DD imagerel ?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z
	DD	imagerel ?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z+832
	DD	imagerel $unwind$?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z
$pdata$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z DD imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
	DD	imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z+255
	DD	imagerel $unwind$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
$pdata$3$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z DD imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z+255
	DD	imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z+553
	DD	imagerel $chain$3$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
$pdata$?rescale@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN65
	DD	imagerel $LN65+26
	DD	imagerel $unwind$?rescale@PPM_CONTEXT@@QEAAXXZ
$pdata$1$?rescale@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN65+26
	DD	imagerel $LN65+304
	DD	imagerel $chain$1$?rescale@PPM_CONTEXT@@QEAAXXZ
$pdata$2$?rescale@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN65+304
	DD	imagerel $LN65+641
	DD	imagerel $chain$2$?rescale@PPM_CONTEXT@@QEAAXXZ
$pdata$?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z DD imagerel ?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z
	DD	imagerel ?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z+386
	DD	imagerel $unwind$?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z
$pdata$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+23
	DD	imagerel $unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$1$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+23
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+61
	DD	imagerel $chain$1$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$2$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+61
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+249
	DD	imagerel $chain$2$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$3$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+249
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+259
	DD	imagerel $chain$3$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$4$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+259
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+349
	DD	imagerel $chain$4$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$5$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+349
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+596
	DD	imagerel $chain$5$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$pdata$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN33
	DD	imagerel $LN33+201
	DD	imagerel $unwind$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$0$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN33+201
	DD	imagerel $LN33+285
	DD	imagerel $chain$0$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$1$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN33+285
	DD	imagerel $LN33+304
	DD	imagerel $chain$1$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN67
	DD	imagerel $LN67+118
	DD	imagerel $unwind$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$0$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN67+118
	DD	imagerel $LN67+283
	DD	imagerel $chain$0$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$1$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD imagerel $LN67+283
	DD	imagerel $LN67+640
	DD	imagerel $chain$1$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
$pdata$?refresh@PPM_CONTEXT@@QEAAXHH@Z DD imagerel $LN11
	DD	imagerel $LN11+179
	DD	imagerel $unwind$?refresh@PPM_CONTEXT@@QEAAXHH@Z
$pdata$?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z DD imagerel $LN80
	DD	imagerel $LN80+840
	DD	imagerel $unwind$?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z
$pdata$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN44
	DD	imagerel $LN44+84
	DD	imagerel $unwind$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
$pdata$0$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN44+84
	DD	imagerel $LN44+204
	DD	imagerel $chain$0$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
$pdata$1$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD imagerel $LN44+204
	DD	imagerel $LN44+210
	DD	imagerel $chain$1$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0PPMD_STARTUP@@QEAA@XZ DD imagerel $LN54
	DD	imagerel $LN54+337
	DD	imagerel $unwind$??0PPMD_STARTUP@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EPPMd_StartUp@@YAXXZ DD imagerel ??__EPPMd_StartUp@@YAXXZ
	DD	imagerel ??__EPPMd_StartUp@@YAXXZ+330
	DD	imagerel $unwind$??__EPPMd_StartUp@@YAXXZ
pdata	ENDS
pdata	SEGMENT
$pdata$?ExpandTextArea@@YAXXZ DD imagerel ?ExpandTextArea@@YAXXZ
	DD	imagerel ?ExpandTextArea@@YAXXZ+229
	DD	imagerel $unwind$?ExpandTextArea@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MoveUnitsUp@@YAPEAXPEAXI@Z DD imagerel $LN26
	DD	imagerel $LN26+79
	DD	imagerel $unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?MoveUnitsUp@@YAPEAXPEAXI@Z DD imagerel $LN26+79
	DD	imagerel $LN26+227
	DD	imagerel $chain$0$?MoveUnitsUp@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?MoveUnitsUp@@YAPEAXPEAXI@Z DD imagerel $LN26+227
	DD	imagerel $LN26+258
	DD	imagerel $chain$2$?MoveUnitsUp@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?MoveUnitsUp@@YAPEAXPEAXI@Z DD imagerel $LN26+258
	DD	imagerel $LN26+268
	DD	imagerel $chain$3$?MoveUnitsUp@@YAPEAXPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ShrinkUnits@@YAPEAXPEAXII@Z DD imagerel $LN25
	DD	imagerel $LN25+221
	DD	imagerel $unwind$?ShrinkUnits@@YAPEAXPEAXII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ExpandUnits@@YAPEAXPEAXI@Z DD imagerel $LN18
	DD	imagerel $LN18+190
	DD	imagerel $unwind$?ExpandUnits@@YAPEAXPEAXI@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?AllocUnitsRare@@YAPEAXI@Z DD imagerel ?AllocUnitsRare@@YAPEAXI@Z
	DD	imagerel ?AllocUnitsRare@@YAPEAXI@Z+289
	DD	imagerel $unwind$?AllocUnitsRare@@YAPEAXI@Z
$pdata$?GlueFreeBlocks@@YAXXZ DD imagerel ?GlueFreeBlocks@@YAXXZ
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+167
	DD	imagerel $unwind$?GlueFreeBlocks@@YAXXZ
$pdata$3$?GlueFreeBlocks@@YAXXZ DD imagerel ?GlueFreeBlocks@@YAXXZ+167
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+469
	DD	imagerel $chain$3$?GlueFreeBlocks@@YAXXZ
$pdata$4$?GlueFreeBlocks@@YAXXZ DD imagerel ?GlueFreeBlocks@@YAXXZ+469
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+486
	DD	imagerel $chain$4$?GlueFreeBlocks@@YAXXZ
$pdata$?InitSubAllocator@@YAXXZ DD imagerel ?InitSubAllocator@@YAXXZ
	DD	imagerel ?InitSubAllocator@@YAXXZ+103
	DD	imagerel $unwind$?InitSubAllocator@@YAXXZ
$pdata$StopSubAllocator DD imagerel $LN7
	DD	imagerel $LN7+50
	DD	imagerel $unwind$StopSubAllocator
$pdata$GetUsedMemory DD imagerel $LN22
	DD	imagerel $LN22+66
	DD	imagerel $unwind$GetUsedMemory
$pdata$1$GetUsedMemory DD imagerel $LN22+66
	DD	imagerel $LN22+280
	DD	imagerel $chain$1$GetUsedMemory
$pdata$2$GetUsedMemory DD imagerel $LN22+280
	DD	imagerel $LN22+297
	DD	imagerel $chain$2$GetUsedMemory
$pdata$3$GetUsedMemory DD imagerel $LN22+297
	DD	imagerel $LN22+434
	DD	imagerel $chain$3$GetUsedMemory
$pdata$4$GetUsedMemory DD imagerel $LN22+434
	DD	imagerel $LN22+445
	DD	imagerel $chain$4$GetUsedMemory
$pdata$StartSubAllocator DD imagerel $LN14
	DD	imagerel $LN14+107
	DD	imagerel $unwind$StartSubAllocator
$pdata$EncodeFile DD imagerel $LN108
	DD	imagerel $LN108+728
	DD	imagerel $unwind$EncodeFile
$pdata$DecodeFile DD imagerel $LN91
	DD	imagerel $LN91+665
	DD	imagerel $unwind$DecodeFile
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ExpandUnits@@YAPEAXPEAXI@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ShrinkUnits@@YAPEAXPEAXII@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?MoveUnitsUp@@YAPEAXPEAXI@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+79
	DD	imagerel $unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?MoveUnitsUp@@YAPEAXPEAXI@Z DD 020021H
	DD	027400H
	DD	imagerel $LN26
	DD	imagerel $LN26+79
	DD	imagerel $unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?MoveUnitsUp@@YAPEAXPEAXI@Z DD 020521H
	DD	027405H
	DD	imagerel $LN26
	DD	imagerel $LN26+79
	DD	imagerel $unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MoveUnitsUp@@YAPEAXPEAXI@Z DD 030601H
	DD	033406H
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EPPMd_StartUp@@YAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0PPMD_STARTUP@@QEAA@XZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ DD 0b1b01H
	DD	010a641bH
	DD	0109541bH
	DD	0108341bH
	DD	0104011bH
	DD	0e012f014H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z DD 010401H
	DD	04204H
xdata	ENDS
xdata	SEGMENT
$unwind$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 030801H
	DD	0e0046208H
	DD	03002H
$chain$1$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 040a21H
	DD	0b640aH
	DD	0a5405H
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel $unwind$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$chain$5$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 082a21H
	DD	04f42aH
	DD	05d41eH
	DD	06c40aH
	DD	0c7405H
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+125
	DD	imagerel $chain$1$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$chain$6$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 060021H
	DD	04f400H
	DD	05d400H
	DD	06c400H
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+125
	DD	imagerel $chain$1$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$chain$7$?StartModelRare@@YAXHW4MR_METHOD@@@Z DD 021H
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z
	DD	imagerel ?StartModelRare@@YAXHW4MR_METHOD@@@Z+115
	DD	imagerel $unwind$?StartModelRare@@YAXHW4MR_METHOD@@@Z
$unwind$?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z DD 0bc501H
	DD	04d4c5H
	DD	0ec4c0H
	DD	0f009420dH
	DD	07005e007H
	DD	050036004H
	DD	03002H
$unwind$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z DD 0afc01H
	DD	01ee4fcH
	DD	01d74f4H
	DD	01c54daH
	DD	019010aH
	DD	030026003H
$chain$3$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z DD 020821H
	DD	018f408H
	DD	imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
	DD	imagerel ?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z+255
	DD	imagerel $unwind$?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z
$unwind$?rescale@PPM_CONTEXT@@QEAAXXZ DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b520fH
$chain$1$?rescale@PPM_CONTEXT@@QEAAXXZ DD 048221H
	DD	085482H
	DD	09e405H
	DD	imagerel $LN65
	DD	imagerel $LN65+26
	DD	imagerel $unwind$?rescale@PPM_CONTEXT@@QEAAXXZ
$chain$2$?rescale@PPM_CONTEXT@@QEAAXXZ DD 021H
	DD	imagerel $LN65
	DD	imagerel $LN65+26
	DD	imagerel $unwind$?rescale@PPM_CONTEXT@@QEAAXXZ
$unwind$?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z DD 0b1d01H
	DD	019741dH
	DD	018641dH
	DD	017541dH
	DD	016341dH
	DD	014011dH
	DD	0e016H
$unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 040901H
	DD	0f0053209H
	DD	030027003H
$chain$1$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 040a21H
	DD	0ae40aH
	DD	085405H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+23
	DD	imagerel $unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$chain$2$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 020521H
	DD	096405H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+23
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+61
	DD	imagerel $chain$1$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$chain$3$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 021H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+23
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+61
	DD	imagerel $chain$1$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$chain$4$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 020021H
	DD	0ae400H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+23
	DD	imagerel $unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$chain$5$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z DD 021H
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
	DD	imagerel ?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z+23
	DD	imagerel $unwind$?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z
$unwind$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
$chain$0$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 020521H
	DD	063405H
	DD	imagerel $LN33
	DD	imagerel $LN33+201
	DD	imagerel $unwind$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
$chain$1$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+201
	DD	imagerel $unwind$?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z
$unwind$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 040b01H
	DD	07007320bH
	DD	050056006H
$chain$0$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN67
	DD	imagerel $LN67+118
	DD	imagerel $unwind$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
$chain$1$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z DD 021H
	DD	imagerel $LN67
	DD	imagerel $LN67+118
	DD	imagerel $unwind$?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z
$unwind$?refresh@PPM_CONTEXT@@QEAAXHH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z DD 082101H
	DD	065421H
	DD	09640fH
	DD	07340fH
	DD	0700b320fH
$unwind$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD 020601H
	DD	030023206H
$chain$0$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN44
	DD	imagerel $LN44+84
	DD	imagerel $unwind$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
$chain$1$?makeSuffix@PPM_CONTEXT@@QEAAXXZ DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+84
	DD	imagerel $unwind$?makeSuffix@PPM_CONTEXT@@QEAAXXZ
$unwind$?ExpandTextArea@@YAXXZ DD 030901H
	DD	0180109H
	DD	03002H
$unwind$?AllocUnitsRare@@YAPEAXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?GlueFreeBlocks@@YAXXZ DD 020601H
	DD	0e0021206H
$chain$3$?GlueFreeBlocks@@YAXXZ DD 081e21H
	DD	07741eH
	DD	043412H
	DD	06640aH
	DD	055405H
	DD	imagerel ?GlueFreeBlocks@@YAXXZ
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+167
	DD	imagerel $unwind$?GlueFreeBlocks@@YAXXZ
$chain$4$?GlueFreeBlocks@@YAXXZ DD 021H
	DD	imagerel ?GlueFreeBlocks@@YAXXZ
	DD	imagerel ?GlueFreeBlocks@@YAXXZ+167
	DD	imagerel $unwind$?GlueFreeBlocks@@YAXXZ
$unwind$?InitSubAllocator@@YAXXZ DD 010401H
	DD	04204H
$unwind$StopSubAllocator DD 010401H
	DD	04204H
$unwind$GetUsedMemory DD 040a01H
	DD	07340aH
	DD	07006320aH
$chain$1$GetUsedMemory DD 040c21H
	DD	0780cH
	DD	016805H
	DD	imagerel $LN22
	DD	imagerel $LN22+66
	DD	imagerel $unwind$GetUsedMemory
$chain$2$GetUsedMemory DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+66
	DD	imagerel $unwind$GetUsedMemory
$chain$3$GetUsedMemory DD 020521H
	DD	066405H
	DD	imagerel $LN22+280
	DD	imagerel $LN22+297
	DD	imagerel $chain$2$GetUsedMemory
$chain$4$GetUsedMemory DD 021H
	DD	imagerel $LN22+280
	DD	imagerel $LN22+297
	DD	imagerel $chain$2$GetUsedMemory
$unwind$StartSubAllocator DD 010401H
	DD	04204H
$unwind$EncodeFile DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$DecodeFile DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
PPMd_StartUp$initializer$ DQ FLAT:??__EPPMd_StartUp@@YAXXZ
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
DecodedFile$ = 48
EncodedFile$ = 56
MaxOrder$dead$ = 64
MRMethod$dead$ = 72
DecodeFile PROC

; 856  : {

$LN91:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbp, rcx

; 857  :     rcInitDecoder(EncodedFile);

	mov	rcx, rdx
	mov	rsi, rdx
	call	?rcInitDecoder@ppmd@@YAXPEAVstream@1compression@@@Z ; ppmd::rcInitDecoder

; 858  :     StartModelRare(MaxOrder,MRMethod);

	xor	edx, edx
	lea	ecx, QWORD PTR [rdx+8]
	call	?StartModelRare@@YAXHW4MR_METHOD@@@Z	; StartModelRare

; 859  :     
; 860  :     PPM_CONTEXT* MinContext=MaxContext;

	mov	rdi, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	ebx, DWORD PTR code
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 861  :     for( BYTE ns=MinContext->NumStats; ; )

	movzx	r10d, BYTE PTR [rdi]
	npad	3
$LL14@DecodeFile:

; 862  :     {
; 863  :         if( ns )
; 864  :         {
; 865  :             MinContext->decodeSymbol1();    

	mov	rcx, rdi
	test	r10b, r10b
	je	SHORT $LN12@DecodeFile
	call	?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ	; PPM_CONTEXT::decodeSymbol1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 141  :     low     += range*SubRange.low;                 

	mov	eax, DWORD PTR range
	mov	r8d, DWORD PTR low
	mov	ecx, DWORD PTR SubRange
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 868  :         else                             

	mov	ebx, DWORD PTR code
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 141  :     low     += range*SubRange.low;                 

	imul	ecx, eax
	add	r8d, ecx

; 142  :     range   *= SubRange.high-SubRange.low;

	mov	ecx, DWORD PTR SubRange+4
	sub	ecx, DWORD PTR SubRange
	mov	DWORD PTR low, r8d
	imul	eax, ecx
	mov	DWORD PTR range, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 868  :         else                             

	jmp	SHORT $LN52@DecodeFile
$LN12@DecodeFile:

; 869  :         {
; 870  :             MinContext->decodeBinSymbol();

	call	?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ	; PPM_CONTEXT::decodeBinSymbol
	mov	r8d, DWORD PTR low
	mov	eax, DWORD PTR range
$LN52@DecodeFile:

; 873  :         while( !FoundState ) 

	mov	rdx, QWORD PTR FoundState
	test	rdx, rdx
	jne	$LN89@DecodeFile
	npad	4
$LL21@DecodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 120  :          ) 

	lea	ecx, DWORD PTR [rax+r8]
	xor	ecx, r8d
	cmp	ecx, 16777216				; 01000000H
	jb	SHORT $LN19@DecodeFile
	cmp	eax, 32768				; 00008000H
	jae	SHORT $LN80@DecodeFile
	mov	eax, r8d
	neg	eax
	and	eax, 32767				; 00007fffH
$LN19@DecodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	ecx, DWORD PTR [rsi]
	mov	rdx, QWORD PTR [rsi+16]
	add	rcx, QWORD PTR [rsi+8]
	cmp	rdx, rcx
	jae	SHORT $LN24@DecodeFile

; 25   : 		return		(*m_pointer++);

	movzx	r9d, BYTE PTR [rdx]
	lea	rcx, QWORD PTR [rdx+1]
	mov	QWORD PTR [rsi+16], rcx
	jmp	SHORT $LN25@DecodeFile
$LN24@DecodeFile:

; 26   : 	return			(EOF);

	or	r9d, -1
$LN25@DecodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 122  :         code    = (code << 8) | _PPMD_D_GETC(stream);

	shl	ebx, 8

; 123  :         range <<= 8;                        

	shl	eax, 8
	or	ebx, r9d
	mov	DWORD PTR range, eax

; 124  :         low   <<= 8;

	shl	r8d, 8
	mov	DWORD PTR code, ebx

; 125  :     }

	jmp	SHORT $LL21@DecodeFile
$LN80@DecodeFile:
	movzx	ecx, BYTE PTR NumMasked
	mov	eax, DWORD PTR OrderFall
	mov	DWORD PTR low, r8d
$LL8@DecodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 879  :                 MinContext=MinContext->Suffix;

	mov	rdi, QWORD PTR [rdi+12]
	inc	eax
	mov	DWORD PTR OrderFall, eax

; 880  :                 if( !MinContext )          

	test	rdi, rdi
	je	$STOP_DECODING$92

; 881  :                     goto STOP_DECODING;
; 882  :             } 
; 883  :             while( MinContext->NumStats == NumMasked );

	cmp	BYTE PTR [rdi], cl
	je	SHORT $LL8@DecodeFile

; 884  : 
; 885  :             MinContext->decodeSymbol2();    

	mov	rcx, rdi
	call	?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ	; PPM_CONTEXT::decodeSymbol2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 141  :     low     += range*SubRange.low;                 

	mov	eax, DWORD PTR range
	mov	r8d, DWORD PTR low
	mov	ecx, DWORD PTR SubRange
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 873  :         while( !FoundState ) 

	mov	rdx, QWORD PTR FoundState
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 141  :     low     += range*SubRange.low;                 

	imul	ecx, eax
	add	r8d, ecx

; 142  :     range   *= SubRange.high-SubRange.low;

	mov	ecx, DWORD PTR SubRange+4
	sub	ecx, DWORD PTR SubRange
	mov	DWORD PTR low, r8d
	imul	eax, ecx
	mov	DWORD PTR range, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 873  :         while( !FoundState ) 

	test	rdx, rdx
	jne	SHORT $LN89@DecodeFile
	mov	ebx, DWORD PTR code
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 120  :          ) 

	jmp	$LL21@DecodeFile
$LN89@DecodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	rcx, QWORD PTR [rbp+16]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [rcx], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [rbp+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 889  :         if (!OrderFall && (BYTE*) FoundState->Successor >= UnitsStart)

	cmp	DWORD PTR OrderFall, 0
	jne	SHORT $LN3@DecodeFile
	mov	rax, QWORD PTR [rdx+2]
	cmp	rax, QWORD PTR UnitsStart
	jb	SHORT $LN3@DecodeFile

; 890  :         {
; 891  :             PrefetchData(MaxContext=FoundState->Successor);

	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 893  :         else 

	jmp	SHORT $LN38@DecodeFile
$LN3@DecodeFile:

; 894  :         {
; 895  :             UpdateModel(MinContext);

	mov	rcx, rdi
	call	?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z	; UpdateModel

; 896  :             PrefetchData(MaxContext);

	mov	rax, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	ecx, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 897  :             if (EscCount == 0)              

	cmp	BYTE PTR EscCount, 0
	jne	SHORT $LN38@DecodeFile

; 792  :     EscCount=1;                             memset(CharMask,0,sizeof(CharMask));

	lea	rcx, OFFSET FLAT:CharMask
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	mov	BYTE PTR EscCount, 1
	call	memset

; 793  :     if (++PrintCount == 0)                  PrintInfo(DecodedFile,EncodedFile);

	inc	BYTE PTR PrintCount
$LN38@DecodeFile:

; 898  :                 ClearMask(EncodedFile,DecodedFile);
; 899  :         }
; 900  :         ns=(MinContext=MaxContext)->NumStats;

	mov	rdi, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	mov	edx, DWORD PTR low
	mov	ecx, DWORD PTR range
	movzx	r10d, BYTE PTR [rdi]
	mov	ebx, DWORD PTR code
	npad	11
$LL42@DecodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 120  :          ) 

	lea	eax, DWORD PTR [rcx+rdx]
	xor	eax, edx
	cmp	eax, 16777216				; 01000000H
	jb	SHORT $LN40@DecodeFile
	cmp	ecx, 32768				; 00008000H
	jae	SHORT $LN78@DecodeFile
	mov	ecx, edx
	neg	ecx
	and	ecx, 32767				; 00007fffH
$LN40@DecodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rsi]
	mov	r8, QWORD PTR [rsi+16]
	add	rax, QWORD PTR [rsi+8]
	cmp	r8, rax
	jae	SHORT $LN45@DecodeFile

; 25   : 		return		(*m_pointer++);

	movzx	r9d, BYTE PTR [r8]
	lea	rax, QWORD PTR [r8+1]
	mov	QWORD PTR [rsi+16], rax
	jmp	SHORT $LN46@DecodeFile
$LN45@DecodeFile:

; 26   : 	return			(EOF);

	or	r9d, -1
$LN46@DecodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 122  :         code    = (code << 8) | _PPMD_D_GETC(stream);

	shl	ebx, 8

; 123  :         range <<= 8;                        

	shl	ecx, 8
	or	ebx, r9d
	mov	DWORD PTR range, ecx

; 124  :         low   <<= 8;

	shl	edx, 8
	mov	DWORD PTR code, ebx

; 125  :     }

	jmp	SHORT $LL42@DecodeFile
$LN78@DecodeFile:

; 124  :         low   <<= 8;

	mov	DWORD PTR low, edx

; 120  :          ) 

	jmp	$LL14@DecodeFile
$STOP_DECODING$92:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 906  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
DecodeFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
EncodedFile$ = 48
DecodedFile$ = 56
MaxOrder$dead$ = 64
MRMethod$dead$ = 72
EncodeFile PROC

; 799  : {

$LN108:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx

; 801  :     StartModelRare(MaxOrder,MRMethod);

	xor	edx, edx
	mov	rdi, rcx
	lea	ecx, QWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 86   : static inline void rcInitEncoder() { low=0; range=DWORD(-1); }

	mov	DWORD PTR low, 0
	mov	DWORD PTR range, -1			; ffffffffH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 801  :     StartModelRare(MaxOrder,MRMethod);

	call	?StartModelRare@@YAXHW4MR_METHOD@@@Z	; StartModelRare
	npad	8
$LL14@EncodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rbp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 805  :         BYTE    ns  =(MinContext=MaxContext)->NumStats;

	mov	rbx, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	rcx, QWORD PTR [rbp+16]
	add	rax, QWORD PTR [rbp+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 805  :         BYTE    ns  =(MinContext=MaxContext)->NumStats;

	movzx	edx, BYTE PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	cmp	rcx, rax
	jae	SHORT $LN19@EncodeFile

; 25   : 		return		(*m_pointer++);

	movzx	esi, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rbp+16], rax
	jmp	SHORT $LN20@EncodeFile
$LN19@EncodeFile:

; 26   : 	return			(EOF);

	or	esi, -1
$LN20@EncodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 808  :         if( ns ) 

	test	dl, dl

; 809  :         {
; 810  :             MinContext->encodeSymbol1(c);   

	mov	rcx, rbx
	mov	edx, esi
	je	SHORT $LN12@EncodeFile
	call	?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z	; PPM_CONTEXT::encodeSymbol1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 98   :     low += SubRange.low*(range/=SubRange.scale);  range *= SubRange.high-SubRange.low;

	mov	eax, DWORD PTR range
	mov	r8d, DWORD PTR low
	mov	ecx, DWORD PTR SubRange
	xor	edx, edx
	div	DWORD PTR SubRange+8
	imul	ecx, eax
	add	r8d, ecx
	mov	ecx, DWORD PTR SubRange+4
	sub	ecx, DWORD PTR SubRange
	mov	DWORD PTR low, r8d
	imul	eax, ecx
	mov	DWORD PTR range, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 813  :         else

	jmp	SHORT $LN60@EncodeFile
$LN12@EncodeFile:

; 814  :         {
; 815  :             MinContext->encodeBinSymbol(c);

	call	?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z	; PPM_CONTEXT::encodeBinSymbol
	mov	r8d, DWORD PTR low
	mov	eax, DWORD PTR range
$LN60@EncodeFile:

; 818  :         while( !FoundState ) 

	mov	rcx, QWORD PTR FoundState
	test	rcx, rcx
	jne	$LN106@EncodeFile
	npad	7
$LL26@EncodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 78   :          ) 

	lea	ecx, DWORD PTR [rax+r8]
	xor	ecx, r8d
	cmp	ecx, 16777216				; 01000000H
	jb	SHORT $LN24@EncodeFile
	cmp	eax, 32768				; 00008000H
	jae	SHORT $LN102@EncodeFile
	mov	eax, r8d
	neg	eax
	and	eax, 32767				; 00007fffH
$LN24@EncodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	rcx, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 80   :         _PPMD_E_PUTC( low >> 24, stream );

	mov	edx, r8d

; 81   :         range   <<= 8;                        

	shl	eax, 8
	shr	edx, 24
	mov	DWORD PTR range, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rcx], dl

; 18   : 	++m_pointer;

	inc	QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 82   :         low     <<= 8;

	shl	r8d, 8
	mov	DWORD PTR low, r8d

; 83   :     }

	jmp	SHORT $LL26@EncodeFile
$LN102@EncodeFile:
	movzx	ecx, BYTE PTR NumMasked
	mov	eax, DWORD PTR OrderFall
	npad	13
$LL8@EncodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 824  :                 MinContext=MinContext->Suffix;

	mov	rbx, QWORD PTR [rbx+12]
	inc	eax
	mov	DWORD PTR OrderFall, eax

; 825  : 
; 826  :                 if( !MinContext )          

	test	rbx, rbx
	je	$STOP_ENCODING$109

; 827  :                     goto STOP_ENCODING;
; 828  :             } while (MinContext->NumStats == NumMasked);

	cmp	BYTE PTR [rbx], cl
	je	SHORT $LL8@EncodeFile

; 829  : 
; 830  :             MinContext->encodeSymbol2(c);   

	mov	edx, esi
	mov	rcx, rbx
	call	?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z	; PPM_CONTEXT::encodeSymbol2
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 98   :     low += SubRange.low*(range/=SubRange.scale);  range *= SubRange.high-SubRange.low;

	mov	eax, DWORD PTR range
	mov	ecx, DWORD PTR SubRange
	mov	r8d, DWORD PTR low
	xor	edx, edx
	div	DWORD PTR SubRange+8
	imul	ecx, eax
	add	r8d, ecx
	mov	ecx, DWORD PTR SubRange+4
	sub	ecx, DWORD PTR SubRange
	mov	DWORD PTR low, r8d
	imul	eax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 818  :         while( !FoundState ) 

	mov	rcx, QWORD PTR FoundState
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 98   :     low += SubRange.low*(range/=SubRange.scale);  range *= SubRange.high-SubRange.low;

	mov	DWORD PTR range, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 818  :         while( !FoundState ) 

	test	rcx, rcx
	je	$LL26@EncodeFile
$LN106@EncodeFile:

; 831  :             rcEncodeSymbol();
; 832  :         }
; 833  :         
; 834  :         if (!OrderFall && (BYTE*) FoundState->Successor >= UnitsStart)

	cmp	DWORD PTR OrderFall, 0
	jne	SHORT $LN3@EncodeFile
	mov	rax, QWORD PTR [rcx+2]
	cmp	rax, QWORD PTR UnitsStart
	jb	SHORT $LN3@EncodeFile

; 835  :         {
; 836  :             PrefetchData(MaxContext=FoundState->Successor);

	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 838  :         else 

	jmp	SHORT $LN103@EncodeFile
$LN3@EncodeFile:

; 839  :         {
; 840  :             UpdateModel(MinContext);        

	mov	rcx, rbx
	call	?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z	; UpdateModel

; 841  :             PrefetchData(MaxContext);

	mov	rax, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	ecx, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 843  :             if (EscCount == 0 )

	cmp	BYTE PTR EscCount, 0
	jne	SHORT $LN103@EncodeFile

; 792  :     EscCount=1;                             memset(CharMask,0,sizeof(CharMask));

	lea	rcx, OFFSET FLAT:CharMask
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	mov	BYTE PTR EscCount, 1
	call	memset

; 793  :     if (++PrintCount == 0)                  PrintInfo(DecodedFile,EncodedFile);

	inc	BYTE PTR PrintCount
$LN103@EncodeFile:
	mov	r8d, DWORD PTR low
	mov	edx, DWORD PTR range
	npad	5
$LL44@EncodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 78   :          ) 

	lea	eax, DWORD PTR [rdx+r8]
	xor	eax, r8d
	cmp	eax, 16777216				; 01000000H
	jb	SHORT $LN42@EncodeFile
	cmp	edx, 32768				; 00008000H
	jae	SHORT $LN100@EncodeFile
	mov	edx, r8d
	neg	edx
	and	edx, 32767				; 00007fffH
$LN42@EncodeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	rax, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 80   :         _PPMD_E_PUTC( low >> 24, stream );

	mov	ecx, r8d

; 81   :         range   <<= 8;                        

	shl	edx, 8
	shr	ecx, 24
	mov	DWORD PTR range, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rax], cl

; 18   : 	++m_pointer;

	inc	QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 82   :         low     <<= 8;

	shl	r8d, 8

; 83   :     }

	jmp	SHORT $LL44@EncodeFile
$LN100@EncodeFile:

; 82   :         low     <<= 8;

	mov	DWORD PTR low, r8d

; 78   :          ) 

	jmp	$LL14@EncodeFile
$STOP_ENCODING$109:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	rax, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 852  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	ecx, r8d
	shl	r8d, 8
	shr	ecx, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rax], cl

; 18   : 	++m_pointer;

	inc	QWORD PTR [rdi+16]
	mov	rcx, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	eax, r8d
	shl	r8d, 8
	shr	eax, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rcx], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [rdi+16]
	mov	rcx, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	eax, r8d
	shl	r8d, 8
	shr	eax, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rcx], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [rdi+16]
	mov	rcx, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	eax, r8d
	shr	eax, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rcx], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	shl	r8d, 8
	mov	DWORD PTR low, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 852  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
EncodeFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	SEGMENT
SASize$dead$ = 48
p$ = 56
StartSubAllocator PROC

; 66   : {

$LN14:
	sub	rsp, 40					; 00000028H

; 67   :     DWORD t=SASize << 20U;
; 68   :     if (SubAllocatorSize == t)              return TRUE;

	mov	eax, DWORD PTR SubAllocatorSize
	cmp	eax, 33554432				; 02000000H
	je	SHORT $LN12@StartSubAl

; 61   :     if ( SubAllocatorSize ) {

	test	eax, eax
	je	SHORT $LN8@StartSubAl

; 62   :         SubAllocatorSize=0;                 delete[] HeapStart;

	mov	rax, QWORD PTR HeapStart
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 62   :         SubAllocatorSize=0;                 delete[] HeapStart;

	mov	DWORD PTR SubAllocatorSize, 0
	mov	QWORD PTR p$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN8@StartSubAl:

; 126  : 	IC void*	operator new		(size_t size)		{	return Memory.mem_alloc(size?size:1);				}

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 33554432				; 02000000H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	QWORD PTR HeapStart, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 70   :     if ((HeapStart=new BYTE[t]) == NULL)    return FALSE;

	test	rax, rax
	jne	SHORT $LN1@StartSubAl

; 72   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN1@StartSubAl:

; 71   :     SubAllocatorSize=t;                     return TRUE;

	mov	DWORD PTR SubAllocatorSize, 33554432	; 02000000H
$LN12@StartSubAl:
	mov	eax, 1

; 72   : }

	add	rsp, 40					; 00000028H
	ret	0
StartSubAllocator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
;	COMDAT ?put_char@stream@ppmd@compression@@QEAAXAEBE@Z
_TEXT	SEGMENT
this$ = 8
object$ = 16
?put_char@stream@ppmd@compression@@QEAAXAEBE@Z PROC	; compression::ppmd::stream::put_char, COMDAT

; 15   : 	VERIFY			(m_pointer >= m_buffer);
; 16   : 	VERIFY			(m_pointer < (m_buffer + m_buffer_size));
; 17   : 	*m_pointer		= object;

	mov	r8, QWORD PTR [rcx+16]
	movzx	eax, BYTE PTR [rdx]
	mov	BYTE PTR [r8], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [rcx+16]

; 19   : }

	ret	0
?put_char@stream@ppmd@compression@@QEAAXAEBE@Z ENDP	; compression::ppmd::stream::put_char
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
;	COMDAT ?get_char@stream@ppmd@compression@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?get_char@stream@ppmd@compression@@QEAAHXZ PROC		; compression::ppmd::stream::get_char, COMDAT

; 23   : 	VERIFY			(m_pointer >= m_buffer);
; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rcx]
	mov	rdx, QWORD PTR [rcx+16]
	add	rax, QWORD PTR [rcx+8]
	cmp	rdx, rax
	jae	SHORT $LN1@get_char

; 25   : 		return		(*m_pointer++);

	movzx	eax, BYTE PTR [rdx]
	inc	rdx
	mov	QWORD PTR [rcx+16], rdx

; 27   : }

	ret	0
$LN1@get_char:

; 26   : 	return			(EOF);

	or	eax, -1

; 27   : }

	ret	0
?get_char@stream@ppmd@compression@@QEAAHXZ ENDP		; compression::ppmd::stream::get_char
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
;	COMDAT ?rcEncNormalize@ppmd@@YAXPEAVstream@1compression@@@Z
_TEXT	SEGMENT
stream$ = 8
?rcEncNormalize@ppmd@@YAXPEAVstream@1compression@@@Z PROC ; ppmd::rcEncNormalize, COMDAT

; 74   : {

	mov	r8d, DWORD PTR low
	mov	eax, DWORD PTR range
	mov	r9, rcx
$LL3@rcEncNorma:

; 75   :     while(      (low ^ (low+range)) < TOP 
; 76   :             ||  range < BOT 
; 77   :             &&  ((range= -low & (BOT-1)),1)
; 78   :          ) 

	lea	edx, DWORD PTR [rax+r8]
	xor	edx, r8d
	cmp	edx, 16777216				; 01000000H
	jb	SHORT $LN1@rcEncNorma
	cmp	eax, 32768				; 00008000H
	jae	SHORT $LN2@rcEncNorma
	mov	eax, r8d
	neg	eax
	and	eax, 32767				; 00007fffH
$LN1@rcEncNorma:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	rcx, QWORD PTR [r9+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 80   :         _PPMD_E_PUTC( low >> 24, stream );

	mov	edx, r8d

; 81   :         range   <<= 8;                        

	shl	eax, 8
	shr	edx, 24
	mov	DWORD PTR range, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rcx], dl

; 18   : 	++m_pointer;

	inc	QWORD PTR [r9+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 82   :         low     <<= 8;

	shl	r8d, 8

; 83   :     }

	jmp	SHORT $LL3@rcEncNorma
$LN2@rcEncNorma:

; 82   :         low     <<= 8;

	mov	DWORD PTR low, r8d

; 84   : }

	ret	0
?rcEncNormalize@ppmd@@YAXPEAVstream@1compression@@@Z ENDP ; ppmd::rcEncNormalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
?rcInitEncoder@ppmd@@YAXXZ PROC				; ppmd::rcInitEncoder

; 86   : static inline void rcInitEncoder() { low=0; range=DWORD(-1); }

	mov	DWORD PTR low, 0
	mov	DWORD PTR range, -1			; ffffffffH
	ret	0
?rcInitEncoder@ppmd@@YAXXZ ENDP				; ppmd::rcInitEncoder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
?rcEncodeSymbol@ppmd@@YAXXZ PROC			; ppmd::rcEncodeSymbol

; 98   :     low += SubRange.low*(range/=SubRange.scale);  range *= SubRange.high-SubRange.low;

	mov	eax, DWORD PTR range
	xor	edx, edx
	div	DWORD PTR SubRange+8
	mov	ecx, eax
	imul	ecx, DWORD PTR SubRange
	add	DWORD PTR low, ecx
	mov	ecx, DWORD PTR SubRange+4
	sub	ecx, DWORD PTR SubRange
	imul	eax, ecx
	mov	DWORD PTR range, eax

; 99   : }

	ret	0
?rcEncodeSymbol@ppmd@@YAXXZ ENDP			; ppmd::rcEncodeSymbol
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
stream$ = 8
?rcFlushEncoder@ppmd@@YAXPEAVstream@1compression@@@Z PROC ; ppmd::rcFlushEncoder
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	rax, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	r8d, DWORD PTR low
	mov	r9, rcx
	mov	edx, r8d
	shl	r8d, 8
	shr	edx, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rax], dl

; 18   : 	++m_pointer;

	inc	QWORD PTR [rcx+16]
	mov	rdx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	eax, r8d
	shl	r8d, 8
	shr	eax, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rdx], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [rcx+16]
	mov	rcx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	eax, r8d
	shl	r8d, 8
	shr	eax, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rcx], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [r9+16]
	mov	rcx, QWORD PTR [r9+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 104  :         _PPMD_E_PUTC(low >> 24,stream);     low <<= 8;

	mov	eax, r8d
	shl	r8d, 8
	shr	eax, 24
	mov	DWORD PTR low, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 17   : 	*m_pointer		= object;

	mov	BYTE PTR [rcx], al

; 18   : 	++m_pointer;

	inc	QWORD PTR [r9+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 106  : }

	ret	0
?rcFlushEncoder@ppmd@@YAXPEAVstream@1compression@@@Z ENDP ; ppmd::rcFlushEncoder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
stream$ = 8
?rcInitDecoder@ppmd@@YAXPEAVstream@1compression@@@Z PROC ; ppmd::rcInitDecoder
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	r10, QWORD PTR [rcx+8]
	mov	r11d, DWORD PTR [rcx]
	mov	r9, QWORD PTR [rcx+16]
	lea	rax, QWORD PTR [r11+r10]
	or	r8d, -1
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 108  : {

	mov	rdx, rcx

; 109  :     low=code=0;                             range=DWORD(-1);

	mov	DWORD PTR low, 0
	mov	DWORD PTR range, -1			; ffffffffH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	cmp	r9, rax
	jae	SHORT $LN6@rcInitDeco

; 25   : 		return		(*m_pointer++);

	movzx	ecx, BYTE PTR [r9]
	lea	rax, QWORD PTR [r9+1]
	mov	QWORD PTR [rdx+16], rax
	jmp	SHORT $LN7@rcInitDeco
$LN6@rcInitDeco:

; 26   : 	return			(EOF);

	mov	ecx, r8d
$LN7@rcInitDeco:

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	rax, QWORD PTR [rdx+16]
	add	r10, r11
	cmp	rax, r10
	jae	SHORT $LN17@rcInitDeco

; 25   : 		return		(*m_pointer++);

	movzx	r9d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdx+16], rax
	jmp	SHORT $LN18@rcInitDeco
$LN17@rcInitDeco:

; 26   : 	return			(EOF);

	mov	r9d, r8d
$LN18@rcInitDeco:

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	rax, QWORD PTR [rdx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 111  :             code=(code << 8) | _PPMD_D_GETC(stream);

	shl	ecx, 8
	or	ecx, r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	cmp	rax, r10
	jae	SHORT $LN20@rcInitDeco

; 25   : 		return		(*m_pointer++);

	movzx	r9d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdx+16], rax
	jmp	SHORT $LN21@rcInitDeco
$LN20@rcInitDeco:

; 26   : 	return			(EOF);

	mov	r9d, r8d
$LN21@rcInitDeco:

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	rax, QWORD PTR [rdx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 111  :             code=(code << 8) | _PPMD_D_GETC(stream);

	shl	ecx, 8
	or	ecx, r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	cmp	rax, r10
	jae	SHORT $LN24@rcInitDeco

; 25   : 		return		(*m_pointer++);

	movzx	r8d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdx+16], rax
$LN24@rcInitDeco:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 111  :             code=(code << 8) | _PPMD_D_GETC(stream);

	shl	ecx, 8
	or	ecx, r8d
	mov	DWORD PTR code, ecx

; 112  : }

	ret	0
?rcInitDecoder@ppmd@@YAXPEAVstream@1compression@@@Z ENDP ; ppmd::rcInitDecoder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
;	COMDAT ?rcDecNormalize@ppmd@@YAXPEAVstream@1compression@@@Z
_TEXT	SEGMENT
stream$ = 8
?rcDecNormalize@ppmd@@YAXPEAVstream@1compression@@@Z PROC ; ppmd::rcDecNormalize, COMDAT
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	r8d, DWORD PTR low
	mov	eax, DWORD PTR range
	mov	r9d, DWORD PTR code
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 116  : {

	mov	r11, rcx
	npad	9
$LL3@rcDecNorma:

; 117  :     while(      (low ^ (low+range)) < TOP 
; 118  :             ||  range < BOT 
; 119  :             &&  ((range= -low & (BOT-1)),1) 
; 120  :          ) 

	lea	edx, DWORD PTR [rax+r8]
	xor	edx, r8d
	cmp	edx, 16777216				; 01000000H
	jb	SHORT $LN1@rcDecNorma
	cmp	eax, 32768				; 00008000H
	jae	SHORT $LN2@rcDecNorma
	mov	eax, r8d
	neg	eax
	and	eax, 32767				; 00007fffH
$LN1@rcDecNorma:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	ecx, DWORD PTR [r11]
	mov	rdx, QWORD PTR [r11+16]
	add	rcx, QWORD PTR [r11+8]
	cmp	rdx, rcx
	jae	SHORT $LN6@rcDecNorma

; 25   : 		return		(*m_pointer++);

	movzx	r10d, BYTE PTR [rdx]
	lea	rcx, QWORD PTR [rdx+1]
	mov	QWORD PTR [r11+16], rcx
	jmp	SHORT $LN7@rcDecNorma
$LN6@rcDecNorma:

; 26   : 	return			(EOF);

	or	r10d, -1
$LN7@rcDecNorma:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 122  :         code    = (code << 8) | _PPMD_D_GETC(stream);

	shl	r9d, 8

; 123  :         range <<= 8;                        

	shl	eax, 8
	or	r9d, r10d
	mov	DWORD PTR range, eax

; 124  :         low   <<= 8;

	shl	r8d, 8
	mov	DWORD PTR code, r9d

; 125  :     }

	jmp	SHORT $LL3@rcDecNorma
$LN2@rcDecNorma:

; 124  :         low   <<= 8;

	mov	DWORD PTR low, r8d

; 126  : }

	ret	0
?rcDecNormalize@ppmd@@YAXPEAVstream@1compression@@@Z ENDP ; ppmd::rcDecNormalize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
?rcGetCurrentCount@ppmd@@YAIXZ PROC			; ppmd::rcGetCurrentCount

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	mov	eax, DWORD PTR range
	xor	edx, edx
	div	DWORD PTR SubRange+8
	xor	edx, edx
	mov	ecx, eax
	mov	DWORD PTR range, eax
	mov	eax, DWORD PTR code
	sub	eax, DWORD PTR low
	div	ecx
	ret	0
?rcGetCurrentCount@ppmd@@YAIXZ ENDP			; ppmd::rcGetCurrentCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
?rcRemoveSubrange@ppmd@@YAXXZ PROC			; ppmd::rcRemoveSubrange

; 141  :     low     += range*SubRange.low;                 

	mov	edx, DWORD PTR range
	mov	eax, DWORD PTR SubRange
	imul	eax, edx
	add	DWORD PTR low, eax

; 142  :     range   *= SubRange.high-SubRange.low;

	mov	eax, DWORD PTR SubRange+4
	sub	eax, DWORD PTR SubRange
	imul	edx, eax
	mov	DWORD PTR range, edx

; 143  : }

	ret	0
?rcRemoveSubrange@ppmd@@YAXXZ ENDP			; ppmd::rcRemoveSubrange
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
f0$ = 8
Shift$dead$ = 16
?rcBinStart@ppmd@@YAIII@Z PROC				; ppmd::rcBinStart

; 145  : static inline UINT rcBinStart(UINT f0,UINT Shift)  { return f0*(range >>= Shift); }

	mov	eax, DWORD PTR range
	shr	eax, 14
	mov	DWORD PTR range, eax
	imul	eax, ecx
	ret	0
?rcBinStart@ppmd@@YAIII@Z ENDP				; ppmd::rcBinStart
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
tmp$ = 8
?rcBinDecode@ppmd@@YAII@Z PROC				; ppmd::rcBinDecode

; 146  : static inline UINT rcBinDecode  (UINT tmp)         { return (code-low >= tmp); }

	mov	edx, DWORD PTR code
	xor	eax, eax
	sub	edx, DWORD PTR low
	cmp	edx, ecx
	setae	al
	ret	0
?rcBinDecode@ppmd@@YAII@Z ENDP				; ppmd::rcBinDecode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
tmp$ = 8
?rcBinCorrect0@ppmd@@YAXI@Z PROC			; ppmd::rcBinCorrect0

; 147  : static inline void rcBinCorrect0(UINT tmp)         { range=tmp; }

	mov	DWORD PTR range, ecx
	ret	0
?rcBinCorrect0@ppmd@@YAXI@Z ENDP			; ppmd::rcBinCorrect0
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
_TEXT	SEGMENT
tmp$ = 8
f1$ = 16
?rcBinCorrect1@ppmd@@YAXII@Z PROC			; ppmd::rcBinCorrect1

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	mov	eax, DWORD PTR range
	add	DWORD PTR low, ecx
	imul	eax, edx
	mov	DWORD PTR range, eax
	ret	0
?rcBinCorrect1@ppmd@@YAXII@Z ENDP			; ppmd::rcBinCorrect1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?avail@BLK_NODE@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?avail@BLK_NODE@@QEBAHXZ PROC				; BLK_NODE::avail, COMDAT

; 15   :     BOOL   avail()      const { return (next != NULL); }

	xor	eax, eax
	cmp	QWORD PTR [rcx+4], rax
	setne	al
	ret	0
?avail@BLK_NODE@@QEBAHXZ ENDP				; BLK_NODE::avail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?link@BLK_NODE@@QEAAXPEAU1@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?link@BLK_NODE@@QEAAXPEAU1@@Z PROC			; BLK_NODE::link, COMDAT

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [rdx+4], rax
	mov	QWORD PTR [rcx+4], rdx
	ret	0
?link@BLK_NODE@@QEAAXPEAU1@@Z ENDP			; BLK_NODE::link
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?unlink@BLK_NODE@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?unlink@BLK_NODE@@QEAAXXZ PROC				; BLK_NODE::unlink, COMDAT

; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rcx+4]
	mov	rdx, QWORD PTR [rax+4]
	mov	QWORD PTR [rcx+4], rdx
	ret	0
?unlink@BLK_NODE@@QEAAXXZ ENDP				; BLK_NODE::unlink
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?remove@BLK_NODE@@QEAAPEAXXZ
_TEXT	SEGMENT
this$ = 8
?remove@BLK_NODE@@QEAAPEAXXZ PROC			; BLK_NODE::remove, COMDAT

; 19   :         BLK_NODE* p=next;                   unlink();

	mov	rax, QWORD PTR [rcx+4]

; 17   :     void  unlink()            { next=next->next; }

	mov	rdx, QWORD PTR [rax+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR [rcx]

; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR [rcx+4], rdx

; 21   :     }

	ret	0
?remove@BLK_NODE@@QEAAPEAXXZ ENDP			; BLK_NODE::remove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?PrefetchData@@YAXPEAX@Z
_TEXT	SEGMENT
Addr$ = 8
?PrefetchData@@YAXPEAX@Z PROC				; PrefetchData, COMDAT

; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rcx]

; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }

	ret	0
?PrefetchData@@YAXPEAX@Z ENDP				; PrefetchData
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?insert@BLK_NODE@@QEAAXPEAXH@Z
_TEXT	SEGMENT
this$ = 8
pv$ = 16
NU$ = 24
?insert@BLK_NODE@@QEAAXPEAXH@Z PROC			; BLK_NODE::insert, COMDAT

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [rdx+4], rax
	mov	QWORD PTR [rcx+4], rdx

; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rdx], -1			; ffffffffH
	mov	DWORD PTR [rdx+12], r8d

; 40   :     Stamp++;

	inc	DWORD PTR [rcx]

; 41   : }

	ret	0
?insert@BLK_NODE@@QEAAXPEAXH@Z ENDP			; BLK_NODE::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?U2B@@YAII@Z
_TEXT	SEGMENT
NU$ = 8
?U2B@@YAII@Z PROC					; U2B, COMDAT

; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	lea	eax, DWORD PTR [rcx+rcx*2]
	shl	eax, 2
	ret	0
?U2B@@YAII@Z ENDP					; U2B
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?SplitBlock@@YAXPEAXII@Z
_TEXT	SEGMENT
pv$ = 8
OldIndx$ = 16
NewIndx$ = 24
?SplitBlock@@YAXPEAXII@Z PROC				; SplitBlock, COMDAT

; 45   :     UINT i, k, UDiff=Indx2Units[OldIndx]-Indx2Units[NewIndx];

	mov	eax, r8d
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	r8d, BYTE PTR Indx2Units[rax+r10]
	mov	eax, edx
	movzx	r9d, BYTE PTR Indx2Units[rax+r10]
	sub	r9d, r8d

; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	lea	r8d, DWORD PTR [r8+r8*2]

; 46   :     BYTE* p=((BYTE*) pv)+U2B(Indx2Units[NewIndx]);
; 47   :     if (Indx2Units[i=Units2Indx[UDiff-1]] != UDiff) {

	lea	eax, DWORD PTR [r9-1]

; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	shl	r8d, 2

; 46   :     BYTE* p=((BYTE*) pv)+U2B(Indx2Units[NewIndx]);
; 47   :     if (Indx2Units[i=Units2Indx[UDiff-1]] != UDiff) {

	movzx	edx, BYTE PTR Units2Indx[rax+r10]
	add	r8, rcx
	movzx	eax, BYTE PTR Indx2Units[rdx+r10]
	cmp	eax, r9d
	je	SHORT $LN1@SplitBlock

; 48   :         k=Indx2Units[--i];                  BList[i].insert(p,k);

	dec	edx
	lea	rcx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10]
	mov	eax, edx
	movzx	edx, BYTE PTR Indx2Units[rdx+r10]
	lea	rax, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rcx+rax*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [r8+4], rax
	mov	QWORD PTR [rcx+4], r8

; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	lea	eax, DWORD PTR [rdx+rdx*2]
	shl	eax, 2

; 17   :     void  unlink()            { next=next->next; }
; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;
; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r8], -1			; ffffffffH
	mov	DWORD PTR [r8+12], edx

; 40   :     Stamp++;

	inc	DWORD PTR [rcx]

; 49   :         p += U2B(k);                        UDiff -= k;

	add	r8, rax
	sub	r9d, edx
$LN1@SplitBlock:

; 50   :     }
; 51   :     BList[Units2Indx[UDiff-1]].insert(p,UDiff);

	lea	eax, DWORD PTR [r9-1]
	movzx	eax, BYTE PTR Units2Indx[rax+r10]
	lea	rcx, QWORD PTR [rax+rax*2]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4+4]
	mov	QWORD PTR [r8+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4+4], r8

; 17   :     void  unlink()            { next=next->next; }
; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;
; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r8], -1			; ffffffffH
	mov	DWORD PTR [r8+12], r9d

; 40   :     Stamp++;

	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r10+rcx*4]

; 52   : }

	ret	0
?SplitBlock@@YAXPEAXII@Z ENDP				; SplitBlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	SEGMENT
GetUsedMemory PROC

; 54   : {

$LN22:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 55   :     DWORD i, RetVal=SubAllocatorSize-(HiUnit-LoUnit)-(UnitsStart-pText);

	mov	eax, DWORD PTR LoUnit

; 56   :     for (i=0;i < N_INDEXES;i++)

	xor	r9d, r9d
	lea	rdi, OFFSET FLAT:Indx2Units
	sub	eax, DWORD PTR HiUnit
	mov	ebx, r9d
	sub	eax, DWORD PTR UnitsStart
	add	eax, DWORD PTR pText
	add	eax, DWORD PTR SubAllocatorSize
	cmp	DWORD PTR __isa_available, 2
	jl	$LN9@GetUsedMem
	movaps	XMMWORD PTR [rsp+16], xmm6
	xorps	xmm6, xmm6
	movaps	XMMWORD PTR [rsp], xmm7
	mov	rdx, rdi
	lea	rcx, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A+24
	lea	ebx, QWORD PTR [r9+32]
	lea	r8d, QWORD PTR [r9+4]
	movdqa	xmm7, XMMWORD PTR __xmm@0000000c0000000c0000000c0000000c
	movdqa	xmm5, xmm6
	npad	4
$LL3@GetUsedMem:

; 57   :             RetVal -= UNIT_SIZE*Indx2Units[i]*BList[i].Stamp;

	movd	xmm0, DWORD PTR [rdx]
	movd	xmm2, DWORD PTR [rcx+12]
	movd	xmm1, DWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx+8]
	pmovzxbd xmm3, xmm0
	movd	xmm0, DWORD PTR [rcx-12]
	movd	xmm4, DWORD PTR [rcx-24]
	lea	rcx, QWORD PTR [rcx+96]
	punpckldq xmm4, xmm1
	punpckldq xmm0, xmm2
	movd	xmm2, DWORD PTR [rcx-36]
	movd	xmm1, DWORD PTR [rcx-48]
	punpckldq xmm4, xmm0
	pmulld	xmm4, xmm3
	pmulld	xmm4, xmm7
	movd	xmm0, DWORD PTR [rdx-4]
	psubd	xmm6, xmm4
	movd	xmm4, DWORD PTR [rcx-72]
	pmovzxbd xmm3, xmm0
	punpckldq xmm4, xmm1
	movd	xmm0, DWORD PTR [rcx-60]
	punpckldq xmm0, xmm2
	punpckldq xmm4, xmm0
	pmulld	xmm4, xmm3
	pmulld	xmm4, xmm7
	psubd	xmm5, xmm4
	dec	r8
	jne	SHORT $LL3@GetUsedMem
	movaps	xmm7, XMMWORD PTR [rsp]
	paddd	xmm5, xmm6
	movaps	xmm6, XMMWORD PTR [rsp+16]
	movdqa	xmm0, xmm5
	psrldq	xmm0, 8
	paddd	xmm5, xmm0
	movdqa	xmm0, xmm5
	psrldq	xmm0, 4
	paddd	xmm5, xmm0
	movd	ecx, xmm5
	add	eax, ecx
$LN9@GetUsedMem:

; 56   :     for (i=0;i < N_INDEXES;i++)

	mov	r10d, r9d
	cmp	ebx, 38					; 00000026H
	jae	$LN20@GetUsedMem
	mov	ecx, 38					; 00000026H
	mov	QWORD PTR [rsp+48], rsi
	lea	rsi, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A ; BList
	sub	ecx, ebx
	cmp	ecx, 2
	jb	SHORT $LC14@GetUsedMem
	mov	ecx, ebx
	lea	rdx, QWORD PTR [rdi+1]
	lea	r8, QWORD PTR [rcx+1]
	add	rdx, rcx
	mov	ecx, 36					; 00000024H
	sub	ecx, ebx
	lea	r8, QWORD PTR [r8+r8*2]
	shr	ecx, 1
	lea	r8, QWORD PTR [rsi+r8*4]
	inc	ecx
	mov	r11d, ecx
	lea	ebx, DWORD PTR [rbx+rcx*2]
$LL16@GetUsedMem:

; 57   :             RetVal -= UNIT_SIZE*Indx2Units[i]*BList[i].Stamp;

	movzx	ecx, BYTE PTR [rdx-1]
	lea	r8, QWORD PTR [r8+24]
	lea	rdx, QWORD PTR [rdx+2]
	imul	ecx, DWORD PTR [r8-36]
	imul	ecx, ecx, -12				; fffffff4H
	add	r9d, ecx
	movzx	ecx, BYTE PTR [rdx-2]
	imul	ecx, DWORD PTR [r8-24]
	imul	ecx, ecx, -12				; fffffff4H
	add	r10d, ecx
	dec	r11
	jne	SHORT $LL16@GetUsedMem
$LC14@GetUsedMem:

; 56   :     for (i=0;i < N_INDEXES;i++)

	cmp	ebx, 38					; 00000026H
	jae	SHORT $LN15@GetUsedMem

; 57   :             RetVal -= UNIT_SIZE*Indx2Units[i]*BList[i].Stamp;

	mov	ecx, ebx
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movzx	ecx, BYTE PTR [rcx+rdi]
	mov	edx, DWORD PTR [rsi+rdx*4]
	imul	edx, ecx
	imul	ecx, edx, -12				; fffffff4H
	add	eax, ecx
$LN15@GetUsedMem:

; 56   :     for (i=0;i < N_INDEXES;i++)

	mov	rsi, QWORD PTR [rsp+48]
	lea	ecx, DWORD PTR [r10+r9]
	add	eax, ecx
$LN20@GetUsedMem:

; 58   :     return RetVal;
; 59   : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
GetUsedMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	SEGMENT
p$ = 48
StopSubAllocator PROC

; 60   : void _STDCALL StopSubAllocator() {

$LN7:
	sub	rsp, 40					; 00000028H

; 61   :     if ( SubAllocatorSize ) {

	cmp	DWORD PTR SubAllocatorSize, 0
	je	SHORT $LN4@StopSubAll

; 62   :         SubAllocatorSize=0;                 delete[] HeapStart;

	mov	rax, QWORD PTR HeapStart
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	lea	rcx, QWORD PTR p$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 62   :         SubAllocatorSize=0;                 delete[] HeapStart;

	mov	DWORD PTR SubAllocatorSize, 0
	mov	QWORD PTR p$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 127  : 	IC void		operator delete		(void *p)			{	xr_free(p);											}

	call	??$xr_free@X@@YAXAEAPEAX@Z		; xr_free<void>
$LN4@StopSubAll:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 64   : }

	add	rsp, 40					; 00000028H
	ret	0
StopSubAllocator ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	SEGMENT
?InitSubAllocator@@YAXXZ PROC				; InitSubAllocator

; 74   : {

	sub	rsp, 40					; 00000028H

; 75   :     memset(BList,0,sizeof(BList));

	lea	rcx, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A ; BList
	xor	edx, edx
	mov	r8d, 456				; 000001c8H
	call	memset

; 76   :     HiUnit=(pText=HeapStart)+SubAllocatorSize;

	mov	rax, QWORD PTR HeapStart
	mov	ecx, DWORD PTR SubAllocatorSize
	lea	r8, QWORD PTR [rax+rcx]

; 77   :     UINT Diff=UNIT_SIZE*(SubAllocatorSize/8/UNIT_SIZE*7);

	shr	ecx, 3
	mov	QWORD PTR pText, rax
	mov	eax, -1431655765			; aaaaaaabH
	mov	QWORD PTR HiUnit, r8

; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;

	mov	DWORD PTR GlueCount, 0
	mul	ecx
	shr	edx, 3
	imul	ecx, edx, 84				; 00000054H
	sub	r8, rcx
	mov	QWORD PTR UnitsStart, r8
	mov	QWORD PTR LoUnit, r8

; 79   : }

	add	rsp, 40					; 00000028H
	ret	0
?InitSubAllocator@@YAXXZ ENDP				; InitSubAllocator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	SEGMENT
s0$ = 0
?GlueFreeBlocks@@YAXXZ PROC				; GlueFreeBlocks

; 81   : {

	push	r14
	sub	rsp, 16

; 82   :     UINT i, k, sz;
; 83   :     MEM_BLK s0, * p, * p0, * p1;
; 84   :     if (LoUnit != HiUnit)                   *LoUnit=0;

	mov	rax, QWORD PTR LoUnit
	cmp	rax, QWORD PTR HiUnit
	je	SHORT $LN16@GlueFreeBl
	mov	BYTE PTR [rax], 0
$LN16@GlueFreeBl:

; 85   :     for (i=0, (p0=&s0)->next=NULL;i < N_INDEXES;i++)

	xor	r11d, r11d
	lea	r14, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A ; BList
	lea	r9, QWORD PTR s0$[rsp]
	mov	r8, r14
	mov	QWORD PTR s0$[rsp+4], r11
	lea	r10d, QWORD PTR [r11+38]
$LL15@GlueFreeBl:

; 15   :     BOOL   avail()      const { return (next != NULL); }

	cmp	QWORD PTR [r8+4], r11

; 86   :             while ( BList[i].avail() ) {

	je	SHORT $LN14@GlueFreeBl
	npad	7
$LL12@GlueFreeBl:

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();

	mov	rdx, QWORD PTR [r8+4]

; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rdx+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR [r8]

; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR [r8+4], rax

; 87   :                 p=(MEM_BLK*) BList[i].remove();
; 88   :                 if ( !p->NU )               continue;

	mov	eax, DWORD PTR [rdx+12]
	test	eax, eax
	je	SHORT $LN53@GlueFreeBl

; 89   :                 while ((p1=p+p->NU)->Stamp == ~0UL) {

	shl	rax, 4
	add	rax, rdx
	cmp	DWORD PTR [rax], -1			; ffffffffH
	jne	SHORT $LN8@GlueFreeBl
$LL9@GlueFreeBl:

; 90   :                     p->NU += p1->NU;        p1->NU=0;

	mov	ecx, DWORD PTR [rax+12]
	add	DWORD PTR [rdx+12], ecx
	mov	DWORD PTR [rax+12], r11d
	mov	eax, DWORD PTR [rdx+12]
	shl	rax, 4
	add	rax, rdx
	cmp	DWORD PTR [rax], -1			; ffffffffH
	je	SHORT $LL9@GlueFreeBl
$LN8@GlueFreeBl:

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [r9+4]
	mov	QWORD PTR [rdx+4], rax
	mov	QWORD PTR [r9+4], rdx

; 91   :                 }
; 92   :                 p0->link(p);                p0=p;

	mov	r9, rdx
$LN53@GlueFreeBl:

; 15   :     BOOL   avail()      const { return (next != NULL); }

	cmp	QWORD PTR [r8+4], r11

; 86   :             while ( BList[i].avail() ) {

	jne	SHORT $LL12@GlueFreeBl
$LN14@GlueFreeBl:

; 85   :     for (i=0, (p0=&s0)->next=NULL;i < N_INDEXES;i++)

	add	r8, 12
	dec	r10
	jne	SHORT $LL15@GlueFreeBl

; 15   :     BOOL   avail()      const { return (next != NULL); }

	mov	r11, QWORD PTR s0$[rsp+4]
	test	r11, r11

; 93   :             }
; 94   :     while ( s0.avail() ) {

	je	$LN67@GlueFreeBl
	mov	QWORD PTR [rsp+40], rbp
	mov	QWORD PTR [rsp+48], rsi
	mov	esi, DWORD PTR s0$[rsp]
	mov	QWORD PTR [rsp+32], rbx
	lea	rbp, OFFSET FLAT:__ImageBase
	mov	QWORD PTR [rsp+56], rdi
	npad	11
$LL7@GlueFreeBl:

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();

	mov	r9, r11

; 17   :     void  unlink()            { next=next->next; }

	mov	r11, QWORD PTR [r11+4]

; 20   :         Stamp--;                            return p;

	lea	esi, DWORD PTR [rsi-1]

; 95   :         p=(MEM_BLK*) s0.remove();           sz=p->NU;

	mov	r10d, DWORD PTR [r9+12]

; 96   :         if ( !sz )                          continue;

	test	r10d, r10d
	je	$LN56@GlueFreeBl

; 97   :         for ( ;sz > 128;sz -= 128, p += 128)

	cmp	r10d, 128				; 00000080H
	jbe	SHORT $LN2@GlueFreeBl
	lea	ecx, DWORD PTR [r10-129]
	shr	ecx, 7
	inc	ecx
	npad	4
$LL4@GlueFreeBl:

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+448

; 97   :         for ( ;sz > 128;sz -= 128, p += 128)

	add	r10d, -128				; ffffff80H

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	QWORD PTR [r9+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+448, r9

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r9], -1			; ffffffffH
	mov	DWORD PTR [r9+12], 128			; 00000080H

; 40   :     Stamp++;

	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A+444

; 97   :         for ( ;sz > 128;sz -= 128, p += 128)

	add	r9, 2048				; 00000800H
	dec	rcx
	jne	SHORT $LL4@GlueFreeBl
$LN2@GlueFreeBl:

; 98   :                 BList[N_INDEXES-1].insert(p,128);
; 99   :         if (Indx2Units[i=Units2Indx[sz-1]] != sz) {

	lea	eax, DWORD PTR [r10-1]
	movzx	eax, BYTE PTR Units2Indx[rax+rbp]
	mov	ebx, eax
	movzx	edi, BYTE PTR Indx2Units[rax+rbp]
	cmp	edi, r10d
	je	SHORT $LN37@GlueFreeBl

; 100  :             k=sz-Indx2Units[--i];           BList[k-1].insert(p+(sz-k),k);

	dec	eax
	mov	r8d, r10d
	movzx	edi, BYTE PTR Indx2Units[rax+rbp]
	mov	ebx, eax
	sub	r8d, edi
	sub	r10d, r8d
	lea	eax, DWORD PTR [r8-1]
	mov	ecx, r10d
	lea	rax, QWORD PTR [rax+rax*2]
	shl	rcx, 4
	add	rcx, r9
	lea	rdx, QWORD PTR [r14+rax*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [r14+rax*4+4]
	mov	QWORD PTR [rcx+4], rax
	mov	QWORD PTR [rdx+4], rcx

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rcx], -1			; ffffffffH
	mov	DWORD PTR [rcx+12], r8d

; 40   :     Stamp++;

	inc	DWORD PTR [rdx]
$LN37@GlueFreeBl:

; 101  :         }
; 102  :         BList[i].insert(p,Indx2Units[i]);

	lea	rax, QWORD PTR [rbx+rbx*2]
	lea	rcx, QWORD PTR [r14+rax*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [r14+rax*4+4]
	mov	QWORD PTR [r9+4], rax
	mov	QWORD PTR [rcx+4], r9

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r9], -1			; ffffffffH
	mov	DWORD PTR [r9+12], edi

; 40   :     Stamp++;

	inc	DWORD PTR [rcx]
$LN56@GlueFreeBl:

; 15   :     BOOL   avail()      const { return (next != NULL); }

	test	r11, r11

; 93   :             }
; 94   :     while ( s0.avail() ) {

	jne	$LL7@GlueFreeBl
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+40]
	mov	rbx, QWORD PTR [rsp+32]
$LN67@GlueFreeBl:

; 103  :     }
; 104  :     GlueCount=1 << 13;

	mov	DWORD PTR GlueCount, 8192		; 00002000H

; 105  : }

	add	rsp, 16
	pop	r14
	ret	0
?GlueFreeBlocks@@YAXXZ ENDP				; GlueFreeBlocks
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	SEGMENT
indx$ = 48
?AllocUnitsRare@@YAPEAXI@Z PROC				; AllocUnitsRare

; 107  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 108  :     UINT i=indx;
; 109  :     if ( !GlueCount ) {

	mov	edx, DWORD PTR GlueCount
	mov	esi, ecx
	mov	ebx, ecx
	lea	rdi, OFFSET FLAT:__ImageBase
	test	edx, edx
	jne	SHORT $LL4@AllocUnits

; 110  :         GlueFreeBlocks();

	call	?GlueFreeBlocks@@YAXXZ			; GlueFreeBlocks

; 111  :         if ( BList[i].avail() )             return BList[i].remove();

	lea	rdx, QWORD PTR [rsi+rsi*2]

; 15   :     BOOL   avail()      const { return (next != NULL); }

	cmp	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rdi+rdx*4+4], 0

; 111  :         if ( BList[i].avail() )             return BList[i].remove();

	je	SHORT $LN34@AllocUnits

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rdi+rdx*4+4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rcx, QWORD PTR [rax+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rdi+rdx*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rdi+rdx*4+4], rcx

; 121  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN34@AllocUnits:

; 111  :         if ( BList[i].avail() )             return BList[i].remove();

	mov	edx, DWORD PTR GlueCount
	npad	7
$LL4@AllocUnits:

; 112  :     }
; 113  :     do {
; 114  :         if (++i == N_INDEXES) {

	inc	ebx
	cmp	ebx, 38					; 00000026H
	je	SHORT $LN26@AllocUnits

; 117  :         }
; 118  :     } while ( !BList[i].avail() );

	lea	rcx, QWORD PTR [rbx+rbx*2]

; 15   :     BOOL   avail()      const { return (next != NULL); }

	cmp	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rdi+rcx*4+4], 0

; 117  :         }
; 118  :     } while ( !BList[i].avail() );

	je	SHORT $LL4@AllocUnits

; 119  :     void* RetVal=BList[i].remove();         SplitBlock(RetVal,i,indx);

	lea	rcx, QWORD PTR [rbx+rbx*2]
	lea	rdx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rdi]
	mov	r8d, esi

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();

	mov	rdi, QWORD PTR [rdx+rcx*4+4]

; 119  :     void* RetVal=BList[i].remove();         SplitBlock(RetVal,i,indx);

	lea	rdx, QWORD PTR [rdx+rcx*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rcx, QWORD PTR [rdi+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR [rdx]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR [rdx+4], rcx

; 119  :     void* RetVal=BList[i].remove();         SplitBlock(RetVal,i,indx);

	mov	edx, ebx
	mov	rcx, rdi
	call	?SplitBlock@@YAXPEAXII@Z		; SplitBlock

; 120  :     return RetVal;

	mov	rax, rdi

; 121  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN26@AllocUnits:

; 115  :             GlueCount--;                    i=U2B(Indx2Units[indx]);

	movzx	eax, BYTE PTR Indx2Units[rsi+rdi]

; 116  :             return (UnitsStart-pText > i)?(UnitsStart -= i):(NULL);

	mov	rcx, QWORD PTR UnitsStart
	dec	edx
	mov	DWORD PTR GlueCount, edx

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;
; 40   :     Stamp++;
; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	lea	edx, DWORD PTR [rax+rax*2]

; 116  :             return (UnitsStart-pText > i)?(UnitsStart -= i):(NULL);

	mov	rax, rcx
	sub	rax, QWORD PTR pText

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;
; 40   :     Stamp++;
; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	shl	edx, 2

; 116  :             return (UnitsStart-pText > i)?(UnitsStart -= i):(NULL);

	cmp	rax, rdx
	jle	SHORT $LN9@AllocUnits
	sub	rcx, rdx
	mov	QWORD PTR UnitsStart, rcx
	mov	rax, rcx

; 121  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN9@AllocUnits:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	xor	ecx, ecx
	mov	eax, ecx
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?AllocUnitsRare@@YAPEAXI@Z ENDP				; AllocUnitsRare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?AllocUnits@@YAPEAXI@Z
_TEXT	SEGMENT
NU$ = 8
?AllocUnits@@YAPEAXI@Z PROC				; AllocUnits, COMDAT

; 124  :     UINT indx=Units2Indx[NU-1];

	lea	eax, DWORD PTR [rcx-1]
	lea	r10, OFFSET FLAT:__ImageBase
	movzx	r9d, BYTE PTR Units2Indx[rax+r10]

; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();

	lea	rax, QWORD PTR [r9+r9*2]
	lea	rdx, QWORD PTR [rax*4]

; 15   :     BOOL   avail()      const { return (next != NULL); }

	cmp	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rdx+r10+4], 0

; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();

	je	SHORT $LN2@AllocUnits

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rdx+r10+4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rcx, QWORD PTR [rax+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rdx+r10]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rdx+r10+4], rcx

; 129  : }

	ret	0
$LN2@AllocUnits:

; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);

	mov	r8, QWORD PTR LoUnit
	movzx	ecx, BYTE PTR Indx2Units[r9+r10]

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;
; 40   :     Stamp++;
; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	lea	ecx, DWORD PTR [rcx+rcx*2]

; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);

	mov	rax, r8

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;
; 40   :     Stamp++;
; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	shl	ecx, 2

; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);

	add	r8, rcx

; 127  :     if (LoUnit <= HiUnit)                   return RetVal;

	cmp	r8, QWORD PTR HiUnit
	mov	QWORD PTR LoUnit, r8
	jbe	SHORT $LN3@AllocUnits

; 128  :     LoUnit -= U2B(Indx2Units[indx]);        return AllocUnitsRare(indx);

	sub	r8, rcx
	mov	ecx, r9d
	mov	QWORD PTR LoUnit, r8
	jmp	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
$LN3@AllocUnits:

; 129  : }

	ret	0
?AllocUnits@@YAPEAXI@Z ENDP				; AllocUnits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?AllocContext@@YAPEAXXZ
_TEXT	SEGMENT
?AllocContext@@YAPEAXXZ PROC				; AllocContext, COMDAT

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	mov	rax, QWORD PTR HiUnit
	cmp	rax, QWORD PTR LoUnit
	je	SHORT $LN4@AllocConte
	sub	rax, 12
	mov	QWORD PTR HiUnit, rax

; 135  : }

	ret	0
$LN4@AllocConte:

; 15   :     BOOL   avail()      const { return (next != NULL); }

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rax, rax

; 133  :     else if ( BList->avail() )              return BList->remove();

	je	SHORT $LN2@AllocConte

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rcx, QWORD PTR [rax+4]

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rcx

; 135  : }

	ret	0
$LN2@AllocConte:

; 134  :     else                                    return AllocUnitsRare(0);

	xor	ecx, ecx
	jmp	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
?AllocContext@@YAPEAXXZ ENDP				; AllocContext
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?UnitsCpy@@YAXPEAX0I@Z
_TEXT	SEGMENT
Dest$ = 8
Src$ = 16
NU$ = 24
?UnitsCpy@@YAXPEAX0I@Z PROC				; UnitsCpy, COMDAT

; 137  : {

	mov	r9, rcx

; 138  :     DWORD* p1=(DWORD*) Dest, * p2=(DWORD*) Src;

	lea	rax, QWORD PTR [rdx+8]

; 143  :     } while ( --NU );

	sub	r9, rdx
	npad	6
$LL3@UnitsCpy:

; 139  :     do {
; 140  :         p1[0]=p2[0];                        p1[1]=p2[1];
; 141  :         p1[2]=p2[2];
; 142  :         p1 += 3;                            p2 += 3;

	mov	edx, DWORD PTR [rax-8]
	lea	rax, QWORD PTR [rax+12]
	mov	DWORD PTR [r9+rax-20], edx
	mov	edx, DWORD PTR [rax-16]
	mov	DWORD PTR [r9+rax-16], edx
	mov	ecx, DWORD PTR [rax-12]
	mov	DWORD PTR [r9+rax-12], ecx

; 143  :     } while ( --NU );

	dec	r8d
	jne	SHORT $LL3@UnitsCpy

; 144  : }

	ret	0
?UnitsCpy@@YAXPEAX0I@Z ENDP				; UnitsCpy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?ExpandUnits@@YAPEAXPEAXI@Z
_TEXT	SEGMENT
OldPtr$ = 48
OldNU$ = 56
?ExpandUnits@@YAPEAXPEAXI@Z PROC			; ExpandUnits, COMDAT

; 146  : {

$LN18:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx

; 147  :     UINT i0=Units2Indx[OldNU-1], i1=Units2Indx[OldNU-1+1];

	lea	rbp, OFFSET FLAT:__ImageBase
	mov	rbx, rcx
	lea	eax, DWORD PTR [rdi-1]
	movzx	esi, BYTE PTR Units2Indx[rax+rbp]
	movzx	eax, BYTE PTR Units2Indx[rdi+rbp]

; 148  :     if (i0 == i1)                           return OldPtr;

	cmp	esi, eax
	jne	SHORT $LN2@ExpandUnit
	mov	rax, rcx
	jmp	SHORT $LN3@ExpandUnit
$LN2@ExpandUnit:

; 149  :     void* ptr=AllocUnits(OldNU+1);

	lea	ecx, DWORD PTR [rdi+1]
	call	?AllocUnits@@YAPEAXI@Z			; AllocUnits
	mov	r9, rax

; 150  :     if ( ptr ) {

	test	rax, rax
	je	SHORT $LN10@ExpandUnit

; 143  :     } while ( --NU );

	mov	rdx, rax

; 151  :         UnitsCpy(ptr,OldPtr,OldNU);         BList[i0].insert(OldPtr,OldNU);

	mov	r8d, edi
	lea	rcx, QWORD PTR [rbx+8]

; 143  :     } while ( --NU );

	sub	rdx, rbx
	npad	7
$LL7@ExpandUnit:

; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }
; 43   : inline void SplitBlock(void* pv,UINT OldIndx,UINT NewIndx)
; 44   : {
; 45   :     UINT i, k, UDiff=Indx2Units[OldIndx]-Indx2Units[NewIndx];
; 46   :     BYTE* p=((BYTE*) pv)+U2B(Indx2Units[NewIndx]);
; 47   :     if (Indx2Units[i=Units2Indx[UDiff-1]] != UDiff) {
; 48   :         k=Indx2Units[--i];                  BList[i].insert(p,k);
; 49   :         p += U2B(k);                        UDiff -= k;
; 50   :     }
; 51   :     BList[Units2Indx[UDiff-1]].insert(p,UDiff);
; 52   : }
; 53   : DWORD _STDCALL GetUsedMemory()
; 54   : {
; 55   :     DWORD i, RetVal=SubAllocatorSize-(HiUnit-LoUnit)-(UnitsStart-pText);
; 56   :     for (i=0;i < N_INDEXES;i++)
; 57   :             RetVal -= UNIT_SIZE*Indx2Units[i]*BList[i].Stamp;
; 58   :     return RetVal;
; 59   : }
; 60   : void _STDCALL StopSubAllocator() {
; 61   :     if ( SubAllocatorSize ) {
; 62   :         SubAllocatorSize=0;                 delete[] HeapStart;
; 63   :     }
; 64   : }
; 65   : BOOL _STDCALL StartSubAllocator(UINT SASize)
; 66   : {
; 67   :     DWORD t=SASize << 20U;
; 68   :     if (SubAllocatorSize == t)              return TRUE;
; 69   :     StopSubAllocator();
; 70   :     if ((HeapStart=new BYTE[t]) == NULL)    return FALSE;
; 71   :     SubAllocatorSize=t;                     return TRUE;
; 72   : }
; 73   : static inline void InitSubAllocator()
; 74   : {
; 75   :     memset(BList,0,sizeof(BList));
; 76   :     HiUnit=(pText=HeapStart)+SubAllocatorSize;
; 77   :     UINT Diff=UNIT_SIZE*(SubAllocatorSize/8/UNIT_SIZE*7);
; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;
; 79   : }
; 80   : static void GlueFreeBlocks()
; 81   : {
; 82   :     UINT i, k, sz;
; 83   :     MEM_BLK s0, * p, * p0, * p1;
; 84   :     if (LoUnit != HiUnit)                   *LoUnit=0;
; 85   :     for (i=0, (p0=&s0)->next=NULL;i < N_INDEXES;i++)
; 86   :             while ( BList[i].avail() ) {
; 87   :                 p=(MEM_BLK*) BList[i].remove();
; 88   :                 if ( !p->NU )               continue;
; 89   :                 while ((p1=p+p->NU)->Stamp == ~0UL) {
; 90   :                     p->NU += p1->NU;        p1->NU=0;
; 91   :                 }
; 92   :                 p0->link(p);                p0=p;
; 93   :             }
; 94   :     while ( s0.avail() ) {
; 95   :         p=(MEM_BLK*) s0.remove();           sz=p->NU;
; 96   :         if ( !sz )                          continue;
; 97   :         for ( ;sz > 128;sz -= 128, p += 128)
; 98   :                 BList[N_INDEXES-1].insert(p,128);
; 99   :         if (Indx2Units[i=Units2Indx[sz-1]] != sz) {
; 100  :             k=sz-Indx2Units[--i];           BList[k-1].insert(p+(sz-k),k);
; 101  :         }
; 102  :         BList[i].insert(p,Indx2Units[i]);
; 103  :     }
; 104  :     GlueCount=1 << 13;
; 105  : }
; 106  : static void* _STDCALL AllocUnitsRare(UINT indx)
; 107  : {
; 108  :     UINT i=indx;
; 109  :     if ( !GlueCount ) {
; 110  :         GlueFreeBlocks();
; 111  :         if ( BList[i].avail() )             return BList[i].remove();
; 112  :     }
; 113  :     do {
; 114  :         if (++i == N_INDEXES) {
; 115  :             GlueCount--;                    i=U2B(Indx2Units[indx]);
; 116  :             return (UnitsStart-pText > i)?(UnitsStart -= i):(NULL);
; 117  :         }
; 118  :     } while ( !BList[i].avail() );
; 119  :     void* RetVal=BList[i].remove();         SplitBlock(RetVal,i,indx);
; 120  :     return RetVal;
; 121  : }
; 122  : inline void* AllocUnits(UINT NU)
; 123  : {
; 124  :     UINT indx=Units2Indx[NU-1];
; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();
; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);
; 127  :     if (LoUnit <= HiUnit)                   return RetVal;
; 128  :     LoUnit -= U2B(Indx2Units[indx]);        return AllocUnitsRare(indx);
; 129  : }
; 130  : inline void* AllocContext()
; 131  : {
; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);
; 133  :     else if ( BList->avail() )              return BList->remove();
; 134  :     else                                    return AllocUnitsRare(0);
; 135  : }
; 136  : inline void UnitsCpy(void* Dest,void* Src,UINT NU)
; 137  : {
; 138  :     DWORD* p1=(DWORD*) Dest, * p2=(DWORD*) Src;
; 139  :     do {
; 140  :         p1[0]=p2[0];                        p1[1]=p2[1];

	mov	eax, DWORD PTR [rcx-8]

; 141  :         p1[2]=p2[2];
; 142  :         p1 += 3;                            p2 += 3;

	lea	rcx, QWORD PTR [rcx+12]
	mov	DWORD PTR [rdx+rcx-20], eax
	mov	eax, DWORD PTR [rcx-16]
	mov	DWORD PTR [rdx+rcx-16], eax
	mov	eax, DWORD PTR [rcx-12]
	mov	DWORD PTR [rdx+rcx-12], eax

; 143  :     } while ( --NU );

	dec	r8d
	jne	SHORT $LL7@ExpandUnit

; 151  :         UnitsCpy(ptr,OldPtr,OldNU);         BList[i0].insert(OldPtr,OldNU);

	lea	rcx, QWORD PTR [rsi+rsi*2]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rcx*4+4]
	mov	QWORD PTR [rbx+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rcx*4+4], rbx

; 17   :     void  unlink()            { next=next->next; }
; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;
; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rbx], -1			; ffffffffH
	mov	DWORD PTR [rbx+12], edi

; 40   :     Stamp++;

	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rbp+rcx*4]
$LN10@ExpandUnit:

; 152  :     }
; 153  :     return ptr;

	mov	rax, r9
$LN3@ExpandUnit:

; 154  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ExpandUnits@@YAPEAXPEAXI@Z ENDP			; ExpandUnits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?ShrinkUnits@@YAPEAXPEAXII@Z
_TEXT	SEGMENT
OldPtr$ = 48
OldNU$ = 56
NewNU$ = 64
?ShrinkUnits@@YAPEAXPEAXII@Z PROC			; ShrinkUnits, COMDAT

; 156  : {

$LN25:
	push	rbx
	sub	rsp, 32					; 00000020H

; 157  :     UINT i0=Units2Indx[OldNU-1], i1=Units2Indx[NewNU-1];

	lea	eax, DWORD PTR [rdx-1]
	lea	r11, OFFSET FLAT:__ImageBase
	mov	rbx, rcx
	movzx	r10d, BYTE PTR Units2Indx[rax+r11]
	lea	eax, DWORD PTR [r8-1]
	movzx	r9d, BYTE PTR Units2Indx[rax+r11]

; 158  :     if (i0 == i1)                           return OldPtr;

	cmp	r10d, r9d
	jne	SHORT $LN3@ShrinkUnit
	mov	rax, rcx

; 165  :     }
; 166  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@ShrinkUnit:

; 159  :     if ( BList[i1].avail() ) {

	lea	rcx, QWORD PTR [r9+r9*2]

; 15   :     BOOL   avail()      const { return (next != NULL); }

	cmp	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+rcx*4+4], 0

; 159  :     if ( BList[i1].avail() ) {

	je	$LN2@ShrinkUnit

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();

	mov	r9, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+rcx*4+4]

; 143  :     } while ( --NU );

	mov	rdx, r9

; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [r9+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+rcx*4]

; 143  :     } while ( --NU );

	sub	rdx, rbx

; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11+rcx*4+4], rax

; 160  :         void* ptr=BList[i1].remove();       UnitsCpy(ptr,OldPtr,NewNU);

	lea	rax, QWORD PTR [rbx+8]
$LL14@ShrinkUnit:

; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }
; 43   : inline void SplitBlock(void* pv,UINT OldIndx,UINT NewIndx)
; 44   : {
; 45   :     UINT i, k, UDiff=Indx2Units[OldIndx]-Indx2Units[NewIndx];
; 46   :     BYTE* p=((BYTE*) pv)+U2B(Indx2Units[NewIndx]);
; 47   :     if (Indx2Units[i=Units2Indx[UDiff-1]] != UDiff) {
; 48   :         k=Indx2Units[--i];                  BList[i].insert(p,k);
; 49   :         p += U2B(k);                        UDiff -= k;
; 50   :     }
; 51   :     BList[Units2Indx[UDiff-1]].insert(p,UDiff);
; 52   : }
; 53   : DWORD _STDCALL GetUsedMemory()
; 54   : {
; 55   :     DWORD i, RetVal=SubAllocatorSize-(HiUnit-LoUnit)-(UnitsStart-pText);
; 56   :     for (i=0;i < N_INDEXES;i++)
; 57   :             RetVal -= UNIT_SIZE*Indx2Units[i]*BList[i].Stamp;
; 58   :     return RetVal;
; 59   : }
; 60   : void _STDCALL StopSubAllocator() {
; 61   :     if ( SubAllocatorSize ) {
; 62   :         SubAllocatorSize=0;                 delete[] HeapStart;
; 63   :     }
; 64   : }
; 65   : BOOL _STDCALL StartSubAllocator(UINT SASize)
; 66   : {
; 67   :     DWORD t=SASize << 20U;
; 68   :     if (SubAllocatorSize == t)              return TRUE;
; 69   :     StopSubAllocator();
; 70   :     if ((HeapStart=new BYTE[t]) == NULL)    return FALSE;
; 71   :     SubAllocatorSize=t;                     return TRUE;
; 72   : }
; 73   : static inline void InitSubAllocator()
; 74   : {
; 75   :     memset(BList,0,sizeof(BList));
; 76   :     HiUnit=(pText=HeapStart)+SubAllocatorSize;
; 77   :     UINT Diff=UNIT_SIZE*(SubAllocatorSize/8/UNIT_SIZE*7);
; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;
; 79   : }
; 80   : static void GlueFreeBlocks()
; 81   : {
; 82   :     UINT i, k, sz;
; 83   :     MEM_BLK s0, * p, * p0, * p1;
; 84   :     if (LoUnit != HiUnit)                   *LoUnit=0;
; 85   :     for (i=0, (p0=&s0)->next=NULL;i < N_INDEXES;i++)
; 86   :             while ( BList[i].avail() ) {
; 87   :                 p=(MEM_BLK*) BList[i].remove();
; 88   :                 if ( !p->NU )               continue;
; 89   :                 while ((p1=p+p->NU)->Stamp == ~0UL) {
; 90   :                     p->NU += p1->NU;        p1->NU=0;
; 91   :                 }
; 92   :                 p0->link(p);                p0=p;
; 93   :             }
; 94   :     while ( s0.avail() ) {
; 95   :         p=(MEM_BLK*) s0.remove();           sz=p->NU;
; 96   :         if ( !sz )                          continue;
; 97   :         for ( ;sz > 128;sz -= 128, p += 128)
; 98   :                 BList[N_INDEXES-1].insert(p,128);
; 99   :         if (Indx2Units[i=Units2Indx[sz-1]] != sz) {
; 100  :             k=sz-Indx2Units[--i];           BList[k-1].insert(p+(sz-k),k);
; 101  :         }
; 102  :         BList[i].insert(p,Indx2Units[i]);
; 103  :     }
; 104  :     GlueCount=1 << 13;
; 105  : }
; 106  : static void* _STDCALL AllocUnitsRare(UINT indx)
; 107  : {
; 108  :     UINT i=indx;
; 109  :     if ( !GlueCount ) {
; 110  :         GlueFreeBlocks();
; 111  :         if ( BList[i].avail() )             return BList[i].remove();
; 112  :     }
; 113  :     do {
; 114  :         if (++i == N_INDEXES) {
; 115  :             GlueCount--;                    i=U2B(Indx2Units[indx]);
; 116  :             return (UnitsStart-pText > i)?(UnitsStart -= i):(NULL);
; 117  :         }
; 118  :     } while ( !BList[i].avail() );
; 119  :     void* RetVal=BList[i].remove();         SplitBlock(RetVal,i,indx);
; 120  :     return RetVal;
; 121  : }
; 122  : inline void* AllocUnits(UINT NU)
; 123  : {
; 124  :     UINT indx=Units2Indx[NU-1];
; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();
; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);
; 127  :     if (LoUnit <= HiUnit)                   return RetVal;
; 128  :     LoUnit -= U2B(Indx2Units[indx]);        return AllocUnitsRare(indx);
; 129  : }
; 130  : inline void* AllocContext()
; 131  : {
; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);
; 133  :     else if ( BList->avail() )              return BList->remove();
; 134  :     else                                    return AllocUnitsRare(0);
; 135  : }
; 136  : inline void UnitsCpy(void* Dest,void* Src,UINT NU)
; 137  : {
; 138  :     DWORD* p1=(DWORD*) Dest, * p2=(DWORD*) Src;
; 139  :     do {
; 140  :         p1[0]=p2[0];                        p1[1]=p2[1];

	mov	ecx, DWORD PTR [rax-8]

; 141  :         p1[2]=p2[2];
; 142  :         p1 += 3;                            p2 += 3;

	lea	rax, QWORD PTR [rax+12]
	mov	DWORD PTR [rdx+rax-20], ecx
	mov	ecx, DWORD PTR [rax-16]
	mov	DWORD PTR [rdx+rax-16], ecx
	mov	ecx, DWORD PTR [rax-12]
	mov	DWORD PTR [rdx+rax-12], ecx

; 143  :     } while ( --NU );

	dec	r8d
	jne	SHORT $LL14@ShrinkUnit

; 161  :         BList[i0].insert(OldPtr,Indx2Units[i0]);

	lea	rcx, QWORD PTR [r10+r10*2]
	lea	rdx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r11]

; 162  :         return ptr;

	mov	rax, r9
	lea	rdx, QWORD PTR [rdx+rcx*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rcx, QWORD PTR [rdx+4]
	mov	QWORD PTR [rbx+4], rcx
	movzx	ecx, BYTE PTR Indx2Units[r10+r11]
	mov	QWORD PTR [rdx+4], rbx

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rbx+12], ecx
	mov	DWORD PTR [rbx], -1			; ffffffffH

; 40   :     Stamp++;

	inc	DWORD PTR [rdx]

; 165  :     }
; 166  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@ShrinkUnit:

; 163  :     } else {
; 164  :         SplitBlock(OldPtr,i0,i1);           return OldPtr;

	mov	r8d, r9d
	mov	edx, r10d
	mov	rcx, rbx
	call	?SplitBlock@@YAXPEAXII@Z		; SplitBlock
	mov	rax, rbx

; 165  :     }
; 166  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ShrinkUnits@@YAPEAXPEAXII@Z ENDP			; ShrinkUnits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?FreeUnits@@YAXPEAXI@Z
_TEXT	SEGMENT
ptr$ = 8
NU$ = 16
?FreeUnits@@YAXPEAXI@Z PROC				; FreeUnits, COMDAT

; 168  :     UINT indx=Units2Indx[NU-1];

	lea	eax, DWORD PTR [rdx-1]
	lea	r9, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR Units2Indx[rax+r9]

; 169  :     BList[indx].insert(ptr,Indx2Units[indx]);

	lea	rdx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9]
	mov	r8d, eax
	lea	rax, QWORD PTR [rax+rax*2]
	lea	rdx, QWORD PTR [rdx+rax*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rdx+4]
	mov	QWORD PTR [rcx+4], rax
	movzx	eax, BYTE PTR Indx2Units[r8+r9]
	mov	QWORD PTR [rdx+4], rcx

; 17   :     void  unlink()            { next=next->next; }
; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;
; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rcx+12], eax
	mov	DWORD PTR [rcx], -1			; ffffffffH

; 40   :     Stamp++;

	inc	DWORD PTR [rdx]

; 170  : }

	ret	0
?FreeUnits@@YAXPEAXI@Z ENDP				; FreeUnits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?SpecialFreeUnit@@YAXPEAX@Z
_TEXT	SEGMENT
ptr$ = 8
?SpecialFreeUnit@@YAXPEAX@Z PROC			; SpecialFreeUnit, COMDAT

; 173  :     if ((BYTE*) ptr != UnitsStart)          BList->insert(ptr,1);

	mov	rax, QWORD PTR UnitsStart
	cmp	rcx, rax
	je	SHORT $LN2@SpecialFre

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	mov	QWORD PTR [rcx+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rcx

; 17   :     void  unlink()            { next=next->next; }
; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;
; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rcx], -1			; ffffffffH
	mov	DWORD PTR [rcx+12], 1

; 40   :     Stamp++;

	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A

; 175  : }

	ret	0
$LN2@SpecialFre:

; 174  :     else { *(DWORD*) ptr=~0UL;              UnitsStart += UNIT_SIZE; }

	add	rax, 12
	mov	DWORD PTR [rcx], -1			; ffffffffH
	mov	QWORD PTR UnitsStart, rax

; 175  : }

	ret	0
?SpecialFreeUnit@@YAXPEAX@Z ENDP			; SpecialFreeUnit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
;	COMDAT ?MoveUnitsUp@@YAPEAXPEAXI@Z
_TEXT	SEGMENT
OldPtr$ = 16
NU$ = 24
?MoveUnitsUp@@YAPEAXPEAXI@Z PROC			; MoveUnitsUp, COMDAT

; 177  : {

$LN26:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi

; 178  :     UINT indx=Units2Indx[NU-1];
; 179  :     if ((BYTE*) OldPtr > UnitsStart+16*1024 || (BLK_NODE*) OldPtr > BList[indx].next)

	mov	r8, QWORD PTR UnitsStart
	lea	eax, DWORD PTR [rdx-1]
	mov	r9, rcx
	lea	rsi, OFFSET FLAT:__ImageBase
	movzx	ecx, BYTE PTR Units2Indx[rax+rsi]
	lea	rax, QWORD PTR [r8+16384]
	cmp	r9, rax
	ja	$LN3@MoveUnitsU
	lea	rax, QWORD PTR [rcx+rcx*2]
	mov	r11d, ecx
	lea	rbx, QWORD PTR [rax*4]
	cmp	r9, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbx+rsi+4]
	ja	$LN3@MoveUnitsU
	mov	QWORD PTR [rsp+16], rdi

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();

	mov	rdi, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbx+rsi+4]

; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rdi+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rbx+rsi]

; 143  :     } while ( --NU );

	mov	r10, rdi

; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbx+rsi+4], rax

; 181  :     void* ptr=BList[indx].remove();

	lea	rax, QWORD PTR [r9+8]

; 143  :     } while ( --NU );

	sub	r10, r9
	npad	7
$LL13@MoveUnitsU:

; 43   : inline void SplitBlock(void* pv,UINT OldIndx,UINT NewIndx)
; 44   : {
; 45   :     UINT i, k, UDiff=Indx2Units[OldIndx]-Indx2Units[NewIndx];
; 46   :     BYTE* p=((BYTE*) pv)+U2B(Indx2Units[NewIndx]);
; 47   :     if (Indx2Units[i=Units2Indx[UDiff-1]] != UDiff) {
; 48   :         k=Indx2Units[--i];                  BList[i].insert(p,k);
; 49   :         p += U2B(k);                        UDiff -= k;
; 50   :     }
; 51   :     BList[Units2Indx[UDiff-1]].insert(p,UDiff);
; 52   : }
; 53   : DWORD _STDCALL GetUsedMemory()
; 54   : {
; 55   :     DWORD i, RetVal=SubAllocatorSize-(HiUnit-LoUnit)-(UnitsStart-pText);
; 56   :     for (i=0;i < N_INDEXES;i++)
; 57   :             RetVal -= UNIT_SIZE*Indx2Units[i]*BList[i].Stamp;
; 58   :     return RetVal;
; 59   : }
; 60   : void _STDCALL StopSubAllocator() {
; 61   :     if ( SubAllocatorSize ) {
; 62   :         SubAllocatorSize=0;                 delete[] HeapStart;
; 63   :     }
; 64   : }
; 65   : BOOL _STDCALL StartSubAllocator(UINT SASize)
; 66   : {
; 67   :     DWORD t=SASize << 20U;
; 68   :     if (SubAllocatorSize == t)              return TRUE;
; 69   :     StopSubAllocator();
; 70   :     if ((HeapStart=new BYTE[t]) == NULL)    return FALSE;
; 71   :     SubAllocatorSize=t;                     return TRUE;
; 72   : }
; 73   : static inline void InitSubAllocator()
; 74   : {
; 75   :     memset(BList,0,sizeof(BList));
; 76   :     HiUnit=(pText=HeapStart)+SubAllocatorSize;
; 77   :     UINT Diff=UNIT_SIZE*(SubAllocatorSize/8/UNIT_SIZE*7);
; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;
; 79   : }
; 80   : static void GlueFreeBlocks()
; 81   : {
; 82   :     UINT i, k, sz;
; 83   :     MEM_BLK s0, * p, * p0, * p1;
; 84   :     if (LoUnit != HiUnit)                   *LoUnit=0;
; 85   :     for (i=0, (p0=&s0)->next=NULL;i < N_INDEXES;i++)
; 86   :             while ( BList[i].avail() ) {
; 87   :                 p=(MEM_BLK*) BList[i].remove();
; 88   :                 if ( !p->NU )               continue;
; 89   :                 while ((p1=p+p->NU)->Stamp == ~0UL) {
; 90   :                     p->NU += p1->NU;        p1->NU=0;
; 91   :                 }
; 92   :                 p0->link(p);                p0=p;
; 93   :             }
; 94   :     while ( s0.avail() ) {
; 95   :         p=(MEM_BLK*) s0.remove();           sz=p->NU;
; 96   :         if ( !sz )                          continue;
; 97   :         for ( ;sz > 128;sz -= 128, p += 128)
; 98   :                 BList[N_INDEXES-1].insert(p,128);
; 99   :         if (Indx2Units[i=Units2Indx[sz-1]] != sz) {
; 100  :             k=sz-Indx2Units[--i];           BList[k-1].insert(p+(sz-k),k);
; 101  :         }
; 102  :         BList[i].insert(p,Indx2Units[i]);
; 103  :     }
; 104  :     GlueCount=1 << 13;
; 105  : }
; 106  : static void* _STDCALL AllocUnitsRare(UINT indx)
; 107  : {
; 108  :     UINT i=indx;
; 109  :     if ( !GlueCount ) {
; 110  :         GlueFreeBlocks();
; 111  :         if ( BList[i].avail() )             return BList[i].remove();
; 112  :     }
; 113  :     do {
; 114  :         if (++i == N_INDEXES) {
; 115  :             GlueCount--;                    i=U2B(Indx2Units[indx]);
; 116  :             return (UnitsStart-pText > i)?(UnitsStart -= i):(NULL);
; 117  :         }
; 118  :     } while ( !BList[i].avail() );
; 119  :     void* RetVal=BList[i].remove();         SplitBlock(RetVal,i,indx);
; 120  :     return RetVal;
; 121  : }
; 122  : inline void* AllocUnits(UINT NU)
; 123  : {
; 124  :     UINT indx=Units2Indx[NU-1];
; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();
; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);
; 127  :     if (LoUnit <= HiUnit)                   return RetVal;
; 128  :     LoUnit -= U2B(Indx2Units[indx]);        return AllocUnitsRare(indx);
; 129  : }
; 130  : inline void* AllocContext()
; 131  : {
; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);
; 133  :     else if ( BList->avail() )              return BList->remove();
; 134  :     else                                    return AllocUnitsRare(0);
; 135  : }
; 136  : inline void UnitsCpy(void* Dest,void* Src,UINT NU)
; 137  : {
; 138  :     DWORD* p1=(DWORD*) Dest, * p2=(DWORD*) Src;
; 139  :     do {
; 140  :         p1[0]=p2[0];                        p1[1]=p2[1];

	mov	ecx, DWORD PTR [rax-8]

; 141  :         p1[2]=p2[2];
; 142  :         p1 += 3;                            p2 += 3;

	lea	rax, QWORD PTR [rax+12]
	mov	DWORD PTR [r10+rax-20], ecx
	mov	ecx, DWORD PTR [rax-16]
	mov	DWORD PTR [r10+rax-16], ecx
	mov	ecx, DWORD PTR [rax-12]
	mov	DWORD PTR [r10+rax-12], ecx

; 143  :     } while ( --NU );

	dec	edx
	jne	SHORT $LL13@MoveUnitsU

; 182  :     UnitsCpy(ptr,OldPtr,NU);                NU=Indx2Units[indx];
; 183  :     if ((BYTE*) OldPtr != UnitsStart)       BList[indx].insert(OldPtr,NU);

	movzx	ecx, BYTE PTR Indx2Units[r11+rsi]
	cmp	r9, r8
	je	SHORT $LN2@MoveUnitsU

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbx+rsi+4]
	mov	QWORD PTR [r9+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A[rbx+rsi+4], r9

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r9], -1			; ffffffffH
	mov	DWORD PTR [r9+12], ecx

; 40   :     Stamp++;

	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A[rbx+rsi]

; 185  :     return ptr;

	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+16]

; 186  : }

	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
$LN2@MoveUnitsU:

; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	lea	ecx, DWORD PTR [rcx+rcx*2]

; 185  :     return ptr;

	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+16]

; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	shl	ecx, 2

; 184  :     else                                    UnitsStart += U2B(NU);

	add	r8, rcx
	mov	QWORD PTR UnitsStart, r8

; 186  : }

	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
$LN3@MoveUnitsU:

; 180  :             return OldPtr;

	mov	rax, r9

; 186  : }

	mov	rbx, QWORD PTR [rsp+24]
	pop	rsi
	ret	0
?MoveUnitsUp@@YAPEAXPEAXI@Z ENDP			; MoveUnitsUp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
_TEXT	SEGMENT
Count$ = 32
?ExpandTextArea@@YAXXZ PROC				; ExpandTextArea

; 188  : {

	push	rbx
	sub	rsp, 192				; 000000c0H

; 189  :     BLK_NODE* p;
; 190  :     UINT Count[N_INDEXES];                  memset(Count,0,sizeof(Count));

	lea	rcx, QWORD PTR Count$[rsp]
	xor	edx, edx
	mov	r8d, 152				; 00000098H
	call	memset

; 191  :     while ((p=(BLK_NODE*) UnitsStart)->Stamp == ~0UL) {

	mov	r8, QWORD PTR UnitsStart
	cmp	DWORD PTR [r8], -1			; ffffffffH
	jne	SHORT $LN10@ExpandText
	lea	r10, OFFSET FLAT:Units2Indx
	xor	r9d, r9d
	npad	14
$LL11@ExpandText:

; 192  :         MEM_BLK* pm=(MEM_BLK*) p;           UnitsStart=(BYTE*) (pm+pm->NU);

	mov	eax, DWORD PTR [r8+12]
	lea	rcx, QWORD PTR [r8+12]
	mov	rdx, r8
	shl	rax, 4

; 193  :         Count[Units2Indx[pm->NU-1]]++;      pm->Stamp=0;

	mov	DWORD PTR [rdx], r9d
	add	r8, rax
	mov	eax, DWORD PTR [rcx]
	dec	eax
	movzx	eax, BYTE PTR [rax+r10]
	inc	DWORD PTR Count$[rsp+rax*4]
	cmp	DWORD PTR [r8], -1			; ffffffffH
	je	SHORT $LL11@ExpandText

; 192  :         MEM_BLK* pm=(MEM_BLK*) p;           UnitsStart=(BYTE*) (pm+pm->NU);

	mov	QWORD PTR UnitsStart, r8
$LN10@ExpandText:

; 194  :     }
; 195  :     for (UINT i=0;i < N_INDEXES;i++)

	lea	r9, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A	; BList
	lea	r10, QWORD PTR Count$[rsp]
	mov	ebx, 38					; 00000026H
	mov	r11, r9
$LL9@ExpandText:

; 196  :         for (p=BList+i;Count[i] != 0;p=p->next)

	mov	r8d, DWORD PTR [r10]
	mov	rax, r11
	test	r8d, r8d
	je	SHORT $LN8@ExpandText
	mov	edx, r8d
$LL6@ExpandText:

; 197  :             while ( !p->next->Stamp ) {

	mov	rcx, QWORD PTR [rax+4]
	cmp	DWORD PTR [rcx], 0
	jne	SHORT $LN5@ExpandText
	npad	6
$LL3@ExpandText:

; 17   :     void  unlink()            { next=next->next; }

	mov	rcx, QWORD PTR [rax+4]
	mov	rdx, QWORD PTR [rcx+4]
	mov	QWORD PTR [rax+4], rdx

; 198  :                 p->unlink();                BList[i].Stamp--;

	dec	DWORD PTR [r9]

; 199  :                 if ( !--Count[i] )          break;

	dec	r8d
	mov	edx, r8d
	je	SHORT $LN5@ExpandText

; 197  :             while ( !p->next->Stamp ) {

	mov	rcx, QWORD PTR [rax+4]
	cmp	DWORD PTR [rcx], 0
	je	SHORT $LL3@ExpandText
$LN5@ExpandText:

; 196  :         for (p=BList+i;Count[i] != 0;p=p->next)

	mov	rax, QWORD PTR [rax+4]
	test	edx, edx
	jne	SHORT $LL6@ExpandText
	mov	DWORD PTR [r10], edx
$LN8@ExpandText:

; 194  :     }
; 195  :     for (UINT i=0;i < N_INDEXES;i++)

	add	r11, 12
	add	r10, 4
	add	r9, 12
	dec	rbx
	jne	SHORT $LL9@ExpandText

; 200  :             }
; 201  : }

	add	rsp, 192				; 000000c0H
	pop	rbx
	ret	0
?ExpandTextArea@@YAXXZ ENDP				; ExpandTextArea
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?init@SEE2_CONTEXT@@QEAAXI@Z
_TEXT	SEGMENT
this$ = 8
InitVal$ = 16
?init@SEE2_CONTEXT@@QEAAXI@Z PROC			; SEE2_CONTEXT::init, COMDAT

; 36   :     void init(UINT InitVal) { Summ=InitVal << (Shift=PERIOD_BITS-4); Count=7; }

	shl	dx, 3
	mov	WORD PTR [rcx+2], 1795			; 00000703H
	mov	WORD PTR [rcx], dx
	ret	0
?init@SEE2_CONTEXT@@QEAAXI@Z ENDP			; SEE2_CONTEXT::init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?getMean@SEE2_CONTEXT@@QEAAIXZ
_TEXT	SEGMENT
this$ = 8
?getMean@SEE2_CONTEXT@@QEAAIXZ PROC			; SEE2_CONTEXT::getMean, COMDAT

; 38   :         UINT RetVal=(Summ >> Shift);        Summ -= RetVal;

	movzx	eax, WORD PTR [rcx]
	mov	rdx, rcx
	movzx	ecx, BYTE PTR [rcx+2]
	mov	r8d, eax
	shr	r8d, cl
	sub	ax, r8w
	mov	WORD PTR [rdx], ax

; 39   :         return RetVal+(RetVal == 0);

	xor	eax, eax
	test	r8d, r8d
	sete	al
	add	eax, r8d

; 40   :     }

	ret	0
?getMean@SEE2_CONTEXT@@QEAAIXZ ENDP			; SEE2_CONTEXT::getMean
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?update@SEE2_CONTEXT@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?update@SEE2_CONTEXT@@QEAAXXZ PROC			; SEE2_CONTEXT::update, COMDAT

; 41   :     void update() {

	mov	rdx, rcx

; 42   :         if (Shift < PERIOD_BITS && --Count == 0) {

	movzx	ecx, BYTE PTR [rcx+2]
	cmp	cl, 7
	jae	SHORT $LN1@update
	dec	BYTE PTR [rdx+3]
	jne	SHORT $LN1@update

; 43   :             Summ += Summ;                   Count=3 << Shift++;

	movzx	eax, WORD PTR [rdx]
	add	ax, ax
	mov	WORD PTR [rdx], ax
	mov	eax, 3
	shl	al, cl
	inc	cl
	mov	BYTE PTR [rdx+2], cl
	mov	BYTE PTR [rdx+3], al
$LN1@update:

; 44   :         }
; 45   :     }

	ret	0
?update@SEE2_CONTEXT@@QEAAXXZ ENDP			; SEE2_CONTEXT::update
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?oneState@PPM_CONTEXT@@QEBAAEAUSTATE@1@XZ
_TEXT	SEGMENT
this$ = 8
?oneState@PPM_CONTEXT@@QEBAAEAUSTATE@1@XZ PROC		; PPM_CONTEXT::oneState, COMDAT

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	lea	rax, QWORD PTR [rcx+2]
	ret	0
?oneState@PPM_CONTEXT@@QEBAAEAUSTATE@1@XZ ENDP		; PPM_CONTEXT::oneState
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?SWAP@@YAXAEAUSTATE@PPM_CONTEXT@@0@Z
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
?SWAP@@YAXAEAUSTATE@PPM_CONTEXT@@0@Z PROC		; SWAP, COMDAT

; 97   :     WORD t1=(WORD&) s1;                     PPM_CONTEXT* t2=s1.Successor;
; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	movzx	eax, WORD PTR [rdx]
	movzx	r9d, WORD PTR [rcx]
	mov	r8, QWORD PTR [rcx+2]
	mov	WORD PTR [rcx], ax
	mov	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR [rcx+2], rax

; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;

	mov	WORD PTR [rdx], r9w
	mov	QWORD PTR [rdx+2], r8

; 100  : }

	ret	0
?SWAP@@YAXAEAUSTATE@PPM_CONTEXT@@0@Z ENDP		; SWAP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?StateCpy@@YAXAEAUSTATE@PPM_CONTEXT@@AEBU12@@Z
_TEXT	SEGMENT
s1$ = 8
s2$ = 16
?StateCpy@@YAXAEAUSTATE@PPM_CONTEXT@@AEBU12@@Z PROC	; StateCpy, COMDAT

; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax

; 104  :     s1.Successor=s2.Successor;

	mov	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR [rcx+2], rax

; 105  : }

	ret	0
?StateCpy@@YAXAEAUSTATE@PPM_CONTEXT@@AEBU12@@Z ENDP	; StateCpy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ??__EPPMd_StartUp@@YAXXZ
text$di	SEGMENT
??__EPPMd_StartUp@@YAXXZ PROC				; `dynamic initializer for 'PPMd_StartUp'', COMDAT

; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;

	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 107  : inline PPMD_STARTUP::PPMD_STARTUP()         // constants initialization
; 108  : {
; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;

	lea	r10, OFFSET FLAT:Indx2Units
	mov	edi, 1
	mov	edx, 4
	mov	rcx, r10
	mov	eax, edi
	mov	r8d, edx
$LL24@dynamic:
	mov	BYTE PTR [rcx], al
	inc	eax
	lea	rcx, QWORD PTR [rcx+1]
	dec	r8
	jne	SHORT $LL24@dynamic

; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+4
	mov	r8, rdx
	npad	4
$LL21@dynamic:
	mov	BYTE PTR [rcx], al
	add	eax, 2
	lea	rcx, QWORD PTR [rcx+1]
	dec	r8
	jne	SHORT $LL21@dynamic

; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+8
	npad	9
$LL18@dynamic:
	mov	BYTE PTR [rcx], al
	add	eax, 3
	lea	rcx, QWORD PTR [rcx+1]
	dec	rdx
	jne	SHORT $LL18@dynamic

; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+12
	mov	edx, 26
	npad	4
$LL15@dynamic:
	mov	BYTE PTR [rcx], al
	add	eax, 4
	lea	rcx, QWORD PTR [rcx+1]
	dec	rdx
	jne	SHORT $LL15@dynamic

; 114  :     for (k=i=0;k < 128;k++) {

	xor	ebx, ebx
	lea	r9, OFFSET FLAT:Units2Indx
	mov	edx, ebx
	mov	r8d, ebx
	npad	4
$LL12@dynamic:

; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;

	mov	eax, edx
	inc	r8d
	lea	r9, QWORD PTR [r9+1]
	movzx	ecx, BYTE PTR [rax+r10]
	cmp	ecx, r8d
	adc	edx, ebx
	mov	BYTE PTR [r9-1], dl
	cmp	r8d, 128				; 00000080H
	jb	SHORT $LL12@dynamic

; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);

	mov	rax, 289360691352306692			; 0404040404040404H
	lea	rcx, OFFSET FLAT:NS2BSIndx+11
	mov	edx, 6
	mov	r8d, 245				; 000000f5H
	mov	WORD PTR NS2BSIndx, 512			; 00000200H
	mov	QWORD PTR NS2BSIndx+2, rax
	mov	BYTE PTR NS2BSIndx+10, al
	call	memset
	lea	rax, OFFSET FLAT:QTable
	npad	2
$LL9@dynamic:

; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;

	mov	BYTE PTR [rax], bl
	inc	ebx
	lea	rax, QWORD PTR [rax+1]
	cmp	ebx, 5
	jb	SHORT $LL9@dynamic

; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {

	mov	eax, 5
	mov	ecx, edi
	lea	rdx, OFFSET FLAT:QTable+5
	mov	r8d, 255				; 000000ffH
$LL6@dynamic:

; 121  :         QTable[i]=m;

	mov	BYTE PTR [rdx], al

; 122  :         if ( !--k ) { k = ++Step;           m++; }

	dec	ecx
	jne	SHORT $LN5@dynamic
	inc	edi
	inc	eax
	mov	ecx, edi
$LN5@dynamic:

; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {

	inc	rdx
	dec	r8
	jne	SHORT $LL6@dynamic

; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;

	mov	DWORD PTR ?DummySEE2Cont@@3USEE2_CONTEXT@@A, -2069057649 ; DummySEE2Cont, 84acaf8fH

; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??__EPPMd_StartUp@@YAXXZ ENDP				; `dynamic initializer for 'PPMd_StartUp''
text$di	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ??0PPMD_STARTUP@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 48
??0PPMD_STARTUP@@QEAA@XZ PROC				; PPMD_STARTUP::PPMD_STARTUP, COMDAT

; 108  : {

$LN54:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;

	lea	r10, OFFSET FLAT:Indx2Units
	mov	edi, 1
	mov	edx, 4
	mov	rcx, r10
	mov	eax, edi
	mov	r8d, edx
$LL22@PPMD_START:
	mov	BYTE PTR [rcx], al
	inc	eax
	lea	rcx, QWORD PTR [rcx+1]
	dec	r8
	jne	SHORT $LL22@PPMD_START

; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+4
	mov	r8, rdx
	npad	4
$LL19@PPMD_START:
	mov	BYTE PTR [rcx], al
	add	eax, 2
	lea	rcx, QWORD PTR [rcx+1]
	dec	r8
	jne	SHORT $LL19@PPMD_START

; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+8
	npad	9
$LL16@PPMD_START:
	mov	BYTE PTR [rcx], al
	add	eax, 3
	lea	rcx, QWORD PTR [rcx+1]
	dec	rdx
	jne	SHORT $LL16@PPMD_START

; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;

	inc	eax
	lea	rcx, OFFSET FLAT:Indx2Units+12
	mov	edx, 26
	npad	4
$LL13@PPMD_START:
	mov	BYTE PTR [rcx], al
	add	eax, 4
	lea	rcx, QWORD PTR [rcx+1]
	dec	rdx
	jne	SHORT $LL13@PPMD_START

; 114  :     for (k=i=0;k < 128;k++) {

	xor	ebx, ebx
	lea	r9, OFFSET FLAT:Units2Indx
	mov	edx, ebx
	mov	r8d, ebx
	npad	4
$LL10@PPMD_START:

; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;

	mov	eax, edx
	inc	r8d
	lea	r9, QWORD PTR [r9+1]
	movzx	ecx, BYTE PTR [rax+r10]
	cmp	ecx, r8d
	adc	edx, ebx
	mov	BYTE PTR [r9-1], dl
	cmp	r8d, 128				; 00000080H
	jb	SHORT $LL10@PPMD_START

; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);

	mov	rax, 289360691352306692			; 0404040404040404H
	lea	rcx, OFFSET FLAT:NS2BSIndx+11
	mov	edx, 6
	mov	r8d, 245				; 000000f5H
	mov	WORD PTR NS2BSIndx, 512			; 00000200H
	mov	QWORD PTR NS2BSIndx+2, rax
	mov	BYTE PTR NS2BSIndx+10, al
	call	memset
	lea	rax, OFFSET FLAT:QTable
	npad	2
$LL7@PPMD_START:

; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;

	mov	BYTE PTR [rax], bl
	inc	ebx
	lea	rax, QWORD PTR [rax+1]
	cmp	ebx, 5
	jb	SHORT $LL7@PPMD_START

; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {

	mov	eax, 5
	mov	ecx, edi
	lea	rdx, OFFSET FLAT:QTable+5
	mov	r8d, 255				; 000000ffH
$LL4@PPMD_START:

; 121  :         QTable[i]=m;

	mov	BYTE PTR [rdx], al

; 122  :         if ( !--k ) { k = ++Step;           m++; }

	dec	ecx
	jne	SHORT $LN3@PPMD_START
	inc	edi
	inc	eax
	mov	ecx, edi
$LN3@PPMD_START:

; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {

	inc	rdx
	dec	r8
	jne	SHORT $LL4@PPMD_START

; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;
; 125  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	DWORD PTR ?DummySEE2Cont@@3USEE2_CONTEXT@@A, -2069057649 ; DummySEE2Cont, 84acaf8fH
	lea	rax, OFFSET FLAT:?PPMd_StartUp@@3UPPMD_STARTUP@@A ; PPMd_StartUp
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0PPMD_STARTUP@@QEAA@XZ ENDP				; PPMD_STARTUP::PPMD_STARTUP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
this$ = 48
?makeSuffix@PPM_CONTEXT@@QEAAXXZ PROC			; PPM_CONTEXT::makeSuffix

; 129  : {

$LN44:
	push	rbx
	sub	rsp, 32					; 00000020H

; 130  :     STATE* p, * p1;
; 131  :     if ( !NumStats ) 

	cmp	BYTE PTR [rcx], 0
	mov	rbx, rcx
	jne	SHORT $LN17@makeSuffix
	npad	2
$LL24@makeSuffix:

; 132  :     {
; 133  :         if ( !(p=&oneState())->Successor )  return;

	mov	r8, QWORD PTR [rbx+4]
	test	r8, r8
	je	$LN7@makeSuffix

; 134  : 
; 135  :         if ( !Suffix->NumStats )            

	mov	rax, QWORD PTR [rbx+12]
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN15@makeSuffix

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	add	rax, 2

; 136  :         {
; 137  :             p1=&(Suffix->oneState());
; 138  :         }
; 139  :         else

	jmp	SHORT $LN11@makeSuffix
$LN15@makeSuffix:

; 140  :         {
; 141  :             for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)

	mov	rax, QWORD PTR [rax+4]
	movzx	ecx, BYTE PTR [rbx+2]
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN11@makeSuffix
$LL13@makeSuffix:
	add	rax, 10
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LL13@makeSuffix
$LN11@makeSuffix:

; 142  :                 ;
; 143  :         }
; 144  :         
; 145  :         p->Successor->Suffix = p1->Successor; 

	mov	rcx, QWORD PTR [rax+2]
	mov	QWORD PTR [r8+12], rcx

; 146  :         p->Successor->makeSuffix();

	mov	rbx, QWORD PTR [rbx+4]
	cmp	BYTE PTR [rbx], 0
	je	SHORT $LL24@makeSuffix
$LN17@makeSuffix:

; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 

	movzx	eax, BYTE PTR [rbx]
	mov	QWORD PTR [rsp+48], rdi
	mov	rdi, QWORD PTR [rbx+4]
	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, QWORD PTR [rdi+rcx*2]
	cmp	rdi, rax
	ja	SHORT $LN42@makeSuffix
	add	rdi, 2
	npad	2
$LL9@makeSuffix:

; 151  :         {
; 152  :             if ( !p->Successor )            

	mov	rdx, QWORD PTR [rdi]
	test	rdx, rdx
	je	SHORT $LN8@makeSuffix

; 153  :                 continue;
; 154  : 
; 155  :             if ( !Suffix )                  

	mov	rax, QWORD PTR [rbx+12]
	test	rax, rax
	jne	SHORT $LN5@makeSuffix

; 156  :             {
; 157  :                 p->Successor->Suffix=this;

	mov	QWORD PTR [rdx+12], rbx

; 158  :             }
; 159  :             else 

	jmp	SHORT $LN4@makeSuffix
$LN5@makeSuffix:

; 160  :             {
; 161  :                 for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)

	mov	rax, QWORD PTR [rax+4]
	movzx	ecx, BYTE PTR [rdi-2]
	cmp	BYTE PTR [rax], cl
	je	SHORT $LN1@makeSuffix
$LL3@makeSuffix:
	add	rax, 10
	cmp	BYTE PTR [rax], cl
	jne	SHORT $LL3@makeSuffix
$LN1@makeSuffix:

; 162  :                     ;
; 163  :                 p->Successor->Suffix=p1->Successor;

	mov	rax, QWORD PTR [rax+2]
	mov	QWORD PTR [rdx+12], rax
$LN4@makeSuffix:

; 164  :             }
; 165  :             p->Successor->makeSuffix();

	mov	rcx, QWORD PTR [rdi]
	call	?makeSuffix@PPM_CONTEXT@@QEAAXXZ	; PPM_CONTEXT::makeSuffix
$LN8@makeSuffix:

; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 

	movzx	eax, BYTE PTR [rbx]
	add	rdi, 10
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	lea	rdx, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [rdi-2]
	cmp	rax, rdx
	jbe	SHORT $LL9@makeSuffix
$LN42@makeSuffix:
	mov	rdi, QWORD PTR [rsp+48]
$LN7@makeSuffix:

; 166  :         }
; 167  :     }
; 168  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?makeSuffix@PPM_CONTEXT@@QEAAXXZ ENDP			; PPM_CONTEXT::makeSuffix
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
this$ = 48
fp$ = 56
EscFreq$1$ = 64
PrevSym$ = 64
?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z PROC ; PPM_CONTEXT::read

; 171  : {

$LN80:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, QWORD PTR HiUnit
	mov	rdi, rdx
	mov	rbx, rcx
	mov	QWORD PTR [rsp+48], rbp
$LL63@read:

; 172  :     STATE* p;                               Suffix=NULL;

	mov	QWORD PTR [rbx+12], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rdi]
	mov	rdx, QWORD PTR [rdi+16]
	add	rax, QWORD PTR [rdi+8]
	cmp	rdx, rax
	jae	SHORT $LN22@read

; 25   : 		return		(*m_pointer++);

	movzx	ecx, BYTE PTR [rdx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN23@read
$LN22@read:

; 26   : 	return			(EOF);

	or	ecx, -1
$LN23@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 173  :     NumStats=_PPMD_E_GETC(fp);                     Flags=0x10*(PrevSym >= 0x40);

	cmp	r8d, 64					; 00000040H
	mov	BYTE PTR [rbx], cl
	setae	al
	shl	al, 4
	mov	BYTE PTR [rbx+1], al

; 174  :     if ( !NumStats ) {

	test	cl, cl
	jne	$LN15@read
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	lea	rbp, QWORD PTR [rbx+2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	add	rax, QWORD PTR [rdi+8]
	cmp	rcx, rax
	jae	SHORT $LN27@read

; 25   : 		return		(*m_pointer++);

	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN28@read
$LN27@read:

; 26   : 	return			(EOF);

	or	edx, -1
$LN28@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 175  :         p=&oneState();                      p->Freq=_PPMD_E_GETC(fp);

	mov	BYTE PTR [rbp+1], dl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+16]
	add	rax, QWORD PTR [rdi+8]
	cmp	rcx, rax
	jae	SHORT $LN30@read

; 25   : 		return		(*m_pointer++);

	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN31@read
$LN30@read:

; 26   : 	return			(EOF);

	or	edx, -1
$LN31@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 176  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);

	cmp	dl, 64					; 00000040H
	mov	BYTE PTR [rbp], dl
	setae	al
	shl	al, 3
	or	BYTE PTR [rbx+1], al

; 177  :         if ((p->Freq & 0x80) != 0) {

	movzx	eax, BYTE PTR [rbp+1]
	test	al, al
	jns	SHORT $LN14@read

; 178  :             p->Freq &= ~0x80;

	and	al, 127					; 0000007fH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	cmp	rsi, QWORD PTR LoUnit
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 178  :             p->Freq &= ~0x80;

	mov	BYTE PTR [rbp+1], al
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	je	SHORT $LN36@read
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 180  :             p->Successor->read(fp,p->Symbol);

	movzx	r8d, BYTE PTR [rbp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	sub	rsi, 12
	mov	rbx, rsi
	mov	QWORD PTR HiUnit, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();

	mov	QWORD PTR [rbp+2], rbx

; 180  :             p->Successor->read(fp,p->Symbol);

	jmp	$LL63@read
$LN36@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 15   :     BOOL   avail()      const { return (next != NULL); }

	mov	rbx, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rbx, rbx

; 133  :     else if ( BList->avail() )              return BList->remove();

	je	SHORT $LN34@read

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rbx+4]

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 180  :             p->Successor->read(fp,p->Symbol);

	movzx	r8d, BYTE PTR [rbp]
	mov	QWORD PTR [rbp+2], rbx
	jmp	$LL63@read
$LN34@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 134  :     else                                    return AllocUnitsRare(0);

	xor	ecx, ecx
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 180  :             p->Successor->read(fp,p->Symbol);

	movzx	r8d, BYTE PTR [rbp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 134  :     else                                    return AllocUnitsRare(0);

	mov	rbx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();

	mov	QWORD PTR [rbp+2], rax

; 180  :             p->Successor->read(fp,p->Symbol);

	jmp	$LL63@read
$LN14@read:

; 181  :         } else                              p->Successor=NULL;

	mov	QWORD PTR [rbp+2], 0

; 182  :         return;

	jmp	$LN1@read
$LN15@read:

; 183  :     }
; 184  :     Stats = (PPM_CONTEXT::STATE*) AllocUnits((NumStats+2) >> 1);

	movzx	ecx, cl
	add	ecx, 2
	sar	ecx, 1
	call	?AllocUnits@@YAPEAXI@Z			; AllocUnits

; 185  :     for (p=Stats;p <= Stats+NumStats;p++) {

	movzx	ecx, BYTE PTR [rbx]
	lea	rdx, QWORD PTR [rcx+rcx*4]
	mov	r8, rax
	mov	QWORD PTR [rbx+4], rax
	lea	rcx, QWORD PTR [rax+rdx*2]
	cmp	rax, rcx
	ja	SHORT $LN10@read
	npad	7
$LL12@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+16]
	add	rax, QWORD PTR [rdi+8]
	cmp	rcx, rax
	jae	SHORT $LN45@read

; 25   : 		return		(*m_pointer++);

	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN46@read
$LN45@read:

; 26   : 	return			(EOF);

	or	edx, -1
$LN46@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 186  :         p->Freq=_PPMD_E_GETC(fp);

	mov	BYTE PTR [r8+1], dl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	eax, DWORD PTR [rdi]
	mov	rcx, QWORD PTR [rdi+16]
	add	rax, QWORD PTR [rdi+8]
	cmp	rcx, rax
	jae	SHORT $LN48@read

; 25   : 		return		(*m_pointer++);

	movzx	edx, BYTE PTR [rcx]
	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rdi+16], rax
	jmp	SHORT $LN49@read
$LN48@read:

; 26   : 	return			(EOF);

	or	edx, -1
$LN49@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 187  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);

	mov	BYTE PTR [r8], dl
	cmp	dl, 64					; 00000040H
	setae	al
	add	r8, 10
	shl	al, 3
	or	BYTE PTR [rbx+1], al
	movzx	eax, BYTE PTR [rbx]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	lea	rcx, QWORD PTR [rax+rcx*2]
	cmp	r8, rcx
	jbe	SHORT $LL12@read
$LN10@read:

; 188  :     }
; 189  :     int EscFreq=SummFreq=(Stats->Freq & ~0x80);

	mov	rbp, QWORD PTR [rbx+4]

; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);

	movzx	ecx, BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbp+1]
	btr	eax, 7
	movzx	edx, ax
	mov	WORD PTR [rbx+2], ax
	mov	DWORD PTR EscFreq$1$[rsp], edx
	cmp	edx, ecx
	jge	SHORT $LN18@read
	cmp	edx, 127				; 0000007fH
	jge	SHORT $LN18@read
	mov	eax, 1
	jmp	SHORT $LN19@read
$LN18@read:
	xor	eax, eax
$LN19@read:
	shl	al, 2

; 191  :     for (p=Stats;p <= Stats+NumStats;p++) {

	lea	rcx, QWORD PTR [rcx+rcx*4]
	or	BYTE PTR [rbx+1], al
	lea	rax, QWORD PTR [rcx*2]
	add	rax, rbp
	cmp	rbp, rax
	ja	$LN7@read

; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);

	inc	rbp
$LL9@read:

; 192  :         if ((p->Freq & 0x80) != 0) {

	movzx	eax, BYTE PTR [rbp]
	test	al, al
	jns	SHORT $LN6@read

; 193  :             p->Freq &= ~0x80;

	and	al, 127					; 0000007fH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	cmp	rsi, QWORD PTR LoUnit
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 193  :             p->Freq &= ~0x80;

	mov	BYTE PTR [rbp], al
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	je	SHORT $LN54@read
	sub	rsi, 12
	mov	QWORD PTR HiUnit, rsi
	jmp	SHORT $LN51@read
$LN54@read:

; 15   :     BOOL   avail()      const { return (next != NULL); }

	mov	rsi, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rsi, rsi

; 133  :     else if ( BList->avail() )              return BList->remove();

	je	SHORT $LN52@read

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rsi+4]

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rax

; 133  :     else if ( BList->avail() )              return BList->remove();

	jmp	SHORT $LN51@read
$LN52@read:

; 134  :     else                                    return AllocUnitsRare(0);

	xor	ecx, ecx
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
	mov	rsi, rax
$LN51@read:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 195  :             p->Successor->read(fp,p->Symbol);

	movzx	r8d, BYTE PTR [rbp-1]
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rbp+1], rsi
	call	?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z ; PPM_CONTEXT::read
	mov	rsi, QWORD PTR HiUnit
	jmp	SHORT $LN5@read
$LN6@read:

; 196  :         } else                              p->Successor=NULL;

	mov	QWORD PTR [rbp+1], 0
$LN5@read:

; 197  :         p->Freq=(p == Stats)?(64):(p[-1].Freq-p[0].Freq);

	lea	rax, QWORD PTR [rbp-1]
	cmp	rax, QWORD PTR [rbx+4]
	jne	SHORT $LN20@read
	mov	ecx, 64					; 00000040H
	jmp	SHORT $LN21@read
$LN20@read:
	movzx	ecx, BYTE PTR [rbp-10]
	movzx	eax, BYTE PTR [rbp]
	sub	ecx, eax
$LN21@read:
	mov	BYTE PTR [rbp], cl

; 198  :         SummFreq += p->Freq;

	movzx	eax, cl
	add	rbp, 10
	add	WORD PTR [rbx+2], ax
	movzx	eax, BYTE PTR [rbx]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	lea	rdx, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [rbp-1]
	cmp	rax, rdx
	jbe	$LL9@read
	mov	edx, DWORD PTR EscFreq$1$[rsp]
$LN7@read:

; 199  :     }
; 200  :     if (EscFreq > 32) {

	cmp	edx, 32					; 00000020H
	jle	SHORT $LN1@read

; 202  :         for (p=Stats;p <= Stats+NumStats;p++)

	movzx	eax, BYTE PTR [rbx]
	mov	r8, QWORD PTR [rbx+4]
	sar	edx, 1
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	WORD PTR [rbx+2], dx
	lea	rax, QWORD PTR [r8+rcx*2]
	cmp	r8, rax
	ja	SHORT $LN1@read

; 201  :         SummFreq=(EscFreq >> 1);

	inc	r8
	npad	14
$LL3@read:

; 203  :                 SummFreq += (p->Freq -= (3*p->Freq) >> 2);

	movzx	ecx, BYTE PTR [r8]
	lea	r8, QWORD PTR [r8+10]
	lea	eax, DWORD PTR [rcx+rcx*2]
	sar	eax, 2
	sub	ecx, eax
	mov	BYTE PTR [r8-10], cl
	movzx	eax, cl
	add	WORD PTR [rbx+2], ax
	movzx	eax, BYTE PTR [rbx]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	lea	rdx, QWORD PTR [rax+rcx*2]
	lea	rax, QWORD PTR [r8-1]
	cmp	rax, rdx
	jbe	SHORT $LL3@read
$LN1@read:
	mov	rbp, QWORD PTR [rsp+48]

; 204  :     }
; 205  : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z ENDP ; PPM_CONTEXT::read
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
this$ = 48
OldNU$ = 56
Scale$ = 64
?refresh@PPM_CONTEXT@@QEAAXHH@Z PROC			; PPM_CONTEXT::refresh

; 251  : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 252  :     int i=NumStats, EscFreq;

	movzx	esi, BYTE PTR [rcx]
	mov	edi, r8d
	mov	rbx, rcx

; 253  :     STATE* p = Stats = (STATE*) ShrinkUnits(Stats,OldNU,(i+2) >> 1);

	mov	rcx, QWORD PTR [rcx+4]
	lea	r8d, DWORD PTR [rsi+2]
	sar	r8d, 1
	call	?ShrinkUnits@@YAPEAXPEAXII@Z		; ShrinkUnits

; 254  :     Flags=(Flags & (0x10+0x04*Scale))+0x08*(p->Symbol >= 0x40);
; 255  :     EscFreq=SummFreq-p->Freq;

	movzx	r9d, WORD PTR [rbx+2]
	lea	edx, DWORD PTR [rdi+4]
	shl	dl, 2
	mov	QWORD PTR [rbx+4], rax
	and	dl, BYTE PTR [rbx+1]
	cmp	BYTE PTR [rax], 64			; 00000040H
	setae	cl
	shl	cl, 3
	add	dl, cl
	mov	BYTE PTR [rbx+1], dl
	movzx	ecx, BYTE PTR [rax+1]

; 256  :     SummFreq = (p->Freq=(p->Freq+Scale) >> Scale);

	lea	edx, DWORD PTR [rcx+rdi]
	sub	r9d, ecx
	mov	ecx, edi
	sar	edx, cl
	movzx	ecx, dl
	mov	BYTE PTR [rax+1], dl
	mov	WORD PTR [rbx+2], cx
$LL3@refresh:

; 257  :     do {
; 258  :         EscFreq -= (++p)->Freq;

	movzx	ecx, BYTE PTR [rax+11]
	lea	rax, QWORD PTR [rax+10]
	sub	r9d, ecx

; 259  :         SummFreq += (p->Freq=(p->Freq+Scale) >> Scale);

	lea	edx, DWORD PTR [rcx+rdi]
	mov	ecx, edi
	sar	edx, cl
	mov	BYTE PTR [rax+1], dl
	movzx	r8d, dl
	add	r8w, WORD PTR [rbx+2]
	mov	WORD PTR [rbx+2], r8w

; 260  :         Flags |= 0x08*(p->Symbol >= 0x40);

	cmp	BYTE PTR [rax], 64			; 00000040H
	setae	cl
	shl	cl, 3
	or	BYTE PTR [rbx+1], cl

; 261  :     } while ( --i );

	dec	esi
	jne	SHORT $LL3@refresh

; 262  :     SummFreq += (EscFreq=(EscFreq+Scale) >> Scale);
; 263  : }

	mov	rsi, QWORD PTR [rsp+56]
	lea	eax, DWORD PTR [r9+rdi]
	mov	ecx, edi
	sar	eax, cl
	add	ax, r8w
	mov	WORD PTR [rbx+2], ax
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?refresh@PPM_CONTEXT@@QEAAXHH@Z ENDP			; PPM_CONTEXT::refresh
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
tmp$1$ = 64
this$ = 64
Order$ = 72
?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z PROC			; PPM_CONTEXT::cutOff

; 267  : {

$LN67:
	mov	DWORD PTR [rsp+16], edx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 268  :     int i, tmp;
; 269  :     STATE* p;
; 270  :     if ( !NumStats ) {

	cmp	BYTE PTR [rcx], 0

; 271  :         if ((BYTE*) (p=&oneState())->Successor >= UnitsStart) {

	mov	rax, QWORD PTR [rcx+4]
	mov	rdi, rcx
	jne	SHORT $LN13@cutOff
	cmp	rax, QWORD PTR UnitsStart
	jb	$REMOVE$68

; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);

	cmp	edx, DWORD PTR MaxOrder
	jge	SHORT $LN17@cutOff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);

	mov	rcx, QWORD PTR [rcx+4]
	inc	edx
	call	?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z	; PPM_CONTEXT::cutOff
	mov	edx, DWORD PTR Order$[rsp]
	mov	QWORD PTR [rdi+4], rax
	jmp	SHORT $LN16@cutOff
$LN17@cutOff:

; 273  :             else                            p->Successor=NULL;

	xor	ebp, ebp
	mov	QWORD PTR [rcx+4], rbp
$LN16@cutOff:

; 274  :             if (!p->Successor && Order > O_BOUND)

	cmp	QWORD PTR [rdi+4], 0
	jne	$LN1@cutOff
	cmp	edx, 9
	jg	$REMOVE$68

; 296  :     }
; 297  :     return this;

	mov	rax, rdi

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN13@cutOff:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	ecx, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 282  :     Stats = (STATE*) MoveUnitsUp(Stats,tmp=(NumStats+2) >> 1);

	movzx	eax, BYTE PTR [rdi]
	mov	rcx, QWORD PTR [rdi+4]
	add	eax, 2
	mov	QWORD PTR [rsp+80], rbx
	sar	eax, 1
	mov	edx, eax
	mov	DWORD PTR tmp$1$[rsp], eax
	call	?MoveUnitsUp@@YAPEAXPEAXI@Z		; MoveUnitsUp

; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)

	movzx	esi, BYTE PTR [rdi]
	xor	ebp, ebp
	lea	rdx, QWORD PTR [rsi+rsi*4]
	mov	QWORD PTR [rdi+4], rax
	lea	rbx, QWORD PTR [rax+rdx*2]
	cmp	rbx, rax
	jb	SHORT $LN64@cutOff
	npad	2
$LL12@cutOff:

; 284  :             if ((BYTE*) p->Successor < UnitsStart) {

	mov	rax, QWORD PTR [rbx+2]
	cmp	rax, QWORD PTR UnitsStart
	jae	SHORT $LN9@cutOff

; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);

	mov	QWORD PTR [rbx+2], rbp
	movsxd	rax, esi
	dec	esi
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rdi+4]
	lea	rdx, QWORD PTR [rax+rcx*2]

; 97   :     WORD t1=(WORD&) s1;                     PPM_CONTEXT* t2=s1.Successor;

	movzx	ecx, WORD PTR [rbx]

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rbx], ax
	mov	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR [rbx+2], rax

; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;

	mov	WORD PTR [rdx], cx
	mov	QWORD PTR [rdx+2], rbp

; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);

	jmp	SHORT $LN11@cutOff
$LN9@cutOff:

; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);

	mov	ecx, DWORD PTR Order$[rsp]
	cmp	ecx, DWORD PTR MaxOrder
	jge	SHORT $LN7@cutOff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);

	lea	edx, DWORD PTR [rcx+1]
	mov	rcx, QWORD PTR [rbx+2]
	call	?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z	; PPM_CONTEXT::cutOff
	mov	QWORD PTR [rbx+2], rax
	jmp	SHORT $LN11@cutOff
$LN7@cutOff:

; 287  :             else                            p->Successor=NULL;

	mov	QWORD PTR [rbx+2], rbp
$LN11@cutOff:

; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)

	sub	rbx, 10
	cmp	rbx, QWORD PTR [rdi+4]
	jae	SHORT $LL12@cutOff
$LN64@cutOff:

; 288  :     if (i != NumStats && Order) {

	movzx	eax, BYTE PTR [rdi]
	mov	rbx, QWORD PTR [rsp+80]
	cmp	esi, eax
	je	$LN1@cutOff
	cmp	DWORD PTR Order$[rsp], ebp
	je	$LN1@cutOff

; 289  :         NumStats=i;                         p=Stats;

	mov	r8, QWORD PTR [rdi+4]
	mov	BYTE PTR [rdi], sil

; 290  :         if (i < 0) { FreeUnits(p,tmp);      goto REMOVE; }

	test	esi, esi
	jns	$LN65@cutOff
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 168  :     UINT indx=Units2Indx[NU-1];

	mov	eax, DWORD PTR tmp$1$[rsp]
	lea	r9, OFFSET FLAT:__ImageBase
	dec	eax

; 169  :     BList[indx].insert(ptr,Indx2Units[indx]);

	lea	rcx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9]
	movzx	eax, BYTE PTR Units2Indx[rax+r9]
	mov	edx, eax
	lea	rax, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rcx+rax*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [r8+4], rax
	movzx	eax, BYTE PTR Indx2Units[rdx+r9]
	mov	QWORD PTR [rcx+4], r8

; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r8+12], eax
	mov	DWORD PTR [r8], -1			; ffffffffH

; 40   :     Stamp++;

	inc	DWORD PTR [rcx]
$REMOVE$68:

; 170  : }
; 171  : inline void SpecialFreeUnit(void* ptr)
; 172  : {
; 173  :     if ((BYTE*) ptr != UnitsStart)          BList->insert(ptr,1);

	cmp	rdi, QWORD PTR UnitsStart
	je	SHORT $LN27@cutOff

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	mov	QWORD PTR [rdi+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rdi

; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rdi], -1			; ffffffffH
	mov	DWORD PTR [rdi+12], 1

; 40   :     Stamp++;

	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;

	xor	eax, eax

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN27@cutOff:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 174  :     else { *(DWORD*) ptr=~0UL;              UnitsStart += UNIT_SIZE; }

	add	QWORD PTR UnitsStart, 12
	mov	DWORD PTR [rdi], -1			; ffffffffH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;

	xor	eax, eax

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN65@cutOff:

; 291  :         else if (i == 0) {

	jne	$LN2@cutOff

; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);

	movzx	eax, BYTE PTR [rdi+1]
	cmp	BYTE PTR [r8], 64			; 00000040H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 168  :     UINT indx=Units2Indx[NU-1];

	lea	r9, OFFSET FLAT:__ImageBase
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);

	setae	cl
	and	al, 16
	shl	cl, 3
	add	cl, al
	mov	BYTE PTR [rdi+1], cl

; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	eax, WORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 169  :     BList[indx].insert(ptr,Indx2Units[indx]);

	lea	rcx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r9]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 103  :     (WORD&) s1=(WORD&) s2;                  

	mov	WORD PTR [rdi+2], ax

; 104  :     s1.Successor=s2.Successor;

	mov	rax, QWORD PTR [r8+2]
	mov	QWORD PTR [rdi+4], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 168  :     UINT indx=Units2Indx[NU-1];

	mov	eax, DWORD PTR tmp$1$[rsp]
	dec	eax
	movzx	eax, BYTE PTR Units2Indx[rax+r9]

; 169  :     BList[indx].insert(ptr,Indx2Units[indx]);

	mov	edx, eax
	lea	rax, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rcx+rax*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [r8+4], rax
	movzx	eax, BYTE PTR Indx2Units[rdx+r9]
	mov	QWORD PTR [rcx+4], r8

; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r8+12], eax
	mov	DWORD PTR [r8], -1			; ffffffffH

; 40   :     Stamp++;

	inc	DWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 294  :             oneState().Freq=(oneState().Freq+11) >> 3;

	movzx	eax, BYTE PTR [rdi+3]
	add	eax, 11
	sar	eax, 3
	mov	BYTE PTR [rdi+3], al

; 296  :     }
; 297  :     return this;

	mov	rax, rdi

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN2@cutOff:

; 295  :         } else                              refresh(tmp,SummFreq > 16*i);

	movzx	eax, WORD PTR [rdi+2]
	mov	edx, DWORD PTR tmp$1$[rsp]
	shl	esi, 4
	cmp	eax, esi
	mov	rcx, rdi
	setg	bpl
	mov	r8d, ebp
	call	?refresh@PPM_CONTEXT@@QEAAXHH@Z		; PPM_CONTEXT::refresh
$LN1@cutOff:

; 296  :     }
; 297  :     return this;

	mov	rax, rdi

; 298  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z ENDP			; PPM_CONTEXT::cutOff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
this$ = 48
Order$ = 56
?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z PROC		; PPM_CONTEXT::removeBinConts

; 300  : {

$LN33:
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 301  :     STATE* p;
; 302  :     if ( !NumStats ) {

	cmp	BYTE PTR [rcx], 0

; 303  :         p=&oneState();
; 304  :         if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)

	mov	rax, QWORD PTR [rcx+4]
	mov	esi, edx
	mov	rdi, rcx
	jne	$LN6@removeBinC
	cmp	rax, QWORD PTR UnitsStart
	jb	SHORT $LN10@removeBinC
	cmp	edx, DWORD PTR MaxOrder
	jge	SHORT $LN10@removeBinC
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 305  :                 P_CALL(removeBinConts);

	mov	rcx, QWORD PTR [rcx+4]
	inc	edx
	call	?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z ; PPM_CONTEXT::removeBinConts
	mov	QWORD PTR [rdi+4], rax
	jmp	SHORT $LN9@removeBinC
$LN10@removeBinC:

; 306  :         else                                p->Successor=NULL;

	xor	ebp, ebp
	mov	QWORD PTR [rcx+4], rbp
$LN9@removeBinC:

; 307  :         if (!p->Successor && (!Suffix->NumStats || Suffix->Flags == 0xFF)) {

	cmp	QWORD PTR [rdi+4], 0
	jne	$LN8@removeBinC
	mov	rax, QWORD PTR [rdi+12]
	cmp	BYTE PTR [rax], 0
	je	SHORT $LN7@removeBinC
	cmp	BYTE PTR [rax+1], 255			; 000000ffH
	jne	$LN8@removeBinC
$LN7@removeBinC:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 168  :     UINT indx=Units2Indx[NU-1];

	movzx	eax, BYTE PTR Units2Indx

; 169  :     BList[indx].insert(ptr,Indx2Units[indx]);

	lea	r8, OFFSET FLAT:__ImageBase
	mov	edx, eax
	lea	rax, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r8]
	lea	rcx, QWORD PTR [rcx+rax*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [rdi+4], rax
	movzx	eax, BYTE PTR Indx2Units[rdx+r8]
	mov	QWORD PTR [rcx+4], rdi

; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rdi+12], eax
	mov	DWORD PTR [rdi], -1			; ffffffffH

; 40   :     Stamp++;

	inc	DWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 308  :             FreeUnits(this,1);              return NULL;

	xor	eax, eax

; 316  :     return this;
; 317  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@removeBinC:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	ecx, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 312  :     for (p=Stats+NumStats;p >= Stats;p--)

	mov	rdx, QWORD PTR [rdi+4]
	movzx	eax, BYTE PTR [rdi]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	QWORD PTR [rsp+48], rbx
	lea	rbx, QWORD PTR [rdx+rcx*2]
	cmp	rbx, rdx
	jb	SHORT $LN3@removeBinC
	xor	ebp, ebp
	npad	7
$LL5@removeBinC:

; 313  :             if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)

	mov	rax, QWORD PTR [rbx+2]
	cmp	rax, QWORD PTR UnitsStart
	jb	SHORT $LN2@removeBinC
	cmp	esi, DWORD PTR MaxOrder
	jge	SHORT $LN2@removeBinC
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 314  :                     P_CALL(removeBinConts);

	mov	rcx, QWORD PTR [rbx+2]
	lea	edx, DWORD PTR [rsi+1]
	call	?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z ; PPM_CONTEXT::removeBinConts
	mov	QWORD PTR [rbx+2], rax
	jmp	SHORT $LN4@removeBinC
$LN2@removeBinC:

; 315  :             else                            p->Successor=NULL;

	mov	QWORD PTR [rbx+2], rbp
$LN4@removeBinC:

; 312  :     for (p=Stats+NumStats;p >= Stats;p--)

	sub	rbx, 10
	cmp	rbx, QWORD PTR [rdi+4]
	jae	SHORT $LL5@removeBinC
$LN3@removeBinC:
	mov	rbx, QWORD PTR [rsp+48]
$LN8@removeBinC:

; 316  :     return this;
; 317  : }

	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z ENDP		; PPM_CONTEXT::removeBinConts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
pc1$ = 64
MinContext$ = 72
FSuccessor$ = 80
?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z PROC	; RestoreModelRare

; 321  : {

	push	rbx
	push	rdi
	push	r15
	sub	rsp, 32					; 00000020H

; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)

	mov	rdi, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	mov	rax, QWORD PTR HeapStart
	mov	QWORD PTR [rsp+64], rbp
	mov	QWORD PTR [rsp+80], r14
	mov	r15, r8
	mov	rbp, rcx
	mov	rbx, rdi
	mov	QWORD PTR pText, rax
	mov	r14, rdx
	cmp	rdi, rcx
	je	$LN23@RestoreMod
	mov	QWORD PTR [rsp+72], rsi
	mov	rsi, QWORD PTR UnitsStart
	npad	7
$LL25@RestoreMod:

; 325  :             if (--(pc->NumStats) == 0) {

	dec	BYTE PTR [rbx]
	jne	SHORT $LN22@RestoreMod

; 326  :                 pc->Flags=(pc->Flags & 0x10)+0x08*(pc->Stats->Symbol >= 0x40);

	mov	rdx, QWORD PTR [rbx+4]
	movzx	eax, BYTE PTR [rbx+1]
	cmp	BYTE PTR [rdx], 64			; 00000040H
	setae	cl
	and	al, 16
	shl	cl, 3
	add	cl, al
	mov	BYTE PTR [rbx+1], cl

; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rbx+2], ax

; 104  :     s1.Successor=s2.Successor;

	mov	rax, QWORD PTR [rdx+2]
	mov	QWORD PTR [rbx+4], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 173  :     if ((BYTE*) ptr != UnitsStart)          BList->insert(ptr,1);

	cmp	rdx, rsi
	je	SHORT $LN33@RestoreMod

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	mov	QWORD PTR [rdx+4], rax
	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rdx

; 17   :     void  unlink()            { next=next->next; }
; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;
; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [rdx], -1			; ffffffffH
	mov	DWORD PTR [rdx+12], 1

; 40   :     Stamp++;

	inc	DWORD PTR ?BList@@3PAUBLK_NODE@@A
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;

	movzx	eax, BYTE PTR [rbx+3]
	add	eax, 11
	sar	eax, 3
	mov	BYTE PTR [rbx+3], al

; 330  :             } else

	jmp	SHORT $LN24@RestoreMod
$LN33@RestoreMod:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 174  :     else { *(DWORD*) ptr=~0UL;              UnitsStart += UNIT_SIZE; }

	mov	DWORD PTR [rdx], -1			; ffffffffH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;

	movzx	eax, BYTE PTR [rbx+3]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 174  :     else { *(DWORD*) ptr=~0UL;              UnitsStart += UNIT_SIZE; }

	add	rsi, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;

	add	eax, 11
	sar	eax, 3
	mov	BYTE PTR [rbx+3], al

; 330  :             } else

	jmp	SHORT $LN24@RestoreMod
$LN22@RestoreMod:

; 331  :                     pc->refresh((pc->NumStats+3) >> 1,FALSE);

	movzx	edx, BYTE PTR [rbx]
	xor	r8d, r8d
	mov	rcx, rbx
	add	edx, 3
	sar	edx, 1
	call	?refresh@PPM_CONTEXT@@QEAAXHH@Z		; PPM_CONTEXT::refresh
$LN24@RestoreMod:

; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)

	mov	rbx, QWORD PTR [rbx+12]
	cmp	rbx, rbp
	jne	$LL25@RestoreMod
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 174  :     else { *(DWORD*) ptr=~0UL;              UnitsStart += UNIT_SIZE; }

	mov	QWORD PTR UnitsStart, rsi
	mov	rsi, QWORD PTR [rsp+72]
$LN23@RestoreMod:
	mov	rbp, QWORD PTR [rsp+64]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)

	cmp	rbx, r14
	je	SHORT $LN18@RestoreMod
$LL20@RestoreMod:

; 333  :             if ( !pc->NumStats )

	movzx	ecx, BYTE PTR [rbx]
	test	cl, cl
	jne	SHORT $LN17@RestoreMod

; 334  :                     pc->oneState().Freq -= pc->oneState().Freq >> 1;

	movzx	eax, BYTE PTR [rbx+3]
	shr	al, 1
	sub	BYTE PTR [rbx+3], al
	jmp	SHORT $LN19@RestoreMod
$LN17@RestoreMod:

; 335  :             else if ((pc->SummFreq += 4) > 128+4*pc->NumStats)

	movzx	eax, WORD PTR [rbx+2]
	movzx	edx, cl
	add	eax, 4
	lea	ecx, DWORD PTR [rdx*4+128]
	mov	WORD PTR [rbx+2], ax
	movzx	eax, ax
	cmp	eax, ecx
	jle	SHORT $LN19@RestoreMod

; 336  :                     pc->refresh((pc->NumStats+2) >> 1,TRUE);

	add	edx, 2
	mov	r8d, 1
	mov	rcx, rbx
	sar	edx, 1
	call	?refresh@PPM_CONTEXT@@QEAAXHH@Z		; PPM_CONTEXT::refresh
$LN19@RestoreMod:

; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)

	mov	rbx, QWORD PTR [rbx+12]
	cmp	rbx, r14
	jne	SHORT $LL20@RestoreMod
$LN18@RestoreMod:

; 337  :     if (MRMethod > MRM_FREEZE) {

	mov	ebx, DWORD PTR MRMethod
	mov	r14, QWORD PTR [rsp+80]
	cmp	ebx, 2
	jle	SHORT $LN76@RestoreMod

; 338  :         MaxContext=FSuccessor;              GlueCount += !(BList[1].Stamp & 1);

	mov	eax, DWORD PTR ?BList@@3PAUBLK_NODE@@A+12
	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, r15 ; MaxContext
	not	eax
	and	eax, 1
	add	DWORD PTR GlueCount, eax

; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN76@RestoreMod:

; 339  :     } else if (MRMethod == MRM_FREEZE) {

	jne	SHORT $LN12@RestoreMod

; 340  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;

	mov	rax, QWORD PTR [rdi+12]
	test	rax, rax
	je	SHORT $LN10@RestoreMod
	npad	7
$LL11@RestoreMod:
	mov	rdi, rax
	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext
	mov	rax, QWORD PTR [rax+12]
	test	rax, rax
	jne	SHORT $LL11@RestoreMod
$LN10@RestoreMod:

; 341  :         MaxContext->removeBinConts(0);      MRMethod=MR_METHOD(MRMethod+1);

	xor	edx, edx
	mov	rcx, rdi
	call	?removeBinConts@PPM_CONTEXT@@QEAAPEAU1@H@Z ; PPM_CONTEXT::removeBinConts
	inc	DWORD PTR MRMethod
$LN74@RestoreMod:

; 342  :         GlueCount=0;                        OrderFall=MaxOrder;

	mov	eax, DWORD PTR MaxOrder
	mov	DWORD PTR GlueCount, 0
	mov	DWORD PTR OrderFall, eax

; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
$LN12@RestoreMod:

; 343  : 	} else if (MRMethod == MRM_RESTART || GetUsedMemory() < (SubAllocatorSize >> 1)) {

	test	ebx, ebx
	je	SHORT $LN7@RestoreMod
	call	GetUsedMemory
	mov	ecx, DWORD PTR SubAllocatorSize
	shr	ecx, 1
	cmp	eax, ecx
	jb	SHORT $LN7@RestoreMod

; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;

	mov	rax, QWORD PTR [rdi+12]
	test	rax, rax
	je	SHORT $LL3@RestoreMod
$LL5@RestoreMod:
	mov	rdi, rax
	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext
	mov	rax, QWORD PTR [rax+12]
	test	rax, rax
	jne	SHORT $LL5@RestoreMod
$LL3@RestoreMod:

; 348  :         do {
; 349  :             MaxContext->cutOff(0);          ExpandTextArea();

	xor	edx, edx
	mov	rcx, rdi
	call	?cutOff@PPM_CONTEXT@@QEAAPEAU1@H@Z	; PPM_CONTEXT::cutOff
	call	?ExpandTextArea@@YAXXZ			; ExpandTextArea

; 350  : 		} while (GetUsedMemory() > 3*(SubAllocatorSize >> 2));

	call	GetUsedMemory
	mov	ecx, DWORD PTR SubAllocatorSize
	shr	ecx, 2
	lea	ecx, DWORD PTR [rcx+rcx*2]
	cmp	eax, ecx
	jbe	SHORT $LN74@RestoreMod

; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;

	mov	rdi, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	jmp	SHORT $LL3@RestoreMod
$LN7@RestoreMod:

; 344  :         StartModelRare(MaxOrder,MRMethod);

	mov	ecx, DWORD PTR MaxOrder
	mov	edx, ebx
	call	?StartModelRare@@YAXHW4MR_METHOD@@@Z	; StartModelRare

; 345  :         EscCount=0;                         PrintCount=0xFF;

	mov	BYTE PTR EscCount, 0
	mov	BYTE PTR PrintCount, 255		; 000000ffH

; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	rdi
	pop	rbx
	ret	0
?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z ENDP	; RestoreModelRare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
ps$ = 32
p$ = 176
pc$ = 184
?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z PROC ; ReduceOrder

; 358  : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 160				; 000000a0H

; 359  :     PPM_CONTEXT::STATE* p1,  * ps[MAX_O], ** pps=ps;
; 360  :     PPM_CONTEXT* pc1=pc, * UpBranch = (PPM_CONTEXT*) pText;
; 361  :     BYTE tmp, sym=FoundState->Symbol;

	mov	r14, QWORD PTR FoundState

; 362  :     *pps++ = FoundState;                    FoundState->Successor=UpBranch;
; 363  :     OrderFall++;

	mov	edi, DWORD PTR OrderFall
	mov	rsi, QWORD PTR pText
	movzx	r9d, BYTE PTR [r14]
	inc	edi
	mov	rbx, rcx
	mov	rbp, rdx
	mov	QWORD PTR ps$[rsp], r14
	lea	r8, QWORD PTR ps$[rsp+8]
	mov	DWORD PTR OrderFall, edi
	mov	QWORD PTR [r14+2], rsi

; 364  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }

	test	rcx, rcx
	je	SHORT $LN18@ReduceOrde
	mov	rdx, QWORD PTR [rdx+12]
	jmp	SHORT $LOOP_ENTRY$35
$LN18@ReduceOrde:

; 365  :     for ( ; ; ) {
; 366  :         if ( !pc->Suffix ) {

	mov	rax, QWORD PTR [rdx+12]
	test	rax, rax
	je	$LN28@ReduceOrde

; 372  :         }
; 373  :         pc=pc->Suffix;
; 374  :         if ( pc->NumStats ) {

	cmp	BYTE PTR [rax], 0
	mov	rdx, rax
	je	SHORT $LN11@ReduceOrde

; 375  :             if ((p=pc->Stats)->Symbol != sym)

	mov	rbx, QWORD PTR [rax+4]
	cmp	BYTE PTR [rbx], r9b
	je	SHORT $LN7@ReduceOrde
	npad	6
$LL9@ReduceOrde:

; 376  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);

	add	rbx, 10
	cmp	BYTE PTR [rbx], r9b
	jne	SHORT $LL9@ReduceOrde
$LN7@ReduceOrde:

; 377  :             tmp=2*(p->Freq < MAX_FREQ-9);

	movzx	ecx, BYTE PTR [rbx+1]
	cmp	cl, 115					; 00000073H
	setb	al
	add	al, al

; 378  :             p->Freq += tmp;                 pc->SummFreq += tmp;

	add	cl, al
	movzx	eax, al
	mov	BYTE PTR [rbx+1], cl
	add	WORD PTR [rdx+2], ax

; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }

	jmp	SHORT $LOOP_ENTRY$35
$LN11@ReduceOrde:

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	lea	rbx, QWORD PTR [rax+2]

; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }

	movzx	eax, BYTE PTR [rax+3]
	cmp	al, 32					; 00000020H
	adc	al, 0
	mov	BYTE PTR [rbx+1], al
$LOOP_ENTRY$35:

; 380  : LOOP_ENTRY:
; 381  :         if ( p->Successor )                 break;

	cmp	QWORD PTR [rbx+2], 0
	jne	SHORT $LN29@ReduceOrde

; 382  :         *pps++ = p;                         p->Successor=UpBranch;

	mov	QWORD PTR [r8], rbx
	add	r8, 8

; 383  :         OrderFall++;

	inc	edi
	mov	DWORD PTR OrderFall, edi
	mov	QWORD PTR [rbx+2], rsi

; 384  :     }

	jmp	SHORT $LN18@ReduceOrde
$LN29@ReduceOrde:

; 385  :     if (MRMethod > MRM_FREEZE) {

	cmp	DWORD PTR MRMethod, 2
	jle	SHORT $LN4@ReduceOrde

; 386  :         pc = p->Successor;                  goto FROZEN;

	mov	rdx, QWORD PTR [rbx+2]
	jmp	SHORT $FROZEN$36
$LN4@ReduceOrde:

; 387  :     } else if (p->Successor <= UpBranch) {

	cmp	QWORD PTR [rbx+2], rsi
	ja	SHORT $LN2@ReduceOrde

; 388  :         p1=FoundState;                      FoundState=p;
; 389  :         p->Successor=CreateSuccessors(FALSE,NULL,pc);

	mov	r8, rdx
	xor	ecx, ecx
	xor	edx, edx
	mov	QWORD PTR FoundState, rbx
	call	?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z ; CreateSuccessors

; 390  :         FoundState=p1;

	mov	QWORD PTR FoundState, r14
	mov	QWORD PTR [rbx+2], rax
$LN2@ReduceOrde:

; 391  :     }
; 392  :     if (OrderFall == 1 && pc1 == MaxContext) {

	cmp	edi, 1
	jne	SHORT $LN1@ReduceOrde
	cmp	rbp, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	jne	SHORT $LN1@ReduceOrde

; 393  :         FoundState->Successor=p->Successor; pText--;

	mov	rax, QWORD PTR [rbx+2]
	dec	rsi
	mov	QWORD PTR [r14+2], rax
	mov	QWORD PTR pText, rsi
$LN1@ReduceOrde:

; 394  :     }
; 395  :     return p->Successor;

	mov	rax, QWORD PTR [rbx+2]
	jmp	SHORT $LN21@ReduceOrde
$LN28@ReduceOrde:

; 367  :             if (MRMethod > MRM_FREEZE) {

	cmp	DWORD PTR MRMethod, 2
	jle	SHORT $LN15@ReduceOrde
$FROZEN$36:

; 368  : FROZEN:         do { (*--pps)->Successor = pc; } while (pps != ps);

	mov	rax, QWORD PTR [r8-8]
	sub	r8, 8
	mov	QWORD PTR [rax+2], rdx
	lea	rax, QWORD PTR ps$[rsp]
	cmp	r8, rax
	jne	SHORT $FROZEN$36

; 369  :                 pText=HeapStart+1;          OrderFall=1;

	mov	rax, QWORD PTR HeapStart
	mov	DWORD PTR OrderFall, 1
	inc	rax
	mov	QWORD PTR pText, rax
$LN15@ReduceOrde:

; 370  :             }
; 371  :             return pc;

	mov	rax, rdx
$LN21@ReduceOrde:

; 396  : }

	lea	r11, QWORD PTR [rsp+160]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z ENDP ; ReduceOrder
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
tmp$ = 32
this$ = 64
?rescale@PPM_CONTEXT@@QEAAXXZ PROC			; PPM_CONTEXT::rescale

; 398  : {

$LN65:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 48					; 00000030H

; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);

	mov	r10, QWORD PTR FoundState
	movzx	r11d, BYTE PTR [rcx]
	mov	QWORD PTR [rsp+72], r14
	mov	rbx, rcx
	cmp	r10, QWORD PTR [rcx+4]
	je	SHORT $LN17@rescale
	npad	8
$LL19@rescale:

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	movzx	eax, WORD PTR [r10-10]
	movzx	r9d, WORD PTR [r10]
	mov	rdx, QWORD PTR [r10+2]
	mov	WORD PTR [r10], ax
	mov	rax, QWORD PTR [r10-8]

; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);

	lea	r8, QWORD PTR [r10-10]

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	mov	QWORD PTR [r10+2], rax

; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;

	mov	QWORD PTR [r10-8], rdx
	mov	WORD PTR [r8], r9w

; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);

	mov	r10, r8
	cmp	r8, QWORD PTR [rcx+4]
	jne	SHORT $LL19@rescale
$LN17@rescale:

; 402  :     p->Freq += 4;                           SummFreq += 4;

	add	BYTE PTR [r10+1], 4
	add	WORD PTR [rcx+2], 4
	movzx	edi, WORD PTR [rcx+2]

; 403  :     EscFreq=SummFreq-p->Freq;

	movzx	eax, BYTE PTR [r10+1]
	lea	rsi, QWORD PTR [rcx+2]
	sub	edi, eax

; 404  :     Adder=(OrderFall != 0 || MRMethod > MRM_FREEZE);

	cmp	DWORD PTR OrderFall, 0
	jne	SHORT $LN22@rescale
	cmp	DWORD PTR MRMethod, 2
	jg	SHORT $LN22@rescale
	xor	r14d, r14d
	jmp	SHORT $LN23@rescale
$LN22@rescale:
	mov	r14d, 1
$LN23@rescale:

; 405  :     SummFreq = (p->Freq=(p->Freq+Adder) >> 1);

	add	eax, r14d
	mov	QWORD PTR [rsp+64], rbp
	shr	eax, 1
	mov	BYTE PTR [r10+1], al
	movzx	eax, al
	mov	WORD PTR [rsi], ax
	npad	8
$LL16@rescale:

; 406  :     do {
; 407  :         EscFreq -= (++p)->Freq;

	movzx	eax, BYTE PTR [r10+11]
	add	r10, 10

; 408  :         SummFreq += (p->Freq=(p->Freq+Adder) >> 1);

	lea	ecx, DWORD PTR [rax+r14]
	sub	edi, eax
	shr	ecx, 1
	mov	BYTE PTR [r10+1], cl
	movzx	eax, cl
	add	WORD PTR [rsi], ax

; 409  :         if (p[0].Freq > p[-1].Freq) {

	movzx	eax, BYTE PTR [r10-9]
	cmp	BYTE PTR [r10+1], al
	jbe	SHORT $LN15@rescale

; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	r9d, WORD PTR [r10]

; 104  :     s1.Successor=s2.Successor;

	mov	rbp, QWORD PTR [r10+2]

; 410  :             StateCpy(tmp,*(p1=p));

	mov	rax, r10

; 103  :     (WORD&) s1=(WORD&) s2;                  

	mov	WORD PTR tmp$[rsp], r9w

; 104  :     s1.Successor=s2.Successor;

	movzx	r8d, BYTE PTR tmp$[rsp+1]
	npad	3
$LL12@rescale:

; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	ecx, WORD PTR [rax-10]

; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);

	lea	rdx, QWORD PTR [rax-10]

; 103  :     (WORD&) s1=(WORD&) s2;                  

	mov	WORD PTR [rax], cx

; 104  :     s1.Successor=s2.Successor;

	mov	rcx, QWORD PTR [rax-8]
	mov	QWORD PTR [rax+2], rcx

; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);

	lea	rax, QWORD PTR [rdx]
	cmp	r8b, BYTE PTR [rdx-9]
	ja	SHORT $LL12@rescale

; 103  :     (WORD&) s1=(WORD&) s2;                  

	mov	WORD PTR [rdx], r9w

; 104  :     s1.Successor=s2.Successor;

	mov	QWORD PTR [rdx+2], rbp
$LN15@rescale:

; 412  :             StateCpy(*p1,tmp);
; 413  :         }
; 414  :     } while ( --i );

	dec	r11d
	jne	SHORT $LL16@rescale

; 415  :     if (p->Freq == 0) {

	mov	r14, QWORD PTR [rsp+72]
	mov	rbp, QWORD PTR [rsp+64]
	inc	r10
	cmp	BYTE PTR [r10], r11b
	jne	$LN1@rescale
	npad	1
$LL8@rescale:

; 416  :         do { i++; } while ((--p)->Freq == 0);

	lea	r10, QWORD PTR [r10-10]
	inc	r11d
	cmp	BYTE PTR [r10], 0
	je	SHORT $LL8@rescale

; 417  :         EscFreq += i;                       OldNU=(NumStats+2) >> 1;

	movzx	eax, BYTE PTR [rbx]
	add	edi, r11d
	lea	r10d, DWORD PTR [rax+2]

; 418  :         if ((NumStats -= i) == 0) {

	sub	eax, r11d
	sar	r10d, 1
	mov	BYTE PTR [rbx], al
	test	al, al
	jne	$LN5@rescale

; 419  :             StateCpy(tmp,*Stats);

	mov	r8, QWORD PTR [rbx+4]

; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;

	xor	edx, edx

; 424  :             FoundState=&oneState();         return;

	mov	QWORD PTR FoundState, rsi

; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	eax, WORD PTR [r8]

; 104  :     s1.Successor=s2.Successor;

	mov	r9, QWORD PTR [r8+2]
	mov	WORD PTR tmp$[rsp], ax

; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;

	shr	ax, 8
	movzx	eax, al
	lea	eax, DWORD PTR [rax*2-1]
	add	eax, edi
	div	edi

; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;

	mov	edx, 41					; 00000029H
	cmp	al, dl
	movzx	ecx, al
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 168  :     UINT indx=Units2Indx[NU-1];

	lea	eax, DWORD PTR [r10-1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;

	cmova	ecx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 168  :     UINT indx=Units2Indx[NU-1];

	lea	r10, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR Units2Indx[rax+r10]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;

	mov	BYTE PTR tmp$[rsp+1], cl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 169  :     BList[indx].insert(ptr,Indx2Units[indx]);

	lea	rcx, QWORD PTR ?BList@@3PAUBLK_NODE@@A[r10]
	mov	edx, eax
	lea	rax, QWORD PTR [rax+rax*2]
	lea	rcx, QWORD PTR [rcx+rax*4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }

	mov	rax, QWORD PTR [rcx+4]
	mov	QWORD PTR [r8+4], rax
	movzx	eax, BYTE PTR Indx2Units[rdx+r10]
	mov	QWORD PTR [rcx+4], r8

; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r8+12], eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	eax, WORD PTR tmp$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 39   :     p->Stamp=~0UL;                          p->NU=NU;

	mov	DWORD PTR [r8], -1			; ffffffffH

; 40   :     Stamp++;

	inc	DWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);

	cmp	al, 64					; 00000040H

; 103  :     (WORD&) s1=(WORD&) s2;                  

	mov	WORD PTR [rsi], ax

; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);

	setae	cl

; 104  :     s1.Successor=s2.Successor;

	mov	QWORD PTR [rsi+2], r9

; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);

	movzx	eax, BYTE PTR [rbx+1]
	and	al, 16
	shl	cl, 3
	add	cl, al
	mov	BYTE PTR [rbx+1], cl

; 433  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN5@rescale:

; 425  :         }
; 426  :         Stats = (STATE*) ShrinkUnits(Stats,OldNU,(NumStats+2) >> 1);

	mov	rcx, QWORD PTR [rbx+4]
	movzx	r8d, al
	mov	edx, r10d
	add	r8d, 2
	sar	r8d, 1
	call	?ShrinkUnits@@YAPEAXPEAXII@Z		; ShrinkUnits

; 427  :         Flags &= ~0x08;                     i=NumStats;

	and	BYTE PTR [rbx+1], 247			; 000000f7H
	movzx	r8d, BYTE PTR [rbx]
	mov	QWORD PTR [rbx+4], rax

; 428  :         Flags |= 0x08*((p=Stats)->Symbol >= 0x40);

	cmp	BYTE PTR [rax], 64			; 00000040H
	mov	rdx, rax
	setae	cl
	shl	cl, 3
	or	cl, BYTE PTR [rbx+1]
	mov	BYTE PTR [rbx+1], cl
	npad	1
$LL3@rescale:

; 429  :         do { Flags |= 0x08*((++p)->Symbol >= 0x40); } while ( --i );

	cmp	BYTE PTR [rdx+10], 64			; 00000040H
	lea	rdx, QWORD PTR [rdx+10]
	setae	al
	shl	al, 3
	or	cl, al
	mov	BYTE PTR [rbx+1], cl
	dec	r8d
	jne	SHORT $LL3@rescale
$LN1@rescale:

; 430  :     }
; 431  :     SummFreq += (EscFreq -= (EscFreq >> 1));

	mov	eax, edi
	shr	eax, 1
	sub	di, ax

; 432  :     Flags |= 0x04;                          FoundState=Stats;

	mov	rax, QWORD PTR [rbx+4]
	add	WORD PTR [rsi], di
	or	BYTE PTR [rbx+1], 4

; 433  : }

	mov	rbx, QWORD PTR [rsp+80]
	mov	rsi, QWORD PTR [rsp+88]
	mov	QWORD PTR FoundState, rax
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?rescale@PPM_CONTEXT@@QEAAXXZ ENDP			; PPM_CONTEXT::rescale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
ct$ = 32
ps$ = 64
Skip$ = 224
p$ = 232
pc$ = 240
?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z PROC ; CreateSuccessors

; 436  : {

	push	rbx
	push	rsi
	sub	rsp, 200				; 000000c8H

; 437  : 
; 438  :     PPM_CONTEXT ct, * UpBranch=FoundState->Successor;

	mov	rax, QWORD PTR FoundState
	mov	rbx, r8

; 439  :     PPM_CONTEXT::STATE* ps[MAX_O], ** pps=ps;

	lea	rsi, QWORD PTR ps$[rsp]
	mov	r10, QWORD PTR [rax+2]

; 440  :     UINT cf, s0;
; 441  :     BYTE tmp, sym=FoundState->Symbol;

	movzx	r9d, BYTE PTR [rax]

; 442  :     if ( !Skip ) {

	test	ecx, ecx
	jne	SHORT $LN25@CreateSucc

; 443  :         *pps++ = FoundState;
; 444  :         if ( !pc->Suffix )                  goto NO_LOOP;

	cmp	QWORD PTR [r8+12], 0
	mov	QWORD PTR ps$[rsp], rax
	lea	rsi, QWORD PTR ps$[rsp+8]
	je	$LN11@CreateSucc
$LN25@CreateSucc:

; 445  :     }
; 446  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }

	test	rdx, rdx
	je	SHORT $LN21@CreateSucc
	mov	rbx, QWORD PTR [r8+12]
	jmp	SHORT $LOOP_ENTRY$76
$LN21@CreateSucc:

; 447  :     do {
; 448  :         pc=pc->Suffix;

	mov	rbx, QWORD PTR [rbx+12]

; 449  :         if ( pc->NumStats ) {

	cmp	BYTE PTR [rbx], 0
	je	SHORT $LN18@CreateSucc

; 450  :             if ((p=pc->Stats)->Symbol != sym)

	mov	rdx, QWORD PTR [rbx+4]
	cmp	BYTE PTR [rdx], r9b
	je	SHORT $LN14@CreateSucc
$LL16@CreateSucc:

; 451  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);

	add	rdx, 10
	cmp	BYTE PTR [rdx], r9b
	jne	SHORT $LL16@CreateSucc
$LN14@CreateSucc:

; 452  :             tmp=(p->Freq < MAX_FREQ-9);

	movzx	ecx, BYTE PTR [rdx+1]
	cmp	cl, 115					; 00000073H
	setb	al

; 453  :             p->Freq += tmp;                 pc->SummFreq += tmp;

	add	cl, al
	movzx	eax, al
	mov	BYTE PTR [rdx+1], cl
	add	WORD PTR [rbx+2], ax

; 454  :         } else {

	jmp	SHORT $LOOP_ENTRY$76
$LN18@CreateSucc:

; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));

	mov	rax, QWORD PTR [rbx+12]

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	lea	rdx, QWORD PTR [rbx+2]

; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));

	cmp	BYTE PTR [rax], 0
	sete	cl
	cmp	BYTE PTR [rdx+1], 24
	setb	al
	and	cl, al
	add	BYTE PTR [rdx+1], cl
$LOOP_ENTRY$76:

; 457  :         }
; 458  : LOOP_ENTRY:
; 459  :         if (p->Successor != UpBranch) {

	cmp	QWORD PTR [rdx+2], r10
	jne	SHORT $LN58@CreateSucc

; 461  :         }
; 462  :         *pps++ = p;

	mov	QWORD PTR [rsi], rdx
	add	rsi, 8

; 463  :     } while ( pc->Suffix );

	cmp	QWORD PTR [rbx+12], 0
	jne	SHORT $LN21@CreateSucc
	jmp	SHORT $LN19@CreateSucc
$LN58@CreateSucc:

; 460  :             pc=p->Successor;                break;

	mov	rbx, QWORD PTR [rdx+2]
$LN19@CreateSucc:

; 464  : NO_LOOP:
; 465  :     if (pps == ps)                          return pc;

	lea	rax, QWORD PTR ps$[rsp]
$NO_LOOP$77:
	cmp	rsi, rax
	jne	SHORT $LN11@CreateSucc
	mov	rax, rbx

; 485  : }

	add	rsp, 200				; 000000c8H
	pop	rsi
	pop	rbx
	ret	0
$LN11@CreateSucc:

; 466  :     ct.NumStats=0;                          ct.Flags=0x10*(sym >= 0x40);
; 467  :     ct.oneState().Symbol=sym=*(BYTE*) UpBranch;

	movzx	edx, BYTE PTR [r10]
	cmp	r9b, 64					; 00000040H

; 468  :     ct.oneState().Successor=(PPM_CONTEXT*) (((BYTE*) UpBranch)+1);
; 469  :     ct.Flags |= 0x08*(sym >= 0x40);
; 470  :     if ( pc->NumStats ) {

	movzx	r9d, BYTE PTR [rbx]
	setae	cl
	mov	QWORD PTR [rsp+224], rbp
	lea	rax, QWORD PTR [r10+1]
	shl	cl, 4
	cmp	dl, 64					; 00000040H
	mov	QWORD PTR ct$[rsp+4], rax
	setae	al
	mov	QWORD PTR [rsp+232], rdi
	mov	QWORD PTR [rsp+240], r14
	shl	al, 3
	mov	QWORD PTR [rsp+192], r15
	mov	BYTE PTR ct$[rsp], 0
	or	cl, al
	mov	BYTE PTR ct$[rsp+2], dl
	mov	BYTE PTR ct$[rsp+1], cl
	test	r9b, r9b
	je	SHORT $LN10@CreateSucc

; 471  :         if ((p=pc->Stats)->Symbol != sym)

	mov	rax, QWORD PTR [rbx+4]
	cmp	BYTE PTR [rax], dl
	je	SHORT $LN6@CreateSucc
$LL8@CreateSucc:

; 472  :                 do { tmp=p[1].Symbol;       p++; } while (tmp != sym);

	add	rax, 10
	cmp	BYTE PTR [rax], dl
	jne	SHORT $LL8@CreateSucc
$LN6@CreateSucc:

; 473  :         s0=pc->SummFreq-pc->NumStats-(cf=p->Freq-1);

	movzx	ecx, BYTE PTR [rax+1]
	movzx	r8d, WORD PTR [rbx+2]
	movzx	eax, r9b
	dec	ecx
	sub	r8d, eax

; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));

	lea	eax, DWORD PTR [rcx+rcx]
	sub	r8d, ecx
	cmp	eax, r8d
	ja	SHORT $LN29@CreateSucc
	lea	eax, DWORD PTR [rcx+rcx*4]
	xor	ecx, ecx
	cmp	eax, r8d
	seta	cl
	inc	cl
	mov	BYTE PTR ct$[rsp+3], cl

; 475  :     } else

	jmp	SHORT $LN70@CreateSucc
$LN29@CreateSucc:

; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));

	lea	eax, DWORD PTR [rcx-3]
	xor	edx, edx
	lea	eax, DWORD PTR [rax+r8*2]
	div	r8d
	mov	ecx, eax
	inc	cl
	mov	BYTE PTR ct$[rsp+3], cl

; 475  :     } else

	jmp	SHORT $LN70@CreateSucc
$LN10@CreateSucc:

; 476  :             ct.oneState().Freq=pc->oneState().Freq;

	movzx	eax, BYTE PTR [rbx+3]
	mov	BYTE PTR ct$[rsp+3], al
$LN70@CreateSucc:
	mov	r14d, DWORD PTR ct$[rsp+4]
	mov	r15d, DWORD PTR ct$[rsp]
	mov	rbp, QWORD PTR LoUnit
	mov	rdi, QWORD PTR HiUnit
$LL4@CreateSucc:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	cmp	rdi, rbp
	je	SHORT $LN46@CreateSucc
	sub	rdi, 12
	mov	QWORD PTR HiUnit, rdi
	mov	rdx, rdi
	jmp	SHORT $LN43@CreateSucc
$LN46@CreateSucc:

; 15   :     BOOL   avail()      const { return (next != NULL); }

	mov	rdx, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rdx, rdx

; 133  :     else if ( BList->avail() )              return BList->remove();

	je	SHORT $LN44@CreateSucc

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rdx+4]

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();
; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rax

; 133  :     else if ( BList->avail() )              return BList->remove();

	jmp	SHORT $LN43@CreateSucc
$LN44@CreateSucc:

; 134  :     else                                    return AllocUnitsRare(0);

	xor	ecx, ecx
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
	mov	rdx, rax
$LN43@CreateSucc:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 479  :         if ( !pc1 )                         return NULL;

	test	rdx, rdx
	je	SHORT $LN59@CreateSucc

; 480  :         ((DWORD*) pc1)[0] = ((DWORD*) &ct)[0];
; 481  :         ((DWORD*) pc1)[1] = ((DWORD*) &ct)[1];
; 482  :         pc1->Suffix=pc;                     (*--pps)->Successor=pc=pc1;

	mov	rcx, QWORD PTR [rsi-8]
	sub	rsi, 8
	mov	QWORD PTR [rdx+12], rbx

; 483  :     } while (pps != ps);

	lea	rax, QWORD PTR ps$[rsp]
	mov	DWORD PTR [rdx], r15d
	mov	DWORD PTR [rdx+4], r14d
	mov	QWORD PTR [rcx+2], rdx
	mov	rbx, rdx
	cmp	rsi, rax
	jne	SHORT $LL4@CreateSucc

; 484  :     return pc;

	mov	rax, rdx
	jmp	SHORT $LN74@CreateSucc
$LN59@CreateSucc:

; 479  :         if ( !pc1 )                         return NULL;

	xor	eax, eax
$LN74@CreateSucc:
	mov	r14, QWORD PTR [rsp+240]
	mov	rdi, QWORD PTR [rsp+232]
	mov	rbp, QWORD PTR [rsp+224]
	mov	r15, QWORD PTR [rsp+192]

; 485  : }

	add	rsp, 200				; 000000c8H
	pop	rsi
	pop	rbx
	ret	0
?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z ENDP ; CreateSuccessors
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
FFreq$1$ = 96
MinContext$ = 96
Successor$1$ = 104
?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z PROC		; UpdateModel

; 489  : {

	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 490  :     PPM_CONTEXT::STATE* p           = NULL;
; 491  :     PPM_CONTEXT*        FSuccessor  = FoundState->Successor;

	mov	rdi, QWORD PTR FoundState

; 492  :     PPM_CONTEXT*        pc          = MinContext->Suffix;

	mov	r10, QWORD PTR [rcx+12]

; 493  :     PPM_CONTEXT*        pc1         = MaxContext;

	mov	rbx, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext

; 494  :     
; 495  :     UINT ns1, ns, cf, sf, s0, FFreq=FoundState->Freq;

	movzx	r11d, BYTE PTR [rdi+1]
	mov	r14, QWORD PTR [rdi+2]

; 496  :     BYTE Flag, sym, FSymbol=FoundState->Symbol;

	movzx	r15d, BYTE PTR [rdi]
	xor	r9d, r9d
	mov	rbp, rcx
	mov	DWORD PTR FFreq$1$[rsp], r11d

; 497  : 
; 498  : 
; 499  :     if( FFreq < MAX_FREQ/4  &&  pc ) 

	cmp	r11d, 31
	jae	SHORT $LN28@UpdateMode
	test	r10, r10
	je	SHORT $LN28@UpdateMode

; 500  :     {
; 501  :         if ( pc->NumStats ) 

	cmp	BYTE PTR [r10], r9b
	je	SHORT $LN34@UpdateMode

; 502  :         {
; 503  :             if ((p=pc->Stats)->Symbol != FSymbol) 

	mov	r9, QWORD PTR [r10+4]
	cmp	BYTE PTR [r9], r15b
	je	SHORT $LN29@UpdateMode
$LL32@UpdateMode:

; 504  :             {
; 505  :                 do { sym=p[1].Symbol;       p++; } while (sym != FSymbol);

	add	r9, 10
	cmp	BYTE PTR [r9], r15b
	jne	SHORT $LL32@UpdateMode

; 506  :                 if (p[0].Freq >= p[-1].Freq) 

	movzx	eax, BYTE PTR [r9-9]
	cmp	BYTE PTR [r9+1], al
	jb	SHORT $LN29@UpdateMode

; 80   : 
; 81   :     void                    read(_PPMD_FILE* fp,UINT PrevSym);
; 82   : };
; 83   : PPM_CONTEXT _PACK_ATTR* MaxContext;
; 84   : #pragma pack()
; 85   : 
; 86   : static BYTE NS2BSIndx[256], QTable[260];    // constants
; 87   : static PPM_CONTEXT::STATE* FoundState;      // found next state transition
; 88   : static int  InitEsc, OrderFall, RunLength, InitRL, MaxOrder;
; 89   : static BYTE CharMask[256], NumMasked, PrevSuccess, EscCount, PrintCount;
; 90   : static WORD BinSumm[25][64];                // binary SEE-contexts
; 91   : static MR_METHOD MRMethod;
; 92   : 
; 93   : static void _STDCALL StartModelRare(int MaxOrder,MR_METHOD MRMethod);
; 94   : 
; 95   : inline void SWAP(PPM_CONTEXT::STATE& s1,PPM_CONTEXT::STATE& s2)
; 96   : {
; 97   :     WORD t1=(WORD&) s1;                     PPM_CONTEXT* t2=s1.Successor;
; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	movzx	eax, WORD PTR [r9-10]
	movzx	edx, WORD PTR [r9]
	mov	rcx, QWORD PTR [r9+2]
	mov	WORD PTR [r9], ax
	mov	rax, QWORD PTR [r9-8]

; 507  :                 {
; 508  :                     SWAP(p[0],p[-1]);       
; 509  :                     p--;

	add	r9, -10

; 80   : 
; 81   :     void                    read(_PPMD_FILE* fp,UINT PrevSym);
; 82   : };
; 83   : PPM_CONTEXT _PACK_ATTR* MaxContext;
; 84   : #pragma pack()
; 85   : 
; 86   : static BYTE NS2BSIndx[256], QTable[260];    // constants
; 87   : static PPM_CONTEXT::STATE* FoundState;      // found next state transition
; 88   : static int  InitEsc, OrderFall, RunLength, InitRL, MaxOrder;
; 89   : static BYTE CharMask[256], NumMasked, PrevSuccess, EscCount, PrintCount;
; 90   : static WORD BinSumm[25][64];                // binary SEE-contexts
; 91   : static MR_METHOD MRMethod;
; 92   : 
; 93   : static void _STDCALL StartModelRare(int MaxOrder,MR_METHOD MRMethod);
; 94   : 
; 95   : inline void SWAP(PPM_CONTEXT::STATE& s1,PPM_CONTEXT::STATE& s2)
; 96   : {
; 97   :     WORD t1=(WORD&) s1;                     PPM_CONTEXT* t2=s1.Successor;
; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	mov	QWORD PTR [r9+12], rax

; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;

	mov	WORD PTR [r9], dx
	mov	QWORD PTR [r9+2], rcx
$LN29@UpdateMode:

; 510  :                 }
; 511  :             }
; 512  :             cf=2*(p->Freq < MAX_FREQ-9);

	movzx	eax, BYTE PTR [r9+1]
	xor	ecx, ecx
	cmp	al, 115					; 00000073H
	setb	cl
	add	ecx, ecx

; 513  :             p->Freq      += cf;                  

	add	al, cl
	mov	BYTE PTR [r9+1], al

; 514  :             pc->SummFreq += cf;

	add	WORD PTR [r10+2], cx

; 515  :         } 
; 516  :         else 

	jmp	SHORT $LN28@UpdateMode
$LN34@UpdateMode:

; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 

	movzx	eax, BYTE PTR [r10+3]

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	lea	r9, QWORD PTR [r10+2]

; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 

	cmp	al, 32					; 00000020H
	adc	al, 0
	mov	BYTE PTR [r9+1], al
$LN28@UpdateMode:

; 520  :         }
; 521  :     }
; 522  :     
; 523  :     if( !OrderFall && FSuccessor) 

	mov	esi, DWORD PTR OrderFall
	mov	QWORD PTR [rsp+112], r12
	mov	QWORD PTR [rsp+32], r13
	test	esi, esi
	jne	SHORT $LN27@UpdateMode
	test	r14, r14
	je	SHORT $LN27@UpdateMode

; 524  :     {
; 525  :         FoundState->Successor=CreateSuccessors(TRUE,p,MinContext);

	lea	ecx, QWORD PTR [rsi+1]
	mov	r8, rbp
	mov	rdx, r9
	call	?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z ; CreateSuccessors
	mov	QWORD PTR [rdi+2], rax

; 526  :         if ( !FoundState->Successor )       

	test	rax, rax
	je	$RESTART_MODEL$59

; 527  :             goto RESTART_MODEL;
; 528  :         MaxContext=FoundState->Successor;   

	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rax ; MaxContext

; 529  :         return;

	jmp	$LN36@UpdateMode
$LN27@UpdateMode:

; 530  :     }
; 531  : 
; 532  :     *pText++ = FSymbol;                     

	mov	rdi, QWORD PTR pText

; 533  : 
; 534  :     PPM_CONTEXT*    Successor = (PPM_CONTEXT*) pText;
; 535  :     
; 536  :     if (pText >= UnitsStart)                

	mov	rax, QWORD PTR UnitsStart
	inc	rdi
	mov	BYTE PTR [rdi-1], r15b
	mov	QWORD PTR pText, rdi
	mov	QWORD PTR Successor$1$[rsp], rdi
	cmp	rdi, rax
	jae	$RESTART_MODEL$59

; 537  :         goto RESTART_MODEL;
; 538  : 
; 539  : 
; 540  :     if( FSuccessor ) 

	test	r14, r14
	je	SHORT $LN22@UpdateMode

; 541  :     {
; 542  :         if ((BYTE*) FSuccessor < UnitsStart)

	cmp	r14, rax
	jae	SHORT $LN20@UpdateMode

; 543  :             FSuccessor=CreateSuccessors(FALSE,p,MinContext);

	mov	r8, rbp
	mov	rdx, r9
	xor	ecx, ecx
	call	?CreateSuccessors@@YAPEAUPPM_CONTEXT@@HPEAUSTATE@1@PEAU1@@Z ; CreateSuccessors

; 544  :     } 
; 545  :     else

	jmp	SHORT $LN55@UpdateMode
$LN22@UpdateMode:

; 546  :     {
; 547  :         FSuccessor=ReduceOrder(p,MinContext);

	mov	rdx, rbp
	mov	rcx, r9
	call	?ReduceOrder@@YAPEAUPPM_CONTEXT@@PEAUSTATE@1@PEAU1@@Z ; ReduceOrder
	mov	esi, DWORD PTR OrderFall
	mov	rdi, QWORD PTR pText
$LN55@UpdateMode:
	mov	r11d, DWORD PTR FFreq$1$[rsp]
	mov	r14, rax
$LN20@UpdateMode:

; 548  :     }
; 549  :     
; 550  :     if( !FSuccessor )                          

	test	r14, r14
	je	$RESTART_MODEL$59

; 551  :         goto RESTART_MODEL;
; 552  : 
; 553  : 
; 554  :     if( !--OrderFall ) 

	dec	esi
	mov	DWORD PTR OrderFall, esi
	jne	SHORT $LN17@UpdateMode

; 555  :     {
; 556  :         Successor=FSuccessor;               
; 557  :         pText -= (MaxContext != MinContext);

	xor	eax, eax
	cmp	rbx, rbp
	setne	al
	sub	rdi, rax
	mov	QWORD PTR pText, rdi
	jmp	SHORT $LN56@UpdateMode
$LN17@UpdateMode:

; 558  :     } 
; 559  :     else if( MRMethod > MRM_FREEZE) 

	cmp	DWORD PTR MRMethod, 2
	jle	SHORT $LN15@UpdateMode

; 562  :         pText=HeapStart;

	mov	rax, QWORD PTR HeapStart

; 563  :         OrderFall=0;

	mov	DWORD PTR OrderFall, 0
	mov	QWORD PTR pText, rax
$LN56@UpdateMode:

; 560  :     {
; 561  :         Successor=FSuccessor;               

	mov	QWORD PTR Successor$1$[rsp], r14
$LN15@UpdateMode:

; 564  :     }
; 565  :     
; 566  :     s0=MinContext->SummFreq-(ns=MinContext->NumStats)-FFreq;

	movzx	esi, BYTE PTR [rbp]
	movzx	r12d, WORD PTR [rbp+2]
	sub	r12d, esi
	sub	r12d, r11d

; 567  :     for (Flag=0x08*(FSymbol >= 0x40);pc1 != MinContext;pc1=pc1->Suffix) 

	cmp	r15b, 64				; 00000040H
	setae	r13b
	shl	r13b, 3
	cmp	rbx, rbp
	je	$LN12@UpdateMode
	npad	7
$LL14@UpdateMode:

; 568  :     {
; 569  :         if ((ns1=pc1->NumStats) != 0) 

	movzx	edi, BYTE PTR [rbx]
	test	edi, edi
	je	SHORT $LN11@UpdateMode

; 570  :         {
; 571  :             if ((ns1 & 1) != 0) 

	test	dil, 1
	je	SHORT $LN10@UpdateMode

; 572  :             {
; 573  :                 p=(PPM_CONTEXT::STATE*) ExpandUnits(pc1->Stats,(ns1+1) >> 1);

	mov	rcx, QWORD PTR [rbx+4]
	lea	edx, DWORD PTR [rdi+1]
	shr	edx, 1
	call	?ExpandUnits@@YAPEAXPEAXI@Z		; ExpandUnits

; 574  :                 if ( !p )                   

	test	rax, rax
	je	$RESTART_MODEL$59

; 575  :                     goto RESTART_MODEL;
; 576  :                 pc1->Stats=p;

	mov	r11d, DWORD PTR FFreq$1$[rsp]
	mov	QWORD PTR [rbx+4], rax
$LN10@UpdateMode:

; 577  :             }
; 578  :             pc1->SummFreq += (3*ns1+1 < ns);

	lea	eax, DWORD PTR [rdi*2+1]
	add	eax, edi
	cmp	eax, esi
	adc	WORD PTR [rbx+2], 0

; 579  :         } 
; 580  :         else 

	jmp	SHORT $LN7@UpdateMode
$LN11@UpdateMode:

; 581  :         {
; 582  :             p=(PPM_CONTEXT::STATE*) AllocUnits(1);

	mov	ecx, 1
	call	?AllocUnits@@YAPEAXI@Z			; AllocUnits

; 583  :             if ( !p )                       

	test	rax, rax
	je	$RESTART_MODEL$59

; 100  : }
; 101  : inline void StateCpy(PPM_CONTEXT::STATE& s1,const PPM_CONTEXT::STATE& s2)
; 102  : {
; 103  :     (WORD&) s1=(WORD&) s2;                  

	movzx	ecx, WORD PTR [rbx+2]
	mov	WORD PTR [rax], cx

; 104  :     s1.Successor=s2.Successor;

	mov	rcx, QWORD PTR [rbx+4]
	mov	QWORD PTR [rax+2], rcx

; 584  :                 goto RESTART_MODEL;
; 585  :                 
; 586  :             StateCpy(*p,pc1->oneState());   
; 587  :             pc1->Stats=p;

	mov	QWORD PTR [rbx+4], rax

; 588  :             
; 589  :             if (p->Freq < MAX_FREQ/4-1)     p->Freq += p->Freq;

	movzx	ecx, BYTE PTR [rax+1]
	cmp	cl, 30
	jae	SHORT $LN4@UpdateMode
	add	cl, cl
	mov	BYTE PTR [rax+1], cl
	jmp	SHORT $LN3@UpdateMode
$LN4@UpdateMode:

; 590  :             else                            p->Freq  = MAX_FREQ-4;

	mov	BYTE PTR [rax+1], 120			; 00000078H
$LN3@UpdateMode:

; 591  :             
; 592  :             pc1->SummFreq=p->Freq+InitEsc+(ns > 2);

	movzx	eax, BYTE PTR [rax+1]
	mov	r11d, DWORD PTR FFreq$1$[rsp]
	xor	ecx, ecx
	cmp	esi, 2
	seta	cl
	add	cx, ax
	add	cx, WORD PTR InitEsc
	mov	WORD PTR [rbx+2], cx
$LN7@UpdateMode:

; 593  :         }
; 594  : 
; 595  :         cf=2*FFreq*(pc1->SummFreq+6);       

	movzx	r9d, WORD PTR [rbx+2]

; 596  :         sf=s0+pc1->SummFreq;

	lea	r10d, DWORD PTR [r9+r12]
	lea	r8d, DWORD PTR [r9+6]

; 597  : 
; 598  :         if (cf < 6*sf) 

	lea	eax, DWORD PTR [r10+r10*2]
	add	eax, eax
	imul	r8d, r11d
	add	r8d, r8d
	cmp	r8d, eax
	jae	SHORT $LN2@UpdateMode

; 599  :         {
; 600  :             cf=1+(cf > sf)+(cf >= 4*sf);

	xor	ecx, ecx
	lea	eax, DWORD PTR [r10*4]
	cmp	r8d, eax
	setae	cl
	xor	eax, eax
	cmp	r8d, r10d
	seta	al
	lea	edx, DWORD PTR [rax+1]
	add	edx, ecx

; 601  :             pc1->SummFreq += 4;

	add	r9w, 4

; 602  :         } 
; 603  :         else 

	jmp	SHORT $LN57@UpdateMode
$LN2@UpdateMode:

; 604  :         {
; 605  :             cf=4+(cf > 9*sf)+(cf > 12*sf)+(cf > 15*sf);

	xor	edx, edx
	imul	eax, r10d, 15
	cmp	r8d, eax
	lea	eax, DWORD PTR [r10+r10*2]
	seta	dl
	xor	ecx, ecx
	shl	eax, 2
	cmp	r8d, eax
	lea	eax, DWORD PTR [r10+r10*8]
	seta	cl
	add	edx, ecx
	xor	ecx, ecx
	cmp	r8d, eax
	seta	cl
	add	edx, 4
	add	edx, ecx

; 606  :             pc1->SummFreq += cf;

	add	r9w, dx
$LN57@UpdateMode:

; 607  :         }
; 608  :         p=pc1->Stats+(++pc1->NumStats);     

	inc	BYTE PTR [rbx]
	movzx	eax, BYTE PTR [rbx]

; 609  :         p->Successor=Successor;

	mov	r8, QWORD PTR Successor$1$[rsp]
	lea	rcx, QWORD PTR [rax+rax*4]
	mov	rax, QWORD PTR [rbx+4]
	mov	WORD PTR [rbx+2], r9w
	mov	QWORD PTR [rax+rcx*2+2], r8

; 610  :         p->Symbol = FSymbol;                

	mov	BYTE PTR [rax+rcx*2], r15b

; 611  :         p->Freq = cf;

	mov	BYTE PTR [rax+rcx*2+1], dl

; 612  :         pc1->Flags |= Flag;

	or	BYTE PTR [rbx+1], r13b
	mov	rbx, QWORD PTR [rbx+12]
	cmp	rbx, rbp
	jne	$LL14@UpdateMode
$LN12@UpdateMode:

; 613  :     }
; 614  : 
; 615  :     MaxContext=FSuccessor;

	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, r14 ; MaxContext
	jmp	SHORT $LN36@UpdateMode
$RESTART_MODEL$59:

; 616  :     return;
; 617  : 
; 618  : RESTART_MODEL:
; 619  :     RestoreModelRare(pc1,MinContext,FSuccessor);

	mov	r8, r14
	mov	rdx, rbp
	mov	rcx, rbx
	call	?RestoreModelRare@@YAXPEAUPPM_CONTEXT@@00@Z ; RestoreModelRare
$LN36@UpdateMode:
	mov	r13, QWORD PTR [rsp+32]
	mov	r12, QWORD PTR [rsp+112]

; 620  : 
; 621  : }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?UpdateModel@@YAXPEAUPPM_CONTEXT@@@Z ENDP		; UpdateModel
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
symbol$ = 16
?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z PROC		; PPM_CONTEXT::encodeBinSymbol, COMDAT

; 626  : {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	mov	rax, QWORD PTR [rcx+12]

; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];

	movzx	r10d, BYTE PTR [rcx+3]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 145  : static inline UINT rcBinStart(UINT f0,UINT Shift)  { return f0*(range >>= Shift); }

	mov	ebx, DWORD PTR range
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	movzx	r8d, BYTE PTR [rax]

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	lea	r11, QWORD PTR [rcx+2]

; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	lea	rsi, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR NS2BSIndx[r8+rsi]

; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];

	mov	r8d, DWORD PTR RunLength
	mov	r9d, edx
	add	al, BYTE PTR [rcx+1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 145  : static inline UINT rcBinStart(UINT f0,UINT Shift)  { return f0*(range >>= Shift); }

	shr	ebx, 14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	add	al, BYTE PTR PrevSuccess

; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];

	movzx	ecx, al
	mov	eax, r8d
	sar	eax, 26
	and	eax, 32					; 00000020H
	add	ecx, eax
	movzx	eax, BYTE PTR QTable[r10+rsi-1]
	shl	rax, 6
	movsxd	rdx, ecx
	add	rdx, rax

; 631  :     if (rs.Symbol == symbol) {

	movzx	eax, BYTE PTR [r11]
	movzx	ecx, WORD PTR BinSumm[rsi+rdx*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 145  : static inline UINT rcBinStart(UINT f0,UINT Shift)  { return f0*(range >>= Shift); }

	mov	edi, ecx
	imul	edi, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 631  :     if (rs.Symbol == symbol) {

	cmp	eax, r9d
	jne	SHORT $LN2@encodeBinS

; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);

	cmp	r10b, 196				; 000000c4H
	mov	QWORD PTR FoundState, r11
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 147  : static inline void rcBinCorrect0(UINT tmp)         { range=tmp; }

	mov	DWORD PTR range, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);

	adc	r10b, 0

; 633  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 634  :         PrevSuccess=1;                      RunLength++;

	mov	BYTE PTR PrevSuccess, 1
	mov	BYTE PTR [r11+1], r10b
	movzx	ecx, WORD PTR BinSumm[rsi+rdx*2]
	lea	eax, DWORD PTR [rcx+32]
	sar	eax, 7
	sub	cx, ax
	mov	eax, 128				; 00000080H
	add	cx, ax
	inc	r8d
	mov	DWORD PTR RunLength, r8d
	mov	WORD PTR BinSumm[rsi+rdx*2], cx

; 640  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
$LN2@encodeBinS:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	add	DWORD PTR low, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 640  : }

	mov	rdi, QWORD PTR [rsp+24]
	mov	eax, 16384				; 00004000H
	sub	eax, ecx
	mov	BYTE PTR PrevSuccess, 0
	mov	BYTE PTR NumMasked, 0
	mov	QWORD PTR FoundState, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	imul	ebx, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 636  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);

	lea	eax, DWORD PTR [rcx+32]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	mov	DWORD PTR range, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 640  : }

	mov	rbx, QWORD PTR [rsp+8]
	sar	eax, 7
	sub	cx, ax
	movzx	eax, cx
	mov	WORD PTR BinSumm[rsi+rdx*2], ax
	movzx	ecx, BYTE PTR [r11]
	shr	rax, 10
	movzx	eax, BYTE PTR ExpEscape[rax+rsi]
	mov	DWORD PTR InitEsc, eax
	movzx	eax, BYTE PTR EscCount
	mov	BYTE PTR CharMask[rcx+rsi], al
	mov	rsi, QWORD PTR [rsp+16]
	ret	0
?encodeBinSymbol@PPM_CONTEXT@@QEAAXH@Z ENDP		; PPM_CONTEXT::encodeBinSymbol
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ
_TEXT	SEGMENT
this$ = 8
?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ PROC		; PPM_CONTEXT::decodeBinSymbol, COMDAT

; 642  : {

$LN16:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi

; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	mov	rax, QWORD PTR [rcx+12]

; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];

	mov	r9d, DWORD PTR RunLength
	movzx	r8d, BYTE PTR [rcx+3]
	movzx	edx, BYTE PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 145  : static inline UINT rcBinStart(UINT f0,UINT Shift)  { return f0*(range >>= Shift); }

	mov	r11d, DWORD PTR range

; 146  : static inline UINT rcBinDecode  (UINT tmp)         { return (code-low >= tmp); }

	mov	ebx, DWORD PTR low
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }

	lea	r10, QWORD PTR [rcx+2]

; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	lea	rsi, OFFSET FLAT:__ImageBase
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 145  : static inline UINT rcBinStart(UINT f0,UINT Shift)  { return f0*(range >>= Shift); }

	shr	r11d, 14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;

	movzx	eax, BYTE PTR NS2BSIndx[rdx+rsi]
	add	al, BYTE PTR [rcx+1]
	add	al, BYTE PTR PrevSuccess

; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];

	movzx	ecx, al
	mov	eax, r9d
	sar	eax, 26
	and	eax, 32					; 00000020H
	add	ecx, eax
	movzx	eax, BYTE PTR QTable[r8+rsi-1]
	shl	rax, 6
	movsxd	rdx, ecx
	add	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 146  : static inline UINT rcBinDecode  (UINT tmp)         { return (code-low >= tmp); }

	mov	eax, DWORD PTR code
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 647  :     UINT tmp=rcBinStart(bs,TOT_BITS);

	movzx	ecx, WORD PTR BinSumm[rsi+rdx*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 146  : static inline UINT rcBinDecode  (UINT tmp)         { return (code-low >= tmp); }

	sub	eax, ebx

; 145  : static inline UINT rcBinStart(UINT f0,UINT Shift)  { return f0*(range >>= Shift); }

	mov	edi, ecx
	imul	edi, r11d

; 146  : static inline UINT rcBinDecode  (UINT tmp)         { return (code-low >= tmp); }

	cmp	eax, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 648  :     if ( !rcBinDecode(tmp) ) {

	jae	SHORT $LN2@decodeBinS

; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);

	cmp	r8b, 196				; 000000c4H
	mov	QWORD PTR FoundState, r10
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 147  : static inline void rcBinCorrect0(UINT tmp)         { range=tmp; }

	mov	DWORD PTR range, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);

	adc	r8b, 0

; 650  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 651  :         PrevSuccess=1;                      RunLength++;

	mov	BYTE PTR PrevSuccess, 1
	mov	BYTE PTR [r10+1], r8b
	movzx	ecx, WORD PTR BinSumm[rsi+rdx*2]
	lea	eax, DWORD PTR [rcx+32]
	sar	eax, 7
	sub	cx, ax
	mov	eax, 128				; 00000080H
	add	cx, ax
	inc	r9d
	mov	DWORD PTR RunLength, r9d
	mov	WORD PTR BinSumm[rsi+rdx*2], cx

; 657  : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rsi, QWORD PTR [rsp+16]
	mov	rdi, QWORD PTR [rsp+24]
	ret	0
$LN2@decodeBinS:

; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);

	mov	eax, 16384				; 00004000H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	add	ebx, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 657  : }

	mov	rdi, QWORD PTR [rsp+24]
	sub	eax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	mov	DWORD PTR low, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 657  : }

	mov	rbx, QWORD PTR [rsp+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	imul	r11d, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);

	lea	eax, DWORD PTR [rcx+32]

; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;

	mov	BYTE PTR PrevSuccess, 0
	sar	eax, 7
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 148  : static inline void rcBinCorrect1(UINT tmp,UINT f1) { low += tmp;   range *= f1; }

	mov	DWORD PTR range, r11d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;

	mov	BYTE PTR NumMasked, 0
	sub	cx, ax
	mov	QWORD PTR FoundState, 0
	movzx	eax, cx
	mov	WORD PTR BinSumm[rsi+rdx*2], ax
	movzx	ecx, BYTE PTR [r10]
	shr	rax, 10
	movzx	eax, BYTE PTR ExpEscape[rax+rsi]
	mov	DWORD PTR InitEsc, eax
	movzx	eax, BYTE PTR EscCount
	mov	BYTE PTR CharMask[rcx+rsi], al

; 657  : }

	mov	rsi, QWORD PTR [rsp+16]
	ret	0
?decodeBinSymbol@PPM_CONTEXT@@QEBAXXZ ENDP		; PPM_CONTEXT::decodeBinSymbol
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z
_TEXT	SEGMENT
this$ = 8
p$ = 16
?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z PROC		; PPM_CONTEXT::update1, COMDAT

; 660  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	add	BYTE PTR [rdx+1], 4
	add	WORD PTR [rcx+2], 4

; 661  :     if (p[0].Freq > p[-1].Freq) {

	movzx	eax, BYTE PTR [rdx-9]
	mov	r10, rcx
	mov	QWORD PTR FoundState, rdx
	cmp	BYTE PTR [rdx+1], al
	jbe	SHORT $LN1@update1

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	movzx	eax, WORD PTR [rdx-10]
	movzx	r8d, WORD PTR [rdx]
	mov	rcx, QWORD PTR [rdx+2]

; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;

	lea	r9, QWORD PTR [rdx-10]

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	mov	WORD PTR [rdx], ax
	mov	rax, QWORD PTR [r9+2]

; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;

	mov	QWORD PTR FoundState, r9

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	mov	QWORD PTR [rdx+2], rax

; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;

	mov	WORD PTR [r9], r8w
	mov	QWORD PTR [r9+2], rcx

; 663  :         if (p->Freq > MAX_FREQ)             rescale();

	cmp	BYTE PTR [r9+1], 124			; 0000007cH
	jbe	SHORT $LN1@update1
	mov	rcx, r10
	jmp	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN1@update1:

; 664  :     }
; 665  : }

	ret	0
?update1@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z ENDP		; PPM_CONTEXT::update1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
symbol$ = 56
?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z PROC		; PPM_CONTEXT::encodeSymbol1, COMDAT

; 667  : {

$LN29:
	sub	rsp, 40					; 00000028H

; 668  :     UINT LoCnt, i=Stats->Symbol;
; 669  :     STATE* p=Stats;                         SubRange.scale=SummFreq;

	mov	rax, QWORD PTR [rcx+4]
	movzx	r11d, WORD PTR [rcx+2]
	mov	r9d, edx
	movzx	r8d, BYTE PTR [rax]
	mov	r10, rcx
	mov	DWORD PTR SubRange+8, r11d

; 670  :     if (i == symbol) {

	cmp	r8d, edx
	jne	SHORT $LN9@encodeSymb

; 671  :         PrevSuccess=(2*(SubRange.high=p->Freq) >= SubRange.scale);

	movzx	edx, BYTE PTR [rax+1]

; 672  :         (FoundState=p)->Freq += 4;          SummFreq += 4;

	mov	QWORD PTR FoundState, rax
	lea	ecx, DWORD PTR [rdx+rdx]
	mov	DWORD PTR SubRange+4, edx
	cmp	ecx, r11d
	setae	cl
	add	dl, 4
	mov	BYTE PTR [rax+1], dl
	add	WORD PTR [r10+2], 4
	mov	BYTE PTR PrevSuccess, cl

; 673  :         RunLength += PrevSuccess;

	movzx	ecx, cl
	add	DWORD PTR RunLength, ecx

; 674  :         if (p->Freq > MAX_FREQ)             rescale();

	cmp	BYTE PTR [rax+1], 124			; 0000007cH
	jbe	SHORT $LN8@encodeSymb
	mov	rcx, r10
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN8@encodeSymb:

; 675  :         SubRange.low=0;                        return;

	mov	DWORD PTR SubRange, 0

; 690  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN9@encodeSymb:

; 676  :     }
; 677  :     LoCnt=p->Freq;

	movzx	r8d, BYTE PTR [rax+1]

; 678  :     i=NumStats;                             PrevSuccess=0;

	movzx	edx, BYTE PTR [rcx]

; 679  :     while ((++p)->Symbol != symbol) {

	movzx	ecx, BYTE PTR [rax+10]
	add	rax, 10
	mov	BYTE PTR PrevSuccess, 0
	cmp	ecx, r9d
	je	SHORT $LN6@encodeSymb
$LL7@encodeSymb:

; 680  :         LoCnt += p->Freq;

	movzx	ecx, BYTE PTR [rax+1]
	add	r8d, ecx

; 681  :         if (--i == 0) {

	dec	edx
	je	$LN22@encodeSymb

; 679  :     while ((++p)->Symbol != symbol) {

	movzx	ecx, BYTE PTR [rax+10]
	add	rax, 10
	cmp	ecx, r9d
	jne	SHORT $LL7@encodeSymb
$LN6@encodeSymb:

; 687  :         }
; 688  :     }
; 689  :     SubRange.high=(SubRange.low=LoCnt)+p->Freq;   update1(p);

	movzx	edx, BYTE PTR [rax+1]
	mov	DWORD PTR SubRange, r8d

; 100  : }
; 101  : inline void StateCpy(PPM_CONTEXT::STATE& s1,const PPM_CONTEXT::STATE& s2)
; 102  : {
; 103  :     (WORD&) s1=(WORD&) s2;                  
; 104  :     s1.Successor=s2.Successor;
; 105  : }
; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;
; 107  : inline PPMD_STARTUP::PPMD_STARTUP()         // constants initialization
; 108  : {
; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;
; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;
; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;
; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;
; 114  :     for (k=i=0;k < 128;k++) {
; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;
; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);
; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;
; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {
; 121  :         QTable[i]=m;
; 122  :         if ( !--k ) { k = ++Step;           m++; }
; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;
; 125  : }
; 126  : 
; 127  : 
; 128  : void PPM_CONTEXT::makeSuffix()
; 129  : {
; 130  :     STATE* p, * p1;
; 131  :     if ( !NumStats ) 
; 132  :     {
; 133  :         if ( !(p=&oneState())->Successor )  return;
; 134  : 
; 135  :         if ( !Suffix->NumStats )            
; 136  :         {
; 137  :             p1=&(Suffix->oneState());
; 138  :         }
; 139  :         else
; 140  :         {
; 141  :             for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 142  :                 ;
; 143  :         }
; 144  :         
; 145  :         p->Successor->Suffix = p1->Successor; 
; 146  :         p->Successor->makeSuffix();
; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 
; 151  :         {
; 152  :             if ( !p->Successor )            
; 153  :                 continue;
; 154  : 
; 155  :             if ( !Suffix )                  
; 156  :             {
; 157  :                 p->Successor->Suffix=this;
; 158  :             }
; 159  :             else 
; 160  :             {
; 161  :                 for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 162  :                     ;
; 163  :                 p->Successor->Suffix=p1->Successor;
; 164  :             }
; 165  :             p->Successor->makeSuffix();
; 166  :         }
; 167  :     }
; 168  : }
; 169  : 
; 170  : void PPM_CONTEXT::read(_PPMD_FILE* fp,UINT PrevSym)
; 171  : {
; 172  :     STATE* p;                               Suffix=NULL;
; 173  :     NumStats=_PPMD_E_GETC(fp);                     Flags=0x10*(PrevSym >= 0x40);
; 174  :     if ( !NumStats ) {
; 175  :         p=&oneState();                      p->Freq=_PPMD_E_GETC(fp);
; 176  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 177  :         if ((p->Freq & 0x80) != 0) {
; 178  :             p->Freq &= ~0x80;
; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 180  :             p->Successor->read(fp,p->Symbol);
; 181  :         } else                              p->Successor=NULL;
; 182  :         return;
; 183  :     }
; 184  :     Stats = (PPM_CONTEXT::STATE*) AllocUnits((NumStats+2) >> 1);
; 185  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 186  :         p->Freq=_PPMD_E_GETC(fp);
; 187  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 188  :     }
; 189  :     int EscFreq=SummFreq=(Stats->Freq & ~0x80);
; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);
; 191  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 192  :         if ((p->Freq & 0x80) != 0) {
; 193  :             p->Freq &= ~0x80;
; 194  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 195  :             p->Successor->read(fp,p->Symbol);
; 196  :         } else                              p->Successor=NULL;
; 197  :         p->Freq=(p == Stats)?(64):(p[-1].Freq-p[0].Freq);
; 198  :         SummFreq += p->Freq;
; 199  :     }
; 200  :     if (EscFreq > 32) {
; 201  :         SummFreq=(EscFreq >> 1);
; 202  :         for (p=Stats;p <= Stats+NumStats;p++)
; 203  :                 SummFreq += (p->Freq -= (3*p->Freq) >> 2);
; 204  :     }
; 205  : }
; 206  : /*
; 207  : void
; 208  : PPM_CONTEXT::write( int o, FILE* fp )
; 209  : {
; 210  :     int EscFreq = EscCount; //(Stats)  ? Stats->Freq & ~0x80  : 0;
; 211  :     int nc      = 0;
; 212  : 
; 213  :     STATE* p;
; 214  :     int f, a, b, c;
; 215  :     if (nc < o)                             
; 216  :         nc=o;
; 217  :         
; 218  :     putc(NumStats,fp);
; 219  :     if ( !NumStats ) {
; 220  :         f=(p=&oneState())->Freq;
; 221  :         if ( EscFreq )                      f=(2*f)/EscFreq;
; 222  :         f=CLAMP(f,1,127) | 0x80*(p->Successor != NULL);
; 223  :         putc(f,fp);                         putc(p->Symbol,fp);
; 224  :         if ( p->Successor )                 p->Successor->write(o+1,fp);
; 225  :         return;
; 226  :     }
; 227  :     for (p=Stats+1;p <= Stats+NumStats;p++) {
; 228  :         if (p[0].Freq > p[-1].Freq) {
; 229  :             STATE* p1=p;
; 230  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq > p1[-1].Freq);
; 231  :         }
; 232  :         if (p[0].Freq == p[-1].Freq && p[0].Successor && !p[-1].Successor) {
; 233  :             STATE* p1=p;
; 234  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq == p1[-1].Freq && !p1[-1].Successor);
; 235  :         }
; 236  :     }
; 237  :     a=Stats->Freq+!Stats->Freq;             f=(64*EscFreq+(b=a >> 1))/a;
; 238  :     f=CLAMP(f,1,127) | 0x80*(Stats->Successor != NULL);
; 239  :     putc(f,fp);                             c=64;
; 240  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 241  :         f=(64*p->Freq+b)/a;                 f += !f;
; 242  :         if (p != Stats)
; 243  :             putc((c-f) | 0x80*(p->Successor != NULL),fp);
; 244  :         c=f;                                putc(p->Symbol,fp);
; 245  :     }
; 246  :     for (p=Stats;p <= Stats+NumStats;p++)
; 247  :             if ( p->Successor )             p->Successor->write(o+1,fp);
; 248  : }
; 249  : */
; 250  : void PPM_CONTEXT::refresh(int OldNU,BOOL Scale)
; 251  : {
; 252  :     int i=NumStats, EscFreq;
; 253  :     STATE* p = Stats = (STATE*) ShrinkUnits(Stats,OldNU,(i+2) >> 1);
; 254  :     Flags=(Flags & (0x10+0x04*Scale))+0x08*(p->Symbol >= 0x40);
; 255  :     EscFreq=SummFreq-p->Freq;
; 256  :     SummFreq = (p->Freq=(p->Freq+Scale) >> Scale);
; 257  :     do {
; 258  :         EscFreq -= (++p)->Freq;
; 259  :         SummFreq += (p->Freq=(p->Freq+Scale) >> Scale);
; 260  :         Flags |= 0x08*(p->Symbol >= 0x40);
; 261  :     } while ( --i );
; 262  :     SummFreq += (EscFreq=(EscFreq+Scale) >> Scale);
; 263  : }
; 264  : #define P_CALL(F) ( PrefetchData(p->Successor), \
; 265  :                     p->Successor=p->Successor->F(Order+1))
; 266  : PPM_CONTEXT* PPM_CONTEXT::cutOff(int Order)
; 267  : {
; 268  :     int i, tmp;
; 269  :     STATE* p;
; 270  :     if ( !NumStats ) {
; 271  :         if ((BYTE*) (p=&oneState())->Successor >= UnitsStart) {
; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);
; 273  :             else                            p->Successor=NULL;
; 274  :             if (!p->Successor && Order > O_BOUND)
; 275  :                     goto REMOVE;
; 276  :             return this;
; 277  :         } else {
; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;
; 279  :         }
; 280  :     }
; 281  :     PrefetchData(Stats);
; 282  :     Stats = (STATE*) MoveUnitsUp(Stats,tmp=(NumStats+2) >> 1);
; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)
; 284  :             if ((BYTE*) p->Successor < UnitsStart) {
; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);
; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);
; 287  :             else                            p->Successor=NULL;
; 288  :     if (i != NumStats && Order) {
; 289  :         NumStats=i;                         p=Stats;
; 290  :         if (i < 0) { FreeUnits(p,tmp);      goto REMOVE; }
; 291  :         else if (i == 0) {
; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);
; 293  :             StateCpy(oneState(),*p);        FreeUnits(p,tmp);
; 294  :             oneState().Freq=(oneState().Freq+11) >> 3;
; 295  :         } else                              refresh(tmp,SummFreq > 16*i);
; 296  :     }
; 297  :     return this;
; 298  : }
; 299  : PPM_CONTEXT* PPM_CONTEXT::removeBinConts(int Order)
; 300  : {
; 301  :     STATE* p;
; 302  :     if ( !NumStats ) {
; 303  :         p=&oneState();
; 304  :         if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 305  :                 P_CALL(removeBinConts);
; 306  :         else                                p->Successor=NULL;
; 307  :         if (!p->Successor && (!Suffix->NumStats || Suffix->Flags == 0xFF)) {
; 308  :             FreeUnits(this,1);              return NULL;
; 309  :         } else                              return this;
; 310  :     }
; 311  :     PrefetchData(Stats);
; 312  :     for (p=Stats+NumStats;p >= Stats;p--)
; 313  :             if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 314  :                     P_CALL(removeBinConts);
; 315  :             else                            p->Successor=NULL;
; 316  :     return this;
; 317  : }
; 318  : 
; 319  : static void RestoreModelRare(PPM_CONTEXT* pc1,PPM_CONTEXT* MinContext,
; 320  :         PPM_CONTEXT* FSuccessor)
; 321  : {
; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)
; 325  :             if (--(pc->NumStats) == 0) {
; 326  :                 pc->Flags=(pc->Flags & 0x10)+0x08*(pc->Stats->Symbol >= 0x40);
; 327  :                 p=pc->Stats;                StateCpy(pc->oneState(),*p);
; 328  :                 SpecialFreeUnit(p);
; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;
; 330  :             } else
; 331  :                     pc->refresh((pc->NumStats+3) >> 1,FALSE);
; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)
; 333  :             if ( !pc->NumStats )
; 334  :                     pc->oneState().Freq -= pc->oneState().Freq >> 1;
; 335  :             else if ((pc->SummFreq += 4) > 128+4*pc->NumStats)
; 336  :                     pc->refresh((pc->NumStats+2) >> 1,TRUE);
; 337  :     if (MRMethod > MRM_FREEZE) {
; 338  :         MaxContext=FSuccessor;              GlueCount += !(BList[1].Stamp & 1);
; 339  :     } else if (MRMethod == MRM_FREEZE) {
; 340  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 341  :         MaxContext->removeBinConts(0);      MRMethod=MR_METHOD(MRMethod+1);
; 342  :         GlueCount=0;                        OrderFall=MaxOrder;
; 343  : 	} else if (MRMethod == MRM_RESTART || GetUsedMemory() < (SubAllocatorSize >> 1)) {
; 344  :         StartModelRare(MaxOrder,MRMethod);
; 345  :         EscCount=0;                         PrintCount=0xFF;
; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 348  :         do {
; 349  :             MaxContext->cutOff(0);          ExpandTextArea();
; 350  : 		} while (GetUsedMemory() > 3*(SubAllocatorSize >> 2));
; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }
; 354  : 
; 355  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 356  :         PPM_CONTEXT* pc);
; 357  : static PPM_CONTEXT* _FASTCALL ReduceOrder(PPM_CONTEXT::STATE* p,PPM_CONTEXT* pc)
; 358  : {
; 359  :     PPM_CONTEXT::STATE* p1,  * ps[MAX_O], ** pps=ps;
; 360  :     PPM_CONTEXT* pc1=pc, * UpBranch = (PPM_CONTEXT*) pText;
; 361  :     BYTE tmp, sym=FoundState->Symbol;
; 362  :     *pps++ = FoundState;                    FoundState->Successor=UpBranch;
; 363  :     OrderFall++;
; 364  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 365  :     for ( ; ; ) {
; 366  :         if ( !pc->Suffix ) {
; 367  :             if (MRMethod > MRM_FREEZE) {
; 368  : FROZEN:         do { (*--pps)->Successor = pc; } while (pps != ps);
; 369  :                 pText=HeapStart+1;          OrderFall=1;
; 370  :             }
; 371  :             return pc;
; 372  :         }
; 373  :         pc=pc->Suffix;
; 374  :         if ( pc->NumStats ) {
; 375  :             if ((p=pc->Stats)->Symbol != sym)
; 376  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 377  :             tmp=2*(p->Freq < MAX_FREQ-9);
; 378  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }
; 380  : LOOP_ENTRY:
; 381  :         if ( p->Successor )                 break;
; 382  :         *pps++ = p;                         p->Successor=UpBranch;
; 383  :         OrderFall++;
; 384  :     }
; 385  :     if (MRMethod > MRM_FREEZE) {
; 386  :         pc = p->Successor;                  goto FROZEN;
; 387  :     } else if (p->Successor <= UpBranch) {
; 388  :         p1=FoundState;                      FoundState=p;
; 389  :         p->Successor=CreateSuccessors(FALSE,NULL,pc);
; 390  :         FoundState=p1;
; 391  :     }
; 392  :     if (OrderFall == 1 && pc1 == MaxContext) {
; 393  :         FoundState->Successor=p->Successor; pText--;
; 394  :     }
; 395  :     return p->Successor;
; 396  : }
; 397  : void PPM_CONTEXT::rescale()
; 398  : {
; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);
; 402  :     p->Freq += 4;                           SummFreq += 4;
; 403  :     EscFreq=SummFreq-p->Freq;
; 404  :     Adder=(OrderFall != 0 || MRMethod > MRM_FREEZE);
; 405  :     SummFreq = (p->Freq=(p->Freq+Adder) >> 1);
; 406  :     do {
; 407  :         EscFreq -= (++p)->Freq;
; 408  :         SummFreq += (p->Freq=(p->Freq+Adder) >> 1);
; 409  :         if (p[0].Freq > p[-1].Freq) {
; 410  :             StateCpy(tmp,*(p1=p));
; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);
; 412  :             StateCpy(*p1,tmp);
; 413  :         }
; 414  :     } while ( --i );
; 415  :     if (p->Freq == 0) {
; 416  :         do { i++; } while ((--p)->Freq == 0);
; 417  :         EscFreq += i;                       OldNU=(NumStats+2) >> 1;
; 418  :         if ((NumStats -= i) == 0) {
; 419  :             StateCpy(tmp,*Stats);
; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;
; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;
; 422  :             FreeUnits(Stats,OldNU);         StateCpy(oneState(),tmp);
; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);
; 424  :             FoundState=&oneState();         return;
; 425  :         }
; 426  :         Stats = (STATE*) ShrinkUnits(Stats,OldNU,(NumStats+2) >> 1);
; 427  :         Flags &= ~0x08;                     i=NumStats;
; 428  :         Flags |= 0x08*((p=Stats)->Symbol >= 0x40);
; 429  :         do { Flags |= 0x08*((++p)->Symbol >= 0x40); } while ( --i );
; 430  :     }
; 431  :     SummFreq += (EscFreq -= (EscFreq >> 1));
; 432  :     Flags |= 0x04;                          FoundState=Stats;
; 433  : }
; 434  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 435  :         PPM_CONTEXT* pc)
; 436  : {
; 437  : 
; 438  :     PPM_CONTEXT ct, * UpBranch=FoundState->Successor;
; 439  :     PPM_CONTEXT::STATE* ps[MAX_O], ** pps=ps;
; 440  :     UINT cf, s0;
; 441  :     BYTE tmp, sym=FoundState->Symbol;
; 442  :     if ( !Skip ) {
; 443  :         *pps++ = FoundState;
; 444  :         if ( !pc->Suffix )                  goto NO_LOOP;
; 445  :     }
; 446  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 447  :     do {
; 448  :         pc=pc->Suffix;
; 449  :         if ( pc->NumStats ) {
; 450  :             if ((p=pc->Stats)->Symbol != sym)
; 451  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 452  :             tmp=(p->Freq < MAX_FREQ-9);
; 453  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 454  :         } else {
; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));
; 457  :         }
; 458  : LOOP_ENTRY:
; 459  :         if (p->Successor != UpBranch) {
; 460  :             pc=p->Successor;                break;
; 461  :         }
; 462  :         *pps++ = p;
; 463  :     } while ( pc->Suffix );
; 464  : NO_LOOP:
; 465  :     if (pps == ps)                          return pc;
; 466  :     ct.NumStats=0;                          ct.Flags=0x10*(sym >= 0x40);
; 467  :     ct.oneState().Symbol=sym=*(BYTE*) UpBranch;
; 468  :     ct.oneState().Successor=(PPM_CONTEXT*) (((BYTE*) UpBranch)+1);
; 469  :     ct.Flags |= 0x08*(sym >= 0x40);
; 470  :     if ( pc->NumStats ) {
; 471  :         if ((p=pc->Stats)->Symbol != sym)
; 472  :                 do { tmp=p[1].Symbol;       p++; } while (tmp != sym);
; 473  :         s0=pc->SummFreq-pc->NumStats-(cf=p->Freq-1);
; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));
; 475  :     } else
; 476  :             ct.oneState().Freq=pc->oneState().Freq;
; 477  :     do {
; 478  :         PPM_CONTEXT* pc1 = (PPM_CONTEXT*) AllocContext();
; 479  :         if ( !pc1 )                         return NULL;
; 480  :         ((DWORD*) pc1)[0] = ((DWORD*) &ct)[0];
; 481  :         ((DWORD*) pc1)[1] = ((DWORD*) &ct)[1];
; 482  :         pc1->Suffix=pc;                     (*--pps)->Successor=pc=pc1;
; 483  :     } while (pps != ps);
; 484  :     return pc;
; 485  : }
; 486  : 
; 487  : 
; 488  : static inline void UpdateModel( PPM_CONTEXT* MinContext)
; 489  : {
; 490  :     PPM_CONTEXT::STATE* p           = NULL;
; 491  :     PPM_CONTEXT*        FSuccessor  = FoundState->Successor;
; 492  :     PPM_CONTEXT*        pc          = MinContext->Suffix;
; 493  :     PPM_CONTEXT*        pc1         = MaxContext;
; 494  :     
; 495  :     UINT ns1, ns, cf, sf, s0, FFreq=FoundState->Freq;
; 496  :     BYTE Flag, sym, FSymbol=FoundState->Symbol;
; 497  : 
; 498  : 
; 499  :     if( FFreq < MAX_FREQ/4  &&  pc ) 
; 500  :     {
; 501  :         if ( pc->NumStats ) 
; 502  :         {
; 503  :             if ((p=pc->Stats)->Symbol != FSymbol) 
; 504  :             {
; 505  :                 do { sym=p[1].Symbol;       p++; } while (sym != FSymbol);
; 506  :                 if (p[0].Freq >= p[-1].Freq) 
; 507  :                 {
; 508  :                     SWAP(p[0],p[-1]);       
; 509  :                     p--;
; 510  :                 }
; 511  :             }
; 512  :             cf=2*(p->Freq < MAX_FREQ-9);
; 513  :             p->Freq      += cf;                  
; 514  :             pc->SummFreq += cf;
; 515  :         } 
; 516  :         else 
; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 
; 520  :         }
; 521  :     }
; 522  :     
; 523  :     if( !OrderFall && FSuccessor) 
; 524  :     {
; 525  :         FoundState->Successor=CreateSuccessors(TRUE,p,MinContext);
; 526  :         if ( !FoundState->Successor )       
; 527  :             goto RESTART_MODEL;
; 528  :         MaxContext=FoundState->Successor;   
; 529  :         return;
; 530  :     }
; 531  : 
; 532  :     *pText++ = FSymbol;                     
; 533  : 
; 534  :     PPM_CONTEXT*    Successor = (PPM_CONTEXT*) pText;
; 535  :     
; 536  :     if (pText >= UnitsStart)                
; 537  :         goto RESTART_MODEL;
; 538  : 
; 539  : 
; 540  :     if( FSuccessor ) 
; 541  :     {
; 542  :         if ((BYTE*) FSuccessor < UnitsStart)
; 543  :             FSuccessor=CreateSuccessors(FALSE,p,MinContext);
; 544  :     } 
; 545  :     else
; 546  :     {
; 547  :         FSuccessor=ReduceOrder(p,MinContext);
; 548  :     }
; 549  :     
; 550  :     if( !FSuccessor )                          
; 551  :         goto RESTART_MODEL;
; 552  : 
; 553  : 
; 554  :     if( !--OrderFall ) 
; 555  :     {
; 556  :         Successor=FSuccessor;               
; 557  :         pText -= (MaxContext != MinContext);
; 558  :     } 
; 559  :     else if( MRMethod > MRM_FREEZE) 
; 560  :     {
; 561  :         Successor=FSuccessor;               
; 562  :         pText=HeapStart;
; 563  :         OrderFall=0;
; 564  :     }
; 565  :     
; 566  :     s0=MinContext->SummFreq-(ns=MinContext->NumStats)-FFreq;
; 567  :     for (Flag=0x08*(FSymbol >= 0x40);pc1 != MinContext;pc1=pc1->Suffix) 
; 568  :     {
; 569  :         if ((ns1=pc1->NumStats) != 0) 
; 570  :         {
; 571  :             if ((ns1 & 1) != 0) 
; 572  :             {
; 573  :                 p=(PPM_CONTEXT::STATE*) ExpandUnits(pc1->Stats,(ns1+1) >> 1);
; 574  :                 if ( !p )                   
; 575  :                     goto RESTART_MODEL;
; 576  :                 pc1->Stats=p;
; 577  :             }
; 578  :             pc1->SummFreq += (3*ns1+1 < ns);
; 579  :         } 
; 580  :         else 
; 581  :         {
; 582  :             p=(PPM_CONTEXT::STATE*) AllocUnits(1);
; 583  :             if ( !p )                       
; 584  :                 goto RESTART_MODEL;
; 585  :                 
; 586  :             StateCpy(*p,pc1->oneState());   
; 587  :             pc1->Stats=p;
; 588  :             
; 589  :             if (p->Freq < MAX_FREQ/4-1)     p->Freq += p->Freq;
; 590  :             else                            p->Freq  = MAX_FREQ-4;
; 591  :             
; 592  :             pc1->SummFreq=p->Freq+InitEsc+(ns > 2);
; 593  :         }
; 594  : 
; 595  :         cf=2*FFreq*(pc1->SummFreq+6);       
; 596  :         sf=s0+pc1->SummFreq;
; 597  : 
; 598  :         if (cf < 6*sf) 
; 599  :         {
; 600  :             cf=1+(cf > sf)+(cf >= 4*sf);
; 601  :             pc1->SummFreq += 4;
; 602  :         } 
; 603  :         else 
; 604  :         {
; 605  :             cf=4+(cf > 9*sf)+(cf > 12*sf)+(cf > 15*sf);
; 606  :             pc1->SummFreq += cf;
; 607  :         }
; 608  :         p=pc1->Stats+(++pc1->NumStats);     
; 609  :         p->Successor=Successor;
; 610  :         p->Symbol = FSymbol;                
; 611  :         p->Freq = cf;
; 612  :         pc1->Flags |= Flag;
; 613  :     }
; 614  : 
; 615  :     MaxContext=FSuccessor;
; 616  :     return;
; 617  : 
; 618  : RESTART_MODEL:
; 619  :     RestoreModelRare(pc1,MinContext,FSuccessor);
; 620  : 
; 621  : }
; 622  : // Tabulated escapes for exponential symbol distribution
; 623  : static const BYTE ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
; 624  : #define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))
; 625  : inline void PPM_CONTEXT::encodeBinSymbol(int symbol)
; 626  : {
; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 630  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 631  :     if (rs.Symbol == symbol) {
; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 633  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 634  :         PrevSuccess=1;                      RunLength++;
; 635  :     } else {
; 636  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 637  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 638  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 639  :     }
; 640  : }
; 641  : inline void PPM_CONTEXT::decodeBinSymbol() const
; 642  : {
; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 647  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 648  :     if ( !rcBinDecode(tmp) ) {
; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 650  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 651  :         PrevSuccess=1;                      RunLength++;
; 652  :     } else {
; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 654  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 656  :     }
; 657  : }
; 658  : inline void PPM_CONTEXT::update1(STATE* p) 
; 659  : {
; 660  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	mov	QWORD PTR FoundState, rax

; 687  :         }
; 688  :     }
; 689  :     SubRange.high=(SubRange.low=LoCnt)+p->Freq;   update1(p);

	lea	ecx, DWORD PTR [r8+rdx]

; 100  : }
; 101  : inline void StateCpy(PPM_CONTEXT::STATE& s1,const PPM_CONTEXT::STATE& s2)
; 102  : {
; 103  :     (WORD&) s1=(WORD&) s2;                  
; 104  :     s1.Successor=s2.Successor;
; 105  : }
; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;
; 107  : inline PPMD_STARTUP::PPMD_STARTUP()         // constants initialization
; 108  : {
; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;
; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;
; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;
; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;
; 114  :     for (k=i=0;k < 128;k++) {
; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;
; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);
; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;
; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {
; 121  :         QTable[i]=m;
; 122  :         if ( !--k ) { k = ++Step;           m++; }
; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;
; 125  : }
; 126  : 
; 127  : 
; 128  : void PPM_CONTEXT::makeSuffix()
; 129  : {
; 130  :     STATE* p, * p1;
; 131  :     if ( !NumStats ) 
; 132  :     {
; 133  :         if ( !(p=&oneState())->Successor )  return;
; 134  : 
; 135  :         if ( !Suffix->NumStats )            
; 136  :         {
; 137  :             p1=&(Suffix->oneState());
; 138  :         }
; 139  :         else
; 140  :         {
; 141  :             for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 142  :                 ;
; 143  :         }
; 144  :         
; 145  :         p->Successor->Suffix = p1->Successor; 
; 146  :         p->Successor->makeSuffix();
; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 
; 151  :         {
; 152  :             if ( !p->Successor )            
; 153  :                 continue;
; 154  : 
; 155  :             if ( !Suffix )                  
; 156  :             {
; 157  :                 p->Successor->Suffix=this;
; 158  :             }
; 159  :             else 
; 160  :             {
; 161  :                 for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 162  :                     ;
; 163  :                 p->Successor->Suffix=p1->Successor;
; 164  :             }
; 165  :             p->Successor->makeSuffix();
; 166  :         }
; 167  :     }
; 168  : }
; 169  : 
; 170  : void PPM_CONTEXT::read(_PPMD_FILE* fp,UINT PrevSym)
; 171  : {
; 172  :     STATE* p;                               Suffix=NULL;
; 173  :     NumStats=_PPMD_E_GETC(fp);                     Flags=0x10*(PrevSym >= 0x40);
; 174  :     if ( !NumStats ) {
; 175  :         p=&oneState();                      p->Freq=_PPMD_E_GETC(fp);
; 176  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 177  :         if ((p->Freq & 0x80) != 0) {
; 178  :             p->Freq &= ~0x80;
; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 180  :             p->Successor->read(fp,p->Symbol);
; 181  :         } else                              p->Successor=NULL;
; 182  :         return;
; 183  :     }
; 184  :     Stats = (PPM_CONTEXT::STATE*) AllocUnits((NumStats+2) >> 1);
; 185  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 186  :         p->Freq=_PPMD_E_GETC(fp);
; 187  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 188  :     }
; 189  :     int EscFreq=SummFreq=(Stats->Freq & ~0x80);
; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);
; 191  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 192  :         if ((p->Freq & 0x80) != 0) {
; 193  :             p->Freq &= ~0x80;
; 194  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 195  :             p->Successor->read(fp,p->Symbol);
; 196  :         } else                              p->Successor=NULL;
; 197  :         p->Freq=(p == Stats)?(64):(p[-1].Freq-p[0].Freq);
; 198  :         SummFreq += p->Freq;
; 199  :     }
; 200  :     if (EscFreq > 32) {
; 201  :         SummFreq=(EscFreq >> 1);
; 202  :         for (p=Stats;p <= Stats+NumStats;p++)
; 203  :                 SummFreq += (p->Freq -= (3*p->Freq) >> 2);
; 204  :     }
; 205  : }
; 206  : /*
; 207  : void
; 208  : PPM_CONTEXT::write( int o, FILE* fp )
; 209  : {
; 210  :     int EscFreq = EscCount; //(Stats)  ? Stats->Freq & ~0x80  : 0;
; 211  :     int nc      = 0;
; 212  : 
; 213  :     STATE* p;
; 214  :     int f, a, b, c;
; 215  :     if (nc < o)                             
; 216  :         nc=o;
; 217  :         
; 218  :     putc(NumStats,fp);
; 219  :     if ( !NumStats ) {
; 220  :         f=(p=&oneState())->Freq;
; 221  :         if ( EscFreq )                      f=(2*f)/EscFreq;
; 222  :         f=CLAMP(f,1,127) | 0x80*(p->Successor != NULL);
; 223  :         putc(f,fp);                         putc(p->Symbol,fp);
; 224  :         if ( p->Successor )                 p->Successor->write(o+1,fp);
; 225  :         return;
; 226  :     }
; 227  :     for (p=Stats+1;p <= Stats+NumStats;p++) {
; 228  :         if (p[0].Freq > p[-1].Freq) {
; 229  :             STATE* p1=p;
; 230  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq > p1[-1].Freq);
; 231  :         }
; 232  :         if (p[0].Freq == p[-1].Freq && p[0].Successor && !p[-1].Successor) {
; 233  :             STATE* p1=p;
; 234  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq == p1[-1].Freq && !p1[-1].Successor);
; 235  :         }
; 236  :     }
; 237  :     a=Stats->Freq+!Stats->Freq;             f=(64*EscFreq+(b=a >> 1))/a;
; 238  :     f=CLAMP(f,1,127) | 0x80*(Stats->Successor != NULL);
; 239  :     putc(f,fp);                             c=64;
; 240  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 241  :         f=(64*p->Freq+b)/a;                 f += !f;
; 242  :         if (p != Stats)
; 243  :             putc((c-f) | 0x80*(p->Successor != NULL),fp);
; 244  :         c=f;                                putc(p->Symbol,fp);
; 245  :     }
; 246  :     for (p=Stats;p <= Stats+NumStats;p++)
; 247  :             if ( p->Successor )             p->Successor->write(o+1,fp);
; 248  : }
; 249  : */
; 250  : void PPM_CONTEXT::refresh(int OldNU,BOOL Scale)
; 251  : {
; 252  :     int i=NumStats, EscFreq;
; 253  :     STATE* p = Stats = (STATE*) ShrinkUnits(Stats,OldNU,(i+2) >> 1);
; 254  :     Flags=(Flags & (0x10+0x04*Scale))+0x08*(p->Symbol >= 0x40);
; 255  :     EscFreq=SummFreq-p->Freq;
; 256  :     SummFreq = (p->Freq=(p->Freq+Scale) >> Scale);
; 257  :     do {
; 258  :         EscFreq -= (++p)->Freq;
; 259  :         SummFreq += (p->Freq=(p->Freq+Scale) >> Scale);
; 260  :         Flags |= 0x08*(p->Symbol >= 0x40);
; 261  :     } while ( --i );
; 262  :     SummFreq += (EscFreq=(EscFreq+Scale) >> Scale);
; 263  : }
; 264  : #define P_CALL(F) ( PrefetchData(p->Successor), \
; 265  :                     p->Successor=p->Successor->F(Order+1))
; 266  : PPM_CONTEXT* PPM_CONTEXT::cutOff(int Order)
; 267  : {
; 268  :     int i, tmp;
; 269  :     STATE* p;
; 270  :     if ( !NumStats ) {
; 271  :         if ((BYTE*) (p=&oneState())->Successor >= UnitsStart) {
; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);
; 273  :             else                            p->Successor=NULL;
; 274  :             if (!p->Successor && Order > O_BOUND)
; 275  :                     goto REMOVE;
; 276  :             return this;
; 277  :         } else {
; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;
; 279  :         }
; 280  :     }
; 281  :     PrefetchData(Stats);
; 282  :     Stats = (STATE*) MoveUnitsUp(Stats,tmp=(NumStats+2) >> 1);
; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)
; 284  :             if ((BYTE*) p->Successor < UnitsStart) {
; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);
; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);
; 287  :             else                            p->Successor=NULL;
; 288  :     if (i != NumStats && Order) {
; 289  :         NumStats=i;                         p=Stats;
; 290  :         if (i < 0) { FreeUnits(p,tmp);      goto REMOVE; }
; 291  :         else if (i == 0) {
; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);
; 293  :             StateCpy(oneState(),*p);        FreeUnits(p,tmp);
; 294  :             oneState().Freq=(oneState().Freq+11) >> 3;
; 295  :         } else                              refresh(tmp,SummFreq > 16*i);
; 296  :     }
; 297  :     return this;
; 298  : }
; 299  : PPM_CONTEXT* PPM_CONTEXT::removeBinConts(int Order)
; 300  : {
; 301  :     STATE* p;
; 302  :     if ( !NumStats ) {
; 303  :         p=&oneState();
; 304  :         if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 305  :                 P_CALL(removeBinConts);
; 306  :         else                                p->Successor=NULL;
; 307  :         if (!p->Successor && (!Suffix->NumStats || Suffix->Flags == 0xFF)) {
; 308  :             FreeUnits(this,1);              return NULL;
; 309  :         } else                              return this;
; 310  :     }
; 311  :     PrefetchData(Stats);
; 312  :     for (p=Stats+NumStats;p >= Stats;p--)
; 313  :             if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 314  :                     P_CALL(removeBinConts);
; 315  :             else                            p->Successor=NULL;
; 316  :     return this;
; 317  : }
; 318  : 
; 319  : static void RestoreModelRare(PPM_CONTEXT* pc1,PPM_CONTEXT* MinContext,
; 320  :         PPM_CONTEXT* FSuccessor)
; 321  : {
; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)
; 325  :             if (--(pc->NumStats) == 0) {
; 326  :                 pc->Flags=(pc->Flags & 0x10)+0x08*(pc->Stats->Symbol >= 0x40);
; 327  :                 p=pc->Stats;                StateCpy(pc->oneState(),*p);
; 328  :                 SpecialFreeUnit(p);
; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;
; 330  :             } else
; 331  :                     pc->refresh((pc->NumStats+3) >> 1,FALSE);
; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)
; 333  :             if ( !pc->NumStats )
; 334  :                     pc->oneState().Freq -= pc->oneState().Freq >> 1;
; 335  :             else if ((pc->SummFreq += 4) > 128+4*pc->NumStats)
; 336  :                     pc->refresh((pc->NumStats+2) >> 1,TRUE);
; 337  :     if (MRMethod > MRM_FREEZE) {
; 338  :         MaxContext=FSuccessor;              GlueCount += !(BList[1].Stamp & 1);
; 339  :     } else if (MRMethod == MRM_FREEZE) {
; 340  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 341  :         MaxContext->removeBinConts(0);      MRMethod=MR_METHOD(MRMethod+1);
; 342  :         GlueCount=0;                        OrderFall=MaxOrder;
; 343  : 	} else if (MRMethod == MRM_RESTART || GetUsedMemory() < (SubAllocatorSize >> 1)) {
; 344  :         StartModelRare(MaxOrder,MRMethod);
; 345  :         EscCount=0;                         PrintCount=0xFF;
; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 348  :         do {
; 349  :             MaxContext->cutOff(0);          ExpandTextArea();
; 350  : 		} while (GetUsedMemory() > 3*(SubAllocatorSize >> 2));
; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }
; 354  : 
; 355  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 356  :         PPM_CONTEXT* pc);
; 357  : static PPM_CONTEXT* _FASTCALL ReduceOrder(PPM_CONTEXT::STATE* p,PPM_CONTEXT* pc)
; 358  : {
; 359  :     PPM_CONTEXT::STATE* p1,  * ps[MAX_O], ** pps=ps;
; 360  :     PPM_CONTEXT* pc1=pc, * UpBranch = (PPM_CONTEXT*) pText;
; 361  :     BYTE tmp, sym=FoundState->Symbol;
; 362  :     *pps++ = FoundState;                    FoundState->Successor=UpBranch;
; 363  :     OrderFall++;
; 364  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 365  :     for ( ; ; ) {
; 366  :         if ( !pc->Suffix ) {
; 367  :             if (MRMethod > MRM_FREEZE) {
; 368  : FROZEN:         do { (*--pps)->Successor = pc; } while (pps != ps);
; 369  :                 pText=HeapStart+1;          OrderFall=1;
; 370  :             }
; 371  :             return pc;
; 372  :         }
; 373  :         pc=pc->Suffix;
; 374  :         if ( pc->NumStats ) {
; 375  :             if ((p=pc->Stats)->Symbol != sym)
; 376  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 377  :             tmp=2*(p->Freq < MAX_FREQ-9);
; 378  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }
; 380  : LOOP_ENTRY:
; 381  :         if ( p->Successor )                 break;
; 382  :         *pps++ = p;                         p->Successor=UpBranch;
; 383  :         OrderFall++;
; 384  :     }
; 385  :     if (MRMethod > MRM_FREEZE) {
; 386  :         pc = p->Successor;                  goto FROZEN;
; 387  :     } else if (p->Successor <= UpBranch) {
; 388  :         p1=FoundState;                      FoundState=p;
; 389  :         p->Successor=CreateSuccessors(FALSE,NULL,pc);
; 390  :         FoundState=p1;
; 391  :     }
; 392  :     if (OrderFall == 1 && pc1 == MaxContext) {
; 393  :         FoundState->Successor=p->Successor; pText--;
; 394  :     }
; 395  :     return p->Successor;
; 396  : }
; 397  : void PPM_CONTEXT::rescale()
; 398  : {
; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);
; 402  :     p->Freq += 4;                           SummFreq += 4;
; 403  :     EscFreq=SummFreq-p->Freq;
; 404  :     Adder=(OrderFall != 0 || MRMethod > MRM_FREEZE);
; 405  :     SummFreq = (p->Freq=(p->Freq+Adder) >> 1);
; 406  :     do {
; 407  :         EscFreq -= (++p)->Freq;
; 408  :         SummFreq += (p->Freq=(p->Freq+Adder) >> 1);
; 409  :         if (p[0].Freq > p[-1].Freq) {
; 410  :             StateCpy(tmp,*(p1=p));
; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);
; 412  :             StateCpy(*p1,tmp);
; 413  :         }
; 414  :     } while ( --i );
; 415  :     if (p->Freq == 0) {
; 416  :         do { i++; } while ((--p)->Freq == 0);
; 417  :         EscFreq += i;                       OldNU=(NumStats+2) >> 1;
; 418  :         if ((NumStats -= i) == 0) {
; 419  :             StateCpy(tmp,*Stats);
; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;
; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;
; 422  :             FreeUnits(Stats,OldNU);         StateCpy(oneState(),tmp);
; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);
; 424  :             FoundState=&oneState();         return;
; 425  :         }
; 426  :         Stats = (STATE*) ShrinkUnits(Stats,OldNU,(NumStats+2) >> 1);
; 427  :         Flags &= ~0x08;                     i=NumStats;
; 428  :         Flags |= 0x08*((p=Stats)->Symbol >= 0x40);
; 429  :         do { Flags |= 0x08*((++p)->Symbol >= 0x40); } while ( --i );
; 430  :     }
; 431  :     SummFreq += (EscFreq -= (EscFreq >> 1));
; 432  :     Flags |= 0x04;                          FoundState=Stats;
; 433  : }
; 434  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 435  :         PPM_CONTEXT* pc)
; 436  : {
; 437  : 
; 438  :     PPM_CONTEXT ct, * UpBranch=FoundState->Successor;
; 439  :     PPM_CONTEXT::STATE* ps[MAX_O], ** pps=ps;
; 440  :     UINT cf, s0;
; 441  :     BYTE tmp, sym=FoundState->Symbol;
; 442  :     if ( !Skip ) {
; 443  :         *pps++ = FoundState;
; 444  :         if ( !pc->Suffix )                  goto NO_LOOP;
; 445  :     }
; 446  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 447  :     do {
; 448  :         pc=pc->Suffix;
; 449  :         if ( pc->NumStats ) {
; 450  :             if ((p=pc->Stats)->Symbol != sym)
; 451  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 452  :             tmp=(p->Freq < MAX_FREQ-9);
; 453  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 454  :         } else {
; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));
; 457  :         }
; 458  : LOOP_ENTRY:
; 459  :         if (p->Successor != UpBranch) {
; 460  :             pc=p->Successor;                break;
; 461  :         }
; 462  :         *pps++ = p;
; 463  :     } while ( pc->Suffix );
; 464  : NO_LOOP:
; 465  :     if (pps == ps)                          return pc;
; 466  :     ct.NumStats=0;                          ct.Flags=0x10*(sym >= 0x40);
; 467  :     ct.oneState().Symbol=sym=*(BYTE*) UpBranch;
; 468  :     ct.oneState().Successor=(PPM_CONTEXT*) (((BYTE*) UpBranch)+1);
; 469  :     ct.Flags |= 0x08*(sym >= 0x40);
; 470  :     if ( pc->NumStats ) {
; 471  :         if ((p=pc->Stats)->Symbol != sym)
; 472  :                 do { tmp=p[1].Symbol;       p++; } while (tmp != sym);
; 473  :         s0=pc->SummFreq-pc->NumStats-(cf=p->Freq-1);
; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));
; 475  :     } else
; 476  :             ct.oneState().Freq=pc->oneState().Freq;
; 477  :     do {
; 478  :         PPM_CONTEXT* pc1 = (PPM_CONTEXT*) AllocContext();
; 479  :         if ( !pc1 )                         return NULL;
; 480  :         ((DWORD*) pc1)[0] = ((DWORD*) &ct)[0];
; 481  :         ((DWORD*) pc1)[1] = ((DWORD*) &ct)[1];
; 482  :         pc1->Suffix=pc;                     (*--pps)->Successor=pc=pc1;
; 483  :     } while (pps != ps);
; 484  :     return pc;
; 485  : }
; 486  : 
; 487  : 
; 488  : static inline void UpdateModel( PPM_CONTEXT* MinContext)
; 489  : {
; 490  :     PPM_CONTEXT::STATE* p           = NULL;
; 491  :     PPM_CONTEXT*        FSuccessor  = FoundState->Successor;
; 492  :     PPM_CONTEXT*        pc          = MinContext->Suffix;
; 493  :     PPM_CONTEXT*        pc1         = MaxContext;
; 494  :     
; 495  :     UINT ns1, ns, cf, sf, s0, FFreq=FoundState->Freq;
; 496  :     BYTE Flag, sym, FSymbol=FoundState->Symbol;
; 497  : 
; 498  : 
; 499  :     if( FFreq < MAX_FREQ/4  &&  pc ) 
; 500  :     {
; 501  :         if ( pc->NumStats ) 
; 502  :         {
; 503  :             if ((p=pc->Stats)->Symbol != FSymbol) 
; 504  :             {
; 505  :                 do { sym=p[1].Symbol;       p++; } while (sym != FSymbol);
; 506  :                 if (p[0].Freq >= p[-1].Freq) 
; 507  :                 {
; 508  :                     SWAP(p[0],p[-1]);       
; 509  :                     p--;
; 510  :                 }
; 511  :             }
; 512  :             cf=2*(p->Freq < MAX_FREQ-9);
; 513  :             p->Freq      += cf;                  
; 514  :             pc->SummFreq += cf;
; 515  :         } 
; 516  :         else 
; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 
; 520  :         }
; 521  :     }
; 522  :     
; 523  :     if( !OrderFall && FSuccessor) 
; 524  :     {
; 525  :         FoundState->Successor=CreateSuccessors(TRUE,p,MinContext);
; 526  :         if ( !FoundState->Successor )       
; 527  :             goto RESTART_MODEL;
; 528  :         MaxContext=FoundState->Successor;   
; 529  :         return;
; 530  :     }
; 531  : 
; 532  :     *pText++ = FSymbol;                     
; 533  : 
; 534  :     PPM_CONTEXT*    Successor = (PPM_CONTEXT*) pText;
; 535  :     
; 536  :     if (pText >= UnitsStart)                
; 537  :         goto RESTART_MODEL;
; 538  : 
; 539  : 
; 540  :     if( FSuccessor ) 
; 541  :     {
; 542  :         if ((BYTE*) FSuccessor < UnitsStart)
; 543  :             FSuccessor=CreateSuccessors(FALSE,p,MinContext);
; 544  :     } 
; 545  :     else
; 546  :     {
; 547  :         FSuccessor=ReduceOrder(p,MinContext);
; 548  :     }
; 549  :     
; 550  :     if( !FSuccessor )                          
; 551  :         goto RESTART_MODEL;
; 552  : 
; 553  : 
; 554  :     if( !--OrderFall ) 
; 555  :     {
; 556  :         Successor=FSuccessor;               
; 557  :         pText -= (MaxContext != MinContext);
; 558  :     } 
; 559  :     else if( MRMethod > MRM_FREEZE) 
; 560  :     {
; 561  :         Successor=FSuccessor;               
; 562  :         pText=HeapStart;
; 563  :         OrderFall=0;
; 564  :     }
; 565  :     
; 566  :     s0=MinContext->SummFreq-(ns=MinContext->NumStats)-FFreq;
; 567  :     for (Flag=0x08*(FSymbol >= 0x40);pc1 != MinContext;pc1=pc1->Suffix) 
; 568  :     {
; 569  :         if ((ns1=pc1->NumStats) != 0) 
; 570  :         {
; 571  :             if ((ns1 & 1) != 0) 
; 572  :             {
; 573  :                 p=(PPM_CONTEXT::STATE*) ExpandUnits(pc1->Stats,(ns1+1) >> 1);
; 574  :                 if ( !p )                   
; 575  :                     goto RESTART_MODEL;
; 576  :                 pc1->Stats=p;
; 577  :             }
; 578  :             pc1->SummFreq += (3*ns1+1 < ns);
; 579  :         } 
; 580  :         else 
; 581  :         {
; 582  :             p=(PPM_CONTEXT::STATE*) AllocUnits(1);
; 583  :             if ( !p )                       
; 584  :                 goto RESTART_MODEL;
; 585  :                 
; 586  :             StateCpy(*p,pc1->oneState());   
; 587  :             pc1->Stats=p;
; 588  :             
; 589  :             if (p->Freq < MAX_FREQ/4-1)     p->Freq += p->Freq;
; 590  :             else                            p->Freq  = MAX_FREQ-4;
; 591  :             
; 592  :             pc1->SummFreq=p->Freq+InitEsc+(ns > 2);
; 593  :         }
; 594  : 
; 595  :         cf=2*FFreq*(pc1->SummFreq+6);       
; 596  :         sf=s0+pc1->SummFreq;
; 597  : 
; 598  :         if (cf < 6*sf) 
; 599  :         {
; 600  :             cf=1+(cf > sf)+(cf >= 4*sf);
; 601  :             pc1->SummFreq += 4;
; 602  :         } 
; 603  :         else 
; 604  :         {
; 605  :             cf=4+(cf > 9*sf)+(cf > 12*sf)+(cf > 15*sf);
; 606  :             pc1->SummFreq += cf;
; 607  :         }
; 608  :         p=pc1->Stats+(++pc1->NumStats);     
; 609  :         p->Successor=Successor;
; 610  :         p->Symbol = FSymbol;                
; 611  :         p->Freq = cf;
; 612  :         pc1->Flags |= Flag;
; 613  :     }
; 614  : 
; 615  :     MaxContext=FSuccessor;
; 616  :     return;
; 617  : 
; 618  : RESTART_MODEL:
; 619  :     RestoreModelRare(pc1,MinContext,FSuccessor);
; 620  : 
; 621  : }
; 622  : // Tabulated escapes for exponential symbol distribution
; 623  : static const BYTE ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
; 624  : #define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))
; 625  : inline void PPM_CONTEXT::encodeBinSymbol(int symbol)
; 626  : {
; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 630  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 631  :     if (rs.Symbol == symbol) {
; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 633  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 634  :         PrevSuccess=1;                      RunLength++;
; 635  :     } else {
; 636  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 637  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 638  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 639  :     }
; 640  : }
; 641  : inline void PPM_CONTEXT::decodeBinSymbol() const
; 642  : {
; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 647  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 648  :     if ( !rcBinDecode(tmp) ) {
; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 650  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 651  :         PrevSuccess=1;                      RunLength++;
; 652  :     } else {
; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 654  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 656  :     }
; 657  : }
; 658  : inline void PPM_CONTEXT::update1(STATE* p) 
; 659  : {
; 660  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	add	dl, 4
	mov	BYTE PTR [rax+1], dl
	add	WORD PTR [r10+2], 4

; 687  :         }
; 688  :     }
; 689  :     SubRange.high=(SubRange.low=LoCnt)+p->Freq;   update1(p);

	mov	DWORD PTR SubRange+4, ecx

; 661  :     if (p[0].Freq > p[-1].Freq) {

	movzx	ecx, BYTE PTR [rax-9]
	cmp	BYTE PTR [rax+1], cl
	jbe	SHORT $LN14@encodeSymb

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	movzx	ecx, WORD PTR [rax-10]
	movzx	r8d, WORD PTR [rax]
	mov	rdx, QWORD PTR [rax+2]

; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;

	lea	r9, QWORD PTR [rax-10]

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	mov	WORD PTR [rax], cx
	mov	rcx, QWORD PTR [r9+2]

; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;

	mov	QWORD PTR FoundState, r9

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	mov	QWORD PTR [rax+2], rcx

; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;

	mov	WORD PTR [r9], r8w
	mov	QWORD PTR [r9+2], rdx

; 663  :         if (p->Freq > MAX_FREQ)             rescale();

	cmp	BYTE PTR [r9+1], 124			; 0000007cH
	jbe	SHORT $LN14@encodeSymb
	mov	rcx, r10

; 690  : }

	add	rsp, 40					; 00000028H

; 663  :         if (p->Freq > MAX_FREQ)             rescale();

	jmp	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN14@encodeSymb:

; 690  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN22@encodeSymb:

; 682  :             if ( Suffix )                   PrefetchData(Suffix);

	mov	rcx, QWORD PTR [r10+12]
	test	rcx, rcx
	je	SHORT $LN12@encodeSymb
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	ecx, BYTE PTR [rcx]
	mov	r11d, DWORD PTR SubRange+8
$LN12@encodeSymb:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 683  :             SubRange.low=LoCnt;                CharMask[p->Symbol]=EscCount;

	movzx	ecx, BYTE PTR [rax]
	mov	DWORD PTR SubRange, r8d
	movzx	r8d, BYTE PTR EscCount
	lea	r9, OFFSET FLAT:CharMask

; 684  :             i=NumMasked=NumStats;           FoundState=NULL;

	mov	QWORD PTR FoundState, 0
	mov	BYTE PTR [rcx+r9], r8b
	movzx	ecx, BYTE PTR [r10]
	mov	BYTE PTR NumMasked, cl
	mov	edx, ecx
	npad	9
$LL3@encodeSymb:

; 685  :             do { CharMask[(--p)->Symbol]=EscCount; } while ( --i );

	movzx	ecx, BYTE PTR [rax-10]
	lea	rax, QWORD PTR [rax-10]
	mov	BYTE PTR [rcx+r9], r8b
	dec	edx
	jne	SHORT $LL3@encodeSymb

; 686  :             SubRange.high=SubRange.scale;         return;

	mov	DWORD PTR SubRange+4, r11d

; 690  : }

	add	rsp, 40					; 00000028H
	ret	0
?encodeSymbol1@PPM_CONTEXT@@QEAAXH@Z ENDP		; PPM_CONTEXT::encodeSymbol1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ PROC		; PPM_CONTEXT::decodeSymbol1, COMDAT

; 692  : {

$LN31:
	push	rbx
	sub	rsp, 32					; 00000020H

; 694  :     STATE* p=Stats;                         SubRange.scale=SummFreq;

	movzx	ebx, WORD PTR [rcx+2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	mov	eax, DWORD PTR range
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 693  :     UINT i, count, HiCnt=Stats->Freq;

	mov	r8, QWORD PTR [rcx+4]
	movzx	r10d, BYTE PTR [r8+1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	xor	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 692  : {

	mov	r11, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	div	ebx
	xor	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 694  :     STATE* p=Stats;                         SubRange.scale=SummFreq;

	mov	DWORD PTR SubRange+8, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	mov	r9d, eax
	mov	DWORD PTR range, eax
	mov	eax, DWORD PTR code
	sub	eax, DWORD PTR low
	div	r9d
	mov	r9d, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 695  :     if ((count=rcGetCurrentCount()) < HiCnt) {

	cmp	eax, r10d
	jae	SHORT $LN9@decodeSymb

; 696  :         PrevSuccess=(2*(SubRange.high=HiCnt) >= SubRange.scale);

	lea	eax, DWORD PTR [r10+r10]
	mov	DWORD PTR SubRange+4, r10d

; 697  : 
; 698  :         (FoundState=p)->Freq=(HiCnt += 4);  

	mov	QWORD PTR FoundState, r8
	cmp	eax, ebx
	setae	al
	add	r10d, 4
	mov	BYTE PTR PrevSuccess, al

; 699  :         SummFreq += 4;
; 700  : 
; 701  :         RunLength += PrevSuccess;

	movzx	eax, al
	mov	BYTE PTR [r8+1], r10b
	add	DWORD PTR RunLength, eax
	add	WORD PTR [rcx+2], 4

; 702  :         if (HiCnt > MAX_FREQ)               rescale();

	cmp	r10d, 124				; 0000007cH
	jbe	SHORT $LN8@decodeSymb
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN8@decodeSymb:

; 703  :         SubRange.low=0;                        return;

	mov	DWORD PTR SubRange, 0

; 715  :     ((PPM_CONTEXT*)this)->update1(p);
; 716  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN9@decodeSymb:

; 704  :     }
; 705  :     i=NumStats;                             PrevSuccess=0;
; 706  :     while ((HiCnt += (++p)->Freq) <= count)

	movzx	eax, BYTE PTR [r8+11]
	movzx	ecx, BYTE PTR [rcx]
	add	r8, 10
	add	r10d, eax
	mov	BYTE PTR PrevSuccess, 0
	cmp	r10d, r9d
	ja	SHORT $LN6@decodeSymb
$LL7@decodeSymb:

; 707  :         if (--i == 0) {

	dec	ecx
	je	$LN24@decodeSymb

; 704  :     }
; 705  :     i=NumStats;                             PrevSuccess=0;
; 706  :     while ((HiCnt += (++p)->Freq) <= count)

	movzx	eax, BYTE PTR [r8+11]
	add	r8, 10
	add	r10d, eax
	cmp	r10d, r9d
	jbe	SHORT $LL7@decodeSymb
$LN6@decodeSymb:

; 713  :         }
; 714  :     SubRange.low=(SubRange.high=HiCnt)-p->Freq;   

	movzx	eax, BYTE PTR [r8+1]
	mov	DWORD PTR SubRange+4, r10d

; 100  : }
; 101  : inline void StateCpy(PPM_CONTEXT::STATE& s1,const PPM_CONTEXT::STATE& s2)
; 102  : {
; 103  :     (WORD&) s1=(WORD&) s2;                  
; 104  :     s1.Successor=s2.Successor;
; 105  : }
; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;
; 107  : inline PPMD_STARTUP::PPMD_STARTUP()         // constants initialization
; 108  : {
; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;
; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;
; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;
; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;
; 114  :     for (k=i=0;k < 128;k++) {
; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;
; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);
; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;
; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {
; 121  :         QTable[i]=m;
; 122  :         if ( !--k ) { k = ++Step;           m++; }
; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;
; 125  : }
; 126  : 
; 127  : 
; 128  : void PPM_CONTEXT::makeSuffix()
; 129  : {
; 130  :     STATE* p, * p1;
; 131  :     if ( !NumStats ) 
; 132  :     {
; 133  :         if ( !(p=&oneState())->Successor )  return;
; 134  : 
; 135  :         if ( !Suffix->NumStats )            
; 136  :         {
; 137  :             p1=&(Suffix->oneState());
; 138  :         }
; 139  :         else
; 140  :         {
; 141  :             for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 142  :                 ;
; 143  :         }
; 144  :         
; 145  :         p->Successor->Suffix = p1->Successor; 
; 146  :         p->Successor->makeSuffix();
; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 
; 151  :         {
; 152  :             if ( !p->Successor )            
; 153  :                 continue;
; 154  : 
; 155  :             if ( !Suffix )                  
; 156  :             {
; 157  :                 p->Successor->Suffix=this;
; 158  :             }
; 159  :             else 
; 160  :             {
; 161  :                 for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 162  :                     ;
; 163  :                 p->Successor->Suffix=p1->Successor;
; 164  :             }
; 165  :             p->Successor->makeSuffix();
; 166  :         }
; 167  :     }
; 168  : }
; 169  : 
; 170  : void PPM_CONTEXT::read(_PPMD_FILE* fp,UINT PrevSym)
; 171  : {
; 172  :     STATE* p;                               Suffix=NULL;
; 173  :     NumStats=_PPMD_E_GETC(fp);                     Flags=0x10*(PrevSym >= 0x40);
; 174  :     if ( !NumStats ) {
; 175  :         p=&oneState();                      p->Freq=_PPMD_E_GETC(fp);
; 176  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 177  :         if ((p->Freq & 0x80) != 0) {
; 178  :             p->Freq &= ~0x80;
; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 180  :             p->Successor->read(fp,p->Symbol);
; 181  :         } else                              p->Successor=NULL;
; 182  :         return;
; 183  :     }
; 184  :     Stats = (PPM_CONTEXT::STATE*) AllocUnits((NumStats+2) >> 1);
; 185  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 186  :         p->Freq=_PPMD_E_GETC(fp);
; 187  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 188  :     }
; 189  :     int EscFreq=SummFreq=(Stats->Freq & ~0x80);
; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);
; 191  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 192  :         if ((p->Freq & 0x80) != 0) {
; 193  :             p->Freq &= ~0x80;
; 194  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 195  :             p->Successor->read(fp,p->Symbol);
; 196  :         } else                              p->Successor=NULL;
; 197  :         p->Freq=(p == Stats)?(64):(p[-1].Freq-p[0].Freq);
; 198  :         SummFreq += p->Freq;
; 199  :     }
; 200  :     if (EscFreq > 32) {
; 201  :         SummFreq=(EscFreq >> 1);
; 202  :         for (p=Stats;p <= Stats+NumStats;p++)
; 203  :                 SummFreq += (p->Freq -= (3*p->Freq) >> 2);
; 204  :     }
; 205  : }
; 206  : /*
; 207  : void
; 208  : PPM_CONTEXT::write( int o, FILE* fp )
; 209  : {
; 210  :     int EscFreq = EscCount; //(Stats)  ? Stats->Freq & ~0x80  : 0;
; 211  :     int nc      = 0;
; 212  : 
; 213  :     STATE* p;
; 214  :     int f, a, b, c;
; 215  :     if (nc < o)                             
; 216  :         nc=o;
; 217  :         
; 218  :     putc(NumStats,fp);
; 219  :     if ( !NumStats ) {
; 220  :         f=(p=&oneState())->Freq;
; 221  :         if ( EscFreq )                      f=(2*f)/EscFreq;
; 222  :         f=CLAMP(f,1,127) | 0x80*(p->Successor != NULL);
; 223  :         putc(f,fp);                         putc(p->Symbol,fp);
; 224  :         if ( p->Successor )                 p->Successor->write(o+1,fp);
; 225  :         return;
; 226  :     }
; 227  :     for (p=Stats+1;p <= Stats+NumStats;p++) {
; 228  :         if (p[0].Freq > p[-1].Freq) {
; 229  :             STATE* p1=p;
; 230  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq > p1[-1].Freq);
; 231  :         }
; 232  :         if (p[0].Freq == p[-1].Freq && p[0].Successor && !p[-1].Successor) {
; 233  :             STATE* p1=p;
; 234  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq == p1[-1].Freq && !p1[-1].Successor);
; 235  :         }
; 236  :     }
; 237  :     a=Stats->Freq+!Stats->Freq;             f=(64*EscFreq+(b=a >> 1))/a;
; 238  :     f=CLAMP(f,1,127) | 0x80*(Stats->Successor != NULL);
; 239  :     putc(f,fp);                             c=64;
; 240  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 241  :         f=(64*p->Freq+b)/a;                 f += !f;
; 242  :         if (p != Stats)
; 243  :             putc((c-f) | 0x80*(p->Successor != NULL),fp);
; 244  :         c=f;                                putc(p->Symbol,fp);
; 245  :     }
; 246  :     for (p=Stats;p <= Stats+NumStats;p++)
; 247  :             if ( p->Successor )             p->Successor->write(o+1,fp);
; 248  : }
; 249  : */
; 250  : void PPM_CONTEXT::refresh(int OldNU,BOOL Scale)
; 251  : {
; 252  :     int i=NumStats, EscFreq;
; 253  :     STATE* p = Stats = (STATE*) ShrinkUnits(Stats,OldNU,(i+2) >> 1);
; 254  :     Flags=(Flags & (0x10+0x04*Scale))+0x08*(p->Symbol >= 0x40);
; 255  :     EscFreq=SummFreq-p->Freq;
; 256  :     SummFreq = (p->Freq=(p->Freq+Scale) >> Scale);
; 257  :     do {
; 258  :         EscFreq -= (++p)->Freq;
; 259  :         SummFreq += (p->Freq=(p->Freq+Scale) >> Scale);
; 260  :         Flags |= 0x08*(p->Symbol >= 0x40);
; 261  :     } while ( --i );
; 262  :     SummFreq += (EscFreq=(EscFreq+Scale) >> Scale);
; 263  : }
; 264  : #define P_CALL(F) ( PrefetchData(p->Successor), \
; 265  :                     p->Successor=p->Successor->F(Order+1))
; 266  : PPM_CONTEXT* PPM_CONTEXT::cutOff(int Order)
; 267  : {
; 268  :     int i, tmp;
; 269  :     STATE* p;
; 270  :     if ( !NumStats ) {
; 271  :         if ((BYTE*) (p=&oneState())->Successor >= UnitsStart) {
; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);
; 273  :             else                            p->Successor=NULL;
; 274  :             if (!p->Successor && Order > O_BOUND)
; 275  :                     goto REMOVE;
; 276  :             return this;
; 277  :         } else {
; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;
; 279  :         }
; 280  :     }
; 281  :     PrefetchData(Stats);
; 282  :     Stats = (STATE*) MoveUnitsUp(Stats,tmp=(NumStats+2) >> 1);
; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)
; 284  :             if ((BYTE*) p->Successor < UnitsStart) {
; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);
; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);
; 287  :             else                            p->Successor=NULL;
; 288  :     if (i != NumStats && Order) {
; 289  :         NumStats=i;                         p=Stats;
; 290  :         if (i < 0) { FreeUnits(p,tmp);      goto REMOVE; }
; 291  :         else if (i == 0) {
; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);
; 293  :             StateCpy(oneState(),*p);        FreeUnits(p,tmp);
; 294  :             oneState().Freq=(oneState().Freq+11) >> 3;
; 295  :         } else                              refresh(tmp,SummFreq > 16*i);
; 296  :     }
; 297  :     return this;
; 298  : }
; 299  : PPM_CONTEXT* PPM_CONTEXT::removeBinConts(int Order)
; 300  : {
; 301  :     STATE* p;
; 302  :     if ( !NumStats ) {
; 303  :         p=&oneState();
; 304  :         if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 305  :                 P_CALL(removeBinConts);
; 306  :         else                                p->Successor=NULL;
; 307  :         if (!p->Successor && (!Suffix->NumStats || Suffix->Flags == 0xFF)) {
; 308  :             FreeUnits(this,1);              return NULL;
; 309  :         } else                              return this;
; 310  :     }
; 311  :     PrefetchData(Stats);
; 312  :     for (p=Stats+NumStats;p >= Stats;p--)
; 313  :             if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 314  :                     P_CALL(removeBinConts);
; 315  :             else                            p->Successor=NULL;
; 316  :     return this;
; 317  : }
; 318  : 
; 319  : static void RestoreModelRare(PPM_CONTEXT* pc1,PPM_CONTEXT* MinContext,
; 320  :         PPM_CONTEXT* FSuccessor)
; 321  : {
; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)
; 325  :             if (--(pc->NumStats) == 0) {
; 326  :                 pc->Flags=(pc->Flags & 0x10)+0x08*(pc->Stats->Symbol >= 0x40);
; 327  :                 p=pc->Stats;                StateCpy(pc->oneState(),*p);
; 328  :                 SpecialFreeUnit(p);
; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;
; 330  :             } else
; 331  :                     pc->refresh((pc->NumStats+3) >> 1,FALSE);
; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)
; 333  :             if ( !pc->NumStats )
; 334  :                     pc->oneState().Freq -= pc->oneState().Freq >> 1;
; 335  :             else if ((pc->SummFreq += 4) > 128+4*pc->NumStats)
; 336  :                     pc->refresh((pc->NumStats+2) >> 1,TRUE);
; 337  :     if (MRMethod > MRM_FREEZE) {
; 338  :         MaxContext=FSuccessor;              GlueCount += !(BList[1].Stamp & 1);
; 339  :     } else if (MRMethod == MRM_FREEZE) {
; 340  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 341  :         MaxContext->removeBinConts(0);      MRMethod=MR_METHOD(MRMethod+1);
; 342  :         GlueCount=0;                        OrderFall=MaxOrder;
; 343  : 	} else if (MRMethod == MRM_RESTART || GetUsedMemory() < (SubAllocatorSize >> 1)) {
; 344  :         StartModelRare(MaxOrder,MRMethod);
; 345  :         EscCount=0;                         PrintCount=0xFF;
; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 348  :         do {
; 349  :             MaxContext->cutOff(0);          ExpandTextArea();
; 350  : 		} while (GetUsedMemory() > 3*(SubAllocatorSize >> 2));
; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }
; 354  : 
; 355  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 356  :         PPM_CONTEXT* pc);
; 357  : static PPM_CONTEXT* _FASTCALL ReduceOrder(PPM_CONTEXT::STATE* p,PPM_CONTEXT* pc)
; 358  : {
; 359  :     PPM_CONTEXT::STATE* p1,  * ps[MAX_O], ** pps=ps;
; 360  :     PPM_CONTEXT* pc1=pc, * UpBranch = (PPM_CONTEXT*) pText;
; 361  :     BYTE tmp, sym=FoundState->Symbol;
; 362  :     *pps++ = FoundState;                    FoundState->Successor=UpBranch;
; 363  :     OrderFall++;
; 364  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 365  :     for ( ; ; ) {
; 366  :         if ( !pc->Suffix ) {
; 367  :             if (MRMethod > MRM_FREEZE) {
; 368  : FROZEN:         do { (*--pps)->Successor = pc; } while (pps != ps);
; 369  :                 pText=HeapStart+1;          OrderFall=1;
; 370  :             }
; 371  :             return pc;
; 372  :         }
; 373  :         pc=pc->Suffix;
; 374  :         if ( pc->NumStats ) {
; 375  :             if ((p=pc->Stats)->Symbol != sym)
; 376  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 377  :             tmp=2*(p->Freq < MAX_FREQ-9);
; 378  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }
; 380  : LOOP_ENTRY:
; 381  :         if ( p->Successor )                 break;
; 382  :         *pps++ = p;                         p->Successor=UpBranch;
; 383  :         OrderFall++;
; 384  :     }
; 385  :     if (MRMethod > MRM_FREEZE) {
; 386  :         pc = p->Successor;                  goto FROZEN;
; 387  :     } else if (p->Successor <= UpBranch) {
; 388  :         p1=FoundState;                      FoundState=p;
; 389  :         p->Successor=CreateSuccessors(FALSE,NULL,pc);
; 390  :         FoundState=p1;
; 391  :     }
; 392  :     if (OrderFall == 1 && pc1 == MaxContext) {
; 393  :         FoundState->Successor=p->Successor; pText--;
; 394  :     }
; 395  :     return p->Successor;
; 396  : }
; 397  : void PPM_CONTEXT::rescale()
; 398  : {
; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);
; 402  :     p->Freq += 4;                           SummFreq += 4;
; 403  :     EscFreq=SummFreq-p->Freq;
; 404  :     Adder=(OrderFall != 0 || MRMethod > MRM_FREEZE);
; 405  :     SummFreq = (p->Freq=(p->Freq+Adder) >> 1);
; 406  :     do {
; 407  :         EscFreq -= (++p)->Freq;
; 408  :         SummFreq += (p->Freq=(p->Freq+Adder) >> 1);
; 409  :         if (p[0].Freq > p[-1].Freq) {
; 410  :             StateCpy(tmp,*(p1=p));
; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);
; 412  :             StateCpy(*p1,tmp);
; 413  :         }
; 414  :     } while ( --i );
; 415  :     if (p->Freq == 0) {
; 416  :         do { i++; } while ((--p)->Freq == 0);
; 417  :         EscFreq += i;                       OldNU=(NumStats+2) >> 1;
; 418  :         if ((NumStats -= i) == 0) {
; 419  :             StateCpy(tmp,*Stats);
; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;
; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;
; 422  :             FreeUnits(Stats,OldNU);         StateCpy(oneState(),tmp);
; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);
; 424  :             FoundState=&oneState();         return;
; 425  :         }
; 426  :         Stats = (STATE*) ShrinkUnits(Stats,OldNU,(NumStats+2) >> 1);
; 427  :         Flags &= ~0x08;                     i=NumStats;
; 428  :         Flags |= 0x08*((p=Stats)->Symbol >= 0x40);
; 429  :         do { Flags |= 0x08*((++p)->Symbol >= 0x40); } while ( --i );
; 430  :     }
; 431  :     SummFreq += (EscFreq -= (EscFreq >> 1));
; 432  :     Flags |= 0x04;                          FoundState=Stats;
; 433  : }
; 434  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 435  :         PPM_CONTEXT* pc)
; 436  : {
; 437  : 
; 438  :     PPM_CONTEXT ct, * UpBranch=FoundState->Successor;
; 439  :     PPM_CONTEXT::STATE* ps[MAX_O], ** pps=ps;
; 440  :     UINT cf, s0;
; 441  :     BYTE tmp, sym=FoundState->Symbol;
; 442  :     if ( !Skip ) {
; 443  :         *pps++ = FoundState;
; 444  :         if ( !pc->Suffix )                  goto NO_LOOP;
; 445  :     }
; 446  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 447  :     do {
; 448  :         pc=pc->Suffix;
; 449  :         if ( pc->NumStats ) {
; 450  :             if ((p=pc->Stats)->Symbol != sym)
; 451  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 452  :             tmp=(p->Freq < MAX_FREQ-9);
; 453  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 454  :         } else {
; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));
; 457  :         }
; 458  : LOOP_ENTRY:
; 459  :         if (p->Successor != UpBranch) {
; 460  :             pc=p->Successor;                break;
; 461  :         }
; 462  :         *pps++ = p;
; 463  :     } while ( pc->Suffix );
; 464  : NO_LOOP:
; 465  :     if (pps == ps)                          return pc;
; 466  :     ct.NumStats=0;                          ct.Flags=0x10*(sym >= 0x40);
; 467  :     ct.oneState().Symbol=sym=*(BYTE*) UpBranch;
; 468  :     ct.oneState().Successor=(PPM_CONTEXT*) (((BYTE*) UpBranch)+1);
; 469  :     ct.Flags |= 0x08*(sym >= 0x40);
; 470  :     if ( pc->NumStats ) {
; 471  :         if ((p=pc->Stats)->Symbol != sym)
; 472  :                 do { tmp=p[1].Symbol;       p++; } while (tmp != sym);
; 473  :         s0=pc->SummFreq-pc->NumStats-(cf=p->Freq-1);
; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));
; 475  :     } else
; 476  :             ct.oneState().Freq=pc->oneState().Freq;
; 477  :     do {
; 478  :         PPM_CONTEXT* pc1 = (PPM_CONTEXT*) AllocContext();
; 479  :         if ( !pc1 )                         return NULL;
; 480  :         ((DWORD*) pc1)[0] = ((DWORD*) &ct)[0];
; 481  :         ((DWORD*) pc1)[1] = ((DWORD*) &ct)[1];
; 482  :         pc1->Suffix=pc;                     (*--pps)->Successor=pc=pc1;
; 483  :     } while (pps != ps);
; 484  :     return pc;
; 485  : }
; 486  : 
; 487  : 
; 488  : static inline void UpdateModel( PPM_CONTEXT* MinContext)
; 489  : {
; 490  :     PPM_CONTEXT::STATE* p           = NULL;
; 491  :     PPM_CONTEXT*        FSuccessor  = FoundState->Successor;
; 492  :     PPM_CONTEXT*        pc          = MinContext->Suffix;
; 493  :     PPM_CONTEXT*        pc1         = MaxContext;
; 494  :     
; 495  :     UINT ns1, ns, cf, sf, s0, FFreq=FoundState->Freq;
; 496  :     BYTE Flag, sym, FSymbol=FoundState->Symbol;
; 497  : 
; 498  : 
; 499  :     if( FFreq < MAX_FREQ/4  &&  pc ) 
; 500  :     {
; 501  :         if ( pc->NumStats ) 
; 502  :         {
; 503  :             if ((p=pc->Stats)->Symbol != FSymbol) 
; 504  :             {
; 505  :                 do { sym=p[1].Symbol;       p++; } while (sym != FSymbol);
; 506  :                 if (p[0].Freq >= p[-1].Freq) 
; 507  :                 {
; 508  :                     SWAP(p[0],p[-1]);       
; 509  :                     p--;
; 510  :                 }
; 511  :             }
; 512  :             cf=2*(p->Freq < MAX_FREQ-9);
; 513  :             p->Freq      += cf;                  
; 514  :             pc->SummFreq += cf;
; 515  :         } 
; 516  :         else 
; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 
; 520  :         }
; 521  :     }
; 522  :     
; 523  :     if( !OrderFall && FSuccessor) 
; 524  :     {
; 525  :         FoundState->Successor=CreateSuccessors(TRUE,p,MinContext);
; 526  :         if ( !FoundState->Successor )       
; 527  :             goto RESTART_MODEL;
; 528  :         MaxContext=FoundState->Successor;   
; 529  :         return;
; 530  :     }
; 531  : 
; 532  :     *pText++ = FSymbol;                     
; 533  : 
; 534  :     PPM_CONTEXT*    Successor = (PPM_CONTEXT*) pText;
; 535  :     
; 536  :     if (pText >= UnitsStart)                
; 537  :         goto RESTART_MODEL;
; 538  : 
; 539  : 
; 540  :     if( FSuccessor ) 
; 541  :     {
; 542  :         if ((BYTE*) FSuccessor < UnitsStart)
; 543  :             FSuccessor=CreateSuccessors(FALSE,p,MinContext);
; 544  :     } 
; 545  :     else
; 546  :     {
; 547  :         FSuccessor=ReduceOrder(p,MinContext);
; 548  :     }
; 549  :     
; 550  :     if( !FSuccessor )                          
; 551  :         goto RESTART_MODEL;
; 552  : 
; 553  : 
; 554  :     if( !--OrderFall ) 
; 555  :     {
; 556  :         Successor=FSuccessor;               
; 557  :         pText -= (MaxContext != MinContext);
; 558  :     } 
; 559  :     else if( MRMethod > MRM_FREEZE) 
; 560  :     {
; 561  :         Successor=FSuccessor;               
; 562  :         pText=HeapStart;
; 563  :         OrderFall=0;
; 564  :     }
; 565  :     
; 566  :     s0=MinContext->SummFreq-(ns=MinContext->NumStats)-FFreq;
; 567  :     for (Flag=0x08*(FSymbol >= 0x40);pc1 != MinContext;pc1=pc1->Suffix) 
; 568  :     {
; 569  :         if ((ns1=pc1->NumStats) != 0) 
; 570  :         {
; 571  :             if ((ns1 & 1) != 0) 
; 572  :             {
; 573  :                 p=(PPM_CONTEXT::STATE*) ExpandUnits(pc1->Stats,(ns1+1) >> 1);
; 574  :                 if ( !p )                   
; 575  :                     goto RESTART_MODEL;
; 576  :                 pc1->Stats=p;
; 577  :             }
; 578  :             pc1->SummFreq += (3*ns1+1 < ns);
; 579  :         } 
; 580  :         else 
; 581  :         {
; 582  :             p=(PPM_CONTEXT::STATE*) AllocUnits(1);
; 583  :             if ( !p )                       
; 584  :                 goto RESTART_MODEL;
; 585  :                 
; 586  :             StateCpy(*p,pc1->oneState());   
; 587  :             pc1->Stats=p;
; 588  :             
; 589  :             if (p->Freq < MAX_FREQ/4-1)     p->Freq += p->Freq;
; 590  :             else                            p->Freq  = MAX_FREQ-4;
; 591  :             
; 592  :             pc1->SummFreq=p->Freq+InitEsc+(ns > 2);
; 593  :         }
; 594  : 
; 595  :         cf=2*FFreq*(pc1->SummFreq+6);       
; 596  :         sf=s0+pc1->SummFreq;
; 597  : 
; 598  :         if (cf < 6*sf) 
; 599  :         {
; 600  :             cf=1+(cf > sf)+(cf >= 4*sf);
; 601  :             pc1->SummFreq += 4;
; 602  :         } 
; 603  :         else 
; 604  :         {
; 605  :             cf=4+(cf > 9*sf)+(cf > 12*sf)+(cf > 15*sf);
; 606  :             pc1->SummFreq += cf;
; 607  :         }
; 608  :         p=pc1->Stats+(++pc1->NumStats);     
; 609  :         p->Successor=Successor;
; 610  :         p->Symbol = FSymbol;                
; 611  :         p->Freq = cf;
; 612  :         pc1->Flags |= Flag;
; 613  :     }
; 614  : 
; 615  :     MaxContext=FSuccessor;
; 616  :     return;
; 617  : 
; 618  : RESTART_MODEL:
; 619  :     RestoreModelRare(pc1,MinContext,FSuccessor);
; 620  : 
; 621  : }
; 622  : // Tabulated escapes for exponential symbol distribution
; 623  : static const BYTE ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
; 624  : #define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))
; 625  : inline void PPM_CONTEXT::encodeBinSymbol(int symbol)
; 626  : {
; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 630  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 631  :     if (rs.Symbol == symbol) {
; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 633  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 634  :         PrevSuccess=1;                      RunLength++;
; 635  :     } else {
; 636  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 637  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 638  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 639  :     }
; 640  : }
; 641  : inline void PPM_CONTEXT::decodeBinSymbol() const
; 642  : {
; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 647  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 648  :     if ( !rcBinDecode(tmp) ) {
; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 650  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 651  :         PrevSuccess=1;                      RunLength++;
; 652  :     } else {
; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 654  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 656  :     }
; 657  : }
; 658  : inline void PPM_CONTEXT::update1(STATE* p) 
; 659  : {
; 660  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	mov	QWORD PTR FoundState, r8

; 713  :         }
; 714  :     SubRange.low=(SubRange.high=HiCnt)-p->Freq;   

	sub	r10d, eax

; 100  : }
; 101  : inline void StateCpy(PPM_CONTEXT::STATE& s1,const PPM_CONTEXT::STATE& s2)
; 102  : {
; 103  :     (WORD&) s1=(WORD&) s2;                  
; 104  :     s1.Successor=s2.Successor;
; 105  : }
; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;
; 107  : inline PPMD_STARTUP::PPMD_STARTUP()         // constants initialization
; 108  : {
; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;
; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;
; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;
; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;
; 114  :     for (k=i=0;k < 128;k++) {
; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;
; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);
; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;
; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {
; 121  :         QTable[i]=m;
; 122  :         if ( !--k ) { k = ++Step;           m++; }
; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;
; 125  : }
; 126  : 
; 127  : 
; 128  : void PPM_CONTEXT::makeSuffix()
; 129  : {
; 130  :     STATE* p, * p1;
; 131  :     if ( !NumStats ) 
; 132  :     {
; 133  :         if ( !(p=&oneState())->Successor )  return;
; 134  : 
; 135  :         if ( !Suffix->NumStats )            
; 136  :         {
; 137  :             p1=&(Suffix->oneState());
; 138  :         }
; 139  :         else
; 140  :         {
; 141  :             for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 142  :                 ;
; 143  :         }
; 144  :         
; 145  :         p->Successor->Suffix = p1->Successor; 
; 146  :         p->Successor->makeSuffix();
; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 
; 151  :         {
; 152  :             if ( !p->Successor )            
; 153  :                 continue;
; 154  : 
; 155  :             if ( !Suffix )                  
; 156  :             {
; 157  :                 p->Successor->Suffix=this;
; 158  :             }
; 159  :             else 
; 160  :             {
; 161  :                 for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 162  :                     ;
; 163  :                 p->Successor->Suffix=p1->Successor;
; 164  :             }
; 165  :             p->Successor->makeSuffix();
; 166  :         }
; 167  :     }
; 168  : }
; 169  : 
; 170  : void PPM_CONTEXT::read(_PPMD_FILE* fp,UINT PrevSym)
; 171  : {
; 172  :     STATE* p;                               Suffix=NULL;
; 173  :     NumStats=_PPMD_E_GETC(fp);                     Flags=0x10*(PrevSym >= 0x40);
; 174  :     if ( !NumStats ) {
; 175  :         p=&oneState();                      p->Freq=_PPMD_E_GETC(fp);
; 176  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 177  :         if ((p->Freq & 0x80) != 0) {
; 178  :             p->Freq &= ~0x80;
; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 180  :             p->Successor->read(fp,p->Symbol);
; 181  :         } else                              p->Successor=NULL;
; 182  :         return;
; 183  :     }
; 184  :     Stats = (PPM_CONTEXT::STATE*) AllocUnits((NumStats+2) >> 1);
; 185  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 186  :         p->Freq=_PPMD_E_GETC(fp);
; 187  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 188  :     }
; 189  :     int EscFreq=SummFreq=(Stats->Freq & ~0x80);
; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);
; 191  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 192  :         if ((p->Freq & 0x80) != 0) {
; 193  :             p->Freq &= ~0x80;
; 194  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 195  :             p->Successor->read(fp,p->Symbol);
; 196  :         } else                              p->Successor=NULL;
; 197  :         p->Freq=(p == Stats)?(64):(p[-1].Freq-p[0].Freq);
; 198  :         SummFreq += p->Freq;
; 199  :     }
; 200  :     if (EscFreq > 32) {
; 201  :         SummFreq=(EscFreq >> 1);
; 202  :         for (p=Stats;p <= Stats+NumStats;p++)
; 203  :                 SummFreq += (p->Freq -= (3*p->Freq) >> 2);
; 204  :     }
; 205  : }
; 206  : /*
; 207  : void
; 208  : PPM_CONTEXT::write( int o, FILE* fp )
; 209  : {
; 210  :     int EscFreq = EscCount; //(Stats)  ? Stats->Freq & ~0x80  : 0;
; 211  :     int nc      = 0;
; 212  : 
; 213  :     STATE* p;
; 214  :     int f, a, b, c;
; 215  :     if (nc < o)                             
; 216  :         nc=o;
; 217  :         
; 218  :     putc(NumStats,fp);
; 219  :     if ( !NumStats ) {
; 220  :         f=(p=&oneState())->Freq;
; 221  :         if ( EscFreq )                      f=(2*f)/EscFreq;
; 222  :         f=CLAMP(f,1,127) | 0x80*(p->Successor != NULL);
; 223  :         putc(f,fp);                         putc(p->Symbol,fp);
; 224  :         if ( p->Successor )                 p->Successor->write(o+1,fp);
; 225  :         return;
; 226  :     }
; 227  :     for (p=Stats+1;p <= Stats+NumStats;p++) {
; 228  :         if (p[0].Freq > p[-1].Freq) {
; 229  :             STATE* p1=p;
; 230  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq > p1[-1].Freq);
; 231  :         }
; 232  :         if (p[0].Freq == p[-1].Freq && p[0].Successor && !p[-1].Successor) {
; 233  :             STATE* p1=p;
; 234  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq == p1[-1].Freq && !p1[-1].Successor);
; 235  :         }
; 236  :     }
; 237  :     a=Stats->Freq+!Stats->Freq;             f=(64*EscFreq+(b=a >> 1))/a;
; 238  :     f=CLAMP(f,1,127) | 0x80*(Stats->Successor != NULL);
; 239  :     putc(f,fp);                             c=64;
; 240  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 241  :         f=(64*p->Freq+b)/a;                 f += !f;
; 242  :         if (p != Stats)
; 243  :             putc((c-f) | 0x80*(p->Successor != NULL),fp);
; 244  :         c=f;                                putc(p->Symbol,fp);
; 245  :     }
; 246  :     for (p=Stats;p <= Stats+NumStats;p++)
; 247  :             if ( p->Successor )             p->Successor->write(o+1,fp);
; 248  : }
; 249  : */
; 250  : void PPM_CONTEXT::refresh(int OldNU,BOOL Scale)
; 251  : {
; 252  :     int i=NumStats, EscFreq;
; 253  :     STATE* p = Stats = (STATE*) ShrinkUnits(Stats,OldNU,(i+2) >> 1);
; 254  :     Flags=(Flags & (0x10+0x04*Scale))+0x08*(p->Symbol >= 0x40);
; 255  :     EscFreq=SummFreq-p->Freq;
; 256  :     SummFreq = (p->Freq=(p->Freq+Scale) >> Scale);
; 257  :     do {
; 258  :         EscFreq -= (++p)->Freq;
; 259  :         SummFreq += (p->Freq=(p->Freq+Scale) >> Scale);
; 260  :         Flags |= 0x08*(p->Symbol >= 0x40);
; 261  :     } while ( --i );
; 262  :     SummFreq += (EscFreq=(EscFreq+Scale) >> Scale);
; 263  : }
; 264  : #define P_CALL(F) ( PrefetchData(p->Successor), \
; 265  :                     p->Successor=p->Successor->F(Order+1))
; 266  : PPM_CONTEXT* PPM_CONTEXT::cutOff(int Order)
; 267  : {
; 268  :     int i, tmp;
; 269  :     STATE* p;
; 270  :     if ( !NumStats ) {
; 271  :         if ((BYTE*) (p=&oneState())->Successor >= UnitsStart) {
; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);
; 273  :             else                            p->Successor=NULL;
; 274  :             if (!p->Successor && Order > O_BOUND)
; 275  :                     goto REMOVE;
; 276  :             return this;
; 277  :         } else {
; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;
; 279  :         }
; 280  :     }
; 281  :     PrefetchData(Stats);
; 282  :     Stats = (STATE*) MoveUnitsUp(Stats,tmp=(NumStats+2) >> 1);
; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)
; 284  :             if ((BYTE*) p->Successor < UnitsStart) {
; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);
; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);
; 287  :             else                            p->Successor=NULL;
; 288  :     if (i != NumStats && Order) {
; 289  :         NumStats=i;                         p=Stats;
; 290  :         if (i < 0) { FreeUnits(p,tmp);      goto REMOVE; }
; 291  :         else if (i == 0) {
; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);
; 293  :             StateCpy(oneState(),*p);        FreeUnits(p,tmp);
; 294  :             oneState().Freq=(oneState().Freq+11) >> 3;
; 295  :         } else                              refresh(tmp,SummFreq > 16*i);
; 296  :     }
; 297  :     return this;
; 298  : }
; 299  : PPM_CONTEXT* PPM_CONTEXT::removeBinConts(int Order)
; 300  : {
; 301  :     STATE* p;
; 302  :     if ( !NumStats ) {
; 303  :         p=&oneState();
; 304  :         if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 305  :                 P_CALL(removeBinConts);
; 306  :         else                                p->Successor=NULL;
; 307  :         if (!p->Successor && (!Suffix->NumStats || Suffix->Flags == 0xFF)) {
; 308  :             FreeUnits(this,1);              return NULL;
; 309  :         } else                              return this;
; 310  :     }
; 311  :     PrefetchData(Stats);
; 312  :     for (p=Stats+NumStats;p >= Stats;p--)
; 313  :             if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 314  :                     P_CALL(removeBinConts);
; 315  :             else                            p->Successor=NULL;
; 316  :     return this;
; 317  : }
; 318  : 
; 319  : static void RestoreModelRare(PPM_CONTEXT* pc1,PPM_CONTEXT* MinContext,
; 320  :         PPM_CONTEXT* FSuccessor)
; 321  : {
; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)
; 325  :             if (--(pc->NumStats) == 0) {
; 326  :                 pc->Flags=(pc->Flags & 0x10)+0x08*(pc->Stats->Symbol >= 0x40);
; 327  :                 p=pc->Stats;                StateCpy(pc->oneState(),*p);
; 328  :                 SpecialFreeUnit(p);
; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;
; 330  :             } else
; 331  :                     pc->refresh((pc->NumStats+3) >> 1,FALSE);
; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)
; 333  :             if ( !pc->NumStats )
; 334  :                     pc->oneState().Freq -= pc->oneState().Freq >> 1;
; 335  :             else if ((pc->SummFreq += 4) > 128+4*pc->NumStats)
; 336  :                     pc->refresh((pc->NumStats+2) >> 1,TRUE);
; 337  :     if (MRMethod > MRM_FREEZE) {
; 338  :         MaxContext=FSuccessor;              GlueCount += !(BList[1].Stamp & 1);
; 339  :     } else if (MRMethod == MRM_FREEZE) {
; 340  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 341  :         MaxContext->removeBinConts(0);      MRMethod=MR_METHOD(MRMethod+1);
; 342  :         GlueCount=0;                        OrderFall=MaxOrder;
; 343  : 	} else if (MRMethod == MRM_RESTART || GetUsedMemory() < (SubAllocatorSize >> 1)) {
; 344  :         StartModelRare(MaxOrder,MRMethod);
; 345  :         EscCount=0;                         PrintCount=0xFF;
; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 348  :         do {
; 349  :             MaxContext->cutOff(0);          ExpandTextArea();
; 350  : 		} while (GetUsedMemory() > 3*(SubAllocatorSize >> 2));
; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }
; 354  : 
; 355  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 356  :         PPM_CONTEXT* pc);
; 357  : static PPM_CONTEXT* _FASTCALL ReduceOrder(PPM_CONTEXT::STATE* p,PPM_CONTEXT* pc)
; 358  : {
; 359  :     PPM_CONTEXT::STATE* p1,  * ps[MAX_O], ** pps=ps;
; 360  :     PPM_CONTEXT* pc1=pc, * UpBranch = (PPM_CONTEXT*) pText;
; 361  :     BYTE tmp, sym=FoundState->Symbol;
; 362  :     *pps++ = FoundState;                    FoundState->Successor=UpBranch;
; 363  :     OrderFall++;
; 364  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 365  :     for ( ; ; ) {
; 366  :         if ( !pc->Suffix ) {
; 367  :             if (MRMethod > MRM_FREEZE) {
; 368  : FROZEN:         do { (*--pps)->Successor = pc; } while (pps != ps);
; 369  :                 pText=HeapStart+1;          OrderFall=1;
; 370  :             }
; 371  :             return pc;
; 372  :         }
; 373  :         pc=pc->Suffix;
; 374  :         if ( pc->NumStats ) {
; 375  :             if ((p=pc->Stats)->Symbol != sym)
; 376  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 377  :             tmp=2*(p->Freq < MAX_FREQ-9);
; 378  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }
; 380  : LOOP_ENTRY:
; 381  :         if ( p->Successor )                 break;
; 382  :         *pps++ = p;                         p->Successor=UpBranch;
; 383  :         OrderFall++;
; 384  :     }
; 385  :     if (MRMethod > MRM_FREEZE) {
; 386  :         pc = p->Successor;                  goto FROZEN;
; 387  :     } else if (p->Successor <= UpBranch) {
; 388  :         p1=FoundState;                      FoundState=p;
; 389  :         p->Successor=CreateSuccessors(FALSE,NULL,pc);
; 390  :         FoundState=p1;
; 391  :     }
; 392  :     if (OrderFall == 1 && pc1 == MaxContext) {
; 393  :         FoundState->Successor=p->Successor; pText--;
; 394  :     }
; 395  :     return p->Successor;
; 396  : }
; 397  : void PPM_CONTEXT::rescale()
; 398  : {
; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);
; 402  :     p->Freq += 4;                           SummFreq += 4;
; 403  :     EscFreq=SummFreq-p->Freq;
; 404  :     Adder=(OrderFall != 0 || MRMethod > MRM_FREEZE);
; 405  :     SummFreq = (p->Freq=(p->Freq+Adder) >> 1);
; 406  :     do {
; 407  :         EscFreq -= (++p)->Freq;
; 408  :         SummFreq += (p->Freq=(p->Freq+Adder) >> 1);
; 409  :         if (p[0].Freq > p[-1].Freq) {
; 410  :             StateCpy(tmp,*(p1=p));
; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);
; 412  :             StateCpy(*p1,tmp);
; 413  :         }
; 414  :     } while ( --i );
; 415  :     if (p->Freq == 0) {
; 416  :         do { i++; } while ((--p)->Freq == 0);
; 417  :         EscFreq += i;                       OldNU=(NumStats+2) >> 1;
; 418  :         if ((NumStats -= i) == 0) {
; 419  :             StateCpy(tmp,*Stats);
; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;
; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;
; 422  :             FreeUnits(Stats,OldNU);         StateCpy(oneState(),tmp);
; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);
; 424  :             FoundState=&oneState();         return;
; 425  :         }
; 426  :         Stats = (STATE*) ShrinkUnits(Stats,OldNU,(NumStats+2) >> 1);
; 427  :         Flags &= ~0x08;                     i=NumStats;
; 428  :         Flags |= 0x08*((p=Stats)->Symbol >= 0x40);
; 429  :         do { Flags |= 0x08*((++p)->Symbol >= 0x40); } while ( --i );
; 430  :     }
; 431  :     SummFreq += (EscFreq -= (EscFreq >> 1));
; 432  :     Flags |= 0x04;                          FoundState=Stats;
; 433  : }
; 434  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 435  :         PPM_CONTEXT* pc)
; 436  : {
; 437  : 
; 438  :     PPM_CONTEXT ct, * UpBranch=FoundState->Successor;
; 439  :     PPM_CONTEXT::STATE* ps[MAX_O], ** pps=ps;
; 440  :     UINT cf, s0;
; 441  :     BYTE tmp, sym=FoundState->Symbol;
; 442  :     if ( !Skip ) {
; 443  :         *pps++ = FoundState;
; 444  :         if ( !pc->Suffix )                  goto NO_LOOP;
; 445  :     }
; 446  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 447  :     do {
; 448  :         pc=pc->Suffix;
; 449  :         if ( pc->NumStats ) {
; 450  :             if ((p=pc->Stats)->Symbol != sym)
; 451  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 452  :             tmp=(p->Freq < MAX_FREQ-9);
; 453  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 454  :         } else {
; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));
; 457  :         }
; 458  : LOOP_ENTRY:
; 459  :         if (p->Successor != UpBranch) {
; 460  :             pc=p->Successor;                break;
; 461  :         }
; 462  :         *pps++ = p;
; 463  :     } while ( pc->Suffix );
; 464  : NO_LOOP:
; 465  :     if (pps == ps)                          return pc;
; 466  :     ct.NumStats=0;                          ct.Flags=0x10*(sym >= 0x40);
; 467  :     ct.oneState().Symbol=sym=*(BYTE*) UpBranch;
; 468  :     ct.oneState().Successor=(PPM_CONTEXT*) (((BYTE*) UpBranch)+1);
; 469  :     ct.Flags |= 0x08*(sym >= 0x40);
; 470  :     if ( pc->NumStats ) {
; 471  :         if ((p=pc->Stats)->Symbol != sym)
; 472  :                 do { tmp=p[1].Symbol;       p++; } while (tmp != sym);
; 473  :         s0=pc->SummFreq-pc->NumStats-(cf=p->Freq-1);
; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));
; 475  :     } else
; 476  :             ct.oneState().Freq=pc->oneState().Freq;
; 477  :     do {
; 478  :         PPM_CONTEXT* pc1 = (PPM_CONTEXT*) AllocContext();
; 479  :         if ( !pc1 )                         return NULL;
; 480  :         ((DWORD*) pc1)[0] = ((DWORD*) &ct)[0];
; 481  :         ((DWORD*) pc1)[1] = ((DWORD*) &ct)[1];
; 482  :         pc1->Suffix=pc;                     (*--pps)->Successor=pc=pc1;
; 483  :     } while (pps != ps);
; 484  :     return pc;
; 485  : }
; 486  : 
; 487  : 
; 488  : static inline void UpdateModel( PPM_CONTEXT* MinContext)
; 489  : {
; 490  :     PPM_CONTEXT::STATE* p           = NULL;
; 491  :     PPM_CONTEXT*        FSuccessor  = FoundState->Successor;
; 492  :     PPM_CONTEXT*        pc          = MinContext->Suffix;
; 493  :     PPM_CONTEXT*        pc1         = MaxContext;
; 494  :     
; 495  :     UINT ns1, ns, cf, sf, s0, FFreq=FoundState->Freq;
; 496  :     BYTE Flag, sym, FSymbol=FoundState->Symbol;
; 497  : 
; 498  : 
; 499  :     if( FFreq < MAX_FREQ/4  &&  pc ) 
; 500  :     {
; 501  :         if ( pc->NumStats ) 
; 502  :         {
; 503  :             if ((p=pc->Stats)->Symbol != FSymbol) 
; 504  :             {
; 505  :                 do { sym=p[1].Symbol;       p++; } while (sym != FSymbol);
; 506  :                 if (p[0].Freq >= p[-1].Freq) 
; 507  :                 {
; 508  :                     SWAP(p[0],p[-1]);       
; 509  :                     p--;
; 510  :                 }
; 511  :             }
; 512  :             cf=2*(p->Freq < MAX_FREQ-9);
; 513  :             p->Freq      += cf;                  
; 514  :             pc->SummFreq += cf;
; 515  :         } 
; 516  :         else 
; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 
; 520  :         }
; 521  :     }
; 522  :     
; 523  :     if( !OrderFall && FSuccessor) 
; 524  :     {
; 525  :         FoundState->Successor=CreateSuccessors(TRUE,p,MinContext);
; 526  :         if ( !FoundState->Successor )       
; 527  :             goto RESTART_MODEL;
; 528  :         MaxContext=FoundState->Successor;   
; 529  :         return;
; 530  :     }
; 531  : 
; 532  :     *pText++ = FSymbol;                     
; 533  : 
; 534  :     PPM_CONTEXT*    Successor = (PPM_CONTEXT*) pText;
; 535  :     
; 536  :     if (pText >= UnitsStart)                
; 537  :         goto RESTART_MODEL;
; 538  : 
; 539  : 
; 540  :     if( FSuccessor ) 
; 541  :     {
; 542  :         if ((BYTE*) FSuccessor < UnitsStart)
; 543  :             FSuccessor=CreateSuccessors(FALSE,p,MinContext);
; 544  :     } 
; 545  :     else
; 546  :     {
; 547  :         FSuccessor=ReduceOrder(p,MinContext);
; 548  :     }
; 549  :     
; 550  :     if( !FSuccessor )                          
; 551  :         goto RESTART_MODEL;
; 552  : 
; 553  : 
; 554  :     if( !--OrderFall ) 
; 555  :     {
; 556  :         Successor=FSuccessor;               
; 557  :         pText -= (MaxContext != MinContext);
; 558  :     } 
; 559  :     else if( MRMethod > MRM_FREEZE) 
; 560  :     {
; 561  :         Successor=FSuccessor;               
; 562  :         pText=HeapStart;
; 563  :         OrderFall=0;
; 564  :     }
; 565  :     
; 566  :     s0=MinContext->SummFreq-(ns=MinContext->NumStats)-FFreq;
; 567  :     for (Flag=0x08*(FSymbol >= 0x40);pc1 != MinContext;pc1=pc1->Suffix) 
; 568  :     {
; 569  :         if ((ns1=pc1->NumStats) != 0) 
; 570  :         {
; 571  :             if ((ns1 & 1) != 0) 
; 572  :             {
; 573  :                 p=(PPM_CONTEXT::STATE*) ExpandUnits(pc1->Stats,(ns1+1) >> 1);
; 574  :                 if ( !p )                   
; 575  :                     goto RESTART_MODEL;
; 576  :                 pc1->Stats=p;
; 577  :             }
; 578  :             pc1->SummFreq += (3*ns1+1 < ns);
; 579  :         } 
; 580  :         else 
; 581  :         {
; 582  :             p=(PPM_CONTEXT::STATE*) AllocUnits(1);
; 583  :             if ( !p )                       
; 584  :                 goto RESTART_MODEL;
; 585  :                 
; 586  :             StateCpy(*p,pc1->oneState());   
; 587  :             pc1->Stats=p;
; 588  :             
; 589  :             if (p->Freq < MAX_FREQ/4-1)     p->Freq += p->Freq;
; 590  :             else                            p->Freq  = MAX_FREQ-4;
; 591  :             
; 592  :             pc1->SummFreq=p->Freq+InitEsc+(ns > 2);
; 593  :         }
; 594  : 
; 595  :         cf=2*FFreq*(pc1->SummFreq+6);       
; 596  :         sf=s0+pc1->SummFreq;
; 597  : 
; 598  :         if (cf < 6*sf) 
; 599  :         {
; 600  :             cf=1+(cf > sf)+(cf >= 4*sf);
; 601  :             pc1->SummFreq += 4;
; 602  :         } 
; 603  :         else 
; 604  :         {
; 605  :             cf=4+(cf > 9*sf)+(cf > 12*sf)+(cf > 15*sf);
; 606  :             pc1->SummFreq += cf;
; 607  :         }
; 608  :         p=pc1->Stats+(++pc1->NumStats);     
; 609  :         p->Successor=Successor;
; 610  :         p->Symbol = FSymbol;                
; 611  :         p->Freq = cf;
; 612  :         pc1->Flags |= Flag;
; 613  :     }
; 614  : 
; 615  :     MaxContext=FSuccessor;
; 616  :     return;
; 617  : 
; 618  : RESTART_MODEL:
; 619  :     RestoreModelRare(pc1,MinContext,FSuccessor);
; 620  : 
; 621  : }
; 622  : // Tabulated escapes for exponential symbol distribution
; 623  : static const BYTE ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
; 624  : #define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))
; 625  : inline void PPM_CONTEXT::encodeBinSymbol(int symbol)
; 626  : {
; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 630  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 631  :     if (rs.Symbol == symbol) {
; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 633  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 634  :         PrevSuccess=1;                      RunLength++;
; 635  :     } else {
; 636  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 637  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 638  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 639  :     }
; 640  : }
; 641  : inline void PPM_CONTEXT::decodeBinSymbol() const
; 642  : {
; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 647  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 648  :     if ( !rcBinDecode(tmp) ) {
; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 650  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 651  :         PrevSuccess=1;                      RunLength++;
; 652  :     } else {
; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 654  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 656  :     }
; 657  : }
; 658  : inline void PPM_CONTEXT::update1(STATE* p) 
; 659  : {
; 660  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	add	al, 4
	mov	BYTE PTR [r8+1], al
	add	WORD PTR [r11+2], 4

; 661  :     if (p[0].Freq > p[-1].Freq) {

	movzx	eax, BYTE PTR [r8-9]

; 713  :         }
; 714  :     SubRange.low=(SubRange.high=HiCnt)-p->Freq;   

	mov	DWORD PTR SubRange, r10d

; 661  :     if (p[0].Freq > p[-1].Freq) {

	cmp	BYTE PTR [r8+1], al
	jbe	SHORT $LN16@decodeSymb

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	movzx	eax, WORD PTR [r8-10]
	movzx	edx, WORD PTR [r8]
	mov	rcx, QWORD PTR [r8+2]

; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;

	lea	r9, QWORD PTR [r8-10]

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	mov	WORD PTR [r8], ax
	mov	rax, QWORD PTR [r9+2]

; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;

	mov	QWORD PTR FoundState, r9

; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;

	mov	QWORD PTR [r8+2], rax

; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;

	mov	WORD PTR [r9], dx
	mov	QWORD PTR [r9+2], rcx

; 663  :         if (p->Freq > MAX_FREQ)             rescale();

	cmp	BYTE PTR [r9+1], 124			; 0000007cH
	jbe	SHORT $LN16@decodeSymb
	mov	rcx, r11

; 715  :     ((PPM_CONTEXT*)this)->update1(p);
; 716  : }

	add	rsp, 32					; 00000020H
	pop	rbx

; 663  :         if (p->Freq > MAX_FREQ)             rescale();

	jmp	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN16@decodeSymb:

; 715  :     ((PPM_CONTEXT*)this)->update1(p);
; 716  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN24@decodeSymb:

; 708  :             if ( Suffix )                   PrefetchData(Suffix);

	mov	rax, QWORD PTR [r11+12]
	test	rax, rax
	je	SHORT $LN14@decodeSymb
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rax]
	mov	ebx, DWORD PTR SubRange+8
$LN14@decodeSymb:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 709  :             SubRange.low=HiCnt;                CharMask[p->Symbol]=EscCount;

	movzx	eax, BYTE PTR [r8]
	movzx	edx, BYTE PTR EscCount
	lea	r9, OFFSET FLAT:CharMask
	mov	BYTE PTR [rax+r9], dl

; 710  :             i=NumMasked=NumStats;           FoundState=NULL;

	movzx	eax, BYTE PTR [r11]
	mov	DWORD PTR SubRange, r10d
	mov	BYTE PTR NumMasked, al
	mov	ecx, eax
	mov	QWORD PTR FoundState, 0
	npad	6
$LL3@decodeSymb:

; 711  :             do { CharMask[(--p)->Symbol]=EscCount; } while ( --i );

	movzx	eax, BYTE PTR [r8-10]
	lea	r8, QWORD PTR [r8-10]
	mov	BYTE PTR [rax+r9], dl
	dec	ecx
	jne	SHORT $LL3@decodeSymb

; 712  :             SubRange.high=SubRange.scale;         return;

	mov	DWORD PTR SubRange+4, ebx

; 715  :     ((PPM_CONTEXT*)this)->update1(p);
; 716  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?decodeSymbol1@PPM_CONTEXT@@QEAAXXZ ENDP		; PPM_CONTEXT::decodeSymbol1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z
_TEXT	SEGMENT
this$ = 48
p$ = 56
?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z PROC		; PPM_CONTEXT::update2, COMDAT

; 718  : {

$LN6:
	sub	rsp, 40					; 00000028H

; 719  : /*
; 720  :     ++EscCount;
; 721  :     RunLength = InitRL;
; 722  : */
; 723  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	add	BYTE PTR [rdx+1], 4
	add	WORD PTR [rcx+2], 4

; 724  :     if (p->Freq > MAX_FREQ)                 rescale();

	cmp	BYTE PTR [rdx+1], 124			; 0000007cH
	mov	QWORD PTR FoundState, rdx
	jbe	SHORT $LN4@update2
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN4@update2:

; 725  :     EscCount++;                             RunLength=InitRL;

	mov	eax, DWORD PTR InitRL
	inc	BYTE PTR EscCount
	mov	DWORD PTR RunLength, eax

; 726  : }

	add	rsp, 40					; 00000028H
	ret	0
?update2@PPM_CONTEXT@@QEAAXPEAUSTATE@1@@Z ENDP		; PPM_CONTEXT::update2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ
_TEXT	SEGMENT
this$ = 8
?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ PROC ; PPM_CONTEXT::makeEscFreq2, COMDAT

; 729  :     BYTE* pb=(BYTE*) Stats;                 UINT t=2*NumStats;

	movzx	edx, BYTE PTR [rcx]
	mov	r9, QWORD PTR [rcx+4]
	mov	r11, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [r9]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 729  :     BYTE* pb=(BYTE*) Stats;                 UINT t=2*NumStats;

	add	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [rdx+r9]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 730  :     PrefetchData(pb);                       PrefetchData(pb+t);

	mov	r8d, edx

; 731  :     PrefetchData(pb += 2*t);                PrefetchData(pb+t);

	add	edx, edx
	add	r9, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;

	movzx	eax, BYTE PTR [r9]
	movzx	eax, BYTE PTR [r8+r9]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 733  :     if (NumStats != 0xFF) {

	cmp	BYTE PTR [rcx], 255			; 000000ffH
	je	$LN2@makeEscFre

; 734  :         t=Suffix->NumStats;

	mov	rax, QWORD PTR [rcx+12]

; 735  :         psee2c=SEE2Cont[QTable[NumStats+2]-3]+(SummFreq > 11*(NumStats+1));
; 736  :         psee2c += 2*(2*NumStats < t+NumMasked)+Flags;

	movzx	r8d, BYTE PTR [rcx]
	xor	r10d, r10d
	movzx	edx, BYTE PTR [rax]
	movzx	eax, BYTE PTR NumMasked
	mov	ecx, r10d
	add	edx, eax
	lea	eax, DWORD PTR [r8+r8]
	cmp	eax, edx
	movzx	eax, BYTE PTR [r11+1]
	mov	edx, r10d
	setb	cl
	lea	ecx, DWORD PTR [rax+rcx*2]
	lea	eax, DWORD PTR [r8+1]
	movsxd	r9, ecx
	imul	ecx, eax, 11
	movzx	eax, WORD PTR [r11+2]
	cmp	eax, ecx
	movzx	eax, BYTE PTR [r11]
	setg	dl
	add	r9, rdx
	lea	rdx, OFFSET FLAT:__ImageBase
	movzx	eax, BYTE PTR QTable[rax+rdx+2]
	sub	eax, 3
	movsxd	rcx, eax
	lea	rax, QWORD PTR ?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A[rdx]
	shl	rcx, 5
	add	r9, rcx

; 38   :         UINT RetVal=(Summ >> Shift);        Summ -= RetVal;

	movzx	ecx, BYTE PTR [rax+r9*4+2]
	movzx	edx, WORD PTR [rax+r9*4]

; 735  :         psee2c=SEE2Cont[QTable[NumStats+2]-3]+(SummFreq > 11*(NumStats+1));
; 736  :         psee2c += 2*(2*NumStats < t+NumMasked)+Flags;

	lea	rax, QWORD PTR [rax+r9*4]

; 38   :         UINT RetVal=(Summ >> Shift);        Summ -= RetVal;

	mov	r8d, edx
	shr	r8d, cl
	sub	dx, r8w

; 39   :         return RetVal+(RetVal == 0);

	test	r8d, r8d
	sete	r10b
	mov	WORD PTR [rax], dx
	add	r10d, r8d

; 737  :         SubRange.scale=psee2c->getMean();

	mov	DWORD PTR SubRange+8, r10d

; 742  : }

	ret	0
$LN2@makeEscFre:

; 738  :     } else {
; 739  :         psee2c=&DummySEE2Cont;              SubRange.scale=1;

	mov	DWORD PTR SubRange+8, 1

; 740  :     }
; 741  :     return psee2c;

	lea	rax, OFFSET FLAT:?DummySEE2Cont@@3USEE2_CONTEXT@@A ; DummySEE2Cont

; 742  : }

	ret	0
?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ ENDP ; PPM_CONTEXT::makeEscFreq2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
symbol$ = 56
?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z PROC		; PPM_CONTEXT::encodeSymbol2, COMDAT

; 744  : {

$LN38:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rsi, rcx

; 745  :     SEE2_CONTEXT* psee2c=makeEscFreq2();

	call	?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ ; PPM_CONTEXT::makeEscFreq2

; 746  :     UINT Sym, LoCnt=0, i=NumStats-NumMasked;

	movzx	r8d, BYTE PTR NumMasked
	movzx	r10d, BYTE PTR [rsi]

; 747  :     STATE* p1, * p=Stats-1;

	movzx	ebx, BYTE PTR EscCount
	sub	r10d, r8d
	mov	r8, QWORD PTR [rsi+4]
	xor	r9d, r9d
	mov	r11, rax
	lea	rbp, OFFSET FLAT:CharMask
	sub	r8, 10
	npad	7
$LL10@encodeSymb:

; 748  :     do {
; 749  :         do { Sym=p[1].Symbol;   p++; } while (CharMask[Sym] == EscCount);

	movzx	ecx, BYTE PTR [r8+10]
	add	r8, 10
	cmp	BYTE PTR [rcx+rbp], bl
	je	SHORT $LL10@encodeSymb

; 750  :         CharMask[Sym]=EscCount;

	mov	BYTE PTR [rcx+rbp], bl

; 751  :         if (Sym == symbol)                  goto SYMBOL_FOUND;
; 752  :         LoCnt += p->Freq;

	movzx	eax, BYTE PTR [r8+1]
	cmp	ecx, edi
	je	SHORT $SYMBOL_FOUND$39
	add	r9d, eax

; 753  :     } while ( --i );

	dec	r10d
	jne	SHORT $LL10@encodeSymb

; 754  :     SubRange.high=(SubRange.scale += (SubRange.low=LoCnt));

	mov	eax, DWORD PTR SubRange+8
	mov	DWORD PTR SubRange, r9d
	add	eax, r9d

; 755  :     psee2c->Summ += SubRange.scale;            NumMasked = NumStats;

	add	WORD PTR [r11], ax
	mov	DWORD PTR SubRange+8, eax
	mov	DWORD PTR SubRange+4, eax
	movzx	eax, BYTE PTR [rsi]
	mov	BYTE PTR NumMasked, al
	jmp	$LN20@encodeSymb
$SYMBOL_FOUND$39:

; 756  :     return;
; 757  : SYMBOL_FOUND:
; 758  :     SubRange.low=LoCnt;                        SubRange.high=(LoCnt += p->Freq);

	mov	DWORD PTR SubRange, r9d
	add	r9d, eax

; 759  :     for (p1=p; --i ; ) {

	mov	rdx, r8
	mov	DWORD PTR SubRange+4, r9d
	dec	r10d
	je	SHORT $LN4@encodeSymb
	npad	7
$LL3@encodeSymb:

; 760  :         do { Sym=p1[1].Symbol;  p1++; } while (CharMask[Sym] == EscCount);

	movzx	eax, BYTE PTR [rdx+10]
	lea	rdx, QWORD PTR [rdx+10]
	mov	ecx, eax
	cmp	BYTE PTR [rax+rbp], bl
	je	SHORT $LL3@encodeSymb

; 761  :         LoCnt += p1->Freq;

	movzx	eax, BYTE PTR [rdx+1]
	add	r9d, eax
	dec	r10d
	jne	SHORT $LL3@encodeSymb
$LN4@encodeSymb:

; 42   :         if (Shift < PERIOD_BITS && --Count == 0) {

	movzx	ecx, BYTE PTR [r11+2]

; 762  :     }
; 763  :     SubRange.scale += LoCnt;

	add	DWORD PTR SubRange+8, r9d

; 42   :         if (Shift < PERIOD_BITS && --Count == 0) {

	cmp	cl, 7
	jae	SHORT $LN16@encodeSymb
	dec	BYTE PTR [r11+3]
	jne	SHORT $LN16@encodeSymb

; 43   :             Summ += Summ;                   Count=3 << Shift++;

	movzx	eax, WORD PTR [r11]
	add	ax, ax
	mov	WORD PTR [r11], ax
	mov	eax, 3
	shl	al, cl
	inc	cl
	mov	BYTE PTR [r11+2], cl
	mov	BYTE PTR [r11+3], al
$LN16@encodeSymb:

; 44   :         }
; 45   :     }
; 46   : };
; 47   : SEE2_CONTEXT _PACK_ATTR SEE2Cont[24][32], DummySEE2Cont;
; 48   : 
; 49   : 
; 50   : //==============================================================================
; 51   : 
; 52   : static struct 
; 53   : PPM_CONTEXT 
; 54   : {                 // Notes:
; 55   :     BYTE NumStats, Flags;                   // 1. NumStats & NumMasked contain
; 56   :     WORD SummFreq;                          //  number of symbols minus 1
; 57   :     struct STATE {                          // 2. sizeof(WORD) > sizeof(BYTE)
; 58   :         BYTE Symbol, Freq;                  // 3. contexts example:
; 59   :         PPM_CONTEXT* Successor;             // MaxOrder:
; 60   :     };
; 61   : 
; 62   :     STATE _PACK_ATTR*       Stats;          //  ABCD    context
; 63   :     PPM_CONTEXT*            Suffix;         //   BCD    suffix
; 64   :     
; 65   :     inline void             encodeBinSymbol(int symbol);//   BCDE   successor
; 66   :     inline void             encodeSymbol1(int symbol);// other orders:
; 67   :     inline void             encodeSymbol2(int symbol);//   BCD    context
; 68   :     inline void             decodeBinSymbol() const;//    CD    suffix
; 69   :     inline void             decodeSymbol1();//   BCDE   successor
; 70   :     inline void             decodeSymbol2();
; 71   :     inline void             update1(STATE* p);
; 72   :     inline void             update2(STATE* p);
; 73   :     inline SEE2_CONTEXT*    makeEscFreq2() const;
; 74   :     void                    rescale();
; 75   :     void                    refresh(int OldNU,BOOL Scale);
; 76   :     PPM_CONTEXT*            cutOff(int Order);
; 77   :     PPM_CONTEXT*            removeBinConts(int Order);
; 78   :     void                    makeSuffix();
; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }
; 80   : 
; 81   :     void                    read(_PPMD_FILE* fp,UINT PrevSym);
; 82   : };
; 83   : PPM_CONTEXT _PACK_ATTR* MaxContext;
; 84   : #pragma pack()
; 85   : 
; 86   : static BYTE NS2BSIndx[256], QTable[260];    // constants
; 87   : static PPM_CONTEXT::STATE* FoundState;      // found next state transition
; 88   : static int  InitEsc, OrderFall, RunLength, InitRL, MaxOrder;
; 89   : static BYTE CharMask[256], NumMasked, PrevSuccess, EscCount, PrintCount;
; 90   : static WORD BinSumm[25][64];                // binary SEE-contexts
; 91   : static MR_METHOD MRMethod;
; 92   : 
; 93   : static void _STDCALL StartModelRare(int MaxOrder,MR_METHOD MRMethod);
; 94   : 
; 95   : inline void SWAP(PPM_CONTEXT::STATE& s1,PPM_CONTEXT::STATE& s2)
; 96   : {
; 97   :     WORD t1=(WORD&) s1;                     PPM_CONTEXT* t2=s1.Successor;
; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;
; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;
; 100  : }
; 101  : inline void StateCpy(PPM_CONTEXT::STATE& s1,const PPM_CONTEXT::STATE& s2)
; 102  : {
; 103  :     (WORD&) s1=(WORD&) s2;                  
; 104  :     s1.Successor=s2.Successor;
; 105  : }
; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;
; 107  : inline PPMD_STARTUP::PPMD_STARTUP()         // constants initialization
; 108  : {
; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;
; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;
; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;
; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;
; 114  :     for (k=i=0;k < 128;k++) {
; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;
; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);
; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;
; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {
; 121  :         QTable[i]=m;
; 122  :         if ( !--k ) { k = ++Step;           m++; }
; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;
; 125  : }
; 126  : 
; 127  : 
; 128  : void PPM_CONTEXT::makeSuffix()
; 129  : {
; 130  :     STATE* p, * p1;
; 131  :     if ( !NumStats ) 
; 132  :     {
; 133  :         if ( !(p=&oneState())->Successor )  return;
; 134  : 
; 135  :         if ( !Suffix->NumStats )            
; 136  :         {
; 137  :             p1=&(Suffix->oneState());
; 138  :         }
; 139  :         else
; 140  :         {
; 141  :             for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 142  :                 ;
; 143  :         }
; 144  :         
; 145  :         p->Successor->Suffix = p1->Successor; 
; 146  :         p->Successor->makeSuffix();
; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 
; 151  :         {
; 152  :             if ( !p->Successor )            
; 153  :                 continue;
; 154  : 
; 155  :             if ( !Suffix )                  
; 156  :             {
; 157  :                 p->Successor->Suffix=this;
; 158  :             }
; 159  :             else 
; 160  :             {
; 161  :                 for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 162  :                     ;
; 163  :                 p->Successor->Suffix=p1->Successor;
; 164  :             }
; 165  :             p->Successor->makeSuffix();
; 166  :         }
; 167  :     }
; 168  : }
; 169  : 
; 170  : void PPM_CONTEXT::read(_PPMD_FILE* fp,UINT PrevSym)
; 171  : {
; 172  :     STATE* p;                               Suffix=NULL;
; 173  :     NumStats=_PPMD_E_GETC(fp);                     Flags=0x10*(PrevSym >= 0x40);
; 174  :     if ( !NumStats ) {
; 175  :         p=&oneState();                      p->Freq=_PPMD_E_GETC(fp);
; 176  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 177  :         if ((p->Freq & 0x80) != 0) {
; 178  :             p->Freq &= ~0x80;
; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 180  :             p->Successor->read(fp,p->Symbol);
; 181  :         } else                              p->Successor=NULL;
; 182  :         return;
; 183  :     }
; 184  :     Stats = (PPM_CONTEXT::STATE*) AllocUnits((NumStats+2) >> 1);
; 185  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 186  :         p->Freq=_PPMD_E_GETC(fp);
; 187  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 188  :     }
; 189  :     int EscFreq=SummFreq=(Stats->Freq & ~0x80);
; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);
; 191  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 192  :         if ((p->Freq & 0x80) != 0) {
; 193  :             p->Freq &= ~0x80;
; 194  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 195  :             p->Successor->read(fp,p->Symbol);
; 196  :         } else                              p->Successor=NULL;
; 197  :         p->Freq=(p == Stats)?(64):(p[-1].Freq-p[0].Freq);
; 198  :         SummFreq += p->Freq;
; 199  :     }
; 200  :     if (EscFreq > 32) {
; 201  :         SummFreq=(EscFreq >> 1);
; 202  :         for (p=Stats;p <= Stats+NumStats;p++)
; 203  :                 SummFreq += (p->Freq -= (3*p->Freq) >> 2);
; 204  :     }
; 205  : }
; 206  : /*
; 207  : void
; 208  : PPM_CONTEXT::write( int o, FILE* fp )
; 209  : {
; 210  :     int EscFreq = EscCount; //(Stats)  ? Stats->Freq & ~0x80  : 0;
; 211  :     int nc      = 0;
; 212  : 
; 213  :     STATE* p;
; 214  :     int f, a, b, c;
; 215  :     if (nc < o)                             
; 216  :         nc=o;
; 217  :         
; 218  :     putc(NumStats,fp);
; 219  :     if ( !NumStats ) {
; 220  :         f=(p=&oneState())->Freq;
; 221  :         if ( EscFreq )                      f=(2*f)/EscFreq;
; 222  :         f=CLAMP(f,1,127) | 0x80*(p->Successor != NULL);
; 223  :         putc(f,fp);                         putc(p->Symbol,fp);
; 224  :         if ( p->Successor )                 p->Successor->write(o+1,fp);
; 225  :         return;
; 226  :     }
; 227  :     for (p=Stats+1;p <= Stats+NumStats;p++) {
; 228  :         if (p[0].Freq > p[-1].Freq) {
; 229  :             STATE* p1=p;
; 230  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq > p1[-1].Freq);
; 231  :         }
; 232  :         if (p[0].Freq == p[-1].Freq && p[0].Successor && !p[-1].Successor) {
; 233  :             STATE* p1=p;
; 234  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq == p1[-1].Freq && !p1[-1].Successor);
; 235  :         }
; 236  :     }
; 237  :     a=Stats->Freq+!Stats->Freq;             f=(64*EscFreq+(b=a >> 1))/a;
; 238  :     f=CLAMP(f,1,127) | 0x80*(Stats->Successor != NULL);
; 239  :     putc(f,fp);                             c=64;
; 240  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 241  :         f=(64*p->Freq+b)/a;                 f += !f;
; 242  :         if (p != Stats)
; 243  :             putc((c-f) | 0x80*(p->Successor != NULL),fp);
; 244  :         c=f;                                putc(p->Symbol,fp);
; 245  :     }
; 246  :     for (p=Stats;p <= Stats+NumStats;p++)
; 247  :             if ( p->Successor )             p->Successor->write(o+1,fp);
; 248  : }
; 249  : */
; 250  : void PPM_CONTEXT::refresh(int OldNU,BOOL Scale)
; 251  : {
; 252  :     int i=NumStats, EscFreq;
; 253  :     STATE* p = Stats = (STATE*) ShrinkUnits(Stats,OldNU,(i+2) >> 1);
; 254  :     Flags=(Flags & (0x10+0x04*Scale))+0x08*(p->Symbol >= 0x40);
; 255  :     EscFreq=SummFreq-p->Freq;
; 256  :     SummFreq = (p->Freq=(p->Freq+Scale) >> Scale);
; 257  :     do {
; 258  :         EscFreq -= (++p)->Freq;
; 259  :         SummFreq += (p->Freq=(p->Freq+Scale) >> Scale);
; 260  :         Flags |= 0x08*(p->Symbol >= 0x40);
; 261  :     } while ( --i );
; 262  :     SummFreq += (EscFreq=(EscFreq+Scale) >> Scale);
; 263  : }
; 264  : #define P_CALL(F) ( PrefetchData(p->Successor), \
; 265  :                     p->Successor=p->Successor->F(Order+1))
; 266  : PPM_CONTEXT* PPM_CONTEXT::cutOff(int Order)
; 267  : {
; 268  :     int i, tmp;
; 269  :     STATE* p;
; 270  :     if ( !NumStats ) {
; 271  :         if ((BYTE*) (p=&oneState())->Successor >= UnitsStart) {
; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);
; 273  :             else                            p->Successor=NULL;
; 274  :             if (!p->Successor && Order > O_BOUND)
; 275  :                     goto REMOVE;
; 276  :             return this;
; 277  :         } else {
; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;
; 279  :         }
; 280  :     }
; 281  :     PrefetchData(Stats);
; 282  :     Stats = (STATE*) MoveUnitsUp(Stats,tmp=(NumStats+2) >> 1);
; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)
; 284  :             if ((BYTE*) p->Successor < UnitsStart) {
; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);
; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);
; 287  :             else                            p->Successor=NULL;
; 288  :     if (i != NumStats && Order) {
; 289  :         NumStats=i;                         p=Stats;
; 290  :         if (i < 0) { FreeUnits(p,tmp);      goto REMOVE; }
; 291  :         else if (i == 0) {
; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);
; 293  :             StateCpy(oneState(),*p);        FreeUnits(p,tmp);
; 294  :             oneState().Freq=(oneState().Freq+11) >> 3;
; 295  :         } else                              refresh(tmp,SummFreq > 16*i);
; 296  :     }
; 297  :     return this;
; 298  : }
; 299  : PPM_CONTEXT* PPM_CONTEXT::removeBinConts(int Order)
; 300  : {
; 301  :     STATE* p;
; 302  :     if ( !NumStats ) {
; 303  :         p=&oneState();
; 304  :         if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 305  :                 P_CALL(removeBinConts);
; 306  :         else                                p->Successor=NULL;
; 307  :         if (!p->Successor && (!Suffix->NumStats || Suffix->Flags == 0xFF)) {
; 308  :             FreeUnits(this,1);              return NULL;
; 309  :         } else                              return this;
; 310  :     }
; 311  :     PrefetchData(Stats);
; 312  :     for (p=Stats+NumStats;p >= Stats;p--)
; 313  :             if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 314  :                     P_CALL(removeBinConts);
; 315  :             else                            p->Successor=NULL;
; 316  :     return this;
; 317  : }
; 318  : 
; 319  : static void RestoreModelRare(PPM_CONTEXT* pc1,PPM_CONTEXT* MinContext,
; 320  :         PPM_CONTEXT* FSuccessor)
; 321  : {
; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)
; 325  :             if (--(pc->NumStats) == 0) {
; 326  :                 pc->Flags=(pc->Flags & 0x10)+0x08*(pc->Stats->Symbol >= 0x40);
; 327  :                 p=pc->Stats;                StateCpy(pc->oneState(),*p);
; 328  :                 SpecialFreeUnit(p);
; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;
; 330  :             } else
; 331  :                     pc->refresh((pc->NumStats+3) >> 1,FALSE);
; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)
; 333  :             if ( !pc->NumStats )
; 334  :                     pc->oneState().Freq -= pc->oneState().Freq >> 1;
; 335  :             else if ((pc->SummFreq += 4) > 128+4*pc->NumStats)
; 336  :                     pc->refresh((pc->NumStats+2) >> 1,TRUE);
; 337  :     if (MRMethod > MRM_FREEZE) {
; 338  :         MaxContext=FSuccessor;              GlueCount += !(BList[1].Stamp & 1);
; 339  :     } else if (MRMethod == MRM_FREEZE) {
; 340  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 341  :         MaxContext->removeBinConts(0);      MRMethod=MR_METHOD(MRMethod+1);
; 342  :         GlueCount=0;                        OrderFall=MaxOrder;
; 343  : 	} else if (MRMethod == MRM_RESTART || GetUsedMemory() < (SubAllocatorSize >> 1)) {
; 344  :         StartModelRare(MaxOrder,MRMethod);
; 345  :         EscCount=0;                         PrintCount=0xFF;
; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 348  :         do {
; 349  :             MaxContext->cutOff(0);          ExpandTextArea();
; 350  : 		} while (GetUsedMemory() > 3*(SubAllocatorSize >> 2));
; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }
; 354  : 
; 355  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 356  :         PPM_CONTEXT* pc);
; 357  : static PPM_CONTEXT* _FASTCALL ReduceOrder(PPM_CONTEXT::STATE* p,PPM_CONTEXT* pc)
; 358  : {
; 359  :     PPM_CONTEXT::STATE* p1,  * ps[MAX_O], ** pps=ps;
; 360  :     PPM_CONTEXT* pc1=pc, * UpBranch = (PPM_CONTEXT*) pText;
; 361  :     BYTE tmp, sym=FoundState->Symbol;
; 362  :     *pps++ = FoundState;                    FoundState->Successor=UpBranch;
; 363  :     OrderFall++;
; 364  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 365  :     for ( ; ; ) {
; 366  :         if ( !pc->Suffix ) {
; 367  :             if (MRMethod > MRM_FREEZE) {
; 368  : FROZEN:         do { (*--pps)->Successor = pc; } while (pps != ps);
; 369  :                 pText=HeapStart+1;          OrderFall=1;
; 370  :             }
; 371  :             return pc;
; 372  :         }
; 373  :         pc=pc->Suffix;
; 374  :         if ( pc->NumStats ) {
; 375  :             if ((p=pc->Stats)->Symbol != sym)
; 376  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 377  :             tmp=2*(p->Freq < MAX_FREQ-9);
; 378  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }
; 380  : LOOP_ENTRY:
; 381  :         if ( p->Successor )                 break;
; 382  :         *pps++ = p;                         p->Successor=UpBranch;
; 383  :         OrderFall++;
; 384  :     }
; 385  :     if (MRMethod > MRM_FREEZE) {
; 386  :         pc = p->Successor;                  goto FROZEN;
; 387  :     } else if (p->Successor <= UpBranch) {
; 388  :         p1=FoundState;                      FoundState=p;
; 389  :         p->Successor=CreateSuccessors(FALSE,NULL,pc);
; 390  :         FoundState=p1;
; 391  :     }
; 392  :     if (OrderFall == 1 && pc1 == MaxContext) {
; 393  :         FoundState->Successor=p->Successor; pText--;
; 394  :     }
; 395  :     return p->Successor;
; 396  : }
; 397  : void PPM_CONTEXT::rescale()
; 398  : {
; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);
; 402  :     p->Freq += 4;                           SummFreq += 4;
; 403  :     EscFreq=SummFreq-p->Freq;
; 404  :     Adder=(OrderFall != 0 || MRMethod > MRM_FREEZE);
; 405  :     SummFreq = (p->Freq=(p->Freq+Adder) >> 1);
; 406  :     do {
; 407  :         EscFreq -= (++p)->Freq;
; 408  :         SummFreq += (p->Freq=(p->Freq+Adder) >> 1);
; 409  :         if (p[0].Freq > p[-1].Freq) {
; 410  :             StateCpy(tmp,*(p1=p));
; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);
; 412  :             StateCpy(*p1,tmp);
; 413  :         }
; 414  :     } while ( --i );
; 415  :     if (p->Freq == 0) {
; 416  :         do { i++; } while ((--p)->Freq == 0);
; 417  :         EscFreq += i;                       OldNU=(NumStats+2) >> 1;
; 418  :         if ((NumStats -= i) == 0) {
; 419  :             StateCpy(tmp,*Stats);
; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;
; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;
; 422  :             FreeUnits(Stats,OldNU);         StateCpy(oneState(),tmp);
; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);
; 424  :             FoundState=&oneState();         return;
; 425  :         }
; 426  :         Stats = (STATE*) ShrinkUnits(Stats,OldNU,(NumStats+2) >> 1);
; 427  :         Flags &= ~0x08;                     i=NumStats;
; 428  :         Flags |= 0x08*((p=Stats)->Symbol >= 0x40);
; 429  :         do { Flags |= 0x08*((++p)->Symbol >= 0x40); } while ( --i );
; 430  :     }
; 431  :     SummFreq += (EscFreq -= (EscFreq >> 1));
; 432  :     Flags |= 0x04;                          FoundState=Stats;
; 433  : }
; 434  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 435  :         PPM_CONTEXT* pc)
; 436  : {
; 437  : 
; 438  :     PPM_CONTEXT ct, * UpBranch=FoundState->Successor;
; 439  :     PPM_CONTEXT::STATE* ps[MAX_O], ** pps=ps;
; 440  :     UINT cf, s0;
; 441  :     BYTE tmp, sym=FoundState->Symbol;
; 442  :     if ( !Skip ) {
; 443  :         *pps++ = FoundState;
; 444  :         if ( !pc->Suffix )                  goto NO_LOOP;
; 445  :     }
; 446  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 447  :     do {
; 448  :         pc=pc->Suffix;
; 449  :         if ( pc->NumStats ) {
; 450  :             if ((p=pc->Stats)->Symbol != sym)
; 451  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 452  :             tmp=(p->Freq < MAX_FREQ-9);
; 453  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 454  :         } else {
; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));
; 457  :         }
; 458  : LOOP_ENTRY:
; 459  :         if (p->Successor != UpBranch) {
; 460  :             pc=p->Successor;                break;
; 461  :         }
; 462  :         *pps++ = p;
; 463  :     } while ( pc->Suffix );
; 464  : NO_LOOP:
; 465  :     if (pps == ps)                          return pc;
; 466  :     ct.NumStats=0;                          ct.Flags=0x10*(sym >= 0x40);
; 467  :     ct.oneState().Symbol=sym=*(BYTE*) UpBranch;
; 468  :     ct.oneState().Successor=(PPM_CONTEXT*) (((BYTE*) UpBranch)+1);
; 469  :     ct.Flags |= 0x08*(sym >= 0x40);
; 470  :     if ( pc->NumStats ) {
; 471  :         if ((p=pc->Stats)->Symbol != sym)
; 472  :                 do { tmp=p[1].Symbol;       p++; } while (tmp != sym);
; 473  :         s0=pc->SummFreq-pc->NumStats-(cf=p->Freq-1);
; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));
; 475  :     } else
; 476  :             ct.oneState().Freq=pc->oneState().Freq;
; 477  :     do {
; 478  :         PPM_CONTEXT* pc1 = (PPM_CONTEXT*) AllocContext();
; 479  :         if ( !pc1 )                         return NULL;
; 480  :         ((DWORD*) pc1)[0] = ((DWORD*) &ct)[0];
; 481  :         ((DWORD*) pc1)[1] = ((DWORD*) &ct)[1];
; 482  :         pc1->Suffix=pc;                     (*--pps)->Successor=pc=pc1;
; 483  :     } while (pps != ps);
; 484  :     return pc;
; 485  : }
; 486  : 
; 487  : 
; 488  : static inline void UpdateModel( PPM_CONTEXT* MinContext)
; 489  : {
; 490  :     PPM_CONTEXT::STATE* p           = NULL;
; 491  :     PPM_CONTEXT*        FSuccessor  = FoundState->Successor;
; 492  :     PPM_CONTEXT*        pc          = MinContext->Suffix;
; 493  :     PPM_CONTEXT*        pc1         = MaxContext;
; 494  :     
; 495  :     UINT ns1, ns, cf, sf, s0, FFreq=FoundState->Freq;
; 496  :     BYTE Flag, sym, FSymbol=FoundState->Symbol;
; 497  : 
; 498  : 
; 499  :     if( FFreq < MAX_FREQ/4  &&  pc ) 
; 500  :     {
; 501  :         if ( pc->NumStats ) 
; 502  :         {
; 503  :             if ((p=pc->Stats)->Symbol != FSymbol) 
; 504  :             {
; 505  :                 do { sym=p[1].Symbol;       p++; } while (sym != FSymbol);
; 506  :                 if (p[0].Freq >= p[-1].Freq) 
; 507  :                 {
; 508  :                     SWAP(p[0],p[-1]);       
; 509  :                     p--;
; 510  :                 }
; 511  :             }
; 512  :             cf=2*(p->Freq < MAX_FREQ-9);
; 513  :             p->Freq      += cf;                  
; 514  :             pc->SummFreq += cf;
; 515  :         } 
; 516  :         else 
; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 
; 520  :         }
; 521  :     }
; 522  :     
; 523  :     if( !OrderFall && FSuccessor) 
; 524  :     {
; 525  :         FoundState->Successor=CreateSuccessors(TRUE,p,MinContext);
; 526  :         if ( !FoundState->Successor )       
; 527  :             goto RESTART_MODEL;
; 528  :         MaxContext=FoundState->Successor;   
; 529  :         return;
; 530  :     }
; 531  : 
; 532  :     *pText++ = FSymbol;                     
; 533  : 
; 534  :     PPM_CONTEXT*    Successor = (PPM_CONTEXT*) pText;
; 535  :     
; 536  :     if (pText >= UnitsStart)                
; 537  :         goto RESTART_MODEL;
; 538  : 
; 539  : 
; 540  :     if( FSuccessor ) 
; 541  :     {
; 542  :         if ((BYTE*) FSuccessor < UnitsStart)
; 543  :             FSuccessor=CreateSuccessors(FALSE,p,MinContext);
; 544  :     } 
; 545  :     else
; 546  :     {
; 547  :         FSuccessor=ReduceOrder(p,MinContext);
; 548  :     }
; 549  :     
; 550  :     if( !FSuccessor )                          
; 551  :         goto RESTART_MODEL;
; 552  : 
; 553  : 
; 554  :     if( !--OrderFall ) 
; 555  :     {
; 556  :         Successor=FSuccessor;               
; 557  :         pText -= (MaxContext != MinContext);
; 558  :     } 
; 559  :     else if( MRMethod > MRM_FREEZE) 
; 560  :     {
; 561  :         Successor=FSuccessor;               
; 562  :         pText=HeapStart;
; 563  :         OrderFall=0;
; 564  :     }
; 565  :     
; 566  :     s0=MinContext->SummFreq-(ns=MinContext->NumStats)-FFreq;
; 567  :     for (Flag=0x08*(FSymbol >= 0x40);pc1 != MinContext;pc1=pc1->Suffix) 
; 568  :     {
; 569  :         if ((ns1=pc1->NumStats) != 0) 
; 570  :         {
; 571  :             if ((ns1 & 1) != 0) 
; 572  :             {
; 573  :                 p=(PPM_CONTEXT::STATE*) ExpandUnits(pc1->Stats,(ns1+1) >> 1);
; 574  :                 if ( !p )                   
; 575  :                     goto RESTART_MODEL;
; 576  :                 pc1->Stats=p;
; 577  :             }
; 578  :             pc1->SummFreq += (3*ns1+1 < ns);
; 579  :         } 
; 580  :         else 
; 581  :         {
; 582  :             p=(PPM_CONTEXT::STATE*) AllocUnits(1);
; 583  :             if ( !p )                       
; 584  :                 goto RESTART_MODEL;
; 585  :                 
; 586  :             StateCpy(*p,pc1->oneState());   
; 587  :             pc1->Stats=p;
; 588  :             
; 589  :             if (p->Freq < MAX_FREQ/4-1)     p->Freq += p->Freq;
; 590  :             else                            p->Freq  = MAX_FREQ-4;
; 591  :             
; 592  :             pc1->SummFreq=p->Freq+InitEsc+(ns > 2);
; 593  :         }
; 594  : 
; 595  :         cf=2*FFreq*(pc1->SummFreq+6);       
; 596  :         sf=s0+pc1->SummFreq;
; 597  : 
; 598  :         if (cf < 6*sf) 
; 599  :         {
; 600  :             cf=1+(cf > sf)+(cf >= 4*sf);
; 601  :             pc1->SummFreq += 4;
; 602  :         } 
; 603  :         else 
; 604  :         {
; 605  :             cf=4+(cf > 9*sf)+(cf > 12*sf)+(cf > 15*sf);
; 606  :             pc1->SummFreq += cf;
; 607  :         }
; 608  :         p=pc1->Stats+(++pc1->NumStats);     
; 609  :         p->Successor=Successor;
; 610  :         p->Symbol = FSymbol;                
; 611  :         p->Freq = cf;
; 612  :         pc1->Flags |= Flag;
; 613  :     }
; 614  : 
; 615  :     MaxContext=FSuccessor;
; 616  :     return;
; 617  : 
; 618  : RESTART_MODEL:
; 619  :     RestoreModelRare(pc1,MinContext,FSuccessor);
; 620  : 
; 621  : }
; 622  : // Tabulated escapes for exponential symbol distribution
; 623  : static const BYTE ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
; 624  : #define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))
; 625  : inline void PPM_CONTEXT::encodeBinSymbol(int symbol)
; 626  : {
; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 630  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 631  :     if (rs.Symbol == symbol) {
; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 633  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 634  :         PrevSuccess=1;                      RunLength++;
; 635  :     } else {
; 636  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 637  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 638  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 639  :     }
; 640  : }
; 641  : inline void PPM_CONTEXT::decodeBinSymbol() const
; 642  : {
; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 647  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 648  :     if ( !rcBinDecode(tmp) ) {
; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 650  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 651  :         PrevSuccess=1;                      RunLength++;
; 652  :     } else {
; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 654  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 656  :     }
; 657  : }
; 658  : inline void PPM_CONTEXT::update1(STATE* p) 
; 659  : {
; 660  :     (FoundState=p)->Freq += 4;              SummFreq += 4;
; 661  :     if (p[0].Freq > p[-1].Freq) {
; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;
; 663  :         if (p->Freq > MAX_FREQ)             rescale();
; 664  :     }
; 665  : }
; 666  : inline void PPM_CONTEXT::encodeSymbol1(int symbol)
; 667  : {
; 668  :     UINT LoCnt, i=Stats->Symbol;
; 669  :     STATE* p=Stats;                         SubRange.scale=SummFreq;
; 670  :     if (i == symbol) {
; 671  :         PrevSuccess=(2*(SubRange.high=p->Freq) >= SubRange.scale);
; 672  :         (FoundState=p)->Freq += 4;          SummFreq += 4;
; 673  :         RunLength += PrevSuccess;
; 674  :         if (p->Freq > MAX_FREQ)             rescale();
; 675  :         SubRange.low=0;                        return;
; 676  :     }
; 677  :     LoCnt=p->Freq;
; 678  :     i=NumStats;                             PrevSuccess=0;
; 679  :     while ((++p)->Symbol != symbol) {
; 680  :         LoCnt += p->Freq;
; 681  :         if (--i == 0) {
; 682  :             if ( Suffix )                   PrefetchData(Suffix);
; 683  :             SubRange.low=LoCnt;                CharMask[p->Symbol]=EscCount;
; 684  :             i=NumMasked=NumStats;           FoundState=NULL;
; 685  :             do { CharMask[(--p)->Symbol]=EscCount; } while ( --i );
; 686  :             SubRange.high=SubRange.scale;         return;
; 687  :         }
; 688  :     }
; 689  :     SubRange.high=(SubRange.low=LoCnt)+p->Freq;   update1(p);
; 690  : }
; 691  : inline void PPM_CONTEXT::decodeSymbol1()
; 692  : {
; 693  :     UINT i, count, HiCnt=Stats->Freq;
; 694  :     STATE* p=Stats;                         SubRange.scale=SummFreq;
; 695  :     if ((count=rcGetCurrentCount()) < HiCnt) {
; 696  :         PrevSuccess=(2*(SubRange.high=HiCnt) >= SubRange.scale);
; 697  : 
; 698  :         (FoundState=p)->Freq=(HiCnt += 4);  
; 699  :         SummFreq += 4;
; 700  : 
; 701  :         RunLength += PrevSuccess;
; 702  :         if (HiCnt > MAX_FREQ)               rescale();
; 703  :         SubRange.low=0;                        return;
; 704  :     }
; 705  :     i=NumStats;                             PrevSuccess=0;
; 706  :     while ((HiCnt += (++p)->Freq) <= count)
; 707  :         if (--i == 0) {
; 708  :             if ( Suffix )                   PrefetchData(Suffix);
; 709  :             SubRange.low=HiCnt;                CharMask[p->Symbol]=EscCount;
; 710  :             i=NumMasked=NumStats;           FoundState=NULL;
; 711  :             do { CharMask[(--p)->Symbol]=EscCount; } while ( --i );
; 712  :             SubRange.high=SubRange.scale;         return;
; 713  :         }
; 714  :     SubRange.low=(SubRange.high=HiCnt)-p->Freq;   
; 715  :     ((PPM_CONTEXT*)this)->update1(p);
; 716  : }
; 717  : inline void PPM_CONTEXT::update2(STATE* p)
; 718  : {
; 719  : /*
; 720  :     ++EscCount;
; 721  :     RunLength = InitRL;
; 722  : */
; 723  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	add	BYTE PTR [r8+1], 4
	add	WORD PTR [rsi+2], 4

; 724  :     if (p->Freq > MAX_FREQ)                 rescale();

	cmp	BYTE PTR [r8+1], 124			; 0000007cH
	mov	QWORD PTR FoundState, r8
	jbe	SHORT $LN19@encodeSymb
	mov	rcx, rsi
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN19@encodeSymb:

; 725  :     EscCount++;                             RunLength=InitRL;

	mov	eax, DWORD PTR InitRL
	inc	bl
	mov	DWORD PTR RunLength, eax
	mov	BYTE PTR EscCount, bl
$LN20@encodeSymb:

; 764  :     psee2c->update();                       update2(p);
; 765  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?encodeSymbol2@PPM_CONTEXT@@QEAAXH@Z ENDP		; PPM_CONTEXT::encodeSymbol2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ
_TEXT	SEGMENT
ps$ = 32
this$ = 2112
?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ PROC		; PPM_CONTEXT::decodeSymbol2, COMDAT

; 767  : {

$LN40:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 2080				; 00000820H
	mov	rbp, rcx

; 768  :     SEE2_CONTEXT* psee2c=makeEscFreq2();

	call	?makeEscFreq2@PPM_CONTEXT@@QEBAPEAUSEE2_CONTEXT@@XZ ; PPM_CONTEXT::makeEscFreq2

; 769  :     UINT Sym, count, HiCnt=0, i=NumStats-NumMasked;

	movzx	edx, BYTE PTR NumMasked
	movzx	r14d, BYTE PTR [rbp]

; 770  :     STATE* ps[256], ** pps=ps, * p=Stats-1;

	movzx	ebx, BYTE PTR EscCount
	xor	r11d, r11d
	mov	r9d, r14d
	mov	rdi, rax
	lea	r8, QWORD PTR ps$[rsp]
	sub	r9d, edx
	mov	rdx, QWORD PTR [rbp+4]
	lea	r15, OFFSET FLAT:CharMask
	sub	rdx, 10
	mov	r10d, r9d
	npad	7
$LL10@decodeSymb:

; 771  :     do {
; 772  :         do { Sym=p[1].Symbol;   p++; } while (CharMask[Sym] == EscCount);

	movzx	eax, BYTE PTR [rdx+10]
	add	rdx, 10
	cmp	BYTE PTR [rax+r15], bl
	je	SHORT $LL10@decodeSymb

; 773  :         HiCnt += p->Freq;                   *pps++ = p;

	movzx	eax, BYTE PTR [rdx+1]
	mov	QWORD PTR [r8], rdx
	add	r8, 8
	add	r11d, eax

; 774  :     } while ( --i );

	dec	r10d
	jne	SHORT $LL10@decodeSymb

; 775  :     SubRange.scale += HiCnt;                   count=rcGetCurrentCount();

	mov	esi, DWORD PTR SubRange+8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	mov	eax, DWORD PTR range
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 776  :     p=*(pps=ps);

	mov	r8, QWORD PTR ps$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	xor	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 775  :     SubRange.scale += HiCnt;                   count=rcGetCurrentCount();

	add	esi, r11d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	div	esi
	xor	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 775  :     SubRange.scale += HiCnt;                   count=rcGetCurrentCount();

	mov	DWORD PTR SubRange+8, esi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	mov	ecx, eax
	mov	DWORD PTR range, eax
	mov	eax, DWORD PTR code
	sub	eax, DWORD PTR low
	div	ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 776  :     p=*(pps=ps);

	lea	rdx, QWORD PTR ps$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\coder.hpp

; 138  : static inline UINT rcGetCurrentCount() { return (code-low)/(range /= SubRange.scale); }

	mov	r10d, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 777  :     if (count < HiCnt) {

	cmp	eax, r11d
	jae	$LN7@decodeSymb

; 778  :         HiCnt=0;
; 779  :         while ((HiCnt += p->Freq) <= count) p=*++pps;

	movzx	ecx, BYTE PTR [r8+1]
	cmp	ecx, eax
	ja	SHORT $LN5@decodeSymb
$LL6@decodeSymb:
	mov	r8, QWORD PTR [rdx+8]
	lea	rdx, QWORD PTR [rdx+8]
	movzx	eax, BYTE PTR [r8+1]
	add	ecx, eax
	cmp	ecx, r10d
	jbe	SHORT $LL6@decodeSymb
$LN5@decodeSymb:

; 780  :         SubRange.low = (SubRange.high=HiCnt)-p->Freq;

	movzx	eax, BYTE PTR [r8+1]
	mov	DWORD PTR SubRange+4, ecx
	sub	ecx, eax
	mov	DWORD PTR SubRange, ecx

; 42   :         if (Shift < PERIOD_BITS && --Count == 0) {

	movzx	ecx, BYTE PTR [rdi+2]
	cmp	cl, 7
	jae	SHORT $LN18@decodeSymb
	dec	BYTE PTR [rdi+3]
	jne	SHORT $LN18@decodeSymb

; 43   :             Summ += Summ;                   Count=3 << Shift++;

	movzx	eax, WORD PTR [rdi]
	add	ax, ax
	mov	WORD PTR [rdi], ax
	mov	eax, 3
	shl	al, cl
	inc	cl
	mov	BYTE PTR [rdi+2], cl
	mov	BYTE PTR [rdi+3], al
$LN18@decodeSymb:

; 44   :         }
; 45   :     }
; 46   : };
; 47   : SEE2_CONTEXT _PACK_ATTR SEE2Cont[24][32], DummySEE2Cont;
; 48   : 
; 49   : 
; 50   : //==============================================================================
; 51   : 
; 52   : static struct 
; 53   : PPM_CONTEXT 
; 54   : {                 // Notes:
; 55   :     BYTE NumStats, Flags;                   // 1. NumStats & NumMasked contain
; 56   :     WORD SummFreq;                          //  number of symbols minus 1
; 57   :     struct STATE {                          // 2. sizeof(WORD) > sizeof(BYTE)
; 58   :         BYTE Symbol, Freq;                  // 3. contexts example:
; 59   :         PPM_CONTEXT* Successor;             // MaxOrder:
; 60   :     };
; 61   : 
; 62   :     STATE _PACK_ATTR*       Stats;          //  ABCD    context
; 63   :     PPM_CONTEXT*            Suffix;         //   BCD    suffix
; 64   :     
; 65   :     inline void             encodeBinSymbol(int symbol);//   BCDE   successor
; 66   :     inline void             encodeSymbol1(int symbol);// other orders:
; 67   :     inline void             encodeSymbol2(int symbol);//   BCD    context
; 68   :     inline void             decodeBinSymbol() const;//    CD    suffix
; 69   :     inline void             decodeSymbol1();//   BCDE   successor
; 70   :     inline void             decodeSymbol2();
; 71   :     inline void             update1(STATE* p);
; 72   :     inline void             update2(STATE* p);
; 73   :     inline SEE2_CONTEXT*    makeEscFreq2() const;
; 74   :     void                    rescale();
; 75   :     void                    refresh(int OldNU,BOOL Scale);
; 76   :     PPM_CONTEXT*            cutOff(int Order);
; 77   :     PPM_CONTEXT*            removeBinConts(int Order);
; 78   :     void                    makeSuffix();
; 79   :     STATE&                  oneState() const { return (STATE&) SummFreq; }
; 80   : 
; 81   :     void                    read(_PPMD_FILE* fp,UINT PrevSym);
; 82   : };
; 83   : PPM_CONTEXT _PACK_ATTR* MaxContext;
; 84   : #pragma pack()
; 85   : 
; 86   : static BYTE NS2BSIndx[256], QTable[260];    // constants
; 87   : static PPM_CONTEXT::STATE* FoundState;      // found next state transition
; 88   : static int  InitEsc, OrderFall, RunLength, InitRL, MaxOrder;
; 89   : static BYTE CharMask[256], NumMasked, PrevSuccess, EscCount, PrintCount;
; 90   : static WORD BinSumm[25][64];                // binary SEE-contexts
; 91   : static MR_METHOD MRMethod;
; 92   : 
; 93   : static void _STDCALL StartModelRare(int MaxOrder,MR_METHOD MRMethod);
; 94   : 
; 95   : inline void SWAP(PPM_CONTEXT::STATE& s1,PPM_CONTEXT::STATE& s2)
; 96   : {
; 97   :     WORD t1=(WORD&) s1;                     PPM_CONTEXT* t2=s1.Successor;
; 98   :     (WORD&) s1 = (WORD&) s2;                s1.Successor=s2.Successor;
; 99   :     (WORD&) s2 = t1;                        s2.Successor=t2;
; 100  : }
; 101  : inline void StateCpy(PPM_CONTEXT::STATE& s1,const PPM_CONTEXT::STATE& s2)
; 102  : {
; 103  :     (WORD&) s1=(WORD&) s2;                  
; 104  :     s1.Successor=s2.Successor;
; 105  : }
; 106  : struct PPMD_STARTUP { inline PPMD_STARTUP(); } PPMd_StartUp;
; 107  : inline PPMD_STARTUP::PPMD_STARTUP()         // constants initialization
; 108  : {
; 109  :     UINT i, k, m, Step;
; 110  :     for (i=0,k=1;i < N1     ;i++,k += 1)    Indx2Units[i]=k;
; 111  :     for (k++;i < N1+N2      ;i++,k += 2)    Indx2Units[i]=k;
; 112  :     for (k++;i < N1+N2+N3   ;i++,k += 3)    Indx2Units[i]=k;
; 113  :     for (k++;i < N1+N2+N3+N4;i++,k += 4)    Indx2Units[i]=k;
; 114  :     for (k=i=0;k < 128;k++) {
; 115  :         i += (Indx2Units[i] < k+1);         Units2Indx[k]=i;
; 116  :     }
; 117  :     NS2BSIndx[0]=2*0;                       NS2BSIndx[1]=2*1;
; 118  :     memset(NS2BSIndx+2,2*2,9);              memset(NS2BSIndx+11,2*3,256-11);
; 119  :     for (i=0;i < UP_FREQ;i++)               QTable[i]=i;
; 120  :     for (m=i=UP_FREQ, k=Step=1;i < 260;i++) {
; 121  :         QTable[i]=m;
; 122  :         if ( !--k ) { k = ++Step;           m++; }
; 123  :     }
; 124  :     (DWORD&) DummySEE2Cont=PPMdSignature;
; 125  : }
; 126  : 
; 127  : 
; 128  : void PPM_CONTEXT::makeSuffix()
; 129  : {
; 130  :     STATE* p, * p1;
; 131  :     if ( !NumStats ) 
; 132  :     {
; 133  :         if ( !(p=&oneState())->Successor )  return;
; 134  : 
; 135  :         if ( !Suffix->NumStats )            
; 136  :         {
; 137  :             p1=&(Suffix->oneState());
; 138  :         }
; 139  :         else
; 140  :         {
; 141  :             for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 142  :                 ;
; 143  :         }
; 144  :         
; 145  :         p->Successor->Suffix = p1->Successor; 
; 146  :         p->Successor->makeSuffix();
; 147  :     } 
; 148  :     else 
; 149  :     {
; 150  :         for (p=Stats;p <= Stats+NumStats;p++) 
; 151  :         {
; 152  :             if ( !p->Successor )            
; 153  :                 continue;
; 154  : 
; 155  :             if ( !Suffix )                  
; 156  :             {
; 157  :                 p->Successor->Suffix=this;
; 158  :             }
; 159  :             else 
; 160  :             {
; 161  :                 for (p1=Suffix->Stats;p1->Symbol != p->Symbol;p1++)
; 162  :                     ;
; 163  :                 p->Successor->Suffix=p1->Successor;
; 164  :             }
; 165  :             p->Successor->makeSuffix();
; 166  :         }
; 167  :     }
; 168  : }
; 169  : 
; 170  : void PPM_CONTEXT::read(_PPMD_FILE* fp,UINT PrevSym)
; 171  : {
; 172  :     STATE* p;                               Suffix=NULL;
; 173  :     NumStats=_PPMD_E_GETC(fp);                     Flags=0x10*(PrevSym >= 0x40);
; 174  :     if ( !NumStats ) {
; 175  :         p=&oneState();                      p->Freq=_PPMD_E_GETC(fp);
; 176  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 177  :         if ((p->Freq & 0x80) != 0) {
; 178  :             p->Freq &= ~0x80;
; 179  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 180  :             p->Successor->read(fp,p->Symbol);
; 181  :         } else                              p->Successor=NULL;
; 182  :         return;
; 183  :     }
; 184  :     Stats = (PPM_CONTEXT::STATE*) AllocUnits((NumStats+2) >> 1);
; 185  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 186  :         p->Freq=_PPMD_E_GETC(fp);
; 187  :         Flags |= 0x08*((p->Symbol=_PPMD_E_GETC(fp)) >= 0x40);
; 188  :     }
; 189  :     int EscFreq=SummFreq=(Stats->Freq & ~0x80);
; 190  :     Flags |= 0x04*(EscFreq < NumStats && EscFreq < 127);
; 191  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 192  :         if ((p->Freq & 0x80) != 0) {
; 193  :             p->Freq &= ~0x80;
; 194  :             p->Successor = (PPM_CONTEXT*) AllocContext();
; 195  :             p->Successor->read(fp,p->Symbol);
; 196  :         } else                              p->Successor=NULL;
; 197  :         p->Freq=(p == Stats)?(64):(p[-1].Freq-p[0].Freq);
; 198  :         SummFreq += p->Freq;
; 199  :     }
; 200  :     if (EscFreq > 32) {
; 201  :         SummFreq=(EscFreq >> 1);
; 202  :         for (p=Stats;p <= Stats+NumStats;p++)
; 203  :                 SummFreq += (p->Freq -= (3*p->Freq) >> 2);
; 204  :     }
; 205  : }
; 206  : /*
; 207  : void
; 208  : PPM_CONTEXT::write( int o, FILE* fp )
; 209  : {
; 210  :     int EscFreq = EscCount; //(Stats)  ? Stats->Freq & ~0x80  : 0;
; 211  :     int nc      = 0;
; 212  : 
; 213  :     STATE* p;
; 214  :     int f, a, b, c;
; 215  :     if (nc < o)                             
; 216  :         nc=o;
; 217  :         
; 218  :     putc(NumStats,fp);
; 219  :     if ( !NumStats ) {
; 220  :         f=(p=&oneState())->Freq;
; 221  :         if ( EscFreq )                      f=(2*f)/EscFreq;
; 222  :         f=CLAMP(f,1,127) | 0x80*(p->Successor != NULL);
; 223  :         putc(f,fp);                         putc(p->Symbol,fp);
; 224  :         if ( p->Successor )                 p->Successor->write(o+1,fp);
; 225  :         return;
; 226  :     }
; 227  :     for (p=Stats+1;p <= Stats+NumStats;p++) {
; 228  :         if (p[0].Freq > p[-1].Freq) {
; 229  :             STATE* p1=p;
; 230  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq > p1[-1].Freq);
; 231  :         }
; 232  :         if (p[0].Freq == p[-1].Freq && p[0].Successor && !p[-1].Successor) {
; 233  :             STATE* p1=p;
; 234  :             do { SWAP(p1[0],p1[-1]); } while (--p1 != Stats && p1[0].Freq == p1[-1].Freq && !p1[-1].Successor);
; 235  :         }
; 236  :     }
; 237  :     a=Stats->Freq+!Stats->Freq;             f=(64*EscFreq+(b=a >> 1))/a;
; 238  :     f=CLAMP(f,1,127) | 0x80*(Stats->Successor != NULL);
; 239  :     putc(f,fp);                             c=64;
; 240  :     for (p=Stats;p <= Stats+NumStats;p++) {
; 241  :         f=(64*p->Freq+b)/a;                 f += !f;
; 242  :         if (p != Stats)
; 243  :             putc((c-f) | 0x80*(p->Successor != NULL),fp);
; 244  :         c=f;                                putc(p->Symbol,fp);
; 245  :     }
; 246  :     for (p=Stats;p <= Stats+NumStats;p++)
; 247  :             if ( p->Successor )             p->Successor->write(o+1,fp);
; 248  : }
; 249  : */
; 250  : void PPM_CONTEXT::refresh(int OldNU,BOOL Scale)
; 251  : {
; 252  :     int i=NumStats, EscFreq;
; 253  :     STATE* p = Stats = (STATE*) ShrinkUnits(Stats,OldNU,(i+2) >> 1);
; 254  :     Flags=(Flags & (0x10+0x04*Scale))+0x08*(p->Symbol >= 0x40);
; 255  :     EscFreq=SummFreq-p->Freq;
; 256  :     SummFreq = (p->Freq=(p->Freq+Scale) >> Scale);
; 257  :     do {
; 258  :         EscFreq -= (++p)->Freq;
; 259  :         SummFreq += (p->Freq=(p->Freq+Scale) >> Scale);
; 260  :         Flags |= 0x08*(p->Symbol >= 0x40);
; 261  :     } while ( --i );
; 262  :     SummFreq += (EscFreq=(EscFreq+Scale) >> Scale);
; 263  : }
; 264  : #define P_CALL(F) ( PrefetchData(p->Successor), \
; 265  :                     p->Successor=p->Successor->F(Order+1))
; 266  : PPM_CONTEXT* PPM_CONTEXT::cutOff(int Order)
; 267  : {
; 268  :     int i, tmp;
; 269  :     STATE* p;
; 270  :     if ( !NumStats ) {
; 271  :         if ((BYTE*) (p=&oneState())->Successor >= UnitsStart) {
; 272  :             if (Order < MaxOrder)           P_CALL(cutOff);
; 273  :             else                            p->Successor=NULL;
; 274  :             if (!p->Successor && Order > O_BOUND)
; 275  :                     goto REMOVE;
; 276  :             return this;
; 277  :         } else {
; 278  : REMOVE:     SpecialFreeUnit(this);          return NULL;
; 279  :         }
; 280  :     }
; 281  :     PrefetchData(Stats);
; 282  :     Stats = (STATE*) MoveUnitsUp(Stats,tmp=(NumStats+2) >> 1);
; 283  :     for (p=Stats+(i=NumStats);p >= Stats;p--)
; 284  :             if ((BYTE*) p->Successor < UnitsStart) {
; 285  :                 p->Successor=NULL;          SWAP(*p,Stats[i--]);
; 286  :             } else if (Order < MaxOrder)    P_CALL(cutOff);
; 287  :             else                            p->Successor=NULL;
; 288  :     if (i != NumStats && Order) {
; 289  :         NumStats=i;                         p=Stats;
; 290  :         if (i < 0) { FreeUnits(p,tmp);      goto REMOVE; }
; 291  :         else if (i == 0) {
; 292  :             Flags=(Flags & 0x10)+0x08*(p->Symbol >= 0x40);
; 293  :             StateCpy(oneState(),*p);        FreeUnits(p,tmp);
; 294  :             oneState().Freq=(oneState().Freq+11) >> 3;
; 295  :         } else                              refresh(tmp,SummFreq > 16*i);
; 296  :     }
; 297  :     return this;
; 298  : }
; 299  : PPM_CONTEXT* PPM_CONTEXT::removeBinConts(int Order)
; 300  : {
; 301  :     STATE* p;
; 302  :     if ( !NumStats ) {
; 303  :         p=&oneState();
; 304  :         if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 305  :                 P_CALL(removeBinConts);
; 306  :         else                                p->Successor=NULL;
; 307  :         if (!p->Successor && (!Suffix->NumStats || Suffix->Flags == 0xFF)) {
; 308  :             FreeUnits(this,1);              return NULL;
; 309  :         } else                              return this;
; 310  :     }
; 311  :     PrefetchData(Stats);
; 312  :     for (p=Stats+NumStats;p >= Stats;p--)
; 313  :             if ((BYTE*) p->Successor >= UnitsStart && Order < MaxOrder)
; 314  :                     P_CALL(removeBinConts);
; 315  :             else                            p->Successor=NULL;
; 316  :     return this;
; 317  : }
; 318  : 
; 319  : static void RestoreModelRare(PPM_CONTEXT* pc1,PPM_CONTEXT* MinContext,
; 320  :         PPM_CONTEXT* FSuccessor)
; 321  : {
; 322  :     PPM_CONTEXT* pc;
; 323  :     PPM_CONTEXT::STATE* p;
; 324  :     for (pc=MaxContext, pText=HeapStart;pc != pc1;pc=pc->Suffix)
; 325  :             if (--(pc->NumStats) == 0) {
; 326  :                 pc->Flags=(pc->Flags & 0x10)+0x08*(pc->Stats->Symbol >= 0x40);
; 327  :                 p=pc->Stats;                StateCpy(pc->oneState(),*p);
; 328  :                 SpecialFreeUnit(p);
; 329  :                 pc->oneState().Freq=(pc->oneState().Freq+11) >> 3;
; 330  :             } else
; 331  :                     pc->refresh((pc->NumStats+3) >> 1,FALSE);
; 332  :     for ( ;pc != MinContext;pc=pc->Suffix)
; 333  :             if ( !pc->NumStats )
; 334  :                     pc->oneState().Freq -= pc->oneState().Freq >> 1;
; 335  :             else if ((pc->SummFreq += 4) > 128+4*pc->NumStats)
; 336  :                     pc->refresh((pc->NumStats+2) >> 1,TRUE);
; 337  :     if (MRMethod > MRM_FREEZE) {
; 338  :         MaxContext=FSuccessor;              GlueCount += !(BList[1].Stamp & 1);
; 339  :     } else if (MRMethod == MRM_FREEZE) {
; 340  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 341  :         MaxContext->removeBinConts(0);      MRMethod=MR_METHOD(MRMethod+1);
; 342  :         GlueCount=0;                        OrderFall=MaxOrder;
; 343  : 	} else if (MRMethod == MRM_RESTART || GetUsedMemory() < (SubAllocatorSize >> 1)) {
; 344  :         StartModelRare(MaxOrder,MRMethod);
; 345  :         EscCount=0;                         PrintCount=0xFF;
; 346  :     } else {
; 347  :         while ( MaxContext->Suffix )        MaxContext=MaxContext->Suffix;
; 348  :         do {
; 349  :             MaxContext->cutOff(0);          ExpandTextArea();
; 350  : 		} while (GetUsedMemory() > 3*(SubAllocatorSize >> 2));
; 351  :         GlueCount=0;                        OrderFall=MaxOrder;
; 352  :     }
; 353  : }
; 354  : 
; 355  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 356  :         PPM_CONTEXT* pc);
; 357  : static PPM_CONTEXT* _FASTCALL ReduceOrder(PPM_CONTEXT::STATE* p,PPM_CONTEXT* pc)
; 358  : {
; 359  :     PPM_CONTEXT::STATE* p1,  * ps[MAX_O], ** pps=ps;
; 360  :     PPM_CONTEXT* pc1=pc, * UpBranch = (PPM_CONTEXT*) pText;
; 361  :     BYTE tmp, sym=FoundState->Symbol;
; 362  :     *pps++ = FoundState;                    FoundState->Successor=UpBranch;
; 363  :     OrderFall++;
; 364  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 365  :     for ( ; ; ) {
; 366  :         if ( !pc->Suffix ) {
; 367  :             if (MRMethod > MRM_FREEZE) {
; 368  : FROZEN:         do { (*--pps)->Successor = pc; } while (pps != ps);
; 369  :                 pText=HeapStart+1;          OrderFall=1;
; 370  :             }
; 371  :             return pc;
; 372  :         }
; 373  :         pc=pc->Suffix;
; 374  :         if ( pc->NumStats ) {
; 375  :             if ((p=pc->Stats)->Symbol != sym)
; 376  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 377  :             tmp=2*(p->Freq < MAX_FREQ-9);
; 378  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 379  :         } else { p=&(pc->oneState());       p->Freq += (p->Freq < 32); }
; 380  : LOOP_ENTRY:
; 381  :         if ( p->Successor )                 break;
; 382  :         *pps++ = p;                         p->Successor=UpBranch;
; 383  :         OrderFall++;
; 384  :     }
; 385  :     if (MRMethod > MRM_FREEZE) {
; 386  :         pc = p->Successor;                  goto FROZEN;
; 387  :     } else if (p->Successor <= UpBranch) {
; 388  :         p1=FoundState;                      FoundState=p;
; 389  :         p->Successor=CreateSuccessors(FALSE,NULL,pc);
; 390  :         FoundState=p1;
; 391  :     }
; 392  :     if (OrderFall == 1 && pc1 == MaxContext) {
; 393  :         FoundState->Successor=p->Successor; pText--;
; 394  :     }
; 395  :     return p->Successor;
; 396  : }
; 397  : void PPM_CONTEXT::rescale()
; 398  : {
; 399  :     UINT OldNU, Adder, EscFreq, i=NumStats;
; 400  :     STATE tmp, * p1, * p;
; 401  :     for (p=FoundState;p != Stats;p--)       SWAP(p[0],p[-1]);
; 402  :     p->Freq += 4;                           SummFreq += 4;
; 403  :     EscFreq=SummFreq-p->Freq;
; 404  :     Adder=(OrderFall != 0 || MRMethod > MRM_FREEZE);
; 405  :     SummFreq = (p->Freq=(p->Freq+Adder) >> 1);
; 406  :     do {
; 407  :         EscFreq -= (++p)->Freq;
; 408  :         SummFreq += (p->Freq=(p->Freq+Adder) >> 1);
; 409  :         if (p[0].Freq > p[-1].Freq) {
; 410  :             StateCpy(tmp,*(p1=p));
; 411  :             do StateCpy(p1[0],p1[-1]); while (tmp.Freq > (--p1)[-1].Freq);
; 412  :             StateCpy(*p1,tmp);
; 413  :         }
; 414  :     } while ( --i );
; 415  :     if (p->Freq == 0) {
; 416  :         do { i++; } while ((--p)->Freq == 0);
; 417  :         EscFreq += i;                       OldNU=(NumStats+2) >> 1;
; 418  :         if ((NumStats -= i) == 0) {
; 419  :             StateCpy(tmp,*Stats);
; 420  :             tmp.Freq=(2*tmp.Freq+EscFreq-1)/EscFreq;
; 421  :             if (tmp.Freq > MAX_FREQ/3)      tmp.Freq=MAX_FREQ/3;
; 422  :             FreeUnits(Stats,OldNU);         StateCpy(oneState(),tmp);
; 423  :             Flags=(Flags & 0x10)+0x08*(tmp.Symbol >= 0x40);
; 424  :             FoundState=&oneState();         return;
; 425  :         }
; 426  :         Stats = (STATE*) ShrinkUnits(Stats,OldNU,(NumStats+2) >> 1);
; 427  :         Flags &= ~0x08;                     i=NumStats;
; 428  :         Flags |= 0x08*((p=Stats)->Symbol >= 0x40);
; 429  :         do { Flags |= 0x08*((++p)->Symbol >= 0x40); } while ( --i );
; 430  :     }
; 431  :     SummFreq += (EscFreq -= (EscFreq >> 1));
; 432  :     Flags |= 0x04;                          FoundState=Stats;
; 433  : }
; 434  : static PPM_CONTEXT* _FASTCALL CreateSuccessors(BOOL Skip,PPM_CONTEXT::STATE* p,
; 435  :         PPM_CONTEXT* pc)
; 436  : {
; 437  : 
; 438  :     PPM_CONTEXT ct, * UpBranch=FoundState->Successor;
; 439  :     PPM_CONTEXT::STATE* ps[MAX_O], ** pps=ps;
; 440  :     UINT cf, s0;
; 441  :     BYTE tmp, sym=FoundState->Symbol;
; 442  :     if ( !Skip ) {
; 443  :         *pps++ = FoundState;
; 444  :         if ( !pc->Suffix )                  goto NO_LOOP;
; 445  :     }
; 446  :     if ( p ) { pc=pc->Suffix;               goto LOOP_ENTRY; }
; 447  :     do {
; 448  :         pc=pc->Suffix;
; 449  :         if ( pc->NumStats ) {
; 450  :             if ((p=pc->Stats)->Symbol != sym)
; 451  :                     do { tmp=p[1].Symbol;   p++; } while (tmp != sym);
; 452  :             tmp=(p->Freq < MAX_FREQ-9);
; 453  :             p->Freq += tmp;                 pc->SummFreq += tmp;
; 454  :         } else {
; 455  :             p=&(pc->oneState());
; 456  :             p->Freq += (!pc->Suffix->NumStats & (p->Freq < 24));
; 457  :         }
; 458  : LOOP_ENTRY:
; 459  :         if (p->Successor != UpBranch) {
; 460  :             pc=p->Successor;                break;
; 461  :         }
; 462  :         *pps++ = p;
; 463  :     } while ( pc->Suffix );
; 464  : NO_LOOP:
; 465  :     if (pps == ps)                          return pc;
; 466  :     ct.NumStats=0;                          ct.Flags=0x10*(sym >= 0x40);
; 467  :     ct.oneState().Symbol=sym=*(BYTE*) UpBranch;
; 468  :     ct.oneState().Successor=(PPM_CONTEXT*) (((BYTE*) UpBranch)+1);
; 469  :     ct.Flags |= 0x08*(sym >= 0x40);
; 470  :     if ( pc->NumStats ) {
; 471  :         if ((p=pc->Stats)->Symbol != sym)
; 472  :                 do { tmp=p[1].Symbol;       p++; } while (tmp != sym);
; 473  :         s0=pc->SummFreq-pc->NumStats-(cf=p->Freq-1);
; 474  :         ct.oneState().Freq=1+((2*cf <= s0)?(5*cf > s0):((cf+2*s0-3)/s0));
; 475  :     } else
; 476  :             ct.oneState().Freq=pc->oneState().Freq;
; 477  :     do {
; 478  :         PPM_CONTEXT* pc1 = (PPM_CONTEXT*) AllocContext();
; 479  :         if ( !pc1 )                         return NULL;
; 480  :         ((DWORD*) pc1)[0] = ((DWORD*) &ct)[0];
; 481  :         ((DWORD*) pc1)[1] = ((DWORD*) &ct)[1];
; 482  :         pc1->Suffix=pc;                     (*--pps)->Successor=pc=pc1;
; 483  :     } while (pps != ps);
; 484  :     return pc;
; 485  : }
; 486  : 
; 487  : 
; 488  : static inline void UpdateModel( PPM_CONTEXT* MinContext)
; 489  : {
; 490  :     PPM_CONTEXT::STATE* p           = NULL;
; 491  :     PPM_CONTEXT*        FSuccessor  = FoundState->Successor;
; 492  :     PPM_CONTEXT*        pc          = MinContext->Suffix;
; 493  :     PPM_CONTEXT*        pc1         = MaxContext;
; 494  :     
; 495  :     UINT ns1, ns, cf, sf, s0, FFreq=FoundState->Freq;
; 496  :     BYTE Flag, sym, FSymbol=FoundState->Symbol;
; 497  : 
; 498  : 
; 499  :     if( FFreq < MAX_FREQ/4  &&  pc ) 
; 500  :     {
; 501  :         if ( pc->NumStats ) 
; 502  :         {
; 503  :             if ((p=pc->Stats)->Symbol != FSymbol) 
; 504  :             {
; 505  :                 do { sym=p[1].Symbol;       p++; } while (sym != FSymbol);
; 506  :                 if (p[0].Freq >= p[-1].Freq) 
; 507  :                 {
; 508  :                     SWAP(p[0],p[-1]);       
; 509  :                     p--;
; 510  :                 }
; 511  :             }
; 512  :             cf=2*(p->Freq < MAX_FREQ-9);
; 513  :             p->Freq      += cf;                  
; 514  :             pc->SummFreq += cf;
; 515  :         } 
; 516  :         else 
; 517  :         { 
; 518  :             p=&(pc->oneState());       
; 519  :             p->Freq += (p->Freq < 32); 
; 520  :         }
; 521  :     }
; 522  :     
; 523  :     if( !OrderFall && FSuccessor) 
; 524  :     {
; 525  :         FoundState->Successor=CreateSuccessors(TRUE,p,MinContext);
; 526  :         if ( !FoundState->Successor )       
; 527  :             goto RESTART_MODEL;
; 528  :         MaxContext=FoundState->Successor;   
; 529  :         return;
; 530  :     }
; 531  : 
; 532  :     *pText++ = FSymbol;                     
; 533  : 
; 534  :     PPM_CONTEXT*    Successor = (PPM_CONTEXT*) pText;
; 535  :     
; 536  :     if (pText >= UnitsStart)                
; 537  :         goto RESTART_MODEL;
; 538  : 
; 539  : 
; 540  :     if( FSuccessor ) 
; 541  :     {
; 542  :         if ((BYTE*) FSuccessor < UnitsStart)
; 543  :             FSuccessor=CreateSuccessors(FALSE,p,MinContext);
; 544  :     } 
; 545  :     else
; 546  :     {
; 547  :         FSuccessor=ReduceOrder(p,MinContext);
; 548  :     }
; 549  :     
; 550  :     if( !FSuccessor )                          
; 551  :         goto RESTART_MODEL;
; 552  : 
; 553  : 
; 554  :     if( !--OrderFall ) 
; 555  :     {
; 556  :         Successor=FSuccessor;               
; 557  :         pText -= (MaxContext != MinContext);
; 558  :     } 
; 559  :     else if( MRMethod > MRM_FREEZE) 
; 560  :     {
; 561  :         Successor=FSuccessor;               
; 562  :         pText=HeapStart;
; 563  :         OrderFall=0;
; 564  :     }
; 565  :     
; 566  :     s0=MinContext->SummFreq-(ns=MinContext->NumStats)-FFreq;
; 567  :     for (Flag=0x08*(FSymbol >= 0x40);pc1 != MinContext;pc1=pc1->Suffix) 
; 568  :     {
; 569  :         if ((ns1=pc1->NumStats) != 0) 
; 570  :         {
; 571  :             if ((ns1 & 1) != 0) 
; 572  :             {
; 573  :                 p=(PPM_CONTEXT::STATE*) ExpandUnits(pc1->Stats,(ns1+1) >> 1);
; 574  :                 if ( !p )                   
; 575  :                     goto RESTART_MODEL;
; 576  :                 pc1->Stats=p;
; 577  :             }
; 578  :             pc1->SummFreq += (3*ns1+1 < ns);
; 579  :         } 
; 580  :         else 
; 581  :         {
; 582  :             p=(PPM_CONTEXT::STATE*) AllocUnits(1);
; 583  :             if ( !p )                       
; 584  :                 goto RESTART_MODEL;
; 585  :                 
; 586  :             StateCpy(*p,pc1->oneState());   
; 587  :             pc1->Stats=p;
; 588  :             
; 589  :             if (p->Freq < MAX_FREQ/4-1)     p->Freq += p->Freq;
; 590  :             else                            p->Freq  = MAX_FREQ-4;
; 591  :             
; 592  :             pc1->SummFreq=p->Freq+InitEsc+(ns > 2);
; 593  :         }
; 594  : 
; 595  :         cf=2*FFreq*(pc1->SummFreq+6);       
; 596  :         sf=s0+pc1->SummFreq;
; 597  : 
; 598  :         if (cf < 6*sf) 
; 599  :         {
; 600  :             cf=1+(cf > sf)+(cf >= 4*sf);
; 601  :             pc1->SummFreq += 4;
; 602  :         } 
; 603  :         else 
; 604  :         {
; 605  :             cf=4+(cf > 9*sf)+(cf > 12*sf)+(cf > 15*sf);
; 606  :             pc1->SummFreq += cf;
; 607  :         }
; 608  :         p=pc1->Stats+(++pc1->NumStats);     
; 609  :         p->Successor=Successor;
; 610  :         p->Symbol = FSymbol;                
; 611  :         p->Freq = cf;
; 612  :         pc1->Flags |= Flag;
; 613  :     }
; 614  : 
; 615  :     MaxContext=FSuccessor;
; 616  :     return;
; 617  : 
; 618  : RESTART_MODEL:
; 619  :     RestoreModelRare(pc1,MinContext,FSuccessor);
; 620  : 
; 621  : }
; 622  : // Tabulated escapes for exponential symbol distribution
; 623  : static const BYTE ExpEscape[16]={ 25,14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };
; 624  : #define GET_MEAN(SUMM,SHIFT,ROUND) ((SUMM+(1 << (SHIFT-ROUND))) >> (SHIFT))
; 625  : inline void PPM_CONTEXT::encodeBinSymbol(int symbol)
; 626  : {
; 627  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 628  :     STATE& rs=oneState();
; 629  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 630  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 631  :     if (rs.Symbol == symbol) {
; 632  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 633  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 634  :         PrevSuccess=1;                      RunLength++;
; 635  :     } else {
; 636  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 637  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 638  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 639  :     }
; 640  : }
; 641  : inline void PPM_CONTEXT::decodeBinSymbol() const
; 642  : {
; 643  :     BYTE indx=NS2BSIndx[Suffix->NumStats]+PrevSuccess+Flags;
; 644  :     STATE& rs=oneState();
; 645  : 
; 646  :     WORD& bs=BinSumm[QTable[rs.Freq-1]][indx+((RunLength >> 26) & 0x20)];
; 647  :     UINT tmp=rcBinStart(bs,TOT_BITS);
; 648  :     if ( !rcBinDecode(tmp) ) {
; 649  :         FoundState=&rs;                     rs.Freq += (rs.Freq < 196);
; 650  :         rcBinCorrect0(tmp);                 bs += INTERVAL-GET_MEAN(bs,PERIOD_BITS,2);
; 651  :         PrevSuccess=1;                      RunLength++;
; 652  :     } else {
; 653  :         rcBinCorrect1(tmp,BIN_SCALE-bs);    bs -= GET_MEAN(bs,PERIOD_BITS,2);
; 654  :         InitEsc=ExpEscape[bs >> 10];        CharMask[rs.Symbol]=EscCount;
; 655  :         NumMasked=PrevSuccess=0;            FoundState=NULL;
; 656  :     }
; 657  : }
; 658  : inline void PPM_CONTEXT::update1(STATE* p) 
; 659  : {
; 660  :     (FoundState=p)->Freq += 4;              SummFreq += 4;
; 661  :     if (p[0].Freq > p[-1].Freq) {
; 662  :         SWAP(p[0],p[-1]);                   FoundState=--p;
; 663  :         if (p->Freq > MAX_FREQ)             rescale();
; 664  :     }
; 665  : }
; 666  : inline void PPM_CONTEXT::encodeSymbol1(int symbol)
; 667  : {
; 668  :     UINT LoCnt, i=Stats->Symbol;
; 669  :     STATE* p=Stats;                         SubRange.scale=SummFreq;
; 670  :     if (i == symbol) {
; 671  :         PrevSuccess=(2*(SubRange.high=p->Freq) >= SubRange.scale);
; 672  :         (FoundState=p)->Freq += 4;          SummFreq += 4;
; 673  :         RunLength += PrevSuccess;
; 674  :         if (p->Freq > MAX_FREQ)             rescale();
; 675  :         SubRange.low=0;                        return;
; 676  :     }
; 677  :     LoCnt=p->Freq;
; 678  :     i=NumStats;                             PrevSuccess=0;
; 679  :     while ((++p)->Symbol != symbol) {
; 680  :         LoCnt += p->Freq;
; 681  :         if (--i == 0) {
; 682  :             if ( Suffix )                   PrefetchData(Suffix);
; 683  :             SubRange.low=LoCnt;                CharMask[p->Symbol]=EscCount;
; 684  :             i=NumMasked=NumStats;           FoundState=NULL;
; 685  :             do { CharMask[(--p)->Symbol]=EscCount; } while ( --i );
; 686  :             SubRange.high=SubRange.scale;         return;
; 687  :         }
; 688  :     }
; 689  :     SubRange.high=(SubRange.low=LoCnt)+p->Freq;   update1(p);
; 690  : }
; 691  : inline void PPM_CONTEXT::decodeSymbol1()
; 692  : {
; 693  :     UINT i, count, HiCnt=Stats->Freq;
; 694  :     STATE* p=Stats;                         SubRange.scale=SummFreq;
; 695  :     if ((count=rcGetCurrentCount()) < HiCnt) {
; 696  :         PrevSuccess=(2*(SubRange.high=HiCnt) >= SubRange.scale);
; 697  : 
; 698  :         (FoundState=p)->Freq=(HiCnt += 4);  
; 699  :         SummFreq += 4;
; 700  : 
; 701  :         RunLength += PrevSuccess;
; 702  :         if (HiCnt > MAX_FREQ)               rescale();
; 703  :         SubRange.low=0;                        return;
; 704  :     }
; 705  :     i=NumStats;                             PrevSuccess=0;
; 706  :     while ((HiCnt += (++p)->Freq) <= count)
; 707  :         if (--i == 0) {
; 708  :             if ( Suffix )                   PrefetchData(Suffix);
; 709  :             SubRange.low=HiCnt;                CharMask[p->Symbol]=EscCount;
; 710  :             i=NumMasked=NumStats;           FoundState=NULL;
; 711  :             do { CharMask[(--p)->Symbol]=EscCount; } while ( --i );
; 712  :             SubRange.high=SubRange.scale;         return;
; 713  :         }
; 714  :     SubRange.low=(SubRange.high=HiCnt)-p->Freq;   
; 715  :     ((PPM_CONTEXT*)this)->update1(p);
; 716  : }
; 717  : inline void PPM_CONTEXT::update2(STATE* p)
; 718  : {
; 719  : /*
; 720  :     ++EscCount;
; 721  :     RunLength = InitRL;
; 722  : */
; 723  :     (FoundState=p)->Freq += 4;              SummFreq += 4;

	add	BYTE PTR [r8+1], 4
	add	WORD PTR [rbp+2], 4

; 724  :     if (p->Freq > MAX_FREQ)                 rescale();

	cmp	BYTE PTR [r8+1], 124			; 0000007cH
	mov	QWORD PTR FoundState, r8
	jbe	SHORT $LN21@decodeSymb
	mov	rcx, rbp
	call	?rescale@PPM_CONTEXT@@QEAAXXZ		; PPM_CONTEXT::rescale
$LN21@decodeSymb:

; 725  :     EscCount++;                             RunLength=InitRL;

	mov	eax, DWORD PTR InitRL
	inc	bl
	mov	DWORD PTR RunLength, eax
	mov	BYTE PTR EscCount, bl

; 781  :         psee2c->update();                   
; 782  :         update2(p);
; 783  :     } else {

	jmp	SHORT $LN4@decodeSymb
$LN7@decodeSymb:

; 784  :         SubRange.low=HiCnt;                    SubRange.high=SubRange.scale;

	mov	DWORD PTR SubRange, r11d
	mov	DWORD PTR SubRange+4, esi

; 785  :         i=NumStats-NumMasked;               NumMasked = NumStats;

	mov	BYTE PTR NumMasked, r14b
	npad	8
$LL3@decodeSymb:

; 786  :         do { CharMask[(*pps)->Symbol]=EscCount; pps++; } while ( --i );

	mov	rax, QWORD PTR [rdx]
	lea	rdx, QWORD PTR [rdx+8]
	movzx	ecx, BYTE PTR [rax]
	mov	BYTE PTR [rcx+r15], bl
	dec	r9d
	jne	SHORT $LL3@decodeSymb

; 787  :         psee2c->Summ += SubRange.scale;

	movzx	eax, WORD PTR SubRange+8
	add	WORD PTR [rdi], ax
$LN4@decodeSymb:

; 788  :     }
; 789  : }

	lea	r11, QWORD PTR [rsp+2080]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+40]
	mov	rsi, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	rdi
	ret	0
?decodeSymbol2@PPM_CONTEXT@@QEAAXXZ ENDP		; PPM_CONTEXT::decodeSymbol2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
;	COMDAT ?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z
_TEXT	SEGMENT
EncodedFile$dead$ = 48
DecodedFile$dead$ = 56
?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z PROC	; ClearMask, COMDAT

; 791  : {

$LN7:
	sub	rsp, 40					; 00000028H

; 792  :     EscCount=1;                             memset(CharMask,0,sizeof(CharMask));

	lea	rcx, OFFSET FLAT:CharMask
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	mov	BYTE PTR EscCount, 1
	call	memset

; 793  :     if (++PrintCount == 0)                  PrintInfo(DecodedFile,EncodedFile);

	inc	BYTE PTR PrintCount

; 794  : }

	add	rsp, 40					; 00000028H
	ret	0
?ClearMask@@YAXPEAVstream@ppmd@compression@@0@Z ENDP	; ClearMask
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp
_TEXT	SEGMENT
MaxOrder$ = 80
MRMethod$ = 88
?StartModelRare@@YAXHW4MR_METHOD@@@Z PROC		; StartModelRare

; 909  : {

	push	rbx
	push	r14
	sub	rsp, 56					; 00000038H
	mov	r14d, ecx
	mov	ebx, edx

; 910  :     static bool         first_time  = true;
; 911  :     static PPM_CONTEXT* context     = 0;
; 912  : 
; 913  :     if( first_time )
; 914  :     {
; 915  :         UINT i, k, m;
; 916  : 
; 917  :         memset( CharMask, 0, sizeof(CharMask) );

	lea	rcx, OFFSET FLAT:CharMask
	xor	edx, edx
	mov	r8d, 256				; 00000100H
	call	memset

; 918  :         EscCount=PrintCount=1;

	mov	BYTE PTR PrintCount, 1
	mov	BYTE PTR EscCount, 1

; 919  :         if( MaxOrder < 2 ) // we are in solid mode

	cmp	r14d, 2
	jge	SHORT $LN30@StartModel

; 920  :         {                     
; 921  :             OrderFall = ::MaxOrder;
; 922  :             for( PPM_CONTEXT* pc=MaxContext; pc&&pc->Suffix; pc=pc->Suffix )

	mov	rax, QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA ; MaxContext
	mov	ecx, DWORD PTR MaxOrder
	mov	DWORD PTR OrderFall, ecx
	test	rax, rax
	je	$LN1@StartModel
$LL29@StartModel:
	mov	rax, QWORD PTR [rax+12]
	test	rax, rax
	je	$LN1@StartModel

; 923  :                 OrderFall--;

	dec	ecx
	mov	DWORD PTR OrderFall, ecx
	test	rax, rax
	jne	SHORT $LL29@StartModel

; 975  :     }
; 976  :     else
; 977  :     {    
; 978  :     
; 979  :         UINT i, k, m;
; 980  : 
; 981  :         memset( CharMask, 0, sizeof(CharMask) );
; 982  :         EscCount=PrintCount=1;
; 983  :         ::OrderFall = ::MaxOrder = MaxOrder;          
; 984  :         ::MRMethod  = MRMethod;
; 985  :         
; 986  : ///        InitSubAllocator();
; 987  :         RunLength = InitRL = -((MaxOrder < 12) ? MaxOrder : 12) - 1;
; 988  : ///        MaxContext = (PPM_CONTEXT*) AllocContext();
; 989  : ///        MaxContext->Suffix = NULL;
; 990  : 
; 991  :         MaxContext  = context;
; 992  :         FoundState  = 0;
; 993  : 
; 994  : /*
; 995  :         if( !trained_model || _PPMD_E_GETC(trained_model) > MaxOrder ) 
; 996  :         {
; 997  :             MaxContext->SummFreq=(MaxContext->NumStats=255)+2;
; 998  :             MaxContext->Stats = (PPM_CONTEXT::STATE*) AllocUnits(256/2);
; 999  :             for( PrevSuccess=i=0;i < 256;i++) 
; 1000 :             {
; 1001 :                 MaxContext->Stats[i].Symbol=i;  MaxContext->Stats[i].Freq=1;
; 1002 :                 MaxContext->Stats[i].Successor=NULL;
; 1003 :             }
; 1004 :         } 
; 1005 :         else 
; 1006 :         {
; 1007 :             MaxContext->read(trained_model,0xFF);
; 1008 :             MaxContext->makeSuffix();
; 1009 :         }
; 1010 : */
; 1011 :     }
; 1012 : }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rbx
	ret	0
$LN30@StartModel:
	mov	QWORD PTR [rsp+80], rbp
	mov	QWORD PTR [rsp+88], rsi
	mov	QWORD PTR [rsp+96], rdi
	mov	QWORD PTR [rsp+48], r12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 75   :     memset(BList,0,sizeof(BList));

	lea	rcx, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A ; BList
	xor	edx, edx
	mov	r8d, 456				; 000001c8H
	mov	QWORD PTR [rsp+40], r13
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 927  :         ::OrderFall = ::MaxOrder = MaxOrder;          

	mov	DWORD PTR MaxOrder, r14d
	mov	QWORD PTR [rsp+32], r15
	mov	DWORD PTR OrderFall, r14d

; 928  :         ::MRMethod  = MRMethod;

	mov	DWORD PTR MRMethod, ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 75   :     memset(BList,0,sizeof(BList));

	call	memset

; 76   :     HiUnit=(pText=HeapStart)+SubAllocatorSize;

	mov	rax, QWORD PTR HeapStart
	mov	ecx, DWORD PTR SubAllocatorSize
	movzx	r10d, BYTE PTR QTable
	lea	rbp, QWORD PTR [rax+rcx]

; 77   :     UINT Diff=UNIT_SIZE*(SubAllocatorSize/8/UNIT_SIZE*7);

	shr	ecx, 3

; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;

	xor	r13d, r13d
	mov	QWORD PTR pText, rax
	mov	eax, -1431655765			; aaaaaaabH
	mov	rsi, rbp
	mov	QWORD PTR HiUnit, rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 927  :         ::OrderFall = ::MaxOrder = MaxOrder;          

	lea	rbx, OFFSET FLAT:BinSumm+16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 77   :     UINT Diff=UNIT_SIZE*(SubAllocatorSize/8/UNIT_SIZE*7);

	mul	ecx
	shr	edx, 3

; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;

	mov	DWORD PTR GlueCount, r13d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 935  :         for( i=m=0; m<25; m++ ) 

	mov	r11d, r13d
	mov	r9d, r13d
	lea	rdi, OFFSET FLAT:BinSumm+2
	lea	r12, OFFSET FLAT:__ImageBase
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 77   :     UINT Diff=UNIT_SIZE*(SubAllocatorSize/8/UNIT_SIZE*7);

	imul	ecx, edx, 84				; 00000054H

; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;

	sub	rsi, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 931  :         RunLength = InitRL = -((MaxOrder < 12) ? MaxOrder : 12) - 1;

	mov	ecx, 12
	cmp	r14d, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 78   :     LoUnit=UnitsStart=HiUnit-Diff;          GlueCount=0;

	mov	QWORD PTR UnitsStart, rsi
	mov	QWORD PTR LoUnit, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 931  :         RunLength = InitRL = -((MaxOrder < 12) ? MaxOrder : 12) - 1;

	cmovl	ecx, r14d
	or	r15d, -1
	mov	eax, r15d
	sub	eax, ecx
	mov	DWORD PTR InitRL, eax
	mov	DWORD PTR RunLength, eax
	npad	6
$LL26@StartModel:

; 936  :         {
; 937  :             while( QTable[i] == m )              

	cmp	r10d, r11d
	jne	SHORT $LN22@StartModel
	npad	11
$LL23@StartModel:

; 938  :                 i++;

	inc	r9d
	movzx	r10d, BYTE PTR QTable[r9+r12]
	cmp	r10d, r11d
	je	SHORT $LL23@StartModel
$LN22@StartModel:

; 939  :                 
; 940  :             for( k=0; k<8; k++ )
; 941  :                 BinSumm[m][k] = BIN_SCALE - InitBinEsc[k]/(i+1);

	xor	edx, edx
	lea	r8d, DWORD PTR [r9+1]
	mov	eax, 15581				; 00003cddH
	div	r8d
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 7999				; 00001f3fH
	div	r8d
	mov	WORD PTR [rdi-2], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 22975				; 000059bfH
	div	r8d
	mov	WORD PTR [rdi], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 18675				; 000048f3H
	div	r8d
	mov	WORD PTR [rdi+2], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 25761				; 000064a1H
	div	r8d
	mov	WORD PTR [rdi+4], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 23228				; 00005abcH
	div	r8d
	mov	WORD PTR [rdi+6], cx
	xor	edx, edx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 26162				; 00006632H
	div	r8d
	mov	WORD PTR [rdi+8], cx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	eax, 24657				; 00006051H
	xor	edx, edx
	div	r8d
	mov	WORD PTR [rdi+10], cx
	mov	ecx, 16384				; 00004000H
	sub	cx, ax
	mov	rax, rbx
	mov	WORD PTR [rdi+12], cx
	mov	ecx, 7
	npad	4
$LL18@StartModel:

; 942  :             for( k=8; k<64; k+=8 )
; 943  :                 memcpy( BinSumm[m]+k, BinSumm[m], 8*sizeof(WORD) );

	movups	xmm0, XMMWORD PTR [rbx-16]
	lea	rax, QWORD PTR [rax+16]
	movups	XMMWORD PTR [rax-16], xmm0
	dec	rcx
	jne	SHORT $LL18@StartModel

; 935  :         for( i=m=0; m<25; m++ ) 

	inc	r11d
	sub	rdi, -128				; ffffffffffffff80H
	sub	rbx, -128				; ffffffffffffff80H
	cmp	r11d, 25
	jb	$LL26@StartModel

; 944  :         }
; 945  :         for( i=m=0; m<24; m++ ) 

	mov	rdi, QWORD PTR [rsp+96]
	mov	r8d, r13d
	lea	r10d, QWORD PTR [rcx+3]
	lea	rdx, OFFSET FLAT:?SEE2Cont@@3PAY0CA@USEE2_CONTEXT@@A ; SEE2Cont
	lea	r11d, QWORD PTR [rcx+24]
	npad	3
$LL15@StartModel:

; 946  :         {
; 947  :             while( QTable[i+3] == m+3 )          

	lea	eax, DWORD PTR [r8+3]
	movzx	ecx, BYTE PTR QTable[rax+r12]
	cmp	ecx, r10d
	jne	SHORT $LN11@StartModel
	npad	14
$LL12@StartModel:

; 948  :                 i++;

	lea	eax, DWORD PTR [rax+1]
	inc	r8d
	movzx	ecx, BYTE PTR QTable[rax+r12]
	cmp	ecx, r10d
	je	SHORT $LL12@StartModel
$LN11@StartModel:

; 36   :     void init(UINT InitVal) { Summ=InitVal << (Shift=PERIOD_BITS-4); Count=7; }

	movzx	eax, r8w
	mov	WORD PTR [rdx+2], 1795			; 00000703H

; 949  :             SEE2Cont[m][0].init(2*i+5);

	lea	rcx, QWORD PTR [rdx+4]

; 36   :     void init(UINT InitVal) { Summ=InitVal << (Shift=PERIOD_BITS-4); Count=7; }

	shl	ax, 4

; 949  :             SEE2Cont[m][0].init(2*i+5);

	mov	r9d, 31

; 36   :     void init(UINT InitVal) { Summ=InitVal << (Shift=PERIOD_BITS-4); Count=7; }

	add	ax, 40					; 00000028H
	mov	WORD PTR [rdx], ax
	npad	13
$LL10@StartModel:

; 950  :             for( k=1; k<32; k++ )
; 951  :                 SEE2Cont[m][k] = SEE2Cont[m][0];

	mov	eax, DWORD PTR [rdx]
	lea	rcx, QWORD PTR [rcx+4]
	mov	DWORD PTR [rcx-4], eax
	dec	r9
	jne	SHORT $LL10@StartModel

; 944  :         }
; 945  :         for( i=m=0; m<24; m++ ) 

	inc	r10d
	sub	rdx, -128				; ffffffffffffff80H
	dec	r11
	jne	SHORT $LL15@StartModel
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 132  :     if (HiUnit != LoUnit)                   return (HiUnit -= UNIT_SIZE);

	cmp	rbp, rsi
	je	SHORT $LN41@StartModel
	sub	rbp, 12
	mov	QWORD PTR HiUnit, rbp
	mov	rbx, rbp
	jmp	SHORT $LN38@StartModel
$LN41@StartModel:

; 15   :     BOOL   avail()      const { return (next != NULL); }

	mov	rbx, QWORD PTR ?BList@@3PAUBLK_NODE@@A+4
	test	rbx, rbx

; 133  :     else if ( BList->avail() )              return BList->remove();

	je	SHORT $LN39@StartModel

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rbx+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR ?BList@@3PAUBLK_NODE@@A

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR ?BList@@3PAUBLK_NODE@@A+4, rax

; 133  :     else if ( BList->avail() )              return BList->remove();

	jmp	SHORT $LN38@StartModel
$LN39@StartModel:

; 134  :     else                                    return AllocUnitsRare(0);

	xor	ecx, ecx
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
	mov	rbx, rax
$LN38@StartModel:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 955  :         MaxContext->Suffix = NULL;

	mov	QWORD PTR [rbx+12], r13

; 957  :         if( !trained_model || _PPMD_E_GETC(trained_model) > MaxOrder ) 

	mov	rdx, QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
	mov	QWORD PTR ?MaxContext@@3PEAUPPM_CONTEXT@@EA, rbx ; MaxContext
	test	rdx, rdx
	je	SHORT $LN6@StartModel
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\compression_ppmd_stream_inline.h

; 24   : 	if (m_pointer < (m_buffer + m_buffer_size))

	mov	ecx, DWORD PTR [rdx]
	mov	rax, QWORD PTR [rdx+16]
	add	rcx, QWORD PTR [rdx+8]
	cmp	rax, rcx
	jae	SHORT $LN50@StartModel

; 25   : 		return		(*m_pointer++);

	movzx	r15d, BYTE PTR [rax]
	inc	rax
	mov	QWORD PTR [rdx+16], rax
	mov	rdx, QWORD PTR ?trained_model@@3PEAVstream@ppmd@compression@@EA ; trained_model
$LN50@StartModel:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 957  :         if( !trained_model || _PPMD_E_GETC(trained_model) > MaxOrder ) 

	cmp	r15d, r14d
	jg	SHORT $LN6@StartModel

; 965  :             }
; 966  :         } 
; 967  :         else 
; 968  :         {
; 969  :             MaxContext->read(trained_model,0xFF);

	mov	r8d, 255				; 000000ffH
	mov	rcx, rbx
	call	?read@PPM_CONTEXT@@QEAAXPEAVstream@ppmd@compression@@I@Z ; PPM_CONTEXT::read

; 970  :             MaxContext->makeSuffix();

	mov	rcx, rbx
	call	?makeSuffix@PPM_CONTEXT@@QEAAXXZ	; PPM_CONTEXT::makeSuffix
	jmp	$LN3@StartModel
$LN6@StartModel:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 124  :     UINT indx=Units2Indx[NU-1];

	movzx	r8d, BYTE PTR Units2Indx+127
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 959  :             MaxContext->SummFreq=(MaxContext->NumStats=255)+2;

	mov	eax, 257				; 00000101H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 15   :     BOOL   avail()      const { return (next != NULL); }

	lea	r10, OFFSET FLAT:?BList@@3PAUBLK_NODE@@A ; BList
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 959  :             MaxContext->SummFreq=(MaxContext->NumStats=255)+2;

	mov	WORD PTR [rbx+2], ax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();

	lea	rax, QWORD PTR [r8+r8*2]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 959  :             MaxContext->SummFreq=(MaxContext->NumStats=255)+2;

	mov	BYTE PTR [rbx], 255			; 000000ffH
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\suballoc.hpp

; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();

	lea	r9, QWORD PTR [rax*4]

; 15   :     BOOL   avail()      const { return (next != NULL); }

	cmp	QWORD PTR [r9+r10+4], r13

; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();

	je	SHORT $LN54@StartModel

; 18   :     void* remove()            {
; 19   :         BLK_NODE* p=next;                   unlink();

	mov	rdx, QWORD PTR [r9+r10+4]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	rax, QWORD PTR [rdx+4]

; 20   :         Stamp--;                            return p;

	dec	DWORD PTR [r9+r10]

; 16   :     void    link(BLK_NODE* p) { p->next=next; next=p; }
; 17   :     void  unlink()            { next=next->next; }

	mov	QWORD PTR [r9+r10+4], rax

; 125  :     if ( BList[indx].avail() )              return BList[indx].remove();

	jmp	SHORT $LN55@StartModel
$LN54@StartModel:

; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);

	movzx	eax, BYTE PTR Indx2Units[r8+r12]
	mov	rdx, rsi

; 21   :     }
; 22   :     inline void insert(void* pv,int NU);
; 23   : } BList[N_INDEXES];
; 24   : struct MEM_BLK: public BLK_NODE { DWORD NU; } _PACK_ATTR;
; 25   : #pragma pack()
; 26   : 
; 27   : static BYTE Indx2Units[N_INDEXES], Units2Indx[128]; // constants
; 28   : static DWORD GlueCount, SubAllocatorSize=0;
; 29   : static BYTE* HeapStart, * pText, * UnitsStart, * LoUnit, * HiUnit;
; 30   : 
; 31   : inline void PrefetchData(void* Addr)
; 32   : {
; 33   : #if defined(_USE_PREFETCHING)
; 34   :     BYTE PrefetchByte = *(volatile BYTE*) Addr;
; 35   : #endif /* defined(_USE_PREFETCHING) */
; 36   : }
; 37   : inline void BLK_NODE::insert(void* pv,int NU) {
; 38   :     MEM_BLK* p=(MEM_BLK*) pv;               link(p);
; 39   :     p->Stamp=~0UL;                          p->NU=NU;
; 40   :     Stamp++;
; 41   : }
; 42   : inline UINT U2B(UINT NU) { return 8*NU+4*NU; }

	lea	eax, DWORD PTR [rax+rax*2]
	shl	eax, 2

; 126  :     void* RetVal=LoUnit;                    LoUnit += U2B(Indx2Units[indx]);

	add	rsi, rax
	mov	QWORD PTR LoUnit, rsi

; 127  :     if (LoUnit <= HiUnit)                   return RetVal;

	cmp	rsi, rbp
	jbe	SHORT $LN55@StartModel

; 128  :     LoUnit -= U2B(Indx2Units[indx]);        return AllocUnitsRare(indx);

	sub	rsi, rax
	mov	ecx, r8d
	mov	QWORD PTR LoUnit, rsi
	call	?AllocUnitsRare@@YAPEAXI@Z		; AllocUnitsRare
	mov	rdx, rax
$LN55@StartModel:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\model.cpp

; 960  :             MaxContext->Stats = (PPM_CONTEXT::STATE*) AllocUnits(256/2);

	mov	QWORD PTR [rbx+4], rdx

; 961  :             for (PrevSuccess=i=0;i < 256;i++) 

	mov	edx, r13d
	mov	rcx, r13
	mov	BYTE PTR PrevSuccess, dl
	npad	8
$LL5@StartModel:

; 962  :             {
; 963  :                 MaxContext->Stats[i].Symbol=i;  MaxContext->Stats[i].Freq=1;

	mov	rax, QWORD PTR [rbx+4]
	lea	rcx, QWORD PTR [rcx+10]
	mov	BYTE PTR [rcx+rax-10], dl
	mov	rax, QWORD PTR [rbx+4]
	inc	edx
	mov	BYTE PTR [rcx+rax-9], 1

; 964  :                 MaxContext->Stats[i].Successor=NULL;

	mov	rax, QWORD PTR [rbx+4]
	mov	QWORD PTR [rcx+rax-8], r13
	cmp	edx, 256				; 00000100H
	jb	SHORT $LL5@StartModel
$LN3@StartModel:
	mov	r15, QWORD PTR [rsp+32]
	mov	r13, QWORD PTR [rsp+40]
	mov	r12, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+88]
	mov	rbp, QWORD PTR [rsp+80]

; 971  :         }
; 972  : 
; 973  : //        first_time  = false;
; 974  :         context     = MaxContext;

	mov	QWORD PTR ?context@?1??StartModelRare@@YAXHW4MR_METHOD@@@Z@4PEAUPPM_CONTEXT@@EA, rbx
$LN1@StartModel:

; 975  :     }
; 976  :     else
; 977  :     {    
; 978  :     
; 979  :         UINT i, k, m;
; 980  : 
; 981  :         memset( CharMask, 0, sizeof(CharMask) );
; 982  :         EscCount=PrintCount=1;
; 983  :         ::OrderFall = ::MaxOrder = MaxOrder;          
; 984  :         ::MRMethod  = MRMethod;
; 985  :         
; 986  : ///        InitSubAllocator();
; 987  :         RunLength = InitRL = -((MaxOrder < 12) ? MaxOrder : 12) - 1;
; 988  : ///        MaxContext = (PPM_CONTEXT*) AllocContext();
; 989  : ///        MaxContext->Suffix = NULL;
; 990  : 
; 991  :         MaxContext  = context;
; 992  :         FoundState  = 0;
; 993  : 
; 994  : /*
; 995  :         if( !trained_model || _PPMD_E_GETC(trained_model) > MaxOrder ) 
; 996  :         {
; 997  :             MaxContext->SummFreq=(MaxContext->NumStats=255)+2;
; 998  :             MaxContext->Stats = (PPM_CONTEXT::STATE*) AllocUnits(256/2);
; 999  :             for( PrevSuccess=i=0;i < 256;i++) 
; 1000 :             {
; 1001 :                 MaxContext->Stats[i].Symbol=i;  MaxContext->Stats[i].Freq=1;
; 1002 :                 MaxContext->Stats[i].Successor=NULL;
; 1003 :             }
; 1004 :         } 
; 1005 :         else 
; 1006 :         {
; 1007 :             MaxContext->read(trained_model,0xFF);
; 1008 :             MaxContext->makeSuffix();
; 1009 :         }
; 1010 : */
; 1011 :     }
; 1012 : }

	add	rsp, 56					; 00000038H
	pop	r14
	pop	rbx
	ret	0
?StartModelRare@@YAXHW4MR_METHOD@@@Z ENDP		; StartModelRare
_TEXT	ENDS
END
