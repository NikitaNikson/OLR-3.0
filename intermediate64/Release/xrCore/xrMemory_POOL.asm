; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BG@MKOFECCD@MEMPOOL?3?3block_create?$AA@	; `string'
PUBLIC	??_C@_0BC@NDOHMDNG@xrMemory_POOL?4cpp?$AA@	; `string'
PUBLIC	??_C@_07GJEIOLDE@0?$DN?$DNlist?$AA@		; `string'
PUBLIC	??_C@_0BF@BGCJKNBA@MEMPOOL?3?3_initialize?$AA@	; `string'
PUBLIC	??_C@_0BF@KMPPNLMJ@_element?5?$DM?5_sector?12?$AA@ ; `string'
;	COMDAT ?ignore_always@?3??_initialize@MEMPOOL@@QEAAXIII@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??_initialize@MEMPOOL@@QEAAXIII@Z@4_NA DB 01H DUP (?) ; `MEMPOOL::_initialize'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??block_create@MEMPOOL@@AEAAXXZ@4_NA
_BSS	SEGMENT
?ignore_always@?3??block_create@MEMPOOL@@AEAAXXZ@4_NA DB 01H DUP (?) ; `MEMPOOL::block_create'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ??_C@_0BF@KMPPNLMJ@_element?5?$DM?5_sector?12?$AA@
CONST	SEGMENT
??_C@_0BF@KMPPNLMJ@_element?5?$DM?5_sector?12?$AA@ DB '_element < _sector'
	DB	'/2', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BGCJKNBA@MEMPOOL?3?3_initialize?$AA@
CONST	SEGMENT
??_C@_0BF@BGCJKNBA@MEMPOOL?3?3_initialize?$AA@ DB 'MEMPOOL::_initialize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GJEIOLDE@0?$DN?$DNlist?$AA@
CONST	SEGMENT
??_C@_07GJEIOLDE@0?$DN?$DNlist?$AA@ DB '0==list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NDOHMDNG@xrMemory_POOL?4cpp?$AA@
CONST	SEGMENT
??_C@_0BC@NDOHMDNG@xrMemory_POOL?4cpp?$AA@ DB 'xrMemory_POOL.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MKOFECCD@MEMPOOL?3?3block_create?$AA@
CONST	SEGMENT
??_C@_0BG@MKOFECCD@MEMPOOL?3?3block_create?$AA@ DB 'MEMPOOL::block_create'
	DB	00H						; `string'
PUBLIC	?access@MEMPOOL@@AEAAPEAPEAXPEAX@Z		; MEMPOOL::access
PUBLIC	?block_create@MEMPOOL@@AEAAXXZ			; MEMPOOL::block_create
PUBLIC	?_initialize@MEMPOOL@@QEAAXIII@Z		; MEMPOOL::_initialize
pdata	SEGMENT
$pdata$?block_create@MEMPOOL@@AEAAXXZ DD imagerel $LN26
	DD	imagerel $LN26+296
	DD	imagerel $unwind$?block_create@MEMPOOL@@AEAAXXZ
$pdata$?_initialize@MEMPOOL@@QEAAXIII@Z DD imagerel $LN10
	DD	imagerel $LN10+163
	DD	imagerel $unwind$?_initialize@MEMPOOL@@QEAAXIII@Z
xdata	SEGMENT
$unwind$?block_create@MEMPOOL@@AEAAXXZ DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
$unwind$?_initialize@MEMPOOL@@QEAAXIII@Z DD 040a01H
	DD	0c340aH
	DD	07006920aH
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.cpp
_TEXT	SEGMENT
this$ = 96
_element$ = 104
_sector$dead$ = 112
_header$dead$ = 120
?_initialize@MEMPOOL@@QEAAXIII@Z PROC			; MEMPOOL::_initialize

; 24   : {

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 80					; 00000050H

; 25   : 	R_ASSERT		(_element < _sector/2);

	cmp	BYTE PTR ?ignore_always@?3??_initialize@MEMPOOL@@QEAAXIII@Z@4_NA, 0
	mov	edi, edx
	mov	rbx, rcx
	jne	SHORT $LN3@initialize
	cmp	edx, 8192				; 00002000H
	jb	SHORT $LN3@initialize
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3??_initialize@MEMPOOL@@QEAAXIII@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0BF@KMPPNLMJ@_element?5?$DM?5_sector?12?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BF@BGCJKNBA@MEMPOOL?3?3_initialize?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0BC@NDOHMDNG@xrMemory_POOL?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 25
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN3@initialize:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.cpp

; 28   : 	s_count			= s_sector/s_element;

	xor	edx, edx
	mov	eax, 16384				; 00004000H
	mov	DWORD PTR [rbx+8], 16384		; 00004000H
	div	edi
	mov	DWORD PTR [rbx+12], edi

; 29   : 	s_offset		= _header;

	mov	QWORD PTR [rbx+20], 1
	mov	DWORD PTR [rbx+16], eax

; 30   : 	list			= NULL;

	mov	QWORD PTR [rbx+32], 0

; 31   : 	block_count		= 0;
; 32   : }

	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_initialize@MEMPOOL@@QEAAXIII@Z ENDP			; MEMPOOL::_initialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.cpp
_TEXT	SEGMENT
this$ = 96
?block_create@MEMPOOL@@AEAAXXZ PROC			; MEMPOOL::block_create

; 8    : {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 80					; 00000050H

; 9    : 	// Allocate
; 10   : 	R_ASSERT				(0==list);

	cmp	BYTE PTR ?ignore_always@?3??block_create@MEMPOOL@@AEAAXXZ@4_NA, 0
	mov	rbx, rcx
	jne	SHORT $LN6@block_crea
	cmp	QWORD PTR [rcx+32], 0
	je	SHORT $LN6@block_crea
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3??block_create@MEMPOOL@@AEAAXXZ@4_NA
	lea	r8, OFFSET FLAT:??_C@_07GJEIOLDE@0?$DN?$DNlist?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BG@MKOFECCD@MEMPOOL?3?3block_create?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0BC@NDOHMDNG@xrMemory_POOL?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 10
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN6@block_crea:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.cpp

; 11   : 	list					= (u8*)		xr_aligned_offset_malloc	(s_sector,16,s_offset);

	mov	edi, DWORD PTR [rbx+20]
	mov	eax, DWORD PTR [rbx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 101  : 	if ( offset >= size && offset != 0)

	cmp	rdi, rax
	jb	SHORT $LN13@block_crea
	test	rdi, rdi
	je	SHORT $LN13@block_crea

; 102  : 		size	= offset+1;

	lea	rax, QWORD PTR [rdi+1]
$LN13@block_crea:

; 103  : 
; 104  : 	align = (align > PTR_SZ ? align : PTR_SZ) -1;
; 105  : 
; 106  : 	/* gap = number of bytes needed to round up offset to align with PTR_SZ*/
; 107  : 	gap = (0 - offset)&(PTR_SZ -1);

	mov	rsi, rdi
	neg	rsi
	and	esi, 7

; 108  : 
; 109  : 	if ( (ptr =(uintptr_t)malloc(PTR_SZ +gap +align +size)) == (uintptr_t)NULL)

	lea	rcx, QWORD PTR [rsi+23]
	add	rcx, rax
	call	QWORD PTR __imp_malloc
	mov	rdx, rax
	test	rax, rax
	jne	SHORT $LN12@block_crea

; 110  : 		return NULL;

	xor	ecx, ecx
	jmp	SHORT $LN15@block_crea
$LN12@block_crea:

; 111  : 
; 112  : 	retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;

	add	rax, rsi
	lea	rcx, QWORD PTR [rdi+23]
	add	rcx, rax
	and	rcx, -16
	sub	rcx, rdi

; 113  : 	((uintptr_t *)(retptr - gap))[-1] = ptr;

	mov	rax, rcx
	sub	rax, rsi
	mov	QWORD PTR [rax-8], rdx
$LN15@block_crea:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.cpp

; 14   : 	for (u32 it=0; it<(s_count-1); it++)

	mov	eax, DWORD PTR [rbx+16]
	xor	r8d, r8d
	mov	QWORD PTR [rbx+32], rcx
	dec	eax
	je	SHORT $LN1@block_crea
	npad	13
$LL3@block_crea:

; 15   : 	{
; 16   : 		u8*	E				= list + it*s_element;

	mov	edx, DWORD PTR [rbx+12]
	mov	ecx, edx
	imul	ecx, r8d
	inc	r8d
	add	rcx, QWORD PTR [rbx+32]

; 17   : 		*access(E)			= E+s_element;

	add	rdx, rcx
	mov	QWORD PTR [rcx], rdx
	mov	eax, DWORD PTR [rbx+16]
	dec	eax
	cmp	r8d, eax
	jb	SHORT $LL3@block_crea
$LN1@block_crea:

; 18   : 	}
; 19   : 	*access	(list+(s_count-1)*s_element)	= NULL;

	mov	ecx, DWORD PTR [rbx+16]
	mov	rax, QWORD PTR [rbx+32]

; 20   : 	block_count				++;
; 21   : }

	mov	rsi, QWORD PTR [rsp+104]
	dec	ecx
	imul	ecx, DWORD PTR [rbx+12]
	mov	QWORD PTR [rcx+rax], 0
	inc	DWORD PTR [rbx+24]
	mov	rbx, QWORD PTR [rsp+96]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?block_create@MEMPOOL@@AEAAXXZ ENDP			; MEMPOOL::block_create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
;	COMDAT ?access@MEMPOOL@@AEAAPEAPEAXPEAX@Z
_TEXT	SEGMENT
this$dead$ = 8
P$ = 16
?access@MEMPOOL@@AEAAPEAPEAXPEAX@Z PROC			; MEMPOOL::access, COMDAT

; 21   : 	ICF void**			access			(void* P)	{ return (void**) ((void*)(P));	}

	mov	rax, rdx
	ret	0
?access@MEMPOOL@@AEAAPEAPEAXPEAX@Z ENDP			; MEMPOOL::access
_TEXT	ENDS
END
