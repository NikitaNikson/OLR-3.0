; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@HIBEFMCL@?$CBCan?8t?5save?5inifile?3?$AA@ ; `string'
PUBLIC	??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@		; `string'
PUBLIC	??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@		; `string'
PUBLIC	??_C@_01BIAFAFID@F?$AA@				; `string'
PUBLIC	??_C@_08GPLAJCBH@?$CDinclude?$AA@		; `string'
PUBLIC	??_C@_0O@OGKPJIFO@path?$CG?$CGpath?$FL0?$FN?$AA@ ; `string'
PUBLIC	??_C@_0BJ@JNOOHJGB@Can?8t?5find?5include?5file?3?$AA@ ; `string'
PUBLIC	??_C@_01JPJNBJEM@I?$AA@				; `string'
PUBLIC	??_C@_0BO@PADAFPII@Duplicate?5section?5?8?$CFs?8?5found?4?$AA@ ; `string'
PUBLIC	??_C@_0BI@IHFKKOHL@Bad?5ini?5section?5found?3?5?$AA@ ; `string'
PUBLIC	??_C@_0BA@NMAHPAMG@strchr?$CIstr?0?8?$FN?8?$CJ?$AA@ ; `string'
PUBLIC	??_C@_02EBHDEFHH@?$FN?3?$AA@			; `string'
PUBLIC	??_C@_0BC@LBCCFBEL@CInifile?3?3save_as?$AA@	; `string'
PUBLIC	??_C@_0BA@HGOPAPJG@fName?$CG?$CGfName?$FL0?$FN?$AA@ ; `string'
PUBLIC	??_C@_04LIFAFMCE@?$FL?$CFs?$FN?$AA@		; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_0BB@DGLKGBOG@?$CF8s?$CF?932s?5?$DN?5?$CF?932s?$AA@ ; `string'
PUBLIC	??_C@_0M@FGDEMPPI@?$CF8s?$CF?932s?5?$DN?5?$AA@	; `string'
PUBLIC	??_C@_0BI@PGHMEHEA@Can?8t?5open?5section?5?8?$CFs?8?$AA@ ; `string'
PUBLIC	??_C@_0BE@BCNJJKHP@CInifile?3?3r_section?$AA@	; `string'
PUBLIC	??_C@_0CI@BBBLINKF@Can?8t?5find?5variable?5?$CFs?5in?5?$FL?$CFs?$FN?0?5@ ; `string'
PUBLIC	??_C@_0BD@DOJGBPMF@CInifile?3?3r_string?$AA@	; `string'
PUBLIC	??_C@_0M@JJJBFJKB@?$CFf?0?$CFf?0?$CFf?0?$CFf?$AA@ ; `string'
PUBLIC	??_C@_0M@MLCONGPP@?$CFd?0?$CFd?0?$CFd?0?$CFd?$AA@ ; `string'
PUBLIC	??_C@_05KABNCBHK@?$CFd?0?$CFd?$AA@		; `string'
PUBLIC	??_C@_08GDAMKODC@?$CFd?0?$CFd?0?$CFd?$AA@	; `string'
PUBLIC	??_C@_05OIOLBAJI@?$CFf?0?$CFf?$AA@		; `string'
PUBLIC	??_C@_08GJNPJIKN@?$CFf?0?$CFf?0?$CFf?$AA@	; `string'
PUBLIC	??_C@_0BD@HEABFKIK@CInifile?3?3w_string?$AA@	; `string'
PUBLIC	??_C@_0L@MCBJLICI@?$CBbReadOnly?$AA@		; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	??_C@_03MCADLMAF@off?$AA@			; `string'
PUBLIC	??_C@_0BG@HJJEFCMD@CInifile?3?3remove_line?$AA@	; `string'
PUBLIC	??_C@_0DA@GAFJJPBK@A?$CB?$DNdata?4Data?4end?$CI?$CJ?5?$CG?$CG?5xr_strcmp?$CI@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?pSettings@@3PEAVCInifile@@EA			; pSettings
EXTRN	__imp__strlwr:PROC
EXTRN	__imp_atof:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_isspace:PROC
;	COMDAT ?ignore_always@?L@??remove_line@CInifile@@QEAAXPEBD0@Z@4_NA
_BSS	SEGMENT
?ignore_always@?L@??remove_line@CInifile@@QEAAXPEBD0@Z@4_NA DB 01H DUP (?) ; `CInifile::remove_line'::`11'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??remove_line@CInifile@@QEAAXPEBD0@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??remove_line@CInifile@@QEAAXPEBD0@Z@4_NA DB 01H DUP (?) ; `CInifile::remove_line'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??w_string@CInifile@@QEAAXPEBD000@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??w_string@CInifile@@QEAAXPEBD000@Z@4_NA DB 01H DUP (?) ; `CInifile::w_string'::`4'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?6??save_as@CInifile@@QEAA_NPEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?6??save_as@CInifile@@QEAA_NPEBD@Z@4_NA DB 01H DUP (?) ; `CInifile::save_as'::`7'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?CH@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?CH@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA DB 01H DUP (?) ; `CInifile::Load'::`39'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BK@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BK@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA DB 01H DUP (?) ; `CInifile::Load'::`26'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?BD@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?BD@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA DB 01H DUP (?) ; `CInifile::Load'::`19'::ignore_always
_BSS	ENDS
;	COMDAT ?ignore_always@?3??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA
_BSS	SEGMENT
?ignore_always@?3??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA DB 01H DUP (?) ; `CInifile::Load'::`4'::ignore_always
	ALIGN	8

?pSettings@@3PEAVCInifile@@EA DQ 01H DUP (?)		; pSettings
_BSS	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@GAFJJPBK@A?$CB?$DNdata?4Data?4end?$CI?$CJ?5?$CG?$CG?5xr_strcmp?$CI@
CONST	SEGMENT
??_C@_0DA@GAFJJPBK@A?$CB?$DNdata?4Data?4end?$CI?$CJ?5?$CG?$CG?5xr_strcmp?$CI@ DB 'A'
	DB	'!=data.Data.end() && xr_strcmp(*A->first,L)==0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HJJEFCMD@CInifile?3?3remove_line?$AA@
CONST	SEGMENT
??_C@_0BG@HJJEFCMD@CInifile?3?3remove_line?$AA@ DB 'CInifile::remove_line'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCADLMAF@off?$AA@
CONST	SEGMENT
??_C@_03MCADLMAF@off?$AA@ DB 'off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MCBJLICI@?$CBbReadOnly?$AA@
CONST	SEGMENT
??_C@_0L@MCBJLICI@?$CBbReadOnly?$AA@ DB '!bReadOnly', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HEABFKIK@CInifile?3?3w_string?$AA@
CONST	SEGMENT
??_C@_0BD@HEABFKIK@CInifile?3?3w_string?$AA@ DB 'CInifile::w_string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GJNPJIKN@?$CFf?0?$CFf?0?$CFf?$AA@
CONST	SEGMENT
??_C@_08GJNPJIKN@?$CFf?0?$CFf?0?$CFf?$AA@ DB '%f,%f,%f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05OIOLBAJI@?$CFf?0?$CFf?$AA@
CONST	SEGMENT
??_C@_05OIOLBAJI@?$CFf?0?$CFf?$AA@ DB '%f,%f', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GDAMKODC@?$CFd?0?$CFd?0?$CFd?$AA@
CONST	SEGMENT
??_C@_08GDAMKODC@?$CFd?0?$CFd?0?$CFd?$AA@ DB '%d,%d,%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KABNCBHK@?$CFd?0?$CFd?$AA@
CONST	SEGMENT
??_C@_05KABNCBHK@?$CFd?0?$CFd?$AA@ DB '%d,%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MLCONGPP@?$CFd?0?$CFd?0?$CFd?0?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@MLCONGPP@?$CFd?0?$CFd?0?$CFd?0?$CFd?$AA@ DB '%d,%d,%d,%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JJJBFJKB@?$CFf?0?$CFf?0?$CFf?0?$CFf?$AA@
CONST	SEGMENT
??_C@_0M@JJJBFJKB@?$CFf?0?$CFf?0?$CFf?0?$CFf?$AA@ DB '%f,%f,%f,%f', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DOJGBPMF@CInifile?3?3r_string?$AA@
CONST	SEGMENT
??_C@_0BD@DOJGBPMF@CInifile?3?3r_string?$AA@ DB 'CInifile::r_string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BBBLINKF@Can?8t?5find?5variable?5?$CFs?5in?5?$FL?$CFs?$FN?0?5@
CONST	SEGMENT
??_C@_0CI@BBBLINKF@Can?8t?5find?5variable?5?$CFs?5in?5?$FL?$CFs?$FN?0?5@ DB 'C'
	DB	'an''t find variable %s in [%s], file %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BCNJJKHP@CInifile?3?3r_section?$AA@
CONST	SEGMENT
??_C@_0BE@BCNJJKHP@CInifile?3?3r_section?$AA@ DB 'CInifile::r_section', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PGHMEHEA@Can?8t?5open?5section?5?8?$CFs?8?$AA@
CONST	SEGMENT
??_C@_0BI@PGHMEHEA@Can?8t?5open?5section?5?8?$CFs?8?$AA@ DB 'Can''t open '
	DB	'section ''%s''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FGDEMPPI@?$CF8s?$CF?932s?5?$DN?5?$AA@
CONST	SEGMENT
??_C@_0M@FGDEMPPI@?$CF8s?$CF?932s?5?$DN?5?$AA@ DB '%8s%-32s = ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DGLKGBOG@?$CF8s?$CF?932s?5?$DN?5?$CF?932s?$AA@
CONST	SEGMENT
??_C@_0BB@DGLKGBOG@?$CF8s?$CF?932s?5?$DN?5?$CF?932s?$AA@ DB '%8s%-32s = %'
	DB	'-32s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LIFAFMCE@?$FL?$CFs?$FN?$AA@
CONST	SEGMENT
??_C@_04LIFAFMCE@?$FL?$CFs?$FN?$AA@ DB '[%s]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HGOPAPJG@fName?$CG?$CGfName?$FL0?$FN?$AA@
CONST	SEGMENT
??_C@_0BA@HGOPAPJG@fName?$CG?$CGfName?$FL0?$FN?$AA@ DB 'fName&&fName[0]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LBCCFBEL@CInifile?3?3save_as?$AA@
CONST	SEGMENT
??_C@_0BC@LBCCFBEL@CInifile?3?3save_as?$AA@ DB 'CInifile::save_as', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02EBHDEFHH@?$FN?3?$AA@
CONST	SEGMENT
??_C@_02EBHDEFHH@?$FN?3?$AA@ DB ']:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NMAHPAMG@strchr?$CIstr?0?8?$FN?8?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@NMAHPAMG@strchr?$CIstr?0?8?$FN?8?$CJ?$AA@ DB 'strchr(str,'']'')'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@IHFKKOHL@Bad?5ini?5section?5found?3?5?$AA@
CONST	SEGMENT
??_C@_0BI@IHFKKOHL@Bad?5ini?5section?5found?3?5?$AA@ DB 'Bad ini section '
	DB	'found: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PADAFPII@Duplicate?5section?5?8?$CFs?8?5found?4?$AA@
CONST	SEGMENT
??_C@_0BO@PADAFPII@Duplicate?5section?5?8?$CFs?8?5found?4?$AA@ DB 'Duplic'
	DB	'ate section ''%s'' found.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JPJNBJEM@I?$AA@
CONST	SEGMENT
??_C@_01JPJNBJEM@I?$AA@ DB 'I', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@JNOOHJGB@Can?8t?5find?5include?5file?3?$AA@
CONST	SEGMENT
??_C@_0BJ@JNOOHJGB@Can?8t?5find?5include?5file?3?$AA@ DB 'Can''t find inc'
	DB	'lude file:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OGKPJIFO@path?$CG?$CGpath?$FL0?$FN?$AA@
CONST	SEGMENT
??_C@_0O@OGKPJIFO@path?$CG?$CGpath?$FL0?$FN?$AA@ DB 'path&&path[0]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GPLAJCBH@?$CDinclude?$AA@
CONST	SEGMENT
??_C@_08GPLAJCBH@?$CDinclude?$AA@ DB '#include', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01BIAFAFID@F?$AA@
CONST	SEGMENT
??_C@_01BIAFAFID@F?$AA@ DB 'F', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
CONST	SEGMENT
??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@ DB 'Xr_ini.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@
CONST	SEGMENT
??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@ DB 'CInifile::Load', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HIBEFMCL@?$CBCan?8t?5save?5inifile?3?$AA@
CONST	SEGMENT
??_C@_0BF@HIBEFMCL@?$CBCan?8t?5save?5inifile?3?$AA@ DB '!Can''t save inif'
	DB	'ile:', 00H					; `string'
PUBLIC	??7shared_str@@QEBA_NXZ				; shared_str::operator!
PUBLIC	??M@YA_NAEBVshared_str@@0@Z			; operator<
PUBLIC	?equal@shared_str@@QEBA_NAEBV1@@Z		; shared_str::equal
PUBLIC	?strchr@@YAPEADPEADH@Z				; strchr
PUBLIC	?color_rgba@@YAIIIII@Z				; color_rgba
PUBLIC	?color_argb@@YAIIIII@Z				; color_argb
PUBLIC	?color_get_A@@YAII@Z				; color_get_A
PUBLIC	?color_get_B@@YAII@Z				; color_get_B
PUBLIC	?color_get_G@@YAII@Z				; color_get_G
PUBLIC	?color_get_R@@YAII@Z				; color_get_R
PUBLIC	??$_Fn@V?$xalloc@PEAUSect@CInifile@@@@PEAUSect@CInifile@@PEAU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAUSect@CInifile@@@@PEAPEAUSect@CInifile@@$$QEAPEAU34@@Z ; std::_Alloc_construct::_Fn<xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>
PUBLIC	??$construct@PEAUSect@CInifile@@PEAU12@@?$allocator_traits@V?$xalloc@PEAUSect@CInifile@@@@@std@@SAXAEAV?$xalloc@PEAUSect@CInifile@@@@PEAPEAUSect@CInifile@@$$QEAPEAU34@@Z ; std::allocator_traits<xalloc<CInifile::Sect * __ptr64> >::construct<CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>
PUBLIC	??$forward@PEAUSect@CInifile@@@std@@YA$$QEAPEAUSect@CInifile@@AEAPEAU12@@Z ; std::forward<CInifile::Sect * __ptr64>
PUBLIC	??$_Fn@V?$xalloc@UItem@CInifile@@@@UItem@CInifile@@U23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@UItem@CInifile@@@@PEAUItem@CInifile@@$$QEAU34@@Z ; std::_Alloc_construct::_Fn<xalloc<CInifile::Item>,CInifile::Item,CInifile::Item>
PUBLIC	??$construct@PEAUSect@CInifile@@PEAU12@@?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAAXPEAPEAUSect@CInifile@@$$QEAPEAU23@@Z ; std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> >::construct<CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>
PUBLIC	??$construct@UItem@CInifile@@U12@@?$allocator_traits@V?$xalloc@UItem@CInifile@@@@@std@@SAXAEAV?$xalloc@UItem@CInifile@@@@PEAUItem@CInifile@@$$QEAU34@@Z ; std::allocator_traits<xalloc<CInifile::Item> >::construct<CInifile::Item,CInifile::Item>
PUBLIC	??$forward@UItem@CInifile@@@std@@YA$$QEAUItem@CInifile@@AEAU12@@Z ; std::forward<CInifile::Item>
PUBLIC	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
PUBLIC	??$construct@UItem@CInifile@@U12@@?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@QEAAXPEAUItem@CInifile@@$$QEAU23@@Z ; std::_Wrap_alloc<xalloc<CInifile::Item> >::construct<CInifile::Item,CInifile::Item>
PUBLIC	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
PUBLIC	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>
PUBLIC	??$_Advance@PEAPEAUSect@CInifile@@_J@std@@YAXAEAPEAPEAUSect@CInifile@@_JUrandom_access_iterator_tag@0@@Z ; std::_Advance<CInifile::Sect * __ptr64 * __ptr64,__int64>
PUBLIC	??$_Distance2@PEAPEAUSect@CInifile@@_J@std@@YAXPEAPEAUSect@CInifile@@0AEA_JUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CInifile::Sect * __ptr64 * __ptr64,__int64>
PUBLIC	??$_Iter_cat@PEAPEAUSect@CInifile@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAPEAUSect@CInifile@@@Z ; std::_Iter_cat<CInifile::Sect * __ptr64 * __ptr64>
PUBLIC	??$_Advance@PEAUItem@CInifile@@_J@std@@YAXAEAPEAUItem@CInifile@@_JUrandom_access_iterator_tag@0@@Z ; std::_Advance<CInifile::Item * __ptr64,__int64>
PUBLIC	??$_Distance2@PEAUItem@CInifile@@_J@std@@YAXPEAUItem@CInifile@@0AEA_JUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CInifile::Item * __ptr64,__int64>
PUBLIC	??$_Iter_cat@PEAUItem@CInifile@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAUItem@CInifile@@@Z ; std::_Iter_cat<CInifile::Item * __ptr64>
PUBLIC	??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
PUBLIC	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >
PUBLIC	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Item> > >
PUBLIC	??$move@AEAUItem@CInifile@@@std@@YA$$QEAUItem@CInifile@@AEAU12@@Z ; std::move<CInifile::Item & __ptr64>
PUBLIC	??$advance@PEAPEAUSect@CInifile@@_J@std@@YAXAEAPEAPEAUSect@CInifile@@_J@Z ; std::advance<CInifile::Sect * __ptr64 * __ptr64,__int64>
PUBLIC	??$_Distance@PEAPEAUSect@CInifile@@_J@std@@YAXPEAPEAUSect@CInifile@@0AEA_J@Z ; std::_Distance<CInifile::Sect * __ptr64 * __ptr64,__int64>
PUBLIC	??$advance@PEAUItem@CInifile@@_J@std@@YAXAEAPEAUItem@CInifile@@_J@Z ; std::advance<CInifile::Item * __ptr64,__int64>
PUBLIC	??$_Distance@PEAUItem@CInifile@@_J@std@@YAXPEAUItem@CInifile@@0AEA_J@Z ; std::_Distance<CInifile::Item * __ptr64,__int64>
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAPEAPEAUSect@CInifile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Unchecked
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAUSect@CInifile@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEAUItem@CInifile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Unchecked
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV12@PEAUItem@CInifile@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Rechecked
PUBLIC	??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
PUBLIC	??$_Val_type@PEAPEAUSect@CInifile@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@@Z ; std::_Val_type<CInifile::Sect * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>
PUBLIC	??$_Val_type@PEAUItem@CInifile@@@std@@YAPEAUItem@CInifile@@PEAU12@@Z ; std::_Val_type<CInifile::Item * __ptr64>
PUBLIC	??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64>
PUBLIC	??$_Fill@PEAPEAUSect@CInifile@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@0AEBQEAU12@@Z ; std::_Fill<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64>
PUBLIC	??$_Uninitialized_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z ; std::_Uninitialized_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >
PUBLIC	??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
PUBLIC	??$_Fill@PEAUItem@CInifile@@U12@@std@@YAXPEAUItem@CInifile@@0AEBU12@@Z ; std::_Fill<CInifile::Item * __ptr64,CInifile::Item>
PUBLIC	??$_Uninitialized_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z ; std::_Uninitialized_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Item> > >
PUBLIC	??$_Move@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
PUBLIC	??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z ; std::_Lower_bound<CInifile::Sect * __ptr64 * __ptr64,char const [256],__int64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@AEAV10@PEAPEAUSect@CInifile@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >
PUBLIC	??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z ; std::_Lower_bound<CInifile::Sect * __ptr64 * __ptr64,char const * __ptr64,__int64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
PUBLIC	??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@YAPEAPEAUSect@CInifile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@AEAV10@PEAUItem@CInifile@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CInifile::Item> > >
PUBLIC	??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z ; std::_Lower_bound<CInifile::Item * __ptr64,char const * __ptr64,__int64,bool (__cdecl*)(CInifile::Item const & __ptr64,char const * __ptr64)>
PUBLIC	??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@YAPEAUItem@CInifile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CInifile::Item> > >
PUBLIC	??_GSect@CInifile@@QEAAPEAXI@Z			; CInifile::Sect::`scalar deleting destructor'
PUBLIC	??R?$xr_special_free@$0A@USect@CInifile@@@@QEAAXAEAPEAUSect@CInifile@@@Z ; xr_special_free<0,CInifile::Sect>::operator()
PUBLIC	??R?$xr_special_free@$00VCInifile@@@@QEAAXAEAPEAVCInifile@@@Z ; xr_special_free<1,CInifile>::operator()
PUBLIC	??$_Uninitialized_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z ; std::_Uninitialized_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >
PUBLIC	??$_Uninitialized_fill_n@PEAUItem@CInifile@@_KU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z ; std::_Uninitialized_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,std::_Wrap_alloc<xalloc<CInifile::Item> > >
PUBLIC	??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00@Z ; std::_Copy_backward<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64>
PUBLIC	??$fill@PEAPEAUSect@CInifile@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@0AEBQEAU12@@Z ; std::fill<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64>
PUBLIC	??$addressof@PEAUSect@CInifile@@@std@@YAPEAPEAUSect@CInifile@@AEAPEAU12@@Z ; std::addressof<CInifile::Sect * __ptr64>
PUBLIC	??$_Umove@PEAPEAUSect@CInifile@@@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU23@00@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Umove<CInifile::Sect * __ptr64 * __ptr64>
PUBLIC	??$addressof@QEAUSect@CInifile@@@std@@YAPEBQEAUSect@CInifile@@AEBQEAU12@@Z ; std::addressof<CInifile::Sect * __ptr64 const>
PUBLIC	??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z ; std::_Copy_backward<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
PUBLIC	??$fill@PEAUItem@CInifile@@U12@@std@@YAXPEAUItem@CInifile@@0AEBU12@@Z ; std::fill<CInifile::Item * __ptr64,CInifile::Item>
PUBLIC	??$addressof@UItem@CInifile@@@std@@YAPEAUItem@CInifile@@AEAU12@@Z ; std::addressof<CInifile::Item>
PUBLIC	??$_Umove@PEAUItem@CInifile@@@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU23@00@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Umove<CInifile::Item * __ptr64>
PUBLIC	??$addressof@$$CBUItem@CInifile@@@std@@YAPEBUItem@CInifile@@AEBU12@@Z ; std::addressof<CInifile::Item const >
PUBLIC	??$_Move@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z ; std::_Move<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
PUBLIC	??$strcpy_s@$0CAA@@@YAHAEAY0CAA@DPEBD@Z		; strcpy_s<512>
PUBLIC	??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@$$BY0BAA@DP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEAY0BAA@$$CBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >,char [256],bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
PUBLIC	??$xr_new@USect@CInifile@@@@YAPEAUSect@CInifile@@XZ ; xr_new<CInifile::Sect>
PUBLIC	??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@PEBDP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >,char const * __ptr64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
PUBLIC	??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z ; xr_delete<CInifile::Sect>
PUBLIC	??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@PEBDP6A_NAEBUItem@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NAEBUItem@CInifile@@PEBD@Z@Z ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >,char const * __ptr64,bool (__cdecl*)(CInifile::Item const & __ptr64,char const * __ptr64)>
PUBLIC	??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z ; xr_delete<CInifile>
PUBLIC	??$xr_new@VCInifile@@PEBDH@@YAPEAVCInifile@@AEBQEBDAEBH@Z ; xr_new<CInifile,char const * __ptr64,int>
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+=
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+=
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+=
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Compat
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Compat
PUBLIC	?_Orphan_range@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEBAXPEAPEAUSect@CInifile@@0@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Orphan_range
PUBLIC	?_Ufill@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU34@_KPEBQEAU34@@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Ufill
PUBLIC	?_Grow_to@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEBA_K_K@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Grow_to
PUBLIC	?_Unused_capacity@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEBA_KXZ ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Unused_capacity
PUBLIC	?_Orphan_range@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEBAXPEAUItem@CInifile@@0@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Orphan_range
PUBLIC	?_Ufill@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU34@_KPEBU34@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Ufill
PUBLIC	?_Grow_to@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEBA_K_K@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Grow_to
PUBLIC	?_Unused_capacity@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEBA_KXZ ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Unused_capacity
PUBLIC	?pointer_to@?$pointer_traits@PEBUItem@CInifile@@@std@@SAPEBUItem@CInifile@@AEBU34@@Z ; std::pointer_traits<CInifile::Item const * __ptr64>::pointer_to
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAA@PEAPEAUSect@CInifile@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA@PEAUItem@CInifile@@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator==
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator++
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAAEBQEAUSect@CInifile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator*
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator==
PUBLIC	?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n
PUBLIC	??0?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA@XZ ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >
PUBLIC	?pointer_to@?$pointer_traits@PEAUItem@CInifile@@@std@@SAPEAUItem@CInifile@@AEAU34@@Z ; std::pointer_traits<CInifile::Item * __ptr64>::pointer_to
PUBLIC	?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n
PUBLIC	?_Make_iter@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Make_iter
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator++
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAAEAPEAUSect@CInifile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEAUItem@CInifile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator->
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAAEAUItem@CInifile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator*
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator!=
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator!=
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++
PUBLIC	??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEBUItem@CInifile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator->
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAAEBUItem@CInifile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator*
PUBLIC	?insert@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@AEBQEAUSect@CInifile@@@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::insert
PUBLIC	?end@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@XZ ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::end
PUBLIC	?begin@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@XZ ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::begin
PUBLIC	??0?$xr_vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@@QEAA@XZ ; xr_vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::xr_vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >
PUBLIC	?erase@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::erase
PUBLIC	?insert@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@AEBUItem@CInifile@@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::insert
PUBLIC	?end@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@XZ ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::end
PUBLIC	?begin@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@XZ ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::begin
PUBLIC	?size@?$xr_vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@@QEBAIXZ ; xr_vector<CInifile::Item,xalloc<CInifile::Item> >::size
PUBLIC	?remove_line@CInifile@@QEAAXPEBD0@Z		; CInifile::remove_line
PUBLIC	?w_bool@CInifile@@QEAAXPEBD0H0@Z		; CInifile::w_bool
PUBLIC	?w_fvector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@M@@0@Z ; CInifile::w_fvector4
PUBLIC	?w_fvector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@M@@0@Z ; CInifile::w_fvector3
PUBLIC	?w_fvector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@M@@0@Z ; CInifile::w_fvector2
PUBLIC	?w_ivector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@H@@0@Z ; CInifile::w_ivector4
PUBLIC	?w_ivector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@H@@0@Z ; CInifile::w_ivector3
PUBLIC	?w_ivector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@H@@0@Z ; CInifile::w_ivector2
PUBLIC	?w_color@CInifile@@QEAAXPEBD0I0@Z		; CInifile::w_color
PUBLIC	?w_fcolor@CInifile@@QEAAXPEBD0AEBU?$_color@M@@0@Z ; CInifile::w_fcolor
PUBLIC	?w_float@CInifile@@QEAAXPEBD0M0@Z		; CInifile::w_float
PUBLIC	?w_s32@CInifile@@QEAAXPEBD0H0@Z			; CInifile::w_s32
PUBLIC	?w_s16@CInifile@@QEAAXPEBD0F0@Z			; CInifile::w_s16
PUBLIC	?w_s8@CInifile@@QEAAXPEBD0C0@Z			; CInifile::w_s8
PUBLIC	?w_u32@CInifile@@QEAAXPEBD0I0@Z			; CInifile::w_u32
PUBLIC	?w_u16@CInifile@@QEAAXPEBD0G0@Z			; CInifile::w_u16
PUBLIC	?w_u8@CInifile@@QEAAXPEBD0E0@Z			; CInifile::w_u8
PUBLIC	?w_string@CInifile@@QEAAXPEBD000@Z		; CInifile::w_string
PUBLIC	?r_line@CInifile@@QEAAHAEBVshared_str@@HPEAPEBD1@Z ; CInifile::r_line
PUBLIC	?r_line@CInifile@@QEAAHPEBDHPEAPEBD1@Z		; CInifile::r_line
PUBLIC	?r_token@CInifile@@QEAAHPEBD0PEBUxr_token@@@Z	; CInifile::r_token
PUBLIC	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z	; CInifile::r_section
PUBLIC	?section_exist@CInifile@@QEAAHAEBVshared_str@@@Z ; CInifile::section_exist
PUBLIC	?line_count@CInifile@@QEAAIAEBVshared_str@@@Z	; CInifile::line_count
PUBLIC	?line_exist@CInifile@@QEAAHAEBVshared_str@@0@Z	; CInifile::line_exist
PUBLIC	?r_section@CInifile@@QEAAAEAUSect@1@AEBVshared_str@@@Z ; CInifile::r_section
PUBLIC	?line_count@CInifile@@QEAAIPEBD@Z		; CInifile::line_count
PUBLIC	?line_exist@CInifile@@QEAAHPEBD0@Z		; CInifile::line_exist
PUBLIC	?section_exist@CInifile@@QEAAHPEBD@Z		; CInifile::section_exist
PUBLIC	?save_as@CInifile@@QEAA_NPEBD@Z			; CInifile::save_as
PUBLIC	?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z	; CInifile::Load
PUBLIC	??0CInifile@@QEAA@PEBDHHH@Z			; CInifile::CInifile
PUBLIC	??0CInifile@@QEAA@PEAVIReader@@PEBD@Z		; CInifile::CInifile
PUBLIC	?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z	; CInifile::Sect::line_exist
PUBLIC	?_decorate@@YAXPEADPEBD@Z			; _decorate
PUBLIC	?_parse@@YAXPEADPEBD@Z				; _parse
PUBLIC	?item_pred@@YA_NAEBUItem@CInifile@@PEBD@Z	; item_pred
PUBLIC	?sect_pred@@YA_NPEBUSect@CInifile@@PEBD@Z	; sect_pred
PUBLIC	?Destroy@CInifile@@SAXPEAV1@@Z			; CInifile::Destroy
PUBLIC	?Create@CInifile@@SAPEAV1@PEBDH@Z		; CInifile::Create
PUBLIC	?r_bool@CInifile@@QEAAHPEBD0@Z			; CInifile::r_bool
PUBLIC	?r_fvector4@CInifile@@QEAA?AU?$_vector4@M@@PEBD0@Z ; CInifile::r_fvector4
PUBLIC	?r_fvector3@CInifile@@QEAA?AU?$_vector3@M@@PEBD0@Z ; CInifile::r_fvector3
PUBLIC	?r_fvector2@CInifile@@QEAA?AU?$_vector2@M@@PEBD0@Z ; CInifile::r_fvector2
PUBLIC	?r_ivector4@CInifile@@QEAA?AU?$_vector4@H@@PEBD0@Z ; CInifile::r_ivector4
PUBLIC	?r_ivector3@CInifile@@QEAA?AU?$_vector3@H@@PEBD0@Z ; CInifile::r_ivector3
PUBLIC	?r_ivector2@CInifile@@QEAA?AU?$_vector2@H@@PEBD0@Z ; CInifile::r_ivector2
PUBLIC	?r_color@CInifile@@QEAAIPEBD0@Z			; CInifile::r_color
PUBLIC	?r_fcolor@CInifile@@QEAA?AU?$_color@M@@PEBD0@Z	; CInifile::r_fcolor
PUBLIC	?r_float@CInifile@@QEAAMPEBD0@Z			; CInifile::r_float
PUBLIC	?r_s32@CInifile@@QEAAHPEBD0@Z			; CInifile::r_s32
PUBLIC	?r_s16@CInifile@@QEAAFPEBD0@Z			; CInifile::r_s16
PUBLIC	?r_s8@CInifile@@QEAACPEBD0@Z			; CInifile::r_s8
PUBLIC	?r_u32@CInifile@@QEAAIPEBD0@Z			; CInifile::r_u32
PUBLIC	?r_u16@CInifile@@QEAAGPEBD0@Z			; CInifile::r_u16
PUBLIC	?r_u8@CInifile@@QEAAEPEBD0@Z			; CInifile::r_u8
PUBLIC	?r_string_wb@CInifile@@QEAA?AVshared_str@@PEBD0@Z ; CInifile::r_string_wb
PUBLIC	?r_string@CInifile@@QEAAPEBDPEBD0@Z		; CInifile::r_string
PUBLIC	?r_clsid@CInifile@@QEAA_KPEBD0@Z		; CInifile::r_clsid
PUBLIC	??1CInifile@@UEAA@XZ				; CInifile::~CInifile
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+60
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN93
	DD	imagerel $LN93+152
	DD	imagerel $unwind$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+104
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN44
	DD	imagerel $LN44+56
	DD	imagerel $unwind$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+23
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN93
	DD	imagerel $LN93+148
	DD	imagerel $unwind$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD imagerel ?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+104
	DD	imagerel $unwind$?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z DD imagerel $LN20
	DD	imagerel $LN20+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD imagerel $LN34
	DD	imagerel $LN34+23
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD imagerel $LN34+23
	DD	imagerel $LN34+132
	DD	imagerel $chain$0$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD imagerel $LN34+132
	DD	imagerel $LN34+137
	DD	imagerel $chain$1$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD imagerel $LN34
	DD	imagerel $LN34+22
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD imagerel $LN34+22
	DD	imagerel $LN34+136
	DD	imagerel $chain$1$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD imagerel $LN34+136
	DD	imagerel $LN34+144
	DD	imagerel $chain$2$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z DD imagerel $LN58
	DD	imagerel $LN58+37
	DD	imagerel $unwind$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z DD imagerel $LN58+37
	DD	imagerel $LN58+121
	DD	imagerel $chain$1$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z DD imagerel $LN58+121
	DD	imagerel $LN58+141
	DD	imagerel $chain$2$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GSect@CInifile@@QEAAPEAXI@Z DD imagerel $LN21
	DD	imagerel $LN21+61
	DD	imagerel $unwind$??_GSect@CInifile@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$0A@USect@CInifile@@@@QEAAXAEAPEAUSect@CInifile@@@Z DD imagerel $LN46
	DD	imagerel $LN46+157
	DD	imagerel $unwind$??R?$xr_special_free@$0A@USect@CInifile@@@@QEAAXAEAPEAUSect@CInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$xr_special_free@$00VCInifile@@@@QEAAXAEAPEAVCInifile@@@Z DD imagerel $LN29
	DD	imagerel $LN29+136
	DD	imagerel $unwind$??R?$xr_special_free@$00VCInifile@@@@QEAAXAEAPEAVCInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z DD imagerel $LN10
	DD	imagerel $LN10+14
	DD	imagerel $unwind$??$_Uninitialized_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_fill_n@PEAUItem@CInifile@@_KU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninitialized_fill_n@PEAUItem@CInifile@@_KU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00@Z DD imagerel $LN8
	DD	imagerel $LN8+48
	DD	imagerel $unwind$??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAPEAUSect@CInifile@@@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU23@00@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??$_Umove@PEAPEAUSect@CInifile@@@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAUItem@CInifile@@@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU23@00@Z DD imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??$_Umove@PEAUItem@CInifile@@@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@$$BY0BAA@DP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEAY0BAA@$$CBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z DD imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@$$BY0BAA@DP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEAY0BAA@$$CBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@USect@CInifile@@@@YAPEAUSect@CInifile@@XZ DD imagerel $LN22
	DD	imagerel $LN22+59
	DD	imagerel $unwind$??$xr_new@USect@CInifile@@@@YAPEAUSect@CInifile@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@PEBDP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z DD imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@PEBDP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z DD imagerel $LN49
	DD	imagerel $LN49+29
	DD	imagerel $unwind$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z DD imagerel $LN49+29
	DD	imagerel $LN49+163
	DD	imagerel $chain$0$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z DD imagerel $LN49+163
	DD	imagerel $LN49+174
	DD	imagerel $chain$1$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@PEBDP6A_NAEBUItem@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NAEBUItem@CInifile@@PEBD@Z@Z DD imagerel $LN18
	DD	imagerel $LN18+41
	DD	imagerel $unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@PEBDP6A_NAEBUItem@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NAEBUItem@CInifile@@PEBD@Z@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z DD imagerel $LN32
	DD	imagerel $LN32+17
	DD	imagerel $unwind$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z DD imagerel $LN32+17
	DD	imagerel $LN32+144
	DD	imagerel $chain$1$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z DD imagerel $LN32+144
	DD	imagerel $LN32+150
	DD	imagerel $chain$2$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$xr_new@VCInifile@@PEBDH@@YAPEAVCInifile@@AEBQEBDAEBH@Z DD imagerel $LN8
	DD	imagerel $LN8+88
	DD	imagerel $unwind$??$xr_new@VCInifile@@PEBDH@@YAPEAVCInifile@@AEBQEBDAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ufill@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU34@_KPEBQEAU34@@Z DD imagerel $LN12
	DD	imagerel $LN12+45
	DD	imagerel $unwind$?_Ufill@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU34@_KPEBQEAU34@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ufill@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU34@_KPEBU34@@Z DD imagerel $LN10
	DD	imagerel $LN10+48
	DD	imagerel $unwind$?_Ufill@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU34@_KPEBU34@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z DD imagerel $LN248
	DD	imagerel $LN248+702
	DD	imagerel $unwind$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA DD imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA+49
	DD	imagerel $unwind$?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA DD imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA+23
	DD	imagerel $unwind$?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z DD imagerel $LN339
	DD	imagerel $LN339+907
	DD	imagerel $unwind$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA DD imagerel ?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA+112
	DD	imagerel $unwind$?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA DD imagerel ?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA+54
	DD	imagerel $unwind$?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@AEBQEAUSect@CInifile@@@Z DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$?insert@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@AEBQEAUSect@CInifile@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z DD imagerel $LN119
	DD	imagerel $LN119+235
	DD	imagerel $unwind$?erase@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@AEBUItem@CInifile@@@Z DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$?insert@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@AEBUItem@CInifile@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?remove_line@CInifile@@QEAAXPEBD0@Z DD imagerel $LN139
	DD	imagerel $LN139+137
	DD	imagerel $unwind$?remove_line@CInifile@@QEAAXPEBD0@Z
$pdata$2$?remove_line@CInifile@@QEAAXPEBD0@Z DD imagerel $LN139+137
	DD	imagerel $LN139+541
	DD	imagerel $chain$2$?remove_line@CInifile@@QEAAXPEBD0@Z
$pdata$3$?remove_line@CInifile@@QEAAXPEBD0@Z DD imagerel $LN139+541
	DD	imagerel $LN139+550
	DD	imagerel $chain$3$?remove_line@CInifile@@QEAAXPEBD0@Z
$pdata$?w_fvector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@M@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+161
	DD	imagerel $unwind$?w_fvector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@M@@0@Z
$pdata$?w_fvector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@M@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+146
	DD	imagerel $unwind$?w_fvector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@M@@0@Z
$pdata$?w_fvector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@M@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+131
	DD	imagerel $unwind$?w_fvector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@M@@0@Z
$pdata$?w_ivector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@H@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+130
	DD	imagerel $unwind$?w_ivector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@H@@0@Z
$pdata$?w_ivector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@H@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+122
	DD	imagerel $unwind$?w_ivector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@H@@0@Z
$pdata$?w_ivector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@H@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+114
	DD	imagerel $unwind$?w_ivector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@H@@0@Z
$pdata$?w_color@CInifile@@QEAAXPEBD0I0@Z DD imagerel $LN12
	DD	imagerel $LN12+154
	DD	imagerel $unwind$?w_color@CInifile@@QEAAXPEBD0I0@Z
$pdata$?w_fcolor@CInifile@@QEAAXPEBD0AEBU?$_color@M@@0@Z DD imagerel $LN4
	DD	imagerel $LN4+161
	DD	imagerel $unwind$?w_fcolor@CInifile@@QEAAXPEBD0AEBU?$_color@M@@0@Z
$pdata$?w_float@CInifile@@QEAAXPEBD0M0@Z DD imagerel $LN4
	DD	imagerel $LN4+112
	DD	imagerel $unwind$?w_float@CInifile@@QEAAXPEBD0M0@Z
$pdata$?w_s32@CInifile@@QEAAXPEBD0H0@Z DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$?w_s32@CInifile@@QEAAXPEBD0H0@Z
$pdata$?w_s16@CInifile@@QEAAXPEBD0F0@Z DD imagerel $LN4
	DD	imagerel $LN4+107
	DD	imagerel $unwind$?w_s16@CInifile@@QEAAXPEBD0F0@Z
$pdata$?w_s8@CInifile@@QEAAXPEBD0C0@Z DD imagerel $LN4
	DD	imagerel $LN4+107
	DD	imagerel $unwind$?w_s8@CInifile@@QEAAXPEBD0C0@Z
$pdata$?w_u32@CInifile@@QEAAXPEBD0I0@Z DD imagerel $LN4
	DD	imagerel $LN4+103
	DD	imagerel $unwind$?w_u32@CInifile@@QEAAXPEBD0I0@Z
$pdata$?w_u16@CInifile@@QEAAXPEBD0G0@Z DD imagerel $LN4
	DD	imagerel $LN4+107
	DD	imagerel $unwind$?w_u16@CInifile@@QEAAXPEBD0G0@Z
$pdata$?w_u8@CInifile@@QEAAXPEBD0E0@Z DD imagerel $LN4
	DD	imagerel $LN4+107
	DD	imagerel $unwind$?w_u8@CInifile@@QEAAXPEBD0E0@Z
$pdata$?w_string@CInifile@@QEAAXPEBD000@Z DD imagerel $LN318
	DD	imagerel $LN318+11
	DD	imagerel $unwind$?w_string@CInifile@@QEAAXPEBD000@Z
$pdata$5$?w_string@CInifile@@QEAAXPEBD000@Z DD imagerel $LN318+11
	DD	imagerel $LN318+641
	DD	imagerel $chain$5$?w_string@CInifile@@QEAAXPEBD000@Z
$pdata$6$?w_string@CInifile@@QEAAXPEBD000@Z DD imagerel $LN318+641
	DD	imagerel $LN318+895
	DD	imagerel $chain$6$?w_string@CInifile@@QEAAXPEBD000@Z
$pdata$7$?w_string@CInifile@@QEAAXPEBD000@Z DD imagerel $LN318+895
	DD	imagerel $LN318+1067
	DD	imagerel $chain$7$?w_string@CInifile@@QEAAXPEBD000@Z
$pdata$8$?w_string@CInifile@@QEAAXPEBD000@Z DD imagerel $LN318+1067
	DD	imagerel $LN318+1083
	DD	imagerel $chain$8$?w_string@CInifile@@QEAAXPEBD000@Z
$pdata$9$?w_string@CInifile@@QEAAXPEBD000@Z DD imagerel $LN318+1083
	DD	imagerel $LN318+1094
	DD	imagerel $chain$9$?w_string@CInifile@@QEAAXPEBD000@Z
$pdata$?r_line@CInifile@@QEAAHAEBVshared_str@@HPEAPEBD1@Z DD imagerel $LN75
	DD	imagerel $LN75+177
	DD	imagerel $unwind$?r_line@CInifile@@QEAAHAEBVshared_str@@HPEAPEBD1@Z
$pdata$?r_line@CInifile@@QEAAHPEBDHPEAPEBD1@Z DD imagerel $LN69
	DD	imagerel $LN69+143
	DD	imagerel $unwind$?r_line@CInifile@@QEAAHPEBDHPEAPEBD1@Z
$pdata$?r_token@CInifile@@QEAAHPEBD0PEBUxr_token@@@Z DD imagerel $LN13
	DD	imagerel $LN13+120
	DD	imagerel $unwind$?r_token@CInifile@@QEAAHPEBD0PEBUxr_token@@@Z
$pdata$?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z DD imagerel $LN100
	DD	imagerel $LN100+325
	DD	imagerel $unwind$?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z
$pdata$?line_count@CInifile@@QEAAIAEBVshared_str@@@Z DD imagerel $LN57
	DD	imagerel $LN57+73
	DD	imagerel $unwind$?line_count@CInifile@@QEAAIAEBVshared_str@@@Z
$pdata$?line_count@CInifile@@QEAAIPEBD@Z DD imagerel $LN51
	DD	imagerel $LN51+66
	DD	imagerel $unwind$?line_count@CInifile@@QEAAIPEBD@Z
$pdata$?line_exist@CInifile@@QEAAHPEBD0@Z DD imagerel $LN126
	DD	imagerel $LN126+45
	DD	imagerel $unwind$?line_exist@CInifile@@QEAAHPEBD0@Z
$pdata$1$?line_exist@CInifile@@QEAAHPEBD0@Z DD imagerel $LN126+45
	DD	imagerel $LN126+82
	DD	imagerel $chain$1$?line_exist@CInifile@@QEAAHPEBD0@Z
$pdata$2$?line_exist@CInifile@@QEAAHPEBD0@Z DD imagerel $LN126+82
	DD	imagerel $LN126+247
	DD	imagerel $chain$2$?line_exist@CInifile@@QEAAHPEBD0@Z
$pdata$3$?line_exist@CInifile@@QEAAHPEBD0@Z DD imagerel $LN126+247
	DD	imagerel $LN126+261
	DD	imagerel $chain$3$?line_exist@CInifile@@QEAAHPEBD0@Z
$pdata$4$?line_exist@CInifile@@QEAAHPEBD0@Z DD imagerel $LN126+261
	DD	imagerel $LN126+332
	DD	imagerel $chain$4$?line_exist@CInifile@@QEAAHPEBD0@Z
$pdata$?section_exist@CInifile@@QEAAHPEBD@Z DD imagerel $LN95
	DD	imagerel $LN95+6
	DD	imagerel $unwind$?section_exist@CInifile@@QEAAHPEBD@Z
$pdata$0$?section_exist@CInifile@@QEAAHPEBD@Z DD imagerel $LN95+6
	DD	imagerel $LN95+33
	DD	imagerel $chain$0$?section_exist@CInifile@@QEAAHPEBD@Z
$pdata$1$?section_exist@CInifile@@QEAAHPEBD@Z DD imagerel $LN95+33
	DD	imagerel $LN95+148
	DD	imagerel $chain$1$?section_exist@CInifile@@QEAAHPEBD@Z
$pdata$2$?section_exist@CInifile@@QEAAHPEBD@Z DD imagerel $LN95+148
	DD	imagerel $LN95+158
	DD	imagerel $chain$2$?section_exist@CInifile@@QEAAHPEBD@Z
$pdata$3$?section_exist@CInifile@@QEAAHPEBD@Z DD imagerel $LN95+158
	DD	imagerel $LN95+210
	DD	imagerel $chain$3$?section_exist@CInifile@@QEAAHPEBD@Z
$pdata$?save_as@CInifile@@QEAA_NPEBD@Z DD imagerel $LN196
	DD	imagerel $LN196+1007
	DD	imagerel $unwind$?save_as@CInifile@@QEAA_NPEBD@Z
$pdata$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z DD imagerel $LN871
	DD	imagerel $LN871+166
	DD	imagerel $unwind$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z
$pdata$0$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z DD imagerel $LN871+166
	DD	imagerel $LN871+3508
	DD	imagerel $chain$0$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z
$pdata$1$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z DD imagerel $LN871+3508
	DD	imagerel $LN871+3519
	DD	imagerel $chain$1$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z
$pdata$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+13
	DD	imagerel $unwind$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$pdata$2$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+13
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+76
	DD	imagerel $chain$2$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$pdata$4$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+76
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+252
	DD	imagerel $chain$4$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$pdata$5$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+252
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+273
	DD	imagerel $chain$5$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$pdata$6$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+273
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+365
	DD	imagerel $chain$6$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$pdata$??0CInifile@@QEAA@PEBDHHH@Z DD imagerel $LN70
	DD	imagerel $LN70+25
	DD	imagerel $unwind$??0CInifile@@QEAA@PEBDHHH@Z
$pdata$1$??0CInifile@@QEAA@PEBDHHH@Z DD imagerel $LN70+25
	DD	imagerel $LN70+172
	DD	imagerel $chain$1$??0CInifile@@QEAA@PEBDHHH@Z
$pdata$2$??0CInifile@@QEAA@PEBDHHH@Z DD imagerel $LN70+172
	DD	imagerel $LN70+460
	DD	imagerel $chain$2$??0CInifile@@QEAA@PEBDHHH@Z
$pdata$??0CInifile@@QEAA@PEAVIReader@@PEBD@Z DD imagerel $LN14
	DD	imagerel $LN14+59
	DD	imagerel $unwind$??0CInifile@@QEAA@PEAVIReader@@PEBD@Z
$pdata$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD imagerel $LN137
	DD	imagerel $LN137+14
	DD	imagerel $unwind$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$pdata$1$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD imagerel $LN137+14
	DD	imagerel $LN137+53
	DD	imagerel $chain$1$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$pdata$3$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD imagerel $LN137+53
	DD	imagerel $LN137+220
	DD	imagerel $chain$3$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$pdata$4$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD imagerel $LN137+220
	DD	imagerel $LN137+236
	DD	imagerel $chain$4$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$pdata$5$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD imagerel $LN137+236
	DD	imagerel $LN137+330
	DD	imagerel $chain$5$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$pdata$?_parse@@YAXPEADPEBD@Z DD imagerel $LN32
	DD	imagerel $LN32+28
	DD	imagerel $unwind$?_parse@@YAXPEADPEBD@Z
$pdata$0$?_parse@@YAXPEADPEBD@Z DD imagerel $LN32+28
	DD	imagerel $LN32+109
	DD	imagerel $chain$0$?_parse@@YAXPEADPEBD@Z
$pdata$2$?_parse@@YAXPEADPEBD@Z DD imagerel $LN32+109
	DD	imagerel $LN32+160
	DD	imagerel $chain$2$?_parse@@YAXPEADPEBD@Z
$pdata$4$?_parse@@YAXPEADPEBD@Z DD imagerel $LN32+160
	DD	imagerel $LN32+179
	DD	imagerel $chain$4$?_parse@@YAXPEADPEBD@Z
$pdata$5$?_parse@@YAXPEADPEBD@Z DD imagerel $LN32+179
	DD	imagerel $LN32+193
	DD	imagerel $chain$5$?_parse@@YAXPEADPEBD@Z
$pdata$?item_pred@@YA_NAEBUItem@CInifile@@PEBD@Z DD imagerel $LN38
	DD	imagerel $LN38+105
	DD	imagerel $unwind$?item_pred@@YA_NAEBUItem@CInifile@@PEBD@Z
$pdata$?Destroy@CInifile@@SAXPEAV1@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$?Destroy@CInifile@@SAXPEAV1@@Z
$pdata$?Create@CInifile@@SAPEAV1@PEBDH@Z DD imagerel $LN10
	DD	imagerel $LN10+87
	DD	imagerel $unwind$?Create@CInifile@@SAPEAV1@PEBDH@Z
$pdata$?r_bool@CInifile@@QEAAHPEBD0@Z DD imagerel $LN24
	DD	imagerel $LN24+213
	DD	imagerel $unwind$?r_bool@CInifile@@QEAAHPEBD0@Z
$pdata$?r_fvector4@CInifile@@QEAA?AU?$_vector4@M@@PEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?r_fvector4@CInifile@@QEAA?AU?$_vector4@M@@PEBD0@Z
$pdata$?r_fvector3@CInifile@@QEAA?AU?$_vector3@M@@PEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$?r_fvector3@CInifile@@QEAA?AU?$_vector3@M@@PEBD0@Z
$pdata$?r_fvector2@CInifile@@QEAA?AU?$_vector2@M@@PEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$?r_fvector2@CInifile@@QEAA?AU?$_vector2@M@@PEBD0@Z
$pdata$?r_ivector4@CInifile@@QEAA?AU?$_vector4@H@@PEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?r_ivector4@CInifile@@QEAA?AU?$_vector4@H@@PEBD0@Z
$pdata$?r_ivector3@CInifile@@QEAA?AU?$_vector3@H@@PEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+73
	DD	imagerel $unwind$?r_ivector3@CInifile@@QEAA?AU?$_vector3@H@@PEBD0@Z
$pdata$?r_ivector2@CInifile@@QEAA?AU?$_vector2@H@@PEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$?r_ivector2@CInifile@@QEAA?AU?$_vector2@H@@PEBD0@Z
$pdata$?r_color@CInifile@@QEAAIPEBD0@Z DD imagerel $LN8
	DD	imagerel $LN8+116
	DD	imagerel $unwind$?r_color@CInifile@@QEAAIPEBD0@Z
$pdata$?r_fcolor@CInifile@@QEAA?AU?$_color@M@@PEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+85
	DD	imagerel $unwind$?r_fcolor@CInifile@@QEAA?AU?$_color@M@@PEBD0@Z
$pdata$?r_float@CInifile@@QEAAMPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$?r_float@CInifile@@QEAAMPEBD0@Z
$pdata$?r_s32@CInifile@@QEAAHPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?r_s32@CInifile@@QEAAHPEBD0@Z
$pdata$?r_s16@CInifile@@QEAAFPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?r_s16@CInifile@@QEAAFPEBD0@Z
$pdata$?r_s8@CInifile@@QEAACPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?r_s8@CInifile@@QEAACPEBD0@Z
$pdata$?r_u32@CInifile@@QEAAIPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?r_u32@CInifile@@QEAAIPEBD0@Z
$pdata$?r_u16@CInifile@@QEAAGPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?r_u16@CInifile@@QEAAGPEBD0@Z
$pdata$?r_u8@CInifile@@QEAAEPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?r_u8@CInifile@@QEAAEPEBD0@Z
$pdata$?r_string_wb@CInifile@@QEAA?AVshared_str@@PEBD0@Z DD imagerel $LN47
	DD	imagerel $LN47+197
	DD	imagerel $unwind$?r_string_wb@CInifile@@QEAA?AVshared_str@@PEBD0@Z
$pdata$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD imagerel $LN137
	DD	imagerel $LN137+12
	DD	imagerel $unwind$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$pdata$1$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD imagerel $LN137+12
	DD	imagerel $LN137+63
	DD	imagerel $chain$1$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$pdata$3$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD imagerel $LN137+63
	DD	imagerel $LN137+239
	DD	imagerel $chain$3$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$pdata$4$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD imagerel $LN137+239
	DD	imagerel $LN137+255
	DD	imagerel $chain$4$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$pdata$5$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD imagerel $LN137+255
	DD	imagerel $LN137+416
	DD	imagerel $chain$5$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$pdata$?r_clsid@CInifile@@QEAA_KPEBD0@Z DD imagerel $LN4
	DD	imagerel $LN4+21
	DD	imagerel $unwind$?r_clsid@CInifile@@QEAA_KPEBD0@Z
$pdata$??1CInifile@@UEAA@XZ DD imagerel $LN349
	DD	imagerel $LN349+236
	DD	imagerel $unwind$??1CInifile@@UEAA@XZ
xdata	SEGMENT
$unwind$?remove_line@CInifile@@QEAAXPEBD0@Z DD 050901H
	DD	07005a209H
	DD	050036004H
	DD	03002H
$chain$2$?remove_line@CInifile@@QEAAXPEBD0@Z DD 061b21H
	DD	0af41bH
	DD	011e416H
	DD	010c408H
	DD	imagerel $LN139
	DD	imagerel $LN139+137
	DD	imagerel $unwind$?remove_line@CInifile@@QEAAXPEBD0@Z
$chain$3$?remove_line@CInifile@@QEAAXPEBD0@Z DD 021H
	DD	imagerel $LN139
	DD	imagerel $LN139+137
	DD	imagerel $unwind$?remove_line@CInifile@@QEAAXPEBD0@Z
$unwind$?w_fvector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@M@@0@Z DD 071201H
	DD	01b6412H
	DD	01a3412H
	DD	0180112H
	DD	0700bH
$unwind$?w_fvector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@M@@0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_fvector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@M@@0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_ivector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@H@@0@Z DD 071201H
	DD	01b6412H
	DD	01a3412H
	DD	0180112H
	DD	0700bH
$unwind$?w_ivector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@H@@0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_ivector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@H@@0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_color@CInifile@@QEAAXPEBD0I0@Z DD 091701H
	DD	01c6417H
	DD	01b5417H
	DD	01a3417H
	DD	0180117H
	DD	07010H
$unwind$?w_fcolor@CInifile@@QEAAXPEBD0AEBU?$_color@M@@0@Z DD 071201H
	DD	01b6412H
	DD	01a3412H
	DD	0180112H
	DD	0700bH
$unwind$?w_float@CInifile@@QEAAXPEBD0M0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_s32@CInifile@@QEAAXPEBD0H0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_s16@CInifile@@QEAAXPEBD0F0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_s8@CInifile@@QEAAXPEBD0C0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_u32@CInifile@@QEAAXPEBD0I0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_u16@CInifile@@QEAAXPEBD0G0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_u8@CInifile@@QEAAXPEBD0E0@Z DD 071201H
	DD	0196412H
	DD	0183412H
	DD	0160112H
	DD	0700bH
$unwind$?w_string@CInifile@@QEAAXPEBD000@Z DD 030b01H
	DD	072010bH
	DD	06004H
$chain$5$?w_string@CInifile@@QEAAXPEBD000@Z DD 0c1821H
	DD	06ef418H
	DD	06fe414H
	DD	070d410H
	DD	076740cH
	DD	0755408H
	DD	0743404H
	DD	imagerel $LN318
	DD	imagerel $LN318+11
	DD	imagerel $unwind$?w_string@CInifile@@QEAAXPEBD000@Z
$chain$6$?w_string@CInifile@@QEAAXPEBD000@Z DD 020821H
	DD	071c408H
	DD	imagerel $LN318+11
	DD	imagerel $LN318+641
	DD	imagerel $chain$5$?w_string@CInifile@@QEAAXPEBD000@Z
$chain$7$?w_string@CInifile@@QEAAXPEBD000@Z DD 060021H
	DD	06ef400H
	DD	0767400H
	DD	0755400H
	DD	imagerel $LN318
	DD	imagerel $LN318+11
	DD	imagerel $unwind$?w_string@CInifile@@QEAAXPEBD000@Z
$chain$8$?w_string@CInifile@@QEAAXPEBD000@Z DD 020021H
	DD	0755400H
	DD	imagerel $LN318
	DD	imagerel $LN318+11
	DD	imagerel $unwind$?w_string@CInifile@@QEAAXPEBD000@Z
$chain$9$?w_string@CInifile@@QEAAXPEBD000@Z DD 021H
	DD	imagerel $LN318
	DD	imagerel $LN318+11
	DD	imagerel $unwind$?w_string@CInifile@@QEAAXPEBD000@Z
$unwind$?r_line@CInifile@@QEAAHAEBVshared_str@@HPEAPEBD1@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?r_line@CInifile@@QEAAHPEBDHPEAPEBD1@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
$unwind$?r_token@CInifile@@QEAAHPEBD0PEBUxr_token@@@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
$unwind$?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z DD 091701H
	DD	02a6417H
	DD	0295417H
	DD	0283417H
	DD	0260117H
	DD	07010H
$unwind$?line_count@CInifile@@QEAAIAEBVshared_str@@@Z DD 020601H
	DD	030023206H
$unwind$?line_count@CInifile@@QEAAIPEBD@Z DD 010401H
	DD	04204H
$unwind$?line_exist@CInifile@@QEAAHPEBD0@Z DD 062d01H
	DD	09e42dH
	DD	070043208H
	DD	030026003H
$chain$1$?line_exist@CInifile@@QEAAHPEBD0@Z DD 020521H
	DD	0af405H
	DD	imagerel $LN126
	DD	imagerel $LN126+45
	DD	imagerel $unwind$?line_exist@CInifile@@QEAAHPEBD0@Z
$chain$2$?line_exist@CInifile@@QEAAHPEBD0@Z DD 020521H
	DD	085405H
	DD	imagerel $LN126+45
	DD	imagerel $LN126+82
	DD	imagerel $chain$1$?line_exist@CInifile@@QEAAHPEBD0@Z
$chain$3$?line_exist@CInifile@@QEAAHPEBD0@Z DD 021H
	DD	imagerel $LN126+45
	DD	imagerel $LN126+82
	DD	imagerel $chain$1$?line_exist@CInifile@@QEAAHPEBD0@Z
$chain$4$?line_exist@CInifile@@QEAAHPEBD0@Z DD 021H
	DD	imagerel $LN126
	DD	imagerel $LN126+45
	DD	imagerel $unwind$?line_exist@CInifile@@QEAAHPEBD0@Z
$unwind$?section_exist@CInifile@@QEAAHPEBD@Z DD 010201H
	DD	03002H
$chain$0$?section_exist@CInifile@@QEAAHPEBD@Z DD 020521H
	DD	026405H
	DD	imagerel $LN95
	DD	imagerel $LN95+6
	DD	imagerel $unwind$?section_exist@CInifile@@QEAAHPEBD@Z
$chain$1$?section_exist@CInifile@@QEAAHPEBD@Z DD 020521H
	DD	037405H
	DD	imagerel $LN95+6
	DD	imagerel $LN95+33
	DD	imagerel $chain$0$?section_exist@CInifile@@QEAAHPEBD@Z
$chain$2$?section_exist@CInifile@@QEAAHPEBD@Z DD 021H
	DD	imagerel $LN95+6
	DD	imagerel $LN95+33
	DD	imagerel $chain$0$?section_exist@CInifile@@QEAAHPEBD@Z
$chain$3$?section_exist@CInifile@@QEAAHPEBD@Z DD 021H
	DD	imagerel $LN95
	DD	imagerel $LN95+6
	DD	imagerel $unwind$?section_exist@CInifile@@QEAAHPEBD@Z
$unwind$?save_as@CInifile@@QEAA_NPEBD@Z DD 091d01H
	DD	093641dH
	DD	092341dH
	DD	08c011dH
	DD	0700ce00eH
	DD	0500bH
$unwind$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z DD 052701H
	DD	04e60127H
	DD	030116012H
	DD	05010H
$chain$0$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z DD 020821H
	DD	04e57408H
	DD	imagerel $LN871
	DD	imagerel $LN871+166
	DD	imagerel $unwind$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z
$chain$1$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z DD 021H
	DD	imagerel $LN871
	DD	imagerel $LN871+166
	DD	imagerel $unwind$?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z
$unwind$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD 040a01H
	DD	0f006720aH
	DD	07002c004H
$chain$2$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD 060f21H
	DD	06e40fH
	DD	07d40aH
	DD	0d3405H
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+13
	DD	imagerel $unwind$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$chain$4$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD 040a21H
	DD	0f640aH
	DD	0e5405H
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+13
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+76
	DD	imagerel $chain$2$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$chain$5$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD 021H
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+13
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+76
	DD	imagerel $chain$2$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$chain$6$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z DD 021H
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
	DD	imagerel ?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z+13
	DD	imagerel $unwind$?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z
$unwind$??0CInifile@@QEAA@PEBDHHH@Z DD 091601H
	DD	0915416H
	DD	0903416H
	DD	08a0116H
	DD	0700dc00fH
	DD	0600cH
$chain$1$??0CInifile@@QEAA@PEBDHHH@Z DD 040821H
	DD	08ff408H
	DD	08ee404H
	DD	imagerel $LN70
	DD	imagerel $LN70+25
	DD	imagerel $unwind$??0CInifile@@QEAA@PEBDHHH@Z
$chain$2$??0CInifile@@QEAA@PEBDHHH@Z DD 021H
	DD	imagerel $LN70
	DD	imagerel $LN70+25
	DD	imagerel $unwind$??0CInifile@@QEAA@PEBDHHH@Z
$unwind$??0CInifile@@QEAA@PEAVIReader@@PEBD@Z DD 020601H
	DD	030023206H
$unwind$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD 040a01H
	DD	0e006320aH
	DD	06002c004H
$chain$1$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD 041121H
	DD	0bf411H
	DD	083405H
	DD	imagerel $LN137
	DD	imagerel $LN137+14
	DD	imagerel $unwind$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$chain$3$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD 040a21H
	DD	0a740aH
	DD	095405H
	DD	imagerel $LN137+14
	DD	imagerel $LN137+53
	DD	imagerel $chain$1$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$chain$4$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD 021H
	DD	imagerel $LN137+14
	DD	imagerel $LN137+53
	DD	imagerel $chain$1$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$chain$5$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z DD 021H
	DD	imagerel $LN137
	DD	imagerel $LN137+14
	DD	imagerel $unwind$?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z
$unwind$?_parse@@YAXPEADPEBD@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
$chain$0$?_parse@@YAXPEADPEBD@Z DD 020521H
	DD	066405H
	DD	imagerel $LN32
	DD	imagerel $LN32+28
	DD	imagerel $unwind$?_parse@@YAXPEADPEBD@Z
$chain$2$?_parse@@YAXPEADPEBD@Z DD 020021H
	DD	066400H
	DD	imagerel $LN32
	DD	imagerel $LN32+28
	DD	imagerel $unwind$?_parse@@YAXPEADPEBD@Z
$chain$4$?_parse@@YAXPEADPEBD@Z DD 020021H
	DD	066400H
	DD	imagerel $LN32
	DD	imagerel $LN32+28
	DD	imagerel $unwind$?_parse@@YAXPEADPEBD@Z
$chain$5$?_parse@@YAXPEADPEBD@Z DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+28
	DD	imagerel $unwind$?_parse@@YAXPEADPEBD@Z
$unwind$?item_pred@@YA_NAEBUItem@CInifile@@PEBD@Z DD 020601H
	DD	030023206H
$unwind$?Destroy@CInifile@@SAXPEAV1@@Z DD 010901H
	DD	04209H
$unwind$?Create@CInifile@@SAPEAV1@PEBDH@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
$unwind$?r_bool@CInifile@@QEAAHPEBD0@Z DD 010401H
	DD	04204H
$unwind$?r_fvector4@CInifile@@QEAA?AU?$_vector4@M@@PEBD0@Z DD 020601H
	DD	030025206H
$unwind$?r_fvector3@CInifile@@QEAA?AU?$_vector3@M@@PEBD0@Z DD 020601H
	DD	030025206H
$unwind$?r_fvector2@CInifile@@QEAA?AU?$_vector2@M@@PEBD0@Z DD 020601H
	DD	030023206H
$unwind$?r_ivector4@CInifile@@QEAA?AU?$_vector4@H@@PEBD0@Z DD 020601H
	DD	030025206H
$unwind$?r_ivector3@CInifile@@QEAA?AU?$_vector3@H@@PEBD0@Z DD 020601H
	DD	030025206H
$unwind$?r_ivector2@CInifile@@QEAA?AU?$_vector2@H@@PEBD0@Z DD 020601H
	DD	030023206H
$unwind$?r_color@CInifile@@QEAAIPEBD0@Z DD 010401H
	DD	08204H
$unwind$?r_fcolor@CInifile@@QEAA?AU?$_color@M@@PEBD0@Z DD 020601H
	DD	030025206H
$unwind$?r_float@CInifile@@QEAAMPEBD0@Z DD 010401H
	DD	04204H
$unwind$?r_s32@CInifile@@QEAAHPEBD0@Z DD 010401H
	DD	04204H
$unwind$?r_s16@CInifile@@QEAAFPEBD0@Z DD 010401H
	DD	04204H
$unwind$?r_s8@CInifile@@QEAACPEBD0@Z DD 010401H
	DD	04204H
$unwind$?r_u32@CInifile@@QEAAIPEBD0@Z DD 010401H
	DD	04204H
$unwind$?r_u16@CInifile@@QEAAGPEBD0@Z DD 010401H
	DD	04204H
$unwind$?r_u8@CInifile@@QEAAEPEBD0@Z DD 010401H
	DD	04204H
$unwind$?r_string_wb@CInifile@@QEAA?AVshared_str@@PEBD0@Z DD 050d01H
	DD	046340dH
	DD	044010dH
	DD	07006H
$unwind$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD 050c01H
	DD	0e008820cH
	DD	0c004d006H
	DD	05002H
$chain$1$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD 041021H
	DD	08f410H
	DD	0e3405H
	DD	imagerel $LN137
	DD	imagerel $LN137+12
	DD	imagerel $unwind$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$chain$3$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD 040d21H
	DD	010740dH
	DD	0f6405H
	DD	imagerel $LN137+12
	DD	imagerel $LN137+63
	DD	imagerel $chain$1$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$chain$4$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD 021H
	DD	imagerel $LN137+12
	DD	imagerel $LN137+63
	DD	imagerel $chain$1$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$chain$5$?r_string@CInifile@@QEAAPEBDPEBD0@Z DD 021H
	DD	imagerel $LN137
	DD	imagerel $LN137+12
	DD	imagerel $unwind$?r_string@CInifile@@QEAAPEBDPEBD0@Z
$unwind$?r_clsid@CInifile@@QEAA_KPEBD0@Z DD 010401H
	DD	04204H
$unwind$??1CInifile@@UEAA@XZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@AEBUItem@CInifile@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z DD 061e01H
	DD	04740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@AEBQEAUSect@CInifile@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA DD 050d19H
	DD	07009620dH
	DD	050076008H
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z DD imagerel ?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
	DD	0ffffffffH
	DD	imagerel ?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z+233
	DD	00H
	DD	imagerel ?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z+325
	DD	0ffffffffH
	DD	imagerel ?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z+504
	DD	02H
	DD	imagerel ?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z+546
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA+16
	DD	01H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA+13
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$1$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$1$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
	DD	02H
	DD	imagerel $tryMap$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
	DD	09H
	DD	imagerel $ip2state$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
	DD	038H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z DD 082c19H
	DD	0f01f9223H
	DD	0d01be01dH
	DD	07017c019H
	DD	030156016H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z DD imagerel ?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
	DD	0ffffffffH
	DD	imagerel ?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z+217
	DD	00H
	DD	imagerel ?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z+298
	DD	0ffffffffH
	DD	imagerel ?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z+420
	DD	02H
	DD	imagerel ?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z+464
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA+13
	DD	01H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA+13
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$1$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$1$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
	DD	02H
	DD	imagerel $tryMap$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
	DD	09H
	DD	imagerel $ip2state$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
	DD	038H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z DD 0a2a19H
	DD	0f642aH
	DD	0e3425H
	DD	0f0137217H
	DD	0d00fe011H
	DD	0700bc00dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ufill@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU34@_KPEBU34@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ufill@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU34@_KPEBQEAU34@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@VCInifile@@PEBDH@@YAPEAVCInifile@@AEBQEBDAEBH@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+17
	DD	imagerel $unwind$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN32
	DD	imagerel $LN32+17
	DD	imagerel $unwind$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z DD 020601H
	DD	060023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@PEBDP6A_NAEBUItem@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NAEBUItem@CInifile@@PEBD@Z@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z DD 021H
	DD	imagerel $LN49
	DD	imagerel $LN49+29
	DD	imagerel $unwind$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN49
	DD	imagerel $LN49+29
	DD	imagerel $unwind$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z DD 040a01H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@PEBDP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$xr_new@USect@CInifile@@@@YAPEAUSect@CInifile@@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@$$BY0BAA@DP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEAY0BAA@$$CBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAUItem@CInifile@@@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU23@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAPEAUSect@CInifile@@@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU23@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_fill_n@PEAUItem@CInifile@@_KU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$00VCInifile@@@@QEAAXAEAPEAVCInifile@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$xr_special_free@$0A@USect@CInifile@@@@QEAAXAEAPEAUSect@CInifile@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GSect@CInifile@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+37
	DD	imagerel $unwind$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z DD 040a21H
	DD	07740aH
	DD	066405H
	DD	imagerel $LN58
	DD	imagerel $LN58+37
	DD	imagerel $unwind$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z DD 061001H
	DD	095410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+22
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD 040921H
	DD	07409H
	DD	023405H
	DD	imagerel $LN34
	DD	imagerel $LN34+22
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+23
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD 020521H
	DD	023405H
	DD	imagerel $LN34
	DD	imagerel $LN34+23
	DD	imagerel $unwind$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z DD 010201H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00U_Scalar_ptr_iterator_tag@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+31
	DD	00H
	DD	imagerel ??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+143
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 011719H
	DD	0620eH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+51
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+31
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+144
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 011719H
	DD	0620eH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel ??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+16
	DD	00H
	DD	imagerel ??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+52
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
	DD	020H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
??1CInifile@@UEAA@XZ PROC				; CInifile::~CInifile

; 103  : {

$LN349:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 104  : 	if (!bReadOnly&&bSaveAtEnd) {

	cmp	DWORD PTR [rcx+40], 0
	lea	rax, OFFSET FLAT:??_7CInifile@@6B@
	mov	rsi, rcx
	mov	QWORD PTR [rcx], rax
	jne	SHORT $LN4@CInifile
	cmp	DWORD PTR [rcx+44], 0
	je	SHORT $LN4@CInifile

; 105  : 		if (!save_as())

	xor	edx, edx
	call	?save_as@CInifile@@QEAA_NPEBD@Z		; CInifile::save_as
	test	al, al
	jne	SHORT $LN4@CInifile

; 106  : 			Log		("!Can't save inifile:",fName);

	mov	rdx, QWORD PTR [rsi+8]
	lea	rcx, OFFSET FLAT:??_C@_0BF@HIBEFMCL@?$CBCan?8t?5save?5inifile?3?$AA@
	call	?Log@@YAXPEBD0@Z			; Log
$LN4@CInifile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rsi+8], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 109  : 	xr_free			(fName);

	lea	rcx, QWORD PTR [rsi+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	je	SHORT $LN266@CInifile
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN266@CInifile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

	mov	rdi, QWORD PTR [rsi+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 113  : 	for ( ; I != E; ++I)

	mov	rbx, QWORD PTR [rsi+16]
	cmp	rbx, rdi
	je	SHORT $LN1@CInifile
$LL289@CInifile:

; 114  : 		xr_delete	(*I);

	mov	rcx, rbx
	call	??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z ; xr_delete<CInifile::Sect>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rbx, 8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 113  : 	for ( ; I != E; ++I)

	cmp	rbx, rdi
	jne	SHORT $LL289@CInifile
$LN1@CInifile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1623 : 		if (this->_Myfirst != pointer())

	mov	rdi, QWORD PTR [rsi+16]
	test	rdi, rdi
	je	SHORT $LN305@CInifile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN321@CInifile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN342@CInifile

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN342@CInifile
$LN321@CInifile:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN342@CInifile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1629 : 			this->_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rsi+16], rax

; 1630 : 			this->_Mylast = pointer();

	mov	QWORD PTR [rsi+24], rax

; 1631 : 			this->_Myend = pointer();

	mov	QWORD PTR [rsi+32], rax
$LN305@CInifile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 115  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??1CInifile@@UEAA@XZ ENDP				; CInifile::~CInifile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
?r_clsid@CInifile@@QEAA_KPEBD0@Z PROC			; CInifile::r_clsid

; 471  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 472  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 473  : 	return		TEXT2CLSID(C);

	mov	rcx, rax

; 474  : }

	add	rsp, 40					; 00000028H

; 473  : 	return		TEXT2CLSID(C);

	jmp	?TEXT2CLSID@@YA_KPEBD@Z			; TEXT2CLSID
?r_clsid@CInifile@@QEAA_KPEBD0@Z ENDP			; CInifile::r_clsid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 112
S$ = 120
L$ = 128
?r_string@CInifile@@QEAAPEBDPEBD0@Z PROC		; CInifile::r_string

; 347  : {

$LN137:
	push	rbp
	push	r12
	push	r13
	push	r14
	sub	rsp, 72					; 00000048H
	mov	QWORD PTR [rsp+112], rbx
	mov	rbp, r8
	mov	r12, rdx
	mov	QWORD PTR [rsp+64], r15
	mov	r13, rcx

; 348  : 	Sect&	I = r_section(S);

	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	r14, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rbx, QWORD PTR [rax+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 348  : 	Sect&	I = r_section(S);

	mov	r15, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	rbx, r14
	sar	rbx, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jle	$LN35@r_string
	mov	QWORD PTR [rsp+120], rsi
	mov	QWORD PTR [rsp+128], rdi
	npad	4
$LL36@r_string:

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	add	rdi, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	mov	rcx, QWORD PTR [r14+rdi*8]
	test	rcx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 21   :     if ((!x.first) || (!val))	return x.first<val;

	je	SHORT $LN52@r_string
	test	rbp, rbp
	je	SHORT $LN52@r_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	add	rcx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rbp
	sub	r8, rcx
	npad	4
$LL134@r_string:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN135@r_string
	inc	rcx
	test	eax, eax
	jne	SHORT $LL134@r_string
$LN135@r_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 22   :     else				   		return xr_strcmp(*x.first,val)<0;

	test	edx, edx
	sets	cl
	jmp	SHORT $LN75@r_string
$LN52@r_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	mov	rdx, rbp
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN63@r_string
	inc	DWORD PTR [rax]
$LN63@r_string:

; 67   : 	char				operator[]	(size_t id)						{	return p_->value[id];							}
; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}
; 69   : 
; 70   : 	// misc func
; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}
; 72   : 	void				swap		(shared_str & rhs)				{	str_value* tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}
; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}
; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}
; 94   : IC bool operator	!=	(shared_str const & a, shared_str const & b)		{ return a._get() != b._get();					}
; 95   : IC bool operator	<	(shared_str const & a, shared_str const & b)		{ return a._get() <  b._get();					}

	cmp	QWORD PTR [r14+rdi*8], rax
	setb	cl

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rax, rax
	je	SHORT $LN75@r_string
	dec	DWORD PTR [rax]
$LN75@r_string:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	test	cl, cl
	je	SHORT $LN34@r_string

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	r14, QWORD PTR [r14+rdi*8]
	sub	rax, rsi
	add	r14, 16
	add	rbx, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN33@r_string
$LN34@r_string:

; 2521 : 			_Count = _Count2;

	mov	rbx, rsi
$LN33@r_string:

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jg	$LL36@r_string
	mov	rdi, QWORD PTR [rsp+128]
	mov	rsi, QWORD PTR [rsp+120]
$LN35@r_string:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r14, QWORD PTR [r15+16]
	mov	rbx, QWORD PTR [rsp+112]
	mov	r15, QWORD PTR [rsp+64]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 350  : 	if (A!=I.Data.end() && xr_strcmp(*A->first,L)==0)	return *A->second;

	je	SHORT $LN2@r_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [r14]
	xor	r9d, r9d
	test	rax, rax
	je	SHORT $LN113@r_string
	add	rax, 12
	jmp	SHORT $LN114@r_string
$LN113@r_string:
	mov	rax, r9
$LN114@r_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rbp
	sub	r8, rax
	npad	7
$LL132@r_string:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN133@r_string
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL132@r_string
$LN133@r_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 350  : 	if (A!=I.Data.end() && xr_strcmp(*A->first,L)==0)	return *A->second;

	test	edx, edx
	jne	SHORT $LN2@r_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [r14+8]
	test	rax, rax
	je	SHORT $LN127@r_string
	lea	r9, QWORD PTR [rax+12]
$LN127@r_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 350  : 	if (A!=I.Data.end() && xr_strcmp(*A->first,L)==0)	return *A->second;

	mov	rax, r9

; 354  : }

	add	rsp, 72					; 00000048H
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
$LN2@r_string:

; 351  : 	else
; 352  : 		Debug.fatal(DEBUG_INFO,"Can't find variable %s in [%s], file %s",L,S, this->fName);

	mov	rax, QWORD PTR [r13+8]
	lea	r9, OFFSET FLAT:??_C@_0BD@DOJGBPMF@CInifile?3?3r_string?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0CI@BBBLINKF@Can?8t?5find?5variable?5?$CFs?5in?5?$FL?$CFs?$FN?0?5@
	mov	QWORD PTR [rsp+48], r12
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	r8d, 352				; 00000160H
	mov	QWORD PTR [rsp+40], rbp
	mov	QWORD PTR [rsp+32], rax
	call	?fatal@xrDebug@@QEAAXPEBDH00ZZ		; xrDebug::fatal

; 353  : 	return 0;

	xor	eax, eax

; 354  : }

	add	rsp, 72					; 00000048H
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?r_string@CInifile@@QEAAPEBDPEBD0@Z ENDP		; CInifile::r_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
_original$ = 32
this$ = 560
__$ReturnUdt$ = 568
S$ = 576
L$ = 584
?r_string_wb@CInifile@@QEAA?AVshared_str@@PEBD0@Z PROC	; CInifile::r_string_wb

; 356  : shared_str		CInifile::r_string_wb(LPCSTR S, LPCSTR L)	{

$LN47:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 544				; 00000220H
	mov	rax, r8
	mov	rbx, rdx

; 357  : 	LPCSTR		_base		= r_string(S,L);

	mov	r8, r9
	mov	rdx, rax
	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 359  : 	if	(0==_base)					return	shared_str(0);

	test	rax, rax
	jne	SHORT $LN4@r_string_w
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	xor	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 359  : 	if	(0==_base)					return	shared_str(0);

	jmp	SHORT $LN44@r_string_w
$LN4@r_string_w:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	lea	rcx, QWORD PTR _original$[rsp]
	mov	r8, rax
	mov	edx, 512				; 00000200H
	call	QWORD PTR __imp_strcpy_s
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR _original$[rsp]
	or	rax, -1
$LL38@r_string_w:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL38@r_string_w
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 364  : 	if	(0==_len)					return	shared_str("");

	test	eax, eax
	jne	SHORT $LN3@r_string_w
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 364  : 	if	(0==_len)					return	shared_str("");

	jmp	SHORT $LN44@r_string_w
$LN3@r_string_w:

; 365  : 	if	('"'==_original[_len-1])	_original[_len-1]=0;				// skip end

	dec	eax
	cmp	BYTE PTR _original$[rsp+rax], 34	; 00000022H
	jne	SHORT $LN2@r_string_w
	mov	BYTE PTR _original$[rsp+rax], 0
$LN2@r_string_w:

; 366  : 	if	('"'==_original[0])			return	shared_str(&_original[0] + 1);	// skip begin

	cmp	BYTE PTR _original$[rsp], 34		; 00000022H
	jne	SHORT $LN1@r_string_w
	lea	rdx, QWORD PTR _original$[rsp+1]
	mov	rcx, rbx
	call	??0shared_str@@QEAA@PEBD@Z		; shared_str::shared_str
	jmp	SHORT $LN45@r_string_w
$LN1@r_string_w:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	lea	rdx, QWORD PTR _original$[rsp]
$LN44@r_string_w:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}
; 54   : 	const str_value*	_get		()	const						{	return p_;																					}
; 55   : public:
; 56   : 	// construction
; 57   : 						shared_str	()								{	p_ = 0;											}
; 58   : 						shared_str	(str_c rhs) 					{	p_ = 0;	_set(rhs);								}

	xor	edi, edi
	mov	QWORD PTR [rbx], rdi

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN31@r_string_w
	inc	DWORD PTR [rax]
$LN31@r_string_w:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN34@r_string_w
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rbx]
	cmp	DWORD PTR [rcx], edi
	jne	SHORT $LN34@r_string_w
	mov	QWORD PTR [rbx], rdi
$LN34@r_string_w:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR [rbx], rax
$LN45@r_string_w:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 367  : 	return									shared_str(_original);

	mov	rax, rbx

; 368  : }

	mov	rbx, QWORD PTR [rsp+560]
	add	rsp, 544				; 00000220H
	pop	rdi
	ret	0
?r_string_wb@CInifile@@QEAA?AVshared_str@@PEBD0@Z ENDP	; CInifile::r_string_wb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
?r_u8@CInifile@@QEAAEPEBD0@Z PROC			; CInifile::r_u8

; 371  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 372  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 373  : 	return		u8(atoi(C));

	mov	rcx, rax

; 374  : }

	add	rsp, 40					; 00000028H

; 373  : 	return		u8(atoi(C));

	rex_jmp	QWORD PTR __imp_atoi
?r_u8@CInifile@@QEAAEPEBD0@Z ENDP			; CInifile::r_u8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
?r_u16@CInifile@@QEAAGPEBD0@Z PROC			; CInifile::r_u16

; 376  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 377  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 378  : 	return		u16(atoi(C));

	mov	rcx, rax

; 379  : }

	add	rsp, 40					; 00000028H

; 378  : 	return		u16(atoi(C));

	rex_jmp	QWORD PTR __imp_atoi
?r_u16@CInifile@@QEAAGPEBD0@Z ENDP			; CInifile::r_u16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
?r_u32@CInifile@@QEAAIPEBD0@Z PROC			; CInifile::r_u32

; 381  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 382  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 383  : 	return		u32(atoi(C));

	mov	rcx, rax

; 384  : }

	add	rsp, 40					; 00000028H

; 383  : 	return		u32(atoi(C));

	rex_jmp	QWORD PTR __imp_atoi
?r_u32@CInifile@@QEAAIPEBD0@Z ENDP			; CInifile::r_u32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
?r_s8@CInifile@@QEAACPEBD0@Z PROC			; CInifile::r_s8

; 386  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 387  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 388  : 	return		s8(atoi(C));

	mov	rcx, rax

; 389  : }

	add	rsp, 40					; 00000028H

; 388  : 	return		s8(atoi(C));

	rex_jmp	QWORD PTR __imp_atoi
?r_s8@CInifile@@QEAACPEBD0@Z ENDP			; CInifile::r_s8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
?r_s16@CInifile@@QEAAFPEBD0@Z PROC			; CInifile::r_s16

; 391  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 392  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 393  : 	return		s16(atoi(C));

	mov	rcx, rax

; 394  : }

	add	rsp, 40					; 00000028H

; 393  : 	return		s16(atoi(C));

	rex_jmp	QWORD PTR __imp_atoi
?r_s16@CInifile@@QEAAFPEBD0@Z ENDP			; CInifile::r_s16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
?r_s32@CInifile@@QEAAHPEBD0@Z PROC			; CInifile::r_s32

; 396  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 397  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 398  : 	return		s32(atoi(C));

	mov	rcx, rax

; 399  : }

	add	rsp, 40					; 00000028H

; 398  : 	return		s32(atoi(C));

	rex_jmp	QWORD PTR __imp_atoi
?r_s32@CInifile@@QEAAHPEBD0@Z ENDP			; CInifile::r_s32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
?r_float@CInifile@@QEAAMPEBD0@Z PROC			; CInifile::r_float

; 401  : {

$LN4:
	sub	rsp, 40					; 00000028H

; 402  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 403  : 	return		float(atof( C ));

	mov	rcx, rax
	call	QWORD PTR __imp_atof
	cvtsd2ss xmm0, xmm0

; 404  : }

	add	rsp, 40					; 00000028H
	ret	0
?r_float@CInifile@@QEAAMPEBD0@Z ENDP			; CInifile::r_float
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
S$ = 80
L$ = 88
?r_fcolor@CInifile@@QEAA?AU?$_color@M@@PEBD0@Z PROC	; CInifile::r_fcolor

; 406  : {

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, r8
	mov	rbx, rdx

; 407  : 	LPCSTR		C = r_string(S,L);

	mov	r8, r9
	mov	rdx, rax
	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 408  : 	Fcolor		V={0,0,0,0};

	xor	edx, edx
	lea	r8, QWORD PTR [rbx+8]
	lea	rcx, QWORD PTR [rbx+12]
	mov	DWORD PTR [r8], edx
	lea	r9, QWORD PTR [rbx+4]
	mov	DWORD PTR [rcx], edx

; 409  : 	sscanf		(C,"%f,%f,%f,%f",&V.r,&V.g,&V.b,&V.a);

	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [r9], edx
	mov	DWORD PTR [rbx], edx
	mov	QWORD PTR [rsp+32], r8
	lea	rdx, OFFSET FLAT:??_C@_0M@JJJBFJKB@?$CFf?0?$CFf?0?$CFf?0?$CFf?$AA@
	mov	r8, rbx
	mov	rcx, rax
	call	QWORD PTR __imp_sscanf

; 410  : 	return V;

	mov	rax, rbx

; 411  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?r_fcolor@CInifile@@QEAA?AU?$_color@M@@PEBD0@Z ENDP	; CInifile::r_fcolor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
a$ = 48
g$ = 52
b$ = 56
this$ = 80
S$ = 88
L$ = 96
r$ = 104
?r_color@CInifile@@QEAAIPEBD0@Z PROC			; CInifile::r_color

; 413  : {

$LN8:
	sub	rsp, 72					; 00000048H

; 414  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 415  : 	u32			r=0,g=0,b=0,a=255;

	xor	ecx, ecx

; 416  : 	sscanf		(C,"%d,%d,%d,%d",&r,&g,&b,&a);

	lea	r9, QWORD PTR g$[rsp]
	mov	DWORD PTR r$[rsp], ecx
	mov	DWORD PTR g$[rsp], ecx
	mov	DWORD PTR b$[rsp], ecx
	lea	rcx, QWORD PTR a$[rsp]
	lea	r8, QWORD PTR r$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0M@MLCONGPP@?$CFd?0?$CFd?0?$CFd?0?$CFd?$AA@
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR b$[rsp]
	mov	DWORD PTR a$[rsp], 255			; 000000ffH
	mov	QWORD PTR [rsp+32], rcx
	mov	rcx, rax
	call	QWORD PTR __imp_sscanf

; 417  : 	return color_rgba(r,g,b,a);

	mov	ecx, DWORD PTR a$[rsp]
	movzx	eax, BYTE PTR r$[rsp]
	shl	ecx, 8
	or	eax, ecx
	movzx	ecx, BYTE PTR g$[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	eax, 8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 417  : 	return color_rgba(r,g,b,a);

	or	eax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	ecx, BYTE PTR b$[rsp]
	shl	eax, 8
	or	eax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 418  : }

	add	rsp, 72					; 00000048H
	ret	0
?r_color@CInifile@@QEAAIPEBD0@Z ENDP			; CInifile::r_color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
S$ = 64
L$ = 72
?r_ivector2@CInifile@@QEAA?AU?$_vector2@H@@PEBD0@Z PROC	; CInifile::r_ivector2

; 421  : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx

; 422  : 	LPCSTR		C = r_string(S,L);

	mov	r8, r9
	mov	rdx, rax
	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 423  : 	Ivector2	V={0,0};

	xor	ecx, ecx
	lea	r9, QWORD PTR [rbx+4]
	mov	DWORD PTR [rbx], ecx
	mov	DWORD PTR [r9], ecx

; 424  : 	sscanf		(C,"%d,%d",&V.x,&V.y);

	lea	rdx, OFFSET FLAT:??_C@_05KABNCBHK@?$CFd?0?$CFd?$AA@
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_sscanf

; 425  : 	return V;

	mov	rax, rbx

; 426  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?r_ivector2@CInifile@@QEAA?AU?$_vector2@H@@PEBD0@Z ENDP	; CInifile::r_ivector2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
S$ = 80
L$ = 88
?r_ivector3@CInifile@@QEAA?AU?$_vector3@H@@PEBD0@Z PROC	; CInifile::r_ivector3

; 428  : {

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, r8
	mov	rbx, rdx

; 429  : 	LPCSTR		C = r_string(S,L);

	mov	r8, r9
	mov	rdx, rax
	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 430  : 	Ivector		V={0,0,0};

	xor	edx, edx
	lea	rcx, QWORD PTR [rbx+8]
	mov	DWORD PTR [rcx], edx
	lea	r9, QWORD PTR [rbx+4]
	mov	DWORD PTR [rbx], edx
	mov	DWORD PTR [r9], edx

; 431  : 	sscanf		(C,"%d,%d,%d",&V.x,&V.y,&V.z);

	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:??_C@_08GDAMKODC@?$CFd?0?$CFd?0?$CFd?$AA@
	mov	r8, rbx
	mov	rcx, rax
	call	QWORD PTR __imp_sscanf

; 432  : 	return V;

	mov	rax, rbx

; 433  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?r_ivector3@CInifile@@QEAA?AU?$_vector3@H@@PEBD0@Z ENDP	; CInifile::r_ivector3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
S$ = 80
L$ = 88
?r_ivector4@CInifile@@QEAA?AU?$_vector4@H@@PEBD0@Z PROC	; CInifile::r_ivector4

; 435  : {

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, r8
	mov	rbx, rdx

; 436  : 	LPCSTR		C = r_string(S,L);

	mov	r8, r9
	mov	rdx, rax
	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 437  : 	Ivector4	V={0,0,0,0};

	xor	edx, edx
	lea	r8, QWORD PTR [rbx+8]
	lea	rcx, QWORD PTR [rbx+12]
	mov	DWORD PTR [r8], edx
	lea	r9, QWORD PTR [rbx+4]
	mov	DWORD PTR [rcx], edx

; 438  : 	sscanf		(C,"%d,%d,%d,%d",&V.x,&V.y,&V.z,&V.w);

	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [r9], edx
	mov	DWORD PTR [rbx], edx
	mov	QWORD PTR [rsp+32], r8
	lea	rdx, OFFSET FLAT:??_C@_0M@MLCONGPP@?$CFd?0?$CFd?0?$CFd?0?$CFd?$AA@
	mov	r8, rbx
	mov	rcx, rax
	call	QWORD PTR __imp_sscanf

; 439  : 	return V;

	mov	rax, rbx

; 440  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?r_ivector4@CInifile@@QEAA?AU?$_vector4@H@@PEBD0@Z ENDP	; CInifile::r_ivector4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
S$ = 64
L$ = 72
?r_fvector2@CInifile@@QEAA?AU?$_vector2@M@@PEBD0@Z PROC	; CInifile::r_fvector2

; 442  : {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx

; 443  : 	LPCSTR		C = r_string(S,L);

	mov	r8, r9
	mov	rdx, rax
	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 444  : 	Fvector2	V={0.f,0.f};

	xor	ecx, ecx
	lea	r9, QWORD PTR [rbx+4]
	mov	DWORD PTR [rbx], ecx
	mov	DWORD PTR [r9], ecx

; 445  : 	sscanf		(C,"%f,%f",&V.x,&V.y);

	lea	rdx, OFFSET FLAT:??_C@_05OIOLBAJI@?$CFf?0?$CFf?$AA@
	mov	rcx, rax
	mov	r8, rbx
	call	QWORD PTR __imp_sscanf

; 446  : 	return V;

	mov	rax, rbx

; 447  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?r_fvector2@CInifile@@QEAA?AU?$_vector2@M@@PEBD0@Z ENDP	; CInifile::r_fvector2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
S$ = 80
L$ = 88
?r_fvector3@CInifile@@QEAA?AU?$_vector3@M@@PEBD0@Z PROC	; CInifile::r_fvector3

; 449  : {

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, r8
	mov	rbx, rdx

; 450  : 	LPCSTR		C = r_string(S,L);

	mov	r8, r9
	mov	rdx, rax
	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 451  : 	Fvector3	V={0.f,0.f,0.f};

	xor	edx, edx
	lea	rcx, QWORD PTR [rbx+8]
	mov	DWORD PTR [rcx], edx
	lea	r9, QWORD PTR [rbx+4]
	mov	DWORD PTR [rbx], edx
	mov	DWORD PTR [r9], edx

; 452  : 	sscanf		(C,"%f,%f,%f",&V.x,&V.y,&V.z);

	mov	QWORD PTR [rsp+32], rcx
	lea	rdx, OFFSET FLAT:??_C@_08GJNPJIKN@?$CFf?0?$CFf?0?$CFf?$AA@
	mov	r8, rbx
	mov	rcx, rax
	call	QWORD PTR __imp_sscanf

; 453  : 	return V;

	mov	rax, rbx

; 454  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?r_fvector3@CInifile@@QEAA?AU?$_vector3@M@@PEBD0@Z ENDP	; CInifile::r_fvector3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
S$ = 80
L$ = 88
?r_fvector4@CInifile@@QEAA?AU?$_vector4@M@@PEBD0@Z PROC	; CInifile::r_fvector4

; 456  : {

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rax, r8
	mov	rbx, rdx

; 457  : 	LPCSTR		C = r_string(S,L);

	mov	r8, r9
	mov	rdx, rax
	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 458  : 	Fvector4	V={0.f,0.f,0.f,0.f};

	xor	edx, edx
	lea	r8, QWORD PTR [rbx+8]
	lea	rcx, QWORD PTR [rbx+12]
	mov	DWORD PTR [r8], edx
	lea	r9, QWORD PTR [rbx+4]
	mov	DWORD PTR [rcx], edx

; 459  : 	sscanf		(C,"%f,%f,%f,%f",&V.x,&V.y,&V.z,&V.w);

	mov	QWORD PTR [rsp+40], rcx
	mov	DWORD PTR [r9], edx
	mov	DWORD PTR [rbx], edx
	mov	QWORD PTR [rsp+32], r8
	lea	rdx, OFFSET FLAT:??_C@_0M@JJJBFJKB@?$CFf?0?$CFf?0?$CFf?0?$CFf?$AA@
	mov	r8, rbx
	mov	rcx, rax
	call	QWORD PTR __imp_sscanf

; 460  : 	return V;

	mov	rax, rbx

; 461  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?r_fvector4@CInifile@@QEAA?AU?$_vector4@M@@PEBD0@Z ENDP	; CInifile::r_fvector4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
B$ = 72
?r_bool@CInifile@@QEAAHPEBD0@Z PROC			; CInifile::r_bool

; 463  : {

$LN24:
	sub	rsp, 40					; 00000028H

; 464  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 465  : 	char		B[8];
; 466  : 	strncpy		(B,C,7);

	lea	rcx, QWORD PTR B$[rsp]
	mov	r8d, 7
	mov	rdx, rax
	call	QWORD PTR __imp_strncpy

; 467  : 	strlwr		(B);

	lea	rcx, QWORD PTR B$[rsp]
	call	QWORD PTR __imp_strlwr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	movzx	eax, BYTE PTR B$[rsp]
	movzx	edx, BYTE PTR B$[rsp+1]
	cmp	al, BYTE PTR ??_C@_02LIELOMNJ@on?$AA@
	jne	SHORT $LN22@r_bool
	cmp	dl, BYTE PTR ??_C@_02LIELOMNJ@on?$AA@+1
	jne	SHORT $LN22@r_bool
	movzx	eax, BYTE PTR B$[rsp+2]
	cmp	al, BYTE PTR ??_C@_02LIELOMNJ@on?$AA@+2
	je	SHORT $LN5@r_bool
$LN22@r_bool:
	xor	ecx, ecx
	lea	r8, QWORD PTR B$[rsp]
	lea	r9, OFFSET FLAT:??_C@_03ICICOMAL@yes?$AA@
	npad	3
$LL20@r_bool:
	movzx	eax, BYTE PTR [r8+rcx]
	inc	rcx
	cmp	al, BYTE PTR [r9+rcx-1]
	jne	SHORT $LN21@r_bool
	cmp	rcx, 4
	jne	SHORT $LL20@r_bool
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 468  :     return 		IsBOOL(B);

	mov	eax, 1

; 469  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN21@r_bool:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	xor	eax, eax
	lea	r8, QWORD PTR B$[rsp]
	lea	r9, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
	npad	3
$LL17@r_bool:
	movzx	ecx, BYTE PTR [r8+rax]
	inc	rax
	cmp	cl, BYTE PTR [r9+rax-1]
	jne	SHORT $LN18@r_bool
	cmp	rax, 5
	jne	SHORT $LL17@r_bool
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 468  :     return 		IsBOOL(B);

	mov	eax, 1

; 469  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN18@r_bool:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	movzx	eax, BYTE PTR B$[rsp]
	cmp	al, BYTE PTR ??_C@_01HIHLOKLC@1?$AA@
	jne	SHORT $LN15@r_bool
	cmp	dl, BYTE PTR ??_C@_01HIHLOKLC@1?$AA@+1
	jne	SHORT $LN15@r_bool
$LN5@r_bool:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 468  :     return 		IsBOOL(B);

	mov	eax, 1

; 469  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN15@r_bool:

; 468  :     return 		IsBOOL(B);

	xor	eax, eax

; 469  : }

	add	rsp, 40					; 00000028H
	ret	0
?r_bool@CInifile@@QEAAHPEBD0@Z ENDP			; CInifile::r_bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
szFileName$ = 64
ReadOnly$ = 72
?Create@CInifile@@SAPEAV1@PEBDH@Z PROC			; CInifile::Create

; 9    : {	return xr_new<CInifile>(szFileName,ReadOnly); }

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	ebx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 48					; 00000030H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 81   : 	return new (ptr) T(p1,p2);

	test	rax, rax
	je	SHORT $LN5@Create
	mov	r9d, 1
	mov	r8d, ebx
	mov	rdx, rdi
	mov	rcx, rax
	mov	DWORD PTR [rsp+32], 1
	call	??0CInifile@@QEAA@PEBDHHH@Z		; CInifile::CInifile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 9    : {	return xr_new<CInifile>(szFileName,ReadOnly); }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN5@Create:
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?Create@CInifile@@SAPEAV1@PEBDH@Z ENDP			; CInifile::Create
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
ini$ = 48
?Destroy@CInifile@@SAXPEAV1@@Z PROC			; CInifile::Destroy

; 12   : {	xr_delete(ini); }

$LN4:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H
	lea	rcx, QWORD PTR ini$[rsp]
	call	??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z ; xr_delete<CInifile>
	add	rsp, 40					; 00000028H
	ret	0
?Destroy@CInifile@@SAXPEAV1@@Z ENDP			; CInifile::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
x$ = 8
val$ = 16
?sect_pred@@YA_NPEBUSect@CInifile@@PEBD@Z PROC		; sect_pred
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rcx]
	xor	r9d, r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 15   : {

	mov	r8, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	rax, rax
	je	SHORT $LN5@sect_pred
	add	rax, 12
	jmp	SHORT $LN6@sect_pred
$LN5@sect_pred:
	mov	rax, r9
$LN6@sect_pred:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	sub	r8, rax
	npad	6
$LL9@sect_pred:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN10@sect_pred
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL9@sect_pred
$LN10@sect_pred:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	test	edx, edx
	sets	al

; 17   : };

	ret	0
?sect_pred@@YA_NPEBUSect@CInifile@@PEBD@Z ENDP		; sect_pred
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
x$ = 48
val$ = 56
?item_pred@@YA_NAEBUItem@CInifile@@PEBD@Z PROC		; item_pred

; 20   : {

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	mov	rax, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 20   : {

	mov	r8, rdx
	mov	rbx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	test	rax, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 21   :     if ((!x.first) || (!val))	return x.first<val;

	je	SHORT $LN2@item_pred
	test	rdx, rdx
	je	SHORT $LN2@item_pred
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	add	rax, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	sub	r8, rax
$LL35@item_pred:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN36@item_pred
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL35@item_pred
$LN36@item_pred:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 22   :     else				   		return xr_strcmp(*x.first,val)<0;

	xor	eax, eax
	test	edx, edx
	sets	al

; 23   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@item_pred:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN13@item_pred
	inc	DWORD PTR [rax]
$LN13@item_pred:

; 67   : 	char				operator[]	(size_t id)						{	return p_->value[id];							}
; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}
; 69   : 
; 70   : 	// misc func
; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}
; 72   : 	void				swap		(shared_str & rhs)				{	str_value* tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}
; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}
; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}
; 94   : IC bool operator	!=	(shared_str const & a, shared_str const & b)		{ return a._get() != b._get();					}
; 95   : IC bool operator	<	(shared_str const & a, shared_str const & b)		{ return a._get() <  b._get();					}

	cmp	QWORD PTR [rbx], rax
	setb	cl

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rax, rax
	je	SHORT $LN25@item_pred
	dec	DWORD PTR [rax]
$LN25@item_pred:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 21   :     if ((!x.first) || (!val))	return x.first<val;

	movzx	eax, cl

; 23   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?item_pred@@YA_NAEBUItem@CInifile@@PEBD@Z ENDP		; item_pred
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
dest$ = 48
src$ = 56
?_parse@@YAXPEADPEBD@Z PROC				; _parse

; 29   : {

$LN32:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, rcx

; 30   : 	if (src) {

	test	rdx, rdx
	je	$LN27@parse

; 31   : 		BOOL bInsideSTR = false;
; 32   : 		while (*src) {

	movzx	eax, BYTE PTR [rdx]
	mov	QWORD PTR [rsp+48], rsi
	xor	esi, esi
	test	al, al
	je	SHORT $LN26@parse
$LL8@parse:

; 33   : 			if (isspace((u8)*src)) {

	movzx	ecx, al
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN6@parse

; 34   : 				if (bInsideSTR) { *dest++ = *src++; continue; }

	movzx	eax, BYTE PTR [rbx]
	test	esi, esi
	je	SHORT $LN15@parse
	mov	BYTE PTR [rdi], al
	jmp	SHORT $LN30@parse
$LN15@parse:

; 35   : 				while (*src && isspace(*src)) src++;

	test	al, al
	je	SHORT $LN28@parse
$LL4@parse:
	movsx	ecx, al
	call	QWORD PTR __imp_isspace
	test	eax, eax
	je	SHORT $LN17@parse
	movzx	eax, BYTE PTR [rbx+1]
	inc	rbx
	test	al, al
	jne	SHORT $LL4@parse

; 41   : 		}
; 42   : 	}
; 43   : 	*dest = 0;

	mov	BYTE PTR [rdi], al
	mov	rsi, QWORD PTR [rsp+48]

; 44   : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN6@parse:

; 36   : 				continue;
; 37   : 			} else if (*src=='"') {

	movzx	ecx, BYTE PTR [rbx]
	cmp	cl, 34					; 00000022H
	jne	SHORT $LN1@parse

; 38   : 				bInsideSTR = !bInsideSTR;

	xor	eax, eax
	test	esi, esi
	sete	al
	mov	esi, eax
$LN1@parse:

; 39   : 			}
; 40   : 			*dest++ = *src++;

	mov	BYTE PTR [rdi], cl
$LN30@parse:
	inc	rdi
	inc	rbx
$LN17@parse:

; 31   : 		BOOL bInsideSTR = false;
; 32   : 		while (*src) {

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	jne	SHORT $LL8@parse
$LN28@parse:

; 41   : 		}
; 42   : 	}
; 43   : 	*dest = 0;

	mov	BYTE PTR [rdi], 0
	mov	rsi, QWORD PTR [rsp+48]

; 44   : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN26@parse:

; 41   : 		}
; 42   : 	}
; 43   : 	*dest = 0;

	mov	BYTE PTR [rcx], sil
	mov	rsi, QWORD PTR [rsp+48]

; 44   : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN27@parse:

; 41   : 		}
; 42   : 	}
; 43   : 	*dest = 0;

	mov	BYTE PTR [rcx], 0

; 44   : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_parse@@YAXPEADPEBD@Z ENDP				; _parse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
dest$ = 8
src$ = 16
?_decorate@@YAXPEADPEBD@Z PROC				; _decorate

; 48   : 	if (src) {

	test	rdx, rdx
	je	SHORT $LN17@decorate

; 49   : 		BOOL bInsideSTR = false;
; 50   : 		while (*src) {

	movzx	r8d, BYTE PTR [rdx]
	xor	r9d, r9d
	test	r8b, r8b
	je	SHORT $LN16@decorate
$LL7@decorate:

; 51   : 			if (*src == ',') {

	cmp	r8b, 44					; 0000002cH
	jne	SHORT $LN5@decorate

; 52   : 				if (bInsideSTR) { *dest++ = *src++; }

	test	r9d, r9d
	je	SHORT $LN4@decorate
	mov	BYTE PTR [rcx], r8b
	jmp	SHORT $LN18@decorate
$LN4@decorate:

; 53   : 				else			{ *dest++ = *src++; *dest++ = ' '; }

	mov	WORD PTR [rcx], 8236			; 0000202cH
	inc	rdx
	add	rcx, 2

; 54   : 				continue;

	jmp	SHORT $LN13@decorate
$LN5@decorate:

; 55   : 			} else if (*src=='"') {

	cmp	r8b, 34					; 00000022H
	jne	SHORT $LN1@decorate

; 56   : 				bInsideSTR = !bInsideSTR;

	xor	eax, eax
	test	r9d, r9d
	sete	al
	mov	r9d, eax
$LN1@decorate:

; 57   : 			}
; 58   : 			*dest++ = *src++;

	mov	BYTE PTR [rcx], r8b
$LN18@decorate:
	inc	rcx
	inc	rdx
$LN13@decorate:

; 49   : 		BOOL bInsideSTR = false;
; 50   : 		while (*src) {

	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	jne	SHORT $LL7@decorate
$LN17@decorate:

; 59   : 		}
; 60   : 	}
; 61   : 	*dest = 0;

	mov	BYTE PTR [rcx], 0

; 62   : }

	ret	0
$LN16@decorate:

; 59   : 		}
; 60   : 	}
; 61   : 	*dest = 0;

	mov	BYTE PTR [rcx], r9b

; 62   : }

	ret	0
?_decorate@@YAXPEADPEBD@Z ENDP				; _decorate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 64
L$ = 72
val$ = 80
?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z PROC	; CInifile::Sect::line_exist

; 66   : {

$LN137:
	push	rsi
	push	r12
	push	r14
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	r14, QWORD PTR [rcx+8]
	mov	QWORD PTR [rsp+64], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rbx, QWORD PTR [rcx+16]
	sub	rbx, r14
	mov	QWORD PTR [rsp+88], r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 66   : {

	mov	r12, r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sar	rbx, 4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 66   : {

	mov	rsi, rdx
	mov	r15, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jle	$LN35@line_exist
	mov	QWORD PTR [rsp+72], rbp
	mov	QWORD PTR [rsp+80], rdi
	npad	1
$LL36@line_exist:

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rbp, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	add	rdi, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	mov	rcx, QWORD PTR [r14+rdi*8]
	test	rcx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 21   :     if ((!x.first) || (!val))	return x.first<val;

	je	SHORT $LN52@line_exist
	test	rsi, rsi
	je	SHORT $LN52@line_exist
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	add	rcx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rsi
	sub	r8, rcx
	npad	4
$LL134@line_exist:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN135@line_exist
	inc	rcx
	test	eax, eax
	jne	SHORT $LL134@line_exist
$LN135@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 22   :     else				   		return xr_strcmp(*x.first,val)<0;

	test	edx, edx
	sets	cl
	jmp	SHORT $LN75@line_exist
$LN52@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	mov	rdx, rsi
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN63@line_exist
	inc	DWORD PTR [rax]
$LN63@line_exist:

; 67   : 	char				operator[]	(size_t id)						{	return p_->value[id];							}
; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}
; 69   : 
; 70   : 	// misc func
; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}
; 72   : 	void				swap		(shared_str & rhs)				{	str_value* tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}
; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}
; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}
; 94   : IC bool operator	!=	(shared_str const & a, shared_str const & b)		{ return a._get() != b._get();					}
; 95   : IC bool operator	<	(shared_str const & a, shared_str const & b)		{ return a._get() <  b._get();					}

	cmp	QWORD PTR [r14+rdi*8], rax
	setb	cl

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rax, rax
	je	SHORT $LN75@line_exist
	dec	DWORD PTR [rax]
$LN75@line_exist:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	test	cl, cl
	je	SHORT $LN34@line_exist

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	r14, QWORD PTR [r14+rdi*8]
	sub	rax, rbp
	add	r14, 16
	add	rbx, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN33@line_exist
$LN34@line_exist:

; 2521 : 			_Count = _Count2;

	mov	rbx, rbp
$LN33@line_exist:

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jg	$LL36@line_exist
	mov	rdi, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
$LN35@line_exist:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r14, QWORD PTR [r15+16]
	mov	rbx, QWORD PTR [rsp+64]
	mov	r15, QWORD PTR [rsp+88]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 68   :     if (A!=Data.end() && xr_strcmp(*A->first,L)==0){

	je	SHORT $LN2@line_exist
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [r14]
	xor	r8d, r8d
	test	rax, rax
	je	SHORT $LN113@line_exist
	add	rax, 12
	jmp	SHORT $LN114@line_exist
$LN113@line_exist:
	mov	rax, r8
$LN114@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	sub	rsi, rax
$LL132@line_exist:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rsi]
	sub	edx, ecx
	jne	SHORT $LN133@line_exist
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL132@line_exist
$LN133@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 68   :     if (A!=Data.end() && xr_strcmp(*A->first,L)==0){

	test	edx, edx
	jne	SHORT $LN2@line_exist

; 69   :     	if (val) *val = *A->second;

	test	r12, r12
	je	SHORT $LN1@line_exist
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [r14+8]
	test	rax, rax
	je	SHORT $LN127@line_exist
	lea	r8, QWORD PTR [rax+12]
$LN127@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 69   :     	if (val) *val = *A->second;

	mov	QWORD PTR [r12], r8
$LN1@line_exist:

; 70   :     	return TRUE;

	mov	eax, 1

; 73   : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	r12
	pop	rsi
	ret	0
$LN2@line_exist:

; 71   :     }
; 72   : 	return FALSE;

	xor	eax, eax

; 73   : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	r12
	pop	rsi
	ret	0
?line_exist@Sect@CInifile@@QEAAHPEBDPEAPEBD@Z ENDP	; CInifile::Sect::line_exist
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
F$ = 56
path$ = 64
??0CInifile@@QEAA@PEAVIReader@@PEBD@Z PROC		; CInifile::CInifile

; 77   : {

$LN14:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7CInifile@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+24], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+32], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 78   : 	fName		= 0;

	mov	QWORD PTR [rcx+8], rax

; 79   : 	bReadOnly	= TRUE;

	mov	QWORD PTR [rcx+40], 1

; 80   : 	bSaveAtEnd	= FALSE;
; 81   : 	Load		(F,path);

	call	?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z ; CInifile::Load

; 82   : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0CInifile@@QEAA@PEAVIReader@@PEBD@Z ENDP		; CInifile::CInifile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_flags.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
path$1 = 48
folder$2 = 576
this$ = 1136
szFileName$ = 1144
ReadOnly$ = 1152
bLoad$ = 1160
SaveAtEnd$ = 1168
??0CInifile@@QEAA@PEBDHHH@Z PROC			; CInifile::CInifile

; 85   : {

$LN70:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbp
	push	rsi
	push	rdi
	push	r12
	sub	rsp, 1104				; 00000450H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	r12d, r12d
	mov	QWORD PTR [rax+8], r14
	mov	QWORD PTR [rax+16], r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 85   : {

	lea	rax, OFFSET FLAT:??_7CInifile@@6B@
	mov	r14d, r9d
	mov	r15d, r8d
	mov	QWORD PTR [rcx], rax
	mov	rsi, rdx
	mov	rdi, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx+16], r12

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+24], r12

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+32], r12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 86   : 	fName		= szFileName?xr_strdup(szFileName):0;

	test	rdx, rdx
	je	SHORT $LN5@CInifile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
	npad	4
$LL65@CInifile:
	inc	rax
	cmp	BYTE PTR [rdx+rax], r12b
	jne	SHORT $LL65@CInifile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.cpp

; 271  : 	);

	inc	eax
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, eax
	mov	ebx, eax
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 272  : 	CopyMemory		(memory,string,len);

	mov	r8d, ebx
	mov	rdx, rsi
	mov	rcx, rax
	mov	rbp, rax
	call	memcpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 86   : 	fName		= szFileName?xr_strdup(szFileName):0;

	jmp	SHORT $LN6@CInifile
$LN5@CInifile:
	mov	rbp, r12
$LN6@CInifile:

; 87   :     bReadOnly	= ReadOnly;
; 88   :     bSaveAtEnd	= SaveAtEnd;

	mov	eax, DWORD PTR SaveAtEnd$[rsp]
	mov	DWORD PTR [rdi+40], r15d
	mov	r15, QWORD PTR [rsp+1144]

; 89   : 	if (bLoad)

	test	r14d, r14d
	mov	r14, QWORD PTR [rsp+1136]
	mov	DWORD PTR [rdi+44], eax
	mov	QWORD PTR [rdi+8], rbp
	je	$LN67@CInifile

; 90   : 	{	
; 91   :     	string_path	path,folder; 
; 92   : 		_splitpath	(fName, path, folder, 0, 0 );

	lea	r8, QWORD PTR folder$2[rsp]
	lea	rdx, QWORD PTR path$1[rsp]
	xor	r9d, r9d
	mov	rcx, rbp
	mov	QWORD PTR [rsp+32], r12
	call	QWORD PTR __imp__splitpath

; 93   :         strcat		(path,folder);

	lea	rcx, QWORD PTR path$1[rsp]
	dec	rcx
$LL63@CInifile:
	cmp	BYTE PTR [rcx+1], r12b
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL63@CInifile
	lea	r8, QWORD PTR folder$2[rsp]
	xor	edx, edx
	npad	10
$LL64@CInifile:
	movzx	eax, BYTE PTR [r8+rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rcx+rdx-1], al
	test	al, al
	jne	SHORT $LL64@CInifile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp

; 1181 : 	return					(r_open_impl<IReader>(path,_fname));

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	mov	r8, rsi
	xor	edx, edx
	call	??$r_open_impl@VIReader@@@CLocatorAPI@@AEAAPEAVIReader@@PEBD0@Z ; CLocatorAPI::r_open_impl<IReader>
	mov	rsi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 95   :         if (R){

	test	rax, rax
	je	$LN67@CInifile

; 96   : 			Load		(R,path);

	lea	r8, QWORD PTR path$1[rsp]
	mov	rdx, rax
	mov	rcx, rdi
	call	?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z ; CInifile::Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_flags.h

; 25   : 	IC 	BOOL	test	(const T mask)						const	{ return BOOL(flags&mask);				}

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	test	DWORD PTR [rcx+112], 512		; 00000200H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp

; 1186 : 	if( m_Flags.test(flDumpFileActivity) )

	je	SHORT $LN28@CInifile

; 1187 : 		_unregister_open_file	(fs);

	mov	rcx, rsi
	call	??$_unregister_open_file@VIReader@@@@YAXPEAVIReader@@@Z ; _unregister_open_file<IReader>
$LN28@CInifile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	rcx, rsi
	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	r8, QWORD PTR [rsi]
	xor	edx, edx
	mov	rcx, rsi
	mov	rbx, rax
	call	QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rbx-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rsi, QWORD PTR [rbx-1]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN40@CInifile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rsi, rsi
	je	SHORT $LN67@CInifile

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rsi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rsi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN67@CInifile
$LN40@CInifile:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rsi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN67@CInifile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 100  : }

	lea	r11, QWORD PTR [rsp+1104]
	mov	rax, rdi
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??0CInifile@@QEAA@PEBDHHH@Z ENDP			; CInifile::CInifile
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
$T1 = 96
tgt$ = 96
I$ = 104
?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z PROC	; insert_item

; 118  : {

	push	rdi
	push	r12
	push	r15
	sub	rsp, 64					; 00000040H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rsp+104], rbx
	mov	QWORD PTR [rsp+56], r13
	mov	QWORD PTR [rsp+48], r14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 118  : {

	mov	r15, rdx
	mov	r13, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	rax, rax
	je	SHORT $LN7@insert_ite
	lea	r14, QWORD PTR [rax+12]
	jmp	SHORT $LN8@insert_ite
$LN7@insert_ite:
	xor	r14d, r14d
$LN8@insert_ite:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	rdi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rbx, QWORD PTR [rcx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 119  : 	CInifile::SectIt_	sect_it		= std::lower_bound(tgt->Data.begin(),tgt->Data.end(),*I.first,item_pred);

	lea	r12, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	rbx, rdi
	sar	rbx, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jle	$LN39@insert_ite
	mov	QWORD PTR [rsp+112], rbp
	mov	QWORD PTR [rsp+120], rsi
	npad	10
$LL40@insert_ite:

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	mov	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rbp, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	add	rsi, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	mov	rcx, QWORD PTR [rdi+rsi*8]
	test	rcx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 21   :     if ((!x.first) || (!val))	return x.first<val;

	je	SHORT $LN56@insert_ite
	test	r14, r14
	je	SHORT $LN56@insert_ite
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	add	rcx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, r14
	sub	r8, rcx
	npad	4
$LL143@insert_ite:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN144@insert_ite
	inc	rcx
	test	eax, eax
	jne	SHORT $LL143@insert_ite
$LN144@insert_ite:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 22   :     else				   		return xr_strcmp(*x.first,val)<0;

	test	edx, edx
	sets	cl
	jmp	SHORT $LN79@insert_ite
$LN56@insert_ite:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	mov	rdx, r14
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN67@insert_ite
	inc	DWORD PTR [rax]
$LN67@insert_ite:

; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}
; 94   : IC bool operator	!=	(shared_str const & a, shared_str const & b)		{ return a._get() != b._get();					}
; 95   : IC bool operator	<	(shared_str const & a, shared_str const & b)		{ return a._get() <  b._get();					}

	cmp	QWORD PTR [rdi+rsi*8], rax
	setb	cl

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rax, rax
	je	SHORT $LN79@insert_ite
	dec	DWORD PTR [rax]
$LN79@insert_ite:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	test	cl, cl
	je	SHORT $LN38@insert_ite

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	rdi, QWORD PTR [rdi+rsi*8]
	sub	rax, rbp
	add	rdi, 16
	add	rbx, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN37@insert_ite
$LN38@insert_ite:

; 2521 : 			_Count = _Count2;

	mov	rbx, rbp
$LN37@insert_ite:

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jg	$LL40@insert_ite
	mov	rsi, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+112]
$LN39@insert_ite:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rdi, QWORD PTR [r13+16]
	mov	r14, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+104]
	mov	r13, QWORD PTR [rsp+56]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 120  : 	if (sect_it!=tgt->Data.end() && sect_it->first.equal(I.first)){ 

	je	SHORT $LN2@insert_ite
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}

	mov	rax, QWORD PTR [r15]
	cmp	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 120  : 	if (sect_it!=tgt->Data.end() && sect_it->first.equal(I.first)){ 

	jne	SHORT $LN2@insert_ite
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rcx, QWORD PTR [r15+8]
	test	rcx, rcx
	je	SHORT $LN131@insert_ite
	inc	DWORD PTR [rcx]
$LN131@insert_ite:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN134@insert_ite
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rdi+8]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN134@insert_ite
	mov	QWORD PTR [rdi+8], 0
$LN134@insert_ite:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rdi+8], rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 128  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
$LN2@insert_ite:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	lea	rdx, QWORD PTR $T1[rsp]
	mov	r8, rdi
	mov	rcx, r12
	mov	QWORD PTR [rsp+32], r15
	call	?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 128  : }

	add	rsp, 64					; 00000040H
	pop	r15
	pop	r12
	pop	rdi
	ret	0
?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z ENDP	; insert_item
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_flags.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
tv2881 = 80
Current$1$ = 80
tmp$1 = 88
Current$ = 120
I$2 = 128
cnt$1$ = 144
inherited_names$1$ = 152
inc_name$3 = 160
$T4 = 224
fn$5 = 240
str$ = 768
inc_path$6 = 4864
folder$7 = 5392
str2$ = 5920
this$ = 10064
tv2871 = 10072
$T8 = 10072
F$ = 10072
path$ = 10080
tv2880 = 10088
tv2872 = 10088
k$1$ = 10088
?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z PROC		; CInifile::Load

; 131  : {

$LN871:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rbx
	push	rsi
	lea	rbp, QWORD PTR [rsp-9776]
	mov	eax, 10032				; 00002730H
	call	__chkstk
	sub	rsp, rax

; 132  : 	R_ASSERT(F);

	xor	ebx, ebx
	lea	rcx, OFFSET FLAT:??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@
	lea	r8, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	cmp	BYTE PTR ?ignore_always@?3??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA, bl
	jne	SHORT $LN48@Load
	test	rdx, rdx
	jne	SHORT $LN48@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	xor	r9d, r9d
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], rcx
	mov	DWORD PTR [rsp+48], 132			; 00000084H
	mov	QWORD PTR [rsp+40], r8
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	lea	r8, OFFSET FLAT:??_C@_01BIAFAFID@F?$AA@
	mov	QWORD PTR [rsp+32], rbx
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
	mov	rdx, QWORD PTR F$[rbp-256]
$LN48@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, DWORD PTR [rdx+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 133  : 	Sect		*Current = 0;

	mov	rsi, rbx
	mov	QWORD PTR Current$1$[rsp], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	sub	eax, DWORD PTR [rdx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 133  : 	Sect		*Current = 0;

	mov	QWORD PTR Current$[rsp], rbx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 137  : 	while (!F->eof())

	jle	$LN770@Load
	mov	QWORD PTR [rsp+10024], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	lea	r8, OFFSET FLAT:?ignore_always@?3??r_string@IReader@@QEAAXPEADI@Z@4_NA
	lea	r10, OFFSET FLAT:??_C@_0BC@LFPNBCKC@IReader?3?3r_string?$AA@
	npad	4
$LL45@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 347  : 	char *src 	= (char *) data+Pos;

	movsxd	rcx, DWORD PTR [rdx+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	r9d, DWORD PTR [rdx+20]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 347  : 	char *src 	= (char *) data+Pos;

	mov	r11, QWORD PTR [rdx+8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 347  : 	char *src 	= (char *) data+Pos;

	lea	rdi, QWORD PTR [r11+rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	sub	eax, ecx

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 335  : 	while (!eof()) {

	jle	$LN839@Load
	npad	3
$LL70@Load:

; 336  :         Pos++;

	inc	DWORD PTR [rdx+16]
	movsxd	rcx, DWORD PTR [rdx+16]

; 337  :         sz++;

	inc	ebx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	edx, ecx
	neg	edx
	lea	eax, DWORD PTR [rdx+r9]

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 338  : 		if (!eof()&&is_term(src[Pos])) {

	jle	SHORT $LN68@Load
	movzx	r8d, BYTE PTR [rcx+r11]

; 330  : IC BOOL			is_term		(char a) { return (a==13)||(a==10); };

	cmp	r8b, 13
	je	SHORT $LN774@Load
	cmp	r8b, 10
	je	SHORT $LN774@Load
$LN68@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	lea	eax, DWORD PTR [rdx+r9]

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 335  : 	while (!eof()) {

	jle	SHORT $LN866@Load
	mov	rdx, QWORD PTR F$[rbp-256]
	jmp	SHORT $LL70@Load
$LN774@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, r9d
	sub	eax, ecx

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 339  :         	while(!eof()&&is_term(src[Pos])) Pos++;

	jle	SHORT $LN866@Load
	mov	r8, QWORD PTR F$[rbp-256]
	npad	9
$LL67@Load:
	movsxd	rax, ecx
	movzx	edx, BYTE PTR [rax+r11]

; 330  : IC BOOL			is_term		(char a) { return (a==13)||(a==10); };

	cmp	dl, 13
	je	SHORT $LN97@Load
	cmp	dl, 10
	jne	SHORT $LN866@Load
$LN97@Load:

; 339  :         	while(!eof()&&is_term(src[Pos])) Pos++;

	inc	ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, r9d
	sub	eax, ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 339  :         	while(!eof()&&is_term(src[Pos])) Pos++;

	mov	DWORD PTR [r8+16], ecx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 339  :         	while(!eof()&&is_term(src[Pos])) Pos++;

	jg	SHORT $LL67@Load
$LN866@Load:
	lea	r8, OFFSET FLAT:?ignore_always@?3??r_string@IReader@@QEAAXPEADI@Z@4_NA
	lea	r10, OFFSET FLAT:??_C@_0BC@LFPNBCKC@IReader?3?3r_string?$AA@
$LN839@Load:

; 348  : 	u32 sz 		= advance_term_string();
; 349  :     R_ASSERT2(sz<(tgt_sz-1),"Dest string less than needed.");

	cmp	BYTE PTR ?ignore_always@?3??r_string@IReader@@QEAAXPEADI@Z@4_NA, 0
	jne	SHORT $LN62@Load
	cmp	ebx, 4095				; 00000fffH
	jb	SHORT $LN62@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 462  : 	backend		(e1,e2,0,0,file,line,function,ignore_always);

	mov	QWORD PTR [rsp+64], r8
	mov	QWORD PTR [rsp+56], r10
	lea	rax, OFFSET FLAT:??_C@_06ODPOMCLF@FS?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 349			; 0000015dH
	mov	QWORD PTR [rsp+40], rax
	lea	r8, OFFSET FLAT:??_C@_0BO@CBOGAODA@Dest?5string?5less?5than?5needed?4?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0O@CCNJDAAG@sz?$DM?$CItgt_sz?91?$CJ?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN62@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.cpp

; 350  :     strncpy		(dest,src,sz);

	mov	ebx, ebx
	lea	rcx, QWORD PTR str$[rbp-256]
	mov	rdx, rdi
	mov	r8d, ebx
	call	QWORD PTR __imp_strncpy

; 351  :     dest[sz]	= 0;

	mov	BYTE PTR str$[rbp+rbx-256], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 7    : 	while( *p && (u8(*p)<=u8(' ')) ) p++;

	movzx	ecx, BYTE PTR str$[rbp-256]
	lea	rax, QWORD PTR str$[rbp-256]
	test	cl, cl
	je	SHORT $LN106@Load
$LL108@Load:
	cmp	cl, 32					; 00000020H
	ja	SHORT $LN107@Load
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL108@Load
$LN107@Load:

; 8    :     if (p!=str){

	lea	rcx, QWORD PTR str$[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN106@Load

; 9    :         for (LPSTR t=str; *p; t++,p++) *t=*p;

	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR str$[rbp-256]
	test	dl, dl
	je	SHORT $LN103@Load
	lea	r8, QWORD PTR str$[rbp-256]
	sub	rax, r8
	npad	9
$LL105@Load:
	mov	BYTE PTR [rcx], dl
	movzx	edx, BYTE PTR [rcx+rax+1]
	inc	rcx
	test	dl, dl
	jne	SHORT $LL105@Load
$LN103@Load:

; 10   :         *t = 0;

	mov	BYTE PTR [rcx], 0
$LN106@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR str$[rbp-256]
	or	rax, -1
	npad	4
$LL852@Load:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL852@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 17   : 	LPSTR p 	= str+xr_strlen(str);

	mov	eax, eax
	lea	rcx, QWORD PTR str$[rbp-256]
	add	rcx, rax

; 18   : 	while( (p!=str) && (u8(*p)<=u8(' ')) ) p--;

	lea	rax, QWORD PTR str$[rbp-256]
	cmp	rcx, rax
	je	SHORT $LN855@Load
$LL112@Load:
	cmp	BYTE PTR [rcx], 32			; 00000020H
	ja	SHORT $LN855@Load
	lea	rax, QWORD PTR str$[rbp-256]
	dec	rcx
	cmp	rcx, rax
	jne	SHORT $LL112@Load
$LN855@Load:

; 19   :     *(++p) 		= 0;

	mov	BYTE PTR [rcx+1], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

	lea	rcx, QWORD PTR str$[rbp-256]
	mov	edx, 59					; 0000003bH
	call	QWORD PTR __imp_strchr
	lea	rcx, QWORD PTR str$[rbp-256]
	mov	edx, 47					; 0000002fH
	mov	rbx, rax
	call	QWORD PTR __imp_strchr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 144  : 		if(semi_1 && (*(semi_1+1)=='/') && ((!semi) || (semi && (semi_1<semi) )) ){

	test	rax, rax
	je	SHORT $LN43@Load
	cmp	BYTE PTR [rax+1], 47			; 0000002fH
	jne	SHORT $LN43@Load
	test	rbx, rbx
	je	SHORT $LN42@Load
	cmp	rax, rbx
	jae	SHORT $LN43@Load
$LN42@Load:

; 145  : 			semi = semi_1;

	mov	rbx, rax
$LN43@Load:

; 146  : 		}
; 147  : 
; 148  : #ifdef DEBUG
; 149  : 		LPSTR comment	= 0;
; 150  : #endif
; 151  : 		if (semi) {

	test	rbx, rbx
	je	SHORT $LN41@Load

; 152  : 			*semi		= 0;

	mov	BYTE PTR [rbx], 0
$LN41@Load:

; 158  :         if (str[0] && (str[0]=='#') && strstr(str,"#include")){

	movzx	eax, BYTE PTR str$[rbp-256]
	test	al, al
	je	$LN28@Load
	cmp	al, 35					; 00000023H
	jne	$LN40@Load
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_08GPLAJCBH@?$CDinclude?$AA@
	lea	rcx, QWORD PTR str$[rbp-256]
	call	QWORD PTR __imp_strstr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 158  :         if (str[0] && (str[0]=='#') && strstr(str,"#include")){

	test	rax, rax
	je	$LN853@Load

; 159  :         	string64	inc_name;	
; 160  : 			R_ASSERT	(path&&path[0]);

	cmp	BYTE PTR ?ignore_always@?BD@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA, 0
	jne	SHORT $LN38@Load
	mov	rax, QWORD PTR path$[rbp-256]
	test	rax, rax
	je	SHORT $LN35@Load
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN38@Load
$LN35@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?BD@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0O@OGKPJIFO@path?$CG?$CGpath?$FL0?$FN?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 160			; 000000a0H
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN38@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 32   : 	LPCSTR	res			= src;

	lea	rbx, QWORD PTR str$[rbp-256]

; 33   : 	u32		p			= 0;

	xor	edi, edi
	npad	7
$LL132@Load:

; 34   : 	while( (p<pos) && (0!=(res=strchr(res,separator))) )

	mov	edx, 34					; 00000022H
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN127@Load

; 35   : 	{
; 36   : 		res		++;
; 37   : 		p		++;

	inc	edi
	inc	rbx
	cmp	edi, 1
	jb	SHORT $LL132@Load

; 50   : 	return		dst;
; 51   : }
; 52   : 
; 53   : int	_GetItemCount ( LPCSTR src, char separator )
; 54   : {
; 55   : 	u32		cnt			= 0;
; 56   : 	if (src&&src[0]){
; 57   : 		LPCSTR	res			= src;
; 58   : 		LPCSTR	last_res	= res;
; 59   : 		while( 0!=(res=strchr(res,separator)) )
; 60   : 		{
; 61   : 			res		++;
; 62   : 			last_res=res;
; 63   : 			cnt		++;
; 64   : 			if (res[0]==separator) break;
; 65   : 		}
; 66   : 		if (xr_strlen(last_res)) cnt++;
; 67   : 	}
; 68   : 	return		cnt;
; 69   : }
; 70   : 
; 71   : LPSTR _GetItem ( LPCSTR src, int index, LPSTR dst, char separator, LPCSTR def, bool trim )
; 72   : {
; 73   : 	LPCSTR	ptr;
; 74   : 	ptr			= _SetPos	( src, index, separator );
; 75   : 	if( ptr )	_CopyVal	( ptr, dst, separator );

	test	rbx, rbx
	je	SHORT $LN127@Load

; 38   : 	}
; 39   : 	return		res;
; 40   : }
; 41   : 
; 42   : LPCSTR _CopyVal ( LPCSTR src, LPSTR dst, char separator )
; 43   : {
; 44   : 	LPCSTR	p;
; 45   : 	size_t	n;
; 46   : 	p			= strchr	( src, separator );

	mov	edx, 34					; 00000022H
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rdi, rax

; 47   : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	test	rax, rax
	je	SHORT $LN137@Load
	sub	rdi, rbx
	jmp	SHORT $LN138@Load
$LN137@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
$LL851@Load:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL851@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 47   : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	mov	edi, eax
$LN138@Load:

; 48   : 	strncpy		( dst, src, n );

	lea	rcx, QWORD PTR inc_name$3[rbp-256]
	mov	r8, rdi
	mov	rdx, rbx
	call	QWORD PTR __imp_strncpy

; 49   : 	dst[n]		= 0;

	mov	BYTE PTR inc_name$3[rbp+rdi-256], 0

; 76   : 		else	strcpy		( dst, def );

	jmp	SHORT $LN126@Load
$LN127@Load:
	xor	ecx, ecx
	lea	rsi, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	npad	1
$LL130@Load:
	movzx	eax, BYTE PTR [rcx+rsi]
	inc	rcx
	mov	BYTE PTR inc_name$3[rbp+rcx-257], al
	test	al, al
	jne	SHORT $LL130@Load
	mov	rsi, QWORD PTR Current$1$[rsp]
$LN126@Load:

; 7    : 	while( *p && (u8(*p)<=u8(' ')) ) p++;

	movzx	ecx, BYTE PTR inc_name$3[rbp-256]
	lea	rax, QWORD PTR inc_name$3[rbp-256]
	test	cl, cl
	je	SHORT $LN146@Load
$LL148@Load:
	cmp	cl, 32					; 00000020H
	ja	SHORT $LN147@Load
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL148@Load
$LN147@Load:

; 8    :     if (p!=str){

	lea	rcx, QWORD PTR inc_name$3[rbp-256]
	cmp	rax, rcx
	je	SHORT $LN146@Load

; 9    :         for (LPSTR t=str; *p; t++,p++) *t=*p;

	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR inc_name$3[rbp-256]
	test	dl, dl
	je	SHORT $LN143@Load
	lea	r8, QWORD PTR inc_name$3[rbp-256]
	sub	rax, r8
	npad	5
$LL145@Load:
	mov	BYTE PTR [rcx], dl
	movzx	edx, BYTE PTR [rcx+rax+1]
	inc	rcx
	test	dl, dl
	jne	SHORT $LL145@Load
$LN143@Load:

; 10   :         *t = 0;

	mov	BYTE PTR [rcx], 0
$LN146@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR inc_name$3[rbp-256]
	or	rax, -1
	npad	7
$LL850@Load:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL850@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 17   : 	LPSTR p 	= str+xr_strlen(str);

	mov	eax, eax
	lea	rcx, QWORD PTR inc_name$3[rbp-256]
	add	rcx, rax

; 18   : 	while( (p!=str) && (u8(*p)<=u8(' ')) ) p--;

	lea	rax, QWORD PTR inc_name$3[rbp-256]
	cmp	rcx, rax
	je	SHORT $LN856@Load
	npad	5
$LL152@Load:
	cmp	BYTE PTR [rcx], 32			; 00000020H
	ja	SHORT $LN856@Load
	lea	rax, QWORD PTR inc_name$3[rbp-256]
	dec	rcx
	cmp	rcx, rax
	jne	SHORT $LL152@Load
$LN856@Load:
	mov	rax, QWORD PTR path$[rbp-256]

; 19   :     *(++p) 		= 0;

	mov	BYTE PTR [rcx+1], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rbx, -1
$LL849@Load:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL849@Load

; 173  : 	strcpy_s(dest,dest_sz,S1);

	lea	rcx, QWORD PTR fn$5[rbp-256]
	mov	r8, rax
	mov	edx, 520				; 00000208H
	call	QWORD PTR __imp_strcpy_s

; 174  : 	strcat_s(dest,dest_sz-l1,S2);

	mov	edx, 520				; 00000208H
	lea	r8, QWORD PTR inc_name$3[rbp-256]
	lea	rcx, QWORD PTR fn$5[rbp-256]
	sub	edx, ebx
	call	QWORD PTR __imp_strcat_s
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 164  : 				_splitpath	(fn,inc_path,folder, 0, 0 );

	lea	r8, QWORD PTR folder$7[rbp-256]
	lea	rdx, QWORD PTR inc_path$6[rbp-256]
	lea	rcx, QWORD PTR fn$5[rbp-256]
	xor	ebx, ebx
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp__splitpath

; 165  : 				strcat		(inc_path,folder);

	lea	rdx, QWORD PTR inc_path$6[rbp-256]
	dec	rdx
	npad	4
$LL847@Load:
	cmp	BYTE PTR [rdx+1], bl
	lea	rdx, QWORD PTR [rdx+1]
	jne	SHORT $LL847@Load
	lea	r8, QWORD PTR folder$7[rbp-256]
	xor	ecx, ecx
	npad	14
$LL848@Load:
	movzx	eax, BYTE PTR [r8+rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx+rcx-1], al
	test	al, al
	jne	SHORT $LL848@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp

; 1181 : 	return					(r_open_impl<IReader>(path,_fname));

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	lea	r8, QWORD PTR fn$5[rbp-256]
	xor	edx, edx
	call	??$r_open_impl@VIReader@@@CLocatorAPI@@AEAAPEAVIReader@@PEBD0@Z ; CLocatorAPI::r_open_impl<IReader>
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 166  :             	IReader* I 	= FS.r_open(fn); R_ASSERT3(I,"Can't find include file:", inc_name);

	cmp	BYTE PTR ?ignore_always@?BK@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA, bl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp

; 1181 : 	return					(r_open_impl<IReader>(path,_fname));

	mov	rdi, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 166  :             	IReader* I 	= FS.r_open(fn); R_ASSERT3(I,"Can't find include file:", inc_name);

	jne	SHORT $LN32@Load
	test	rax, rax
	jne	SHORT $LN32@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?BK@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA
	lea	r9, QWORD PTR inc_name$3[rbp-256]
	lea	r8, OFFSET FLAT:??_C@_0BJ@JNOOHJGB@Can?8t?5find?5include?5file?3?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@
	lea	rdx, OFFSET FLAT:??_C@_01JPJNBJEM@I?$AA@
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 166			; 000000a6H
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+32], rbx
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN32@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 167  :             	Load		(I,inc_path);

	mov	rcx, QWORD PTR this$[rbp-256]
	lea	r8, QWORD PTR inc_path$6[rbp-256]
	mov	rdx, rdi
	call	?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z ; CInifile::Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_flags.h

; 25   : 	IC 	BOOL	test	(const T mask)						const	{ return BOOL(flags&mask);				}

	mov	rax, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	test	DWORD PTR [rax+112], 512		; 00000200H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\locatorapi.cpp

; 1186 : 	if( m_Flags.test(flDumpFileActivity) )

	je	SHORT $LN167@Load

; 1187 : 		_unregister_open_file	(fs);

	mov	rcx, rdi
	call	??$_unregister_open_file@VIReader@@@@YAXPEAVIReader@@@Z ; _unregister_open_file<IReader>
$LN167@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 151  : 	if (ptr) 

	test	rdi, rdi
	je	$LN676@Load

; 70   : }
; 71   : // new(1)
; 72   : template <class T, class P1>
; 73   : IC	T*		xr_new		(const P1& p1) {
; 74   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 75   : 	return new (ptr) T(p1);
; 76   : }
; 77   : // new(2)
; 78   : template <class T, class P1, class P2> 
; 79   : IC	T*		xr_new		(const P1& p1, const P2& p2) {
; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 81   : 	return new (ptr) T(p1,p2);
; 82   : }
; 83   : // new(3)
; 84   : template <class T, class P1, class P2, class P3>
; 85   : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3) {
; 86   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 87   : 	return new (ptr) T(p1,p2,p3);
; 88   : }
; 89   : // new(4)
; 90   : template <class T, class P1, class P2, class P3, class P4>
; 91   : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3, const P4& p4) {
; 92   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 93   : 	return new (ptr) T(p1,p2,p3,p4);
; 94   : }
; 95   : // new(5)
; 96   : template <class T, class P1, class P2, class P3, class P4, class P5>
; 97   : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5) {
; 98   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 99   : 	return new (ptr) T(p1,p2,p3,p4,p5);
; 100  : }
; 101  : // new(6)
; 102  : template <class T, class P1, class P2, class P3, class P4, class P5, class P6>
; 103  : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6) {
; 104  : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 105  : 	return new (ptr) T(p1,p2,p3,p4,p5,p6);
; 106  : }
; 107  : // new(7)
; 108  : template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7>
; 109  : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6, const P7& p7) {
; 110  : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 111  : 	return new (ptr) T(p1,p2,p3,p4,p5,p6,p7);
; 112  : }
; 113  : // new(8)
; 114  : template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8>
; 115  : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6, const P7& p7, const P8& p8) {
; 116  : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 117  : 	return new (ptr) T(p1,p2,p3,p4,p5,p6,p7,p8);
; 118  : }
; 119  : // new(9)
; 120  : template <class T, class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8, class P9>
; 121  : IC	T*		xr_new		(const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6, const P7& p7, const P8& p8, const P8& p9) {
; 122  : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));
; 123  : 	return new (ptr) T(p1,p2,p3,p4,p5,p6,p7,p8,p9);
; 124  : }
; 125  : #endif // DEBUG_MEMORY_NAME
; 126  : 
; 127  : template <bool _is_pm, typename T>
; 128  : struct xr_special_free
; 129  : {
; 130  : 	IC void operator()(T* &ptr)
; 131  : 	{
; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	rcx, rdi
	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	xor	edx, edx
	mov	rcx, rdi
	mov	rbx, rax
	mov	rax, QWORD PTR [rdi]
	call	QWORD PTR [rax]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rbx-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rdi, QWORD PTR [rbx-1]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN179@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	$LN861@Load

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	$LN861@Load
$LN179@Load:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 169  :             }

	jmp	$LN861@Load
$LN853@Load:
	movzx	eax, BYTE PTR str$[rbp-256]
$LN40@Load:
	cmp	al, 91					; 0000005bH
	jne	$LN28@Load

; 170  :         }else if (str[0] && (str[0]=='[')){
; 171  : 			// insert previous filled section
; 172  : 			if (Current){

	test	rsi, rsi
	je	$LN292@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rsi, QWORD PTR [rsi]
	mov	QWORD PTR tv2872[rbp-256], rsi
	test	rsi, rsi
	je	SHORT $LN204@Load
	lea	rdi, QWORD PTR [rsi+12]
	jmp	SHORT $LN205@Load
$LN204@Load:
	xor	edi, edi
$LN205@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 173  : 				RootIt I		= std::lower_bound(DATA.begin(),DATA.end(),*Current->Name,sect_pred);

	mov	rcx, QWORD PTR this$[rbp-256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rax, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	rbx, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	r9, rax
	mov	QWORD PTR tv2881[rsp], rax
	sub	r9, rbx
	sar	r9, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jle	SHORT $LN236@Load
	xor	esi, esi
	npad	13
$LL237@Load:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	r11, QWORD PTR [rbx+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	mov	rax, QWORD PTR [rbx+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	je	SHORT $LN256@Load
	add	rax, 12
	jmp	SHORT $LN257@Load
$LN256@Load:
	mov	rax, rsi
$LN257@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rdi
	sub	r8, rax
	npad	3
$LL845@Load:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN846@Load
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL845@Load
$LN846@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	test	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	jns	SHORT $LN235@Load

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	rbx, QWORD PTR [r11+8]
	sub	rax, r10
	add	r9, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN234@Load
$LN235@Load:

; 2521 : 			_Count = _Count2;

	mov	r9, r10
$LN234@Load:

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jg	SHORT $LL237@Load
	mov	rsi, QWORD PTR tv2872[rbp-256]
	mov	rax, QWORD PTR tv2881[rsp]
$LN236@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 174  : 				if ((I!=DATA.end())&&((*I)->Name==Current->Name))

	je	SHORT $LN26@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 54   : 	const str_value*	_get		()	const						{	return p_;																					}

	mov	rax, QWORD PTR [rbx]

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}
; 67   : 	char				operator[]	(size_t id)						{	return p_->value[id];							}
; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}
; 69   : 
; 70   : 	// misc func
; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}
; 72   : 	void				swap		(shared_str & rhs)				{	str_value* tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}
; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}
; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}

	cmp	QWORD PTR [rax], rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 174  : 				if ((I!=DATA.end())&&((*I)->Name==Current->Name))

	jne	SHORT $LN26@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	rsi, rsi
	je	SHORT $LN290@Load
	lea	rax, QWORD PTR [rsi+12]
	jmp	SHORT $LN291@Load
$LN290@Load:
	xor	eax, eax
$LN291@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 175  : 					Debug.fatal(DEBUG_INFO,"Duplicate section '%s' found.",*Current->Name);

	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_0BO@PADAFPII@Duplicate?5section?5?8?$CFs?8?5found?4?$AA@
	lea	r9, OFFSET FLAT:??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	r8d, 175				; 000000afH
	mov	QWORD PTR [rsp+32], rax
	call	?fatal@xrDebug@@QEAAXPEBDH00ZZ		; xrDebug::fatal
$LN26@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	mov	rcx, QWORD PTR this$[rbp-256]
	lea	rax, QWORD PTR Current$[rsp]
	lea	rdx, QWORD PTR $T4[rbp-256]
	mov	r8, rbx
	add	rcx, 16
	mov	QWORD PTR [rsp+32], rax
	call	?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n
$LN292@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 32					; 00000020H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	xor	edi, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	mov	rsi, rax
	mov	QWORD PTR Current$1$[rsp], rax

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN296@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	QWORD PTR [rax], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	QWORD PTR Current$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rax+8], rdi

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rax+16], rdi

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rax+24], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	jmp	SHORT $LN297@Load
$LN296@Load:
	mov	rsi, rdi
	mov	QWORD PTR Current$1$[rsp], rdi
	mov	QWORD PTR Current$[rsp], rdi
$LN297@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	xor	edx, edx
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN316@Load
	inc	DWORD PTR [rax]
$LN316@Load:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rcx, QWORD PTR [rsi]
	test	rcx, rcx
	je	SHORT $LN319@Load
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rsi]
	cmp	DWORD PTR [rcx], 0
	jne	SHORT $LN319@Load
	mov	QWORD PTR [rsi], rdi
$LN319@Load:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR [rsi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 181  : 			R_ASSERT3(strchr(str,']'),"Bad ini section found: ",str);

	cmp	BYTE PTR ?ignore_always@?CH@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA, 0
	jne	SHORT $LN24@Load
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

	lea	rcx, QWORD PTR str$[rbp-256]
	mov	edx, 93					; 0000005dH
	call	QWORD PTR __imp_strchr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 181  : 			R_ASSERT3(strchr(str,']'),"Bad ini section found: ",str);

	test	rax, rax
	jne	SHORT $LN24@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 467  : 	backend		(e1,e2,e3,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?CH@??Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z@4_NA
	lea	r9, QWORD PTR str$[rbp-256]
	lea	r8, OFFSET FLAT:??_C@_0BI@IHFKKOHL@Bad?5ini?5section?5found?3?5?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BA@NMAHPAMG@strchr?$CIstr?0?8?$FN?8?$CJ?$AA@
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 181			; 000000b5H
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+32], rdi
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN24@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 228  :         { return (char*)strstr((const char*)_Str, _SubStr); }

	lea	rdx, OFFSET FLAT:??_C@_02EBHDEFHH@?$FN?3?$AA@
	lea	rcx, QWORD PTR str$[rbp-256]
	call	QWORD PTR __imp_strstr
	mov	rbx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 183  : 			if (0!=inherited_names){

	test	rax, rax
	je	$LN15@Load

; 184  : 				VERIFY2			(bReadOnly,"Allow for readonly mode only.");
; 185  : 				inherited_names	+= 2;

	add	rbx, 2

; 186  : 				int cnt			= _GetItemCount(inherited_names);

	mov	dl, 44					; 0000002cH
	mov	rcx, rbx
	mov	QWORD PTR inherited_names$1$[rbp-256], rbx
	call	?_GetItemCount@@YAHPEBDD@Z		; _GetItemCount

; 187  : 				for (int k=0; k<cnt; ++k){

	mov	esi, edi
	mov	DWORD PTR k$1$[rbp-256], edi
	mov	DWORD PTR cnt$1$[rbp-256], eax
	test	eax, eax
	jle	$LN859@Load
	jmp	SHORT $LN17@Load
$LL864@Load:
	xor	edi, edi
$LN17@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR tmp$1[rsp+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR tmp$1[rsp+16], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR tmp$1[rsp], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 34   : 	while( (p<pos) && (0!=(res=strchr(res,separator))) )

	test	esi, esi
	je	SHORT $LN377@Load
	npad	7
$LL378@Load:
	mov	edx, 44					; 0000002cH
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rbx, rax
	test	rax, rax
	je	$LN836@Load

; 35   : 	{
; 36   : 		res		++;
; 37   : 		p		++;

	inc	edi
	inc	rbx
	cmp	edi, esi
	jb	SHORT $LL378@Load
$LN377@Load:

; 398  : 	return		dst.c_str();
; 399  : }
; 400  : 
; 401  : LPCSTR _GetItem ( LPCSTR src, int index, xr_string& dst, char separator, LPCSTR def, bool trim )
; 402  : {
; 403  : 	LPCSTR	ptr;
; 404  : 	ptr			= _SetPos	( src, index, separator );
; 405  : 	if( ptr )	_CopyVal	( ptr, dst, separator );

	test	rbx, rbx
	je	$LN836@Load

; 387  : 	return str;
; 388  : }
; 389  : 
; 390  : LPCSTR _CopyVal ( LPCSTR src, xr_string& dst, char separator )
; 391  : {
; 392  : 	LPCSTR		p;
; 393  : 	ptrdiff_t	n;
; 394  : 	p			= strchr	( src, separator );

	mov	edx, 44					; 0000002cH
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rdi, rax

; 395  : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	test	rax, rax
	je	SHORT $LN383@Load
	sub	rdi, rbx
	jmp	SHORT $LN384@Load
$LN383@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
	npad	5
$LL844@Load:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL844@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 395  : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	mov	edi, eax
$LN384@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LN393@Load
	xor	r8d, r8d
	jmp	SHORT $LN394@Load
$LN393@Load:
	or	r8, -1
	npad	7
$LL843@Load:
	inc	r8
	cmp	BYTE PTR [rbx+r8], 0
	jne	SHORT $LL843@Load
$LN394@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rcx, QWORD PTR tmp$1[rsp]
	mov	rdx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 397  : 	dst			= dst.erase	(n,dst.length());

	mov	r8, QWORD PTR tmp$1[rsp+16]
	lea	rcx, QWORD PTR tmp$1[rsp]
	mov	rdx, rdi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 998  : 		if (this != &_Right)

	lea	rcx, QWORD PTR tmp$1[rsp]
	cmp	rcx, rax
	je	SHORT $LN464@Load

; 999  : 			{	// different, assign it
; 1000 : 			if (this->_Getal() != _Right._Getal()
; 1001 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1002 : 				{	// change allocator before copying
; 1003 : 				_Tidy(true);
; 1004 : 				this->_Change_alloc(_Right._Getal());
; 1005 : 				}
; 1006 : 
; 1007 : 			assign(_Right);
; 1008 : 			}
; 1009 : 		return (*this);
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& operator=(const _Elem *_Ptr)
; 1013 : 		{	// assign [_Ptr, <null>)
; 1014 : 		return (assign(_Ptr));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& operator=(_Elem _Ch)
; 1018 : 		{	// assign 1 * _Ch
; 1019 : 		return (assign(1, _Ch));
; 1020 : 		}
; 1021 : 
; 1022 : 	_Myt& operator+=(const _Myt& _Right)
; 1023 : 		{	// append _Right
; 1024 : 		return (append(_Right));
; 1025 : 		}
; 1026 : 
; 1027 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1028 : 		{	// append [_Ptr, <null>)
; 1029 : 		return (append(_Ptr));
; 1030 : 		}
; 1031 : 
; 1032 : 	_Myt& operator+=(_Elem _Ch)
; 1033 : 		{	// append 1 * _Ch
; 1034 : 		return (append((size_type)1, _Ch));
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Myt& _Right)
; 1038 : 		{	// append _Right
; 1039 : 		return (append(_Right, 0, npos));
; 1040 : 		}
; 1041 : 
; 1042 : 	_Myt& append(const _Myt& _Right,
; 1043 : 		size_type _Roff, size_type _Count)
; 1044 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1045 : 		if (_Right.size() < _Roff)
; 1046 : 			_Xran();	// _Roff off end
; 1047 : 		size_type _Num = _Right.size() - _Roff;
; 1048 : 		if (_Num < _Count)
; 1049 : 			_Count = _Num;	// trim _Count to size
; 1050 : 		if (npos - this->_Mysize <= _Count)
; 1051 : 			_Xlen();	// result too long
; 1052 : 
; 1053 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1054 : 			{	// make room and append new stuff
; 1055 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1056 : 				_Right._Myptr() + _Roff, _Count);
; 1057 : 			_Eos(_Num);
; 1058 : 			}
; 1059 : 		return (*this);
; 1060 : 		}
; 1061 : 
; 1062 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1063 : 		{	// append [_Ptr, _Ptr + _Count)
; 1064 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1065 : 		if (_Count != 0)
; 1066 : 			_DEBUG_POINTER(_Ptr);
; 1067 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1068 : 
; 1069 : 		if (_Inside(_Ptr))
; 1070 : 			return (append(*this,
; 1071 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1072 : 		if (npos - this->_Mysize <= _Count)
; 1073 : 			_Xlen();	// result too long
; 1074 : 
; 1075 : 		size_type _Num;
; 1076 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1077 : 			{	// make room and append new stuff
; 1078 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1079 : 			_Eos(_Num);
; 1080 : 			}
; 1081 : 		return (*this);
; 1082 : 		}
; 1083 : 
; 1084 : 	_Myt& append(const _Elem *_Ptr)
; 1085 : 		{	// append [_Ptr, <null>)
; 1086 : 		_DEBUG_POINTER(_Ptr);
; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1088 : 		}
; 1089 : 
; 1090 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1091 : 		{	// append _Count * _Ch
; 1092 : 		if (npos - this->_Mysize <= _Count)
; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		size_type _Num;
; 1096 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1097 : 			{	// make room and append new stuff using assign
; 1098 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1099 : 			_Eos(_Num);
; 1100 : 			}
; 1101 : 		return (*this);
; 1102 : 		}
; 1103 : 
; 1104 : 	template<class _Iter>
; 1105 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1106 : 			_Myt&>::type
; 1107 : 		append(_Iter _First, _Iter _Last)
; 1108 : 		{	// append [_First, _Last), input iterators
; 1109 : 		return (replace(end(), end(), _First, _Last));
; 1110 : 		}
; 1111 : 
; 1112 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1113 : 		{	// append [_First, _Last), const pointers
; 1114 : 		return (replace(end(), end(), _First, _Last));
; 1115 : 		}
; 1116 : 
; 1117 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1118 : 		{	// append [_First, _Last), const_iterators
; 1119 : 		return (replace(end(), end(), _First, _Last));
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Myt& _Right)
; 1123 : 		{	// assign _Right
; 1124 : 		return (assign(_Right, 0, npos));

	lea	rcx, QWORD PTR tmp$1[rsp]
	or	r9, -1
	xor	r8d, r8d
	mov	rdx, rax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 406  : 	else	dst = def;

	jmp	SHORT $LN464@Load
$LN836@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	lea	rcx, QWORD PTR tmp$1[rsp]
	xor	r8d, r8d
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
$LN464@Load:

; 520  : 			: this->_Bx._Buf);

	mov	rax, QWORD PTR tmp$1[rsp+24]
	lea	r8, QWORD PTR tmp$1[rsp]
	lea	rdx, QWORD PTR tmp$1[rsp]
	cmp	rax, 16
	cmovae	r8, QWORD PTR tmp$1[rsp]
	cmovae	rdx, QWORD PTR tmp$1[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 365  : 	while( *p && (u8(*p)<=u8(' ')) ) p++;

	movzx	eax, BYTE PTR [r8]
	test	al, al
	je	SHORT $LN857@Load
$LL476@Load:
	cmp	al, 32					; 00000020H
	ja	SHORT $LN857@Load
	movzx	eax, BYTE PTR [r8+1]
	inc	r8
	test	al, al
	jne	SHORT $LL476@Load
$LN857@Load:

; 366  :     if (p!=b)

	cmp	r8, rdx
	je	SHORT $LN474@Load

; 367  :     	str.erase	(0,p-b);

	sub	r8, rdx
	lea	rcx, QWORD PTR tmp$1[rsp]
	xor	edx, edx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::erase
$LN474@Load:

; 368  : 	return str;
; 369  : }
; 370  : 
; 371  : xr_string& _TrimRight( xr_string& str )
; 372  : {
; 373  : 	LPCSTR b		= str.c_str();
; 374  :     size_t l		= str.length();
; 375  :     if (l){
; 376  :         LPCSTR p 		= str.c_str()+l-1;
; 377  :         while( (p!=b) && (u8(*p)<=u8(' ')) ) p--;
; 378  :         if (p!=(str+b))	str.erase	(p-b+1,l-(p-b));
; 379  :     }
; 380  : 	return str;
; 381  : }
; 382  : 
; 383  : xr_string& _Trim( xr_string& str )
; 384  : {
; 385  : 	_TrimLeft		( str );
; 386  : 	_TrimRight		( str );

	lea	rcx, QWORD PTR tmp$1[rsp]
	call	?_TrimRight@@YAAEAV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@AEAV12@@Z ; _TrimRight
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR tmp$1[rsp+24], 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 190  : 					Sect& inherited_section = r_section(tmp.c_str());

	mov	rcx, QWORD PTR this$[rbp-256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	lea	rdx, QWORD PTR tmp$1[rsp]
	cmovae	rdx, QWORD PTR tmp$1[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 190  : 					Sect& inherited_section = r_section(tmp.c_str());

	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

	mov	rbx, QWORD PTR [rax+8]

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR [rax+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 191  : 					for (SectIt_ it =inherited_section.Data.begin(); it!=inherited_section.Data.end(); it++)

	je	SHORT $LN12@Load
	mov	rsi, QWORD PTR Current$1$[rsp]
$LL523@Load:

; 192  : 						insert_item	(Current,*it);

	mov	rdx, rbx
	mov	rcx, rsi
	call	?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z ; insert_item
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rbx, 16

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR [rdi+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 191  : 					for (SectIt_ it =inherited_section.Data.begin(); it!=inherited_section.Data.end(); it++)

	jne	SHORT $LL523@Load
	mov	esi, DWORD PTR k$1$[rbp-256]
$LN12@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR tmp$1[rsp+24], 16
	jb	SHORT $LN591@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	mov	rdi, QWORD PTR tmp$1[rsp]
	test	rdi, rdi
	je	SHORT $LN591@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN570@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN591@Load

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN591@Load
$LN570@Load:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN591@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 187  : 				for (int k=0; k<cnt; ++k){

	mov	rbx, QWORD PTR inherited_names$1$[rbp-256]
	inc	esi
	mov	DWORD PTR k$1$[rbp-256], esi
	cmp	esi, DWORD PTR cnt$1$[rbp-256]
	jl	$LL864@Load
$LN859@Load:
	mov	rsi, QWORD PTR Current$1$[rsp]
$LN15@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

	lea	rcx, QWORD PTR str$[rbp-256]
	mov	edx, 93					; 0000005dH
	call	QWORD PTR __imp_strchr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 196  : 			Current->Name 		= strlwr(str+1);

	lea	rcx, QWORD PTR str$[rbp-255]
	mov	BYTE PTR [rax], 0
	call	QWORD PTR __imp_strlwr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	mov	rdx, rax
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN607@Load
	inc	DWORD PTR [rax]
$LN607@Load:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rcx, QWORD PTR [rsi]
	xor	ebx, ebx
	test	rcx, rcx
	je	SHORT $LN610@Load
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rsi]
	cmp	DWORD PTR [rcx], ebx
	jne	SHORT $LN610@Load
	mov	QWORD PTR [rsi], rbx
$LN610@Load:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR [rsi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 197  : 		} else {

	jmp	$LN676@Load
$LN28@Load:

; 198  : 			if (Current){

	test	rsi, rsi
	je	$LN861@Load
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

	lea	rcx, QWORD PTR str$[rbp-256]
	mov	edx, 61					; 0000003dH
	call	QWORD PTR __imp_strchr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 203  : 					_Trim	(name);

	lea	rcx, QWORD PTR str$[rbp-256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

	mov	rbx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 201  : 				if (t)		{

	test	rax, rax
	je	SHORT $LN9@Load

; 202  : 					*t		= 0;

	mov	BYTE PTR [rax], 0

; 203  : 					_Trim	(name);

	call	?_Trim@@YAPEADPEAD@Z			; _Trim

; 204  : 					_parse	(str2,++t);

	lea	rdx, QWORD PTR [rbx+1]
	lea	rcx, QWORD PTR str2$[rbp-256]
	call	?_parse@@YAXPEADPEBD@Z			; _parse

; 205  : 				} else {

	jmp	SHORT $LN8@Load
$LN9@Load:

; 206  : 					_Trim	(name);

	call	?_Trim@@YAPEADPEAD@Z			; _Trim

; 207  : 					str2[0]	= 0;

	mov	BYTE PTR str2$[rbp-256], 0
$LN8@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	xor	edx, edx
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN620@Load
	inc	DWORD PTR [rax]
$LN620@Load:
	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	xor	edx, edx
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	rsi, rax
	test	rax, rax
	je	SHORT $LN629@Load
	inc	DWORD PTR [rax]
$LN629@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 211  : 				I.first		= (name[0]?name:NULL);

	cmp	BYTE PTR str$[rbp-256], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 211  : 				I.first		= (name[0]?name:NULL);

	mov	eax, 0
	lea	rdx, QWORD PTR str$[rbp-256]
	cmove	rdx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN638@Load
	inc	DWORD PTR [rax]
$LN638@Load:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rdi, rdi
	je	SHORT $LN641@Load
	dec	DWORD PTR [rdi]
$LN641@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 212  : 				I.second	= (str2[0]?str2:NULL);

	cmp	BYTE PTR str2$[rbp-256], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 212  : 				I.second	= (str2[0]?str2:NULL);

	lea	rdx, QWORD PTR str2$[rbp-256]
	mov	edi, 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR I$2[rbp-256], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 212  : 				I.second	= (str2[0]?str2:NULL);

	cmove	rdx, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	rcx, rax
	test	rax, rax
	je	SHORT $LN647@Load
	inc	DWORD PTR [rax]
$LN647@Load:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rsi, rsi
	je	SHORT $LN650@Load
	dec	DWORD PTR [rsi]
$LN650@Load:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR I$2[rbp-248], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 217  : 				if (bReadOnly) {

	mov	rax, QWORD PTR this$[rbp-256]
	cmp	DWORD PTR [rax+40], edi
	je	SHORT $LN7@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	rbx, rbx
	je	SHORT $LN4@Load
	lea	rax, QWORD PTR [rbx+12]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 219  : 				} else {

	jmp	SHORT $LN869@Load
$LN7@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	rbx, rbx
	je	SHORT $LN837@Load
	lea	rax, QWORD PTR [rbx+12]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 226  : 						)

	test	rax, rax
	jne	SHORT $LN3@Load
$LN837@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	rcx, rcx
	je	SHORT $LN670@Load
	lea	rax, QWORD PTR [rcx+12]
$LN869@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 226  : 						)

	test	rax, rax
	je	SHORT $LN4@Load
$LN3@Load:

; 227  : 						insert_item	(Current,I);

	mov	rcx, QWORD PTR Current$1$[rsp]
	lea	rdx, QWORD PTR I$2[rbp-256]
	call	?insert_item@@YAXPEAUSect@CInifile@@AEBUItem@2@@Z ; insert_item
	mov	rbx, QWORD PTR I$2[rbp-256]
	mov	rcx, QWORD PTR I$2[rbp-248]
$LN4@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rcx, rcx
	je	SHORT $LN670@Load
	dec	DWORD PTR [rcx]
	cmove	rcx, rdi
	mov	QWORD PTR I$2[rbp-248], rcx
$LN670@Load:
	mov	rsi, QWORD PTR Current$1$[rsp]
	test	rbx, rbx
	je	SHORT $LN861@Load
	dec	DWORD PTR [rbx]
	cmove	rbx, rdi
	mov	QWORD PTR I$2[rbp-256], rbx
$LN861@Load:
	xor	ebx, ebx
$LN676@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	rdx, QWORD PTR F$[rbp-256]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 137  : 	while (!F->eof())

	lea	r8, OFFSET FLAT:?ignore_always@?3??r_string@IReader@@QEAAXPEADI@Z@4_NA
	lea	r10, OFFSET FLAT:??_C@_0BC@LFPNBCKC@IReader?3?3r_string?$AA@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 261  : 	IC int			elapsed		()	const		{	return Size-Pos;		};

	mov	eax, DWORD PTR [rdx+20]
	sub	eax, DWORD PTR [rdx+16]

; 140  : 	IC BOOL			eof			()	const		{return impl().elapsed()<=0;	};

	test	eax, eax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 137  : 	while (!F->eof())

	jg	$LL45@Load

; 228  : 				}
; 229  : 			}
; 230  : 		}
; 231  : 	}
; 232  : 	if (Current)

	test	rsi, rsi
	je	$LN867@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rdi, QWORD PTR [rsi]
	mov	QWORD PTR tv2871[rbp-256], rdi
	lea	rsi, QWORD PTR [rdi+12]
	test	rdi, rdi
	jne	SHORT $LN683@Load
	mov	rsi, rbx
$LN683@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 234  : 		RootIt I		= std::lower_bound(DATA.begin(),DATA.end(),*Current->Name,sect_pred);

	mov	rcx, QWORD PTR this$[rbp-256]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rax, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	rbx, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	r9, rax
	mov	QWORD PTR tv2880[rbp-256], rax
	sub	r9, rbx
	sar	r9, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jle	SHORT $LN714@Load
	xor	edi, edi
	npad	7
$LL715@Load:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	r11, QWORD PTR [rbx+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	mov	rcx, QWORD PTR [r11]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN734@Load
	add	rcx, 12
	jmp	SHORT $LN735@Load
$LN734@Load:
	mov	rcx, rdi
$LN735@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rsi
	sub	r8, rcx
	npad	4
$LL841@Load:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN842@Load
	inc	rcx
	test	eax, eax
	jne	SHORT $LL841@Load
$LN842@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	test	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	jns	SHORT $LN713@Load

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	rbx, QWORD PTR [r11+8]
	sub	rax, r10
	add	r9, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN712@Load
$LN713@Load:

; 2521 : 			_Count = _Count2;

	mov	r9, r10
$LN712@Load:

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jg	SHORT $LL715@Load
	mov	rdi, QWORD PTR tv2871[rbp-256]
	mov	rax, QWORD PTR tv2880[rbp-256]
$LN714@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 235  : 		if ((I!=DATA.end())&&((*I)->Name==Current->Name))

	je	SHORT $LN1@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 54   : 	const str_value*	_get		()	const						{	return p_;																					}

	mov	rax, QWORD PTR [rbx]

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}
; 67   : 	char				operator[]	(size_t id)						{	return p_->value[id];							}
; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}
; 69   : 
; 70   : 	// misc func
; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}
; 72   : 	void				swap		(shared_str & rhs)				{	str_value* tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}
; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}
; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}

	cmp	QWORD PTR [rax], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 235  : 		if ((I!=DATA.end())&&((*I)->Name==Current->Name))

	jne	SHORT $LN1@Load
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	rdi, rdi
	je	SHORT $LN768@Load
	lea	rax, QWORD PTR [rdi+12]
	jmp	SHORT $LN769@Load
$LN768@Load:
	xor	eax, eax
$LN769@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 236  : 			Debug.fatal(DEBUG_INFO,"Duplicate section '%s' found.",*Current->Name);

	mov	QWORD PTR [rsp+40], rax
	lea	rax, OFFSET FLAT:??_C@_0BO@PADAFPII@Duplicate?5section?5?8?$CFs?8?5found?4?$AA@
	lea	r9, OFFSET FLAT:??_C@_0P@PFFEEJAK@CInifile?3?3Load?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	r8d, 236				; 000000ecH
	mov	QWORD PTR [rsp+32], rax
	call	?fatal@xrDebug@@QEAAXPEBDH00ZZ		; xrDebug::fatal
$LN1@Load:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	mov	rcx, QWORD PTR this$[rbp-256]
	lea	rax, QWORD PTR Current$[rsp]
	lea	rdx, QWORD PTR $T8[rbp-256]
	mov	r8, rbx
	add	rcx, 16
	mov	QWORD PTR [rsp+32], rax
	call	?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n
$LN867@Load:
	mov	rdi, QWORD PTR [rsp+10024]
$LN770@Load:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 239  : }

	add	rsp, 10032				; 00002730H
	pop	rsi
	pop	rbx
	pop	rbp
	ret	0
?Load@CInifile@@AEAAXPEAVIReader@@PEBD@Z ENDP		; CInifile::Load
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$1 = 80
fname$2 = 592
val$3 = 592
d$ = 1152
d$ = 1152
d$ = 1152
d$ = 1152
d$ = 1152
d$ = 1152
this$ = 1152
F$ = 1160
new_fname$ = 1160
?save_as@CInifile@@QEAA_NPEBD@Z PROC			; CInifile::save_as

; 242  : {

$LN196:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rbp
	push	rdi
	push	r14
	lea	rbp, QWORD PTR [rsp-864]
	sub	rsp, 1120				; 00000460H
	mov	rbx, rdx
	mov	r14, rcx

; 243  : 	// save if needed
; 244  :     if (new_fname&&new_fname[0]){

	test	rdx, rdx
	je	SHORT $LN17@save_as
	cmp	BYTE PTR [rdx], 0
	je	SHORT $LN17@save_as
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	cmp	QWORD PTR [rcx+8], 0
	je	SHORT $LN21@save_as
	add	rcx, 8
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN21@save_as:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 246  :         fName			= xr_strdup(new_fname);

	mov	rcx, rbx
	call	?xr_strdup@@YAPEADPEBD@Z		; xr_strdup
	mov	QWORD PTR [r14+8], rax
$LN17@save_as:

; 247  :     }
; 248  :     R_ASSERT			(fName&&fName[0]);

	cmp	BYTE PTR ?ignore_always@?6??save_as@CInifile@@QEAA_NPEBD@Z@4_NA, 0
	jne	SHORT $LN16@save_as
	mov	rax, QWORD PTR [r14+8]
	test	rax, rax
	je	SHORT $LN13@save_as
	cmp	BYTE PTR [rax], 0
	jne	SHORT $LN16@save_as
$LN13@save_as:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?6??save_as@CInifile@@QEAA_NPEBD@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0BA@HGOPAPJG@fName?$CG?$CGfName?$FL0?$FN?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BC@LBCCFBEL@CInifile?3?3save_as?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 248			; 000000f8H
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN16@save_as:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	mov	r8, QWORD PTR [r14+8]
	lea	rcx, QWORD PTR fname$2[rbp-256]
	mov	edx, 520				; 00000208H
	call	QWORD PTR __imp_strcpy_s
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 273  : {	return strlwr(S);				}

	lea	rcx, QWORD PTR fname$2[rbp-256]
	call	QWORD PTR __imp_strlwr
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 48					; 00000030H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 81   : 	return new (ptr) T(p1,p2);

	test	rax, rax
	je	SHORT $LN41@save_as
	lea	rdx, QWORD PTR fname$2[rbp-256]
	mov	r8b, 1
	mov	rcx, rax
	call	??0CFileWriter@@QEAA@PEBD_N@Z		; CFileWriter::CFileWriter
	mov	rsi, rax
	jmp	SHORT $LN42@save_as
$LN41@save_as:
	xor	esi, esi
$LN42@save_as:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 249  :     IWriter* F			= FS.w_open_ex(fName);

	mov	QWORD PTR F$[rbp-256], rsi

; 250  :     if (F){

	test	rsi, rsi
	je	$LN12@save_as
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 47   : 		{	// construct with pointer _Parg

	mov	rdi, QWORD PTR [r14+16]

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rdi, QWORD PTR [r14+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 252  :         for (RootIt r_it=DATA.begin(); r_it!=DATA.end(); ++r_it)

	je	$LN9@save_as
$LL55@save_as:

; 254  :             sprintf_s		(temp,sizeof(temp),"[%s]",*(*r_it)->Name);

	mov	rax, QWORD PTR [rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN77@save_as
	lea	r9, QWORD PTR [rcx+12]
	jmp	SHORT $LN78@save_as
$LN77@save_as:
	xor	r9d, r9d
$LN78@save_as:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 254  :             sprintf_s		(temp,sizeof(temp),"[%s]",*(*r_it)->Name);

	lea	r8, OFFSET FLAT:??_C@_04LIFAFMCE@?$FL?$CFs?$FN?$AA@
	lea	rcx, QWORD PTR temp$1[rsp]
	mov	edx, 512				; 00000200H
	call	QWORD PTR __imp_sprintf_s
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	rax, QWORD PTR [rsi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR temp$1[rsp]
	or	r8, -1
	npad	7
$LL192@save_as:
	inc	r8
	cmp	BYTE PTR [rcx+r8], 0
	jne	SHORT $LL192@save_as
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	lea	rdx, QWORD PTR temp$1[rsp]
	mov	rcx, rsi
	call	QWORD PTR [rax+24]

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR d$[rbp-256]
	mov	r8d, 1
	mov	rcx, rsi

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	BYTE PTR d$[rbp-256], 13

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	call	QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR d$[rbp-256]
	mov	r8d, 1
	mov	rcx, rsi

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	BYTE PTR d$[rbp-256], 10

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	call	QWORD PTR [rax+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 256  :             for (SectCIt s_it=(*r_it)->Data.begin(); s_it!=(*r_it)->Data.end(); ++s_it)

	mov	rax, QWORD PTR [rdi]
	mov	rbx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR [rax+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 256  :             for (SectCIt s_it=(*r_it)->Data.begin(); s_it!=(*r_it)->Data.end(); ++s_it)

	je	$LN6@save_as
$LL99@save_as:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rbx]
	test	rax, rax
	je	$LN5@save_as
	add	rax, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 259  :                 if (*I.first) {

	je	$LN5@save_as
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rdx, QWORD PTR [rbx+8]
	test	rdx, rdx
	je	$LN4@save_as
	add	rdx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 260  :                     if (*I.second) {

	je	$LN4@save_as

; 50   : 		while (*src) {

	movzx	r8d, BYTE PTR [rdx]
	xor	r9d, r9d

; 261  :                         _decorate	(val,*I.second);

	lea	rax, QWORD PTR val$3[rbp-256]

; 50   : 		while (*src) {

	test	r8b, r8b
	je	SHORT $LN138@save_as
$LL139@save_as:

; 51   : 			if (*src == ',') {

	cmp	r8b, 44					; 0000002cH
	jne	SHORT $LN137@save_as

; 52   : 				if (bInsideSTR) { *dest++ = *src++; }

	test	r9d, r9d
	je	SHORT $LN136@save_as
	mov	BYTE PTR [rax], r8b
	jmp	SHORT $LN194@save_as
$LN136@save_as:

; 53   : 				else			{ *dest++ = *src++; *dest++ = ' '; }

	mov	WORD PTR [rax], 8236			; 0000202cH
	inc	rdx
	add	rax, 2

; 54   : 				continue;

	jmp	SHORT $LN178@save_as
$LN137@save_as:

; 55   : 			} else if (*src=='"') {

	cmp	r8b, 34					; 00000022H
	jne	SHORT $LN133@save_as

; 56   : 				bInsideSTR = !bInsideSTR;

	xor	ecx, ecx
	test	r9d, r9d
	sete	cl
	mov	r9d, ecx
$LN133@save_as:

; 57   : 			}
; 58   : 			*dest++ = *src++;

	mov	BYTE PTR [rax], r8b
$LN194@save_as:
	inc	rax
	inc	rdx
$LN178@save_as:

; 50   : 		while (*src) {

	movzx	r8d, BYTE PTR [rdx]
	test	r8b, r8b
	jne	SHORT $LL139@save_as
$LN138@save_as:

; 59   : 		}
; 60   : 	}
; 61   : 	*dest = 0;

	mov	BYTE PTR [rax], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rbx]
	test	rax, rax
	je	SHORT $LN146@save_as
	add	rax, 12
$LN146@save_as:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 270  :                             sprintf_s	(temp,sizeof(temp),"%8s%-32s = %-32s"," ",*I.first,val);

	lea	rcx, QWORD PTR val$3[rbp-256]
	lea	r9, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	lea	r8, OFFSET FLAT:??_C@_0BB@DGLKGBOG@?$CF8s?$CF?932s?5?$DN?5?$CF?932s?$AA@
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, QWORD PTR temp$1[rsp]
	mov	edx, 512				; 00000200H
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_sprintf_s

; 271  :                         }
; 272  :                     } else {

	jmp	SHORT $LN2@save_as
$LN4@save_as:

; 273  : #ifdef DEBUG
; 274  :                         if (*I.comment) {
; 275  :                             // name and comment
; 276  :                             sprintf_s(temp,sizeof(temp),"%8s%-32s = ;%s"," ",*I.first,*I.comment);
; 277  :                         } else
; 278  : #endif
; 279  : 						{
; 280  :                             // only name
; 281  :                             sprintf_s(temp,sizeof(temp),"%8s%-32s = "," ",*I.first);

	lea	r9, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	lea	r8, OFFSET FLAT:??_C@_0M@FGDEMPPI@?$CF8s?$CF?932s?5?$DN?5?$AA@
	lea	rcx, QWORD PTR temp$1[rsp]
	mov	edx, 512				; 00000200H
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_sprintf_s

; 282  :                         }
; 283  :                     }
; 284  :                 } else {

	jmp	SHORT $LN2@save_as
$LN5@save_as:

; 285  :                     // no name, so no value
; 286  : #ifdef DEBUG
; 287  :                     if (*I.comment)
; 288  : 						sprintf_s		(temp,sizeof(temp),"%8s;%s"," ",*I.comment);
; 289  :                     else
; 290  : #endif
; 291  : 						temp[0]		= 0;

	mov	BYTE PTR temp$1[rsp], 0
$LN2@save_as:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR temp$1[rsp]
	or	rax, -1
$LL191@save_as:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL191@save_as
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 17   : 	LPSTR p 	= str+xr_strlen(str);

	mov	eax, eax
	lea	rcx, QWORD PTR temp$1[rsp]
	add	rcx, rax

; 18   : 	while( (p!=str) && (u8(*p)<=u8(' ')) ) p--;

	lea	rax, QWORD PTR temp$1[rsp]
	cmp	rcx, rax
	je	SHORT $LN193@save_as
$LL152@save_as:
	cmp	BYTE PTR [rcx], 32			; 00000020H
	ja	SHORT $LN193@save_as
	lea	rax, QWORD PTR temp$1[rsp]
	dec	rcx
	cmp	rcx, rax
	jne	SHORT $LL152@save_as
$LN193@save_as:

; 19   :     *(++p) 		= 0;

	mov	BYTE PTR [rcx+1], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 294  :                 if (temp[0])		F->w_string	(temp);

	cmp	BYTE PTR temp$1[rsp], 0
	je	SHORT $LN7@save_as
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	rax, QWORD PTR [rsi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR temp$1[rsp]
	or	r8, -1
	npad	6
$LL190@save_as:
	inc	r8
	cmp	BYTE PTR [rcx+r8], 0
	jne	SHORT $LL190@save_as
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	lea	rdx, QWORD PTR temp$1[rsp]
	mov	rcx, rsi
	call	QWORD PTR [rax+24]

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR d$[rbp-256]
	mov	r8d, 1
	mov	rcx, rsi

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	BYTE PTR d$[rbp-256], 13

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	call	QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR d$[rbp-256]
	mov	r8d, 1
	mov	rcx, rsi

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	BYTE PTR d$[rbp-256], 10

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	call	QWORD PTR [rax+24]
$LN7@save_as:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rax, QWORD PTR [rdi]

; 112  : 		++this->_Ptr;

	add	rbx, 16

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, QWORD PTR [rax+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 256  :             for (SectCIt s_it=(*r_it)->Data.begin(); s_it!=(*r_it)->Data.end(); ++s_it)

	jne	$LL99@save_as
$LN6@save_as:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\fs.h

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	rax, QWORD PTR [rsi]
	lea	rdx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	mov	r8d, 1
	mov	rcx, rsi
	call	QWORD PTR [rax+24]

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR d$[rbp-256]
	mov	r8d, 1
	mov	rcx, rsi

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	BYTE PTR d$[rbp-256], 13

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	call	QWORD PTR [rax+24]
	mov	rax, QWORD PTR [rsi]
	lea	rdx, QWORD PTR d$[rbp-256]
	mov	r8d, 1
	mov	rcx, rsi

; 54   : 	IC void			w_string(const char *p)			{	w(p,(u32)xr_strlen(p));w_u8(13);w_u8(10);	}

	mov	BYTE PTR d$[rbp-256], 10

; 48   : 	IC void			w_u8	(u8 d)					{	w(&d,sizeof(u8));	}

	call	QWORD PTR [rax+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rdi, 8

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rdi, QWORD PTR [r14+24]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 252  :         for (RootIt r_it=DATA.begin(); r_it!=DATA.end(); ++r_it)

	jne	$LL55@save_as
$LN9@save_as:

; 295  :             }
; 296  :             F->w_string		(" ");
; 297  :         }
; 298  :         FS.w_close			(F);

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	lea	rdx, QWORD PTR F$[rbp-256]
	call	?w_close@CLocatorAPI@@QEAAXAEAPEAVIWriter@@@Z ; CLocatorAPI::w_close

; 299  : 	    return true;

	mov	al, 1
	jmp	SHORT $LN19@save_as
$LN12@save_as:

; 300  :     }
; 301  :     return false;

	xor	al, al
$LN19@save_as:

; 302  : }

	lea	r11, QWORD PTR [rsp+1120]
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rbp
	ret	0
?save_as@CInifile@@QEAA_NPEBD@Z ENDP			; CInifile::save_as
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 16
S$ = 24
?section_exist@CInifile@@QEAAHPEBD@Z PROC		; CInifile::section_exist

; 305  : {

$LN95:
	push	rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	rbx, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+16], rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rsi, QWORD PTR [rcx+24]
	mov	r8, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 305  : {

	mov	r11, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	r8, rbx
	sar	r8, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r8, r8
	jle	SHORT $LN35@section_ex
	mov	QWORD PTR [rsp+24], rdi
	npad	10
$LL36@section_ex:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r8
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	rdi, QWORD PTR [rbx+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	mov	rax, QWORD PTR [rbx+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	je	SHORT $LN56@section_ex
	add	rax, 12
$LN56@section_ex:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r9, r11
	sub	r9, rax
	npad	8
$LL92@section_ex:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN93@section_ex
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL92@section_ex
$LN93@section_ex:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	test	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	jns	SHORT $LN34@section_ex

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	rbx, QWORD PTR [rdi+8]
	sub	rax, r10
	add	r8, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN33@section_ex
$LN34@section_ex:

; 2521 : 			_Count = _Count2;

	mov	r8, r10
$LN33@section_ex:

; 2508 : 	while (0 < _Count)

	test	r8, r8
	jg	SHORT $LL36@section_ex
	mov	rdi, QWORD PTR [rsp+24]
$LN35@section_ex:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rbx, rsi
	mov	rsi, QWORD PTR [rsp+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 307  : 	return (I!=DATA.end() && xr_strcmp(*(*I)->Name,S)==0);

	je	SHORT $LN3@section_ex
	mov	rax, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	je	SHORT $LN84@section_ex
	add	rax, 12
$LN84@section_ex:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	sub	r11, rax
$LL90@section_ex:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r11]
	sub	edx, ecx
	jne	SHORT $LN91@section_ex
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL90@section_ex
$LN91@section_ex:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 307  : 	return (I!=DATA.end() && xr_strcmp(*(*I)->Name,S)==0);

	test	edx, edx
	jne	SHORT $LN3@section_ex
	mov	eax, 1

; 308  : }

	pop	rbx
	ret	0
$LN3@section_ex:

; 307  : 	return (I!=DATA.end() && xr_strcmp(*(*I)->Name,S)==0);

	xor	eax, eax

; 308  : }

	pop	rbx
	ret	0
?section_exist@CInifile@@QEAAHPEBD@Z ENDP		; CInifile::section_exist
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 64
S$ = 72
L$ = 80
?line_exist@CInifile@@QEAAHPEBD0@Z PROC			; CInifile::line_exist

; 311  : {

$LN126:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r8
	mov	rbx, rdx
	mov	rdi, rcx

; 312  : 	if (!section_exist(S)) return FALSE;

	call	?section_exist@CInifile@@QEAAHPEBD@Z	; CInifile::section_exist
	test	eax, eax
	jne	SHORT $LN1@line_exist

; 316  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN1@line_exist:

; 313  : 	Sect&	I = r_section(S);

	mov	rdx, rbx
	mov	rcx, rdi
	mov	QWORD PTR [rsp+72], r14
	mov	QWORD PTR [rsp+80], r15
	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	r14, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rbx, QWORD PTR [rax+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 313  : 	Sect&	I = r_section(S);

	mov	r15, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	rbx, r14
	sar	rbx, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jle	$LN36@line_exist
	mov	QWORD PTR [rsp+64], rbp
	npad	9
$LL37@line_exist:

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rbp, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	add	rdi, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	mov	rcx, QWORD PTR [r14+rdi*8]
	test	rcx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 21   :     if ((!x.first) || (!val))	return x.first<val;

	je	SHORT $LN53@line_exist
	test	rsi, rsi
	je	SHORT $LN53@line_exist
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	add	rcx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rsi
	sub	r8, rcx
	npad	4
$LL123@line_exist:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN124@line_exist
	inc	rcx
	test	eax, eax
	jne	SHORT $LL123@line_exist
$LN124@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 22   :     else				   		return xr_strcmp(*x.first,val)<0;

	test	edx, edx
	sets	cl
	jmp	SHORT $LN76@line_exist
$LN53@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	mov	rdx, rsi
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN64@line_exist
	inc	DWORD PTR [rax]
$LN64@line_exist:

; 67   : 	char				operator[]	(size_t id)						{	return p_->value[id];							}
; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}
; 69   : 
; 70   : 	// misc func
; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}
; 72   : 	void				swap		(shared_str & rhs)				{	str_value* tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}
; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}
; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}
; 94   : IC bool operator	!=	(shared_str const & a, shared_str const & b)		{ return a._get() != b._get();					}
; 95   : IC bool operator	<	(shared_str const & a, shared_str const & b)		{ return a._get() <  b._get();					}

	cmp	QWORD PTR [r14+rdi*8], rax
	setb	cl

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rax, rax
	je	SHORT $LN76@line_exist
	dec	DWORD PTR [rax]
$LN76@line_exist:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	test	cl, cl
	je	SHORT $LN35@line_exist

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	r14, QWORD PTR [r14+rdi*8]
	sub	rax, rbp
	add	r14, 16
	add	rbx, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN34@line_exist
$LN35@line_exist:

; 2521 : 			_Count = _Count2;

	mov	rbx, rbp
$LN34@line_exist:

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jg	$LL37@line_exist
	mov	rbp, QWORD PTR [rsp+64]
$LN36@line_exist:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	xor	r8d, r8d
	cmp	r14, QWORD PTR [r15+16]
	mov	r15, QWORD PTR [rsp+80]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 315  : 	return (A!=I.Data.end() && xr_strcmp(*A->first,L)==0);

	je	SHORT $LN4@line_exist
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [r14]
	test	rax, rax
	je	SHORT $LN114@line_exist
	add	rax, 12
	jmp	SHORT $LN115@line_exist
$LN114@line_exist:
	mov	rax, r8
$LN115@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	sub	rsi, rax
	npad	7
$LL121@line_exist:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rsi]
	sub	edx, ecx
	jne	SHORT $LN122@line_exist
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL121@line_exist
$LN122@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 315  : 	return (A!=I.Data.end() && xr_strcmp(*A->first,L)==0);

	test	edx, edx
	jne	SHORT $LN4@line_exist
	mov	r8d, 1
$LN4@line_exist:
	mov	eax, r8d
	mov	r14, QWORD PTR [rsp+72]

; 316  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?line_exist@CInifile@@QEAAHPEBD0@Z ENDP			; CInifile::line_exist
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
Sname$ = 56
?line_count@CInifile@@QEAAIPEBD@Z PROC			; CInifile::line_count

; 319  : {

$LN51:
	sub	rsp, 40					; 00000028H

; 320  : 	Sect&	S = r_section(Sname);

	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section

; 321  : 	SectCIt	I = S.Data.begin();
; 322  : 	u32	C = 0;

	xor	r8d, r8d
	mov	r9, QWORD PTR [rax+16]

; 323  : 	for (; I!=S.Data.end(); I++)	if (*I->first) C++;

	mov	rcx, QWORD PTR [rax+8]
	cmp	rcx, r9
	je	SHORT $LN49@line_count
	npad	7
$LL17@line_count:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	je	SHORT $LN3@line_count
	add	rdx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 323  : 	for (; I!=S.Data.end(); I++)	if (*I->first) C++;

	je	SHORT $LN3@line_count
	inc	r8d
$LN3@line_count:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rcx, 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 323  : 	for (; I!=S.Data.end(); I++)	if (*I->first) C++;

	cmp	rcx, r9
	jne	SHORT $LL17@line_count
$LN49@line_count:

; 324  : 	return  C;

	mov	eax, r8d

; 325  : }

	add	rsp, 40					; 00000028H
	ret	0
?line_count@CInifile@@QEAAIPEBD@Z ENDP			; CInifile::line_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 8
S$ = 16
?r_section@CInifile@@QEAAAEAUSect@1@AEBVshared_str@@@Z PROC ; CInifile::r_section
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rdx, QWORD PTR [rdx]
	test	rdx, rdx
	je	SHORT $LN5@r_section
	add	rdx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 329  : CInifile::Sect&	CInifile::r_section		( const shared_str& S	)					{ return	r_section(*S);		}

	jmp	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
$LN5@r_section:
	jmp	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
?r_section@CInifile@@QEAAAEAUSect@1@AEBVshared_str@@@Z ENDP ; CInifile::r_section
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 8
S$ = 16
L$ = 24
?line_exist@CInifile@@QEAAHAEBVshared_str@@0@Z PROC	; CInifile::line_exist
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	r8, QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 330  : BOOL			CInifile::line_exist	( const shared_str& S, const shared_str& L )	{ return	line_exist(*S,*L);	}

	mov	rax, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	xor	edx, edx
	test	r8, r8
	je	SHORT $LN5@line_exist
	add	r8, 12
	jmp	SHORT $LN6@line_exist
$LN5@line_exist:
	mov	r8, rdx
$LN6@line_exist:
	mov	rax, QWORD PTR [rax]
	test	rax, rax
	je	SHORT $LN10@line_exist
	lea	rdx, QWORD PTR [rax+12]
$LN10@line_exist:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 330  : BOOL			CInifile::line_exist	( const shared_str& S, const shared_str& L )	{ return	line_exist(*S,*L);	}

	jmp	?line_exist@CInifile@@QEAAHPEBD0@Z	; CInifile::line_exist
?line_exist@CInifile@@QEAAHAEBVshared_str@@0@Z ENDP	; CInifile::line_exist
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
?line_count@CInifile@@QEAAIAEBVshared_str@@@Z PROC	; CInifile::line_count

; 331  : u32				CInifile::line_count	( const shared_str& S	)					{ return	line_count(*S);		}

$LN57:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rdx]
	xor	ebx, ebx
	lea	rdx, QWORD PTR [rax+12]
	test	rax, rax
	jne	SHORT $LN6@line_count
	mov	edx, ebx
$LN6@line_count:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 320  : 	Sect&	S = r_section(Sname);

	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
	mov	r8, QWORD PTR [rax+16]

; 323  : 	for (; I!=S.Data.end(); I++)	if (*I->first) C++;

	mov	rcx, QWORD PTR [rax+8]
	cmp	rcx, r8
	je	SHORT $LN55@line_count
$LL23@line_count:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	je	SHORT $LN9@line_count
	add	rdx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 323  : 	for (; I!=S.Data.end(); I++)	if (*I->first) C++;

	je	SHORT $LN9@line_count
	inc	ebx
$LN9@line_count:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rcx, 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 323  : 	for (; I!=S.Data.end(); I++)	if (*I->first) C++;

	cmp	rcx, r8
	jne	SHORT $LL23@line_count
$LN55@line_count:

; 331  : u32				CInifile::line_count	( const shared_str& S	)					{ return	line_count(*S);		}

	mov	eax, ebx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?line_count@CInifile@@QEAAIAEBVshared_str@@@Z ENDP	; CInifile::line_count
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 8
S$ = 16
?section_exist@CInifile@@QEAAHAEBVshared_str@@@Z PROC	; CInifile::section_exist
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rdx, QWORD PTR [rdx]
	test	rdx, rdx
	je	SHORT $LN5@section_ex
	add	rdx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 332  : BOOL			CInifile::section_exist	( const shared_str& S	)					{ return	section_exist(*S);	}

	jmp	?section_exist@CInifile@@QEAAHPEBD@Z	; CInifile::section_exist
$LN5@section_ex:
	jmp	?section_exist@CInifile@@QEAAHPEBD@Z	; CInifile::section_exist
?section_exist@CInifile@@QEAAHAEBVshared_str@@@Z ENDP	; CInifile::section_exist
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
section$ = 48
this$ = 320
S$ = 328
?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z PROC		; CInifile::r_section

; 338  : {

$LN100:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 304				; 00000130H
	mov	rbx, rcx
	mov	rbp, rdx

; 339  : 	char	section[256]; strcpy_s(section,sizeof(section),S); strlwr(section);

	mov	r8, rdx
	lea	rcx, QWORD PTR section$[rsp]
	mov	edx, 256				; 00000100H
	call	QWORD PTR __imp_strcpy_s
	lea	rcx, QWORD PTR section$[rsp]
	call	QWORD PTR __imp_strlwr
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rsi, QWORD PTR [rbx+24]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	rdi, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	r10, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	xor	r8d, r8d
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	r10, rdi
	sar	r10, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r10, r10
	jle	SHORT $LN35@r_section
	npad	11
$LL36@r_section:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r10
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r11, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	rbx, QWORD PTR [rdi+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	mov	rax, QWORD PTR [rdi+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rax]
	test	rax, rax
	je	SHORT $LN55@r_section
	add	rax, 12
	jmp	SHORT $LN56@r_section
$LN55@r_section:
	mov	rax, r8
$LN56@r_section:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	lea	r9, QWORD PTR section$[rsp]
	sub	r9, rax
	npad	1
$LL96@r_section:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r9]
	sub	edx, ecx
	jne	SHORT $LN97@r_section
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL96@r_section
$LN97@r_section:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	test	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	jns	SHORT $LN34@r_section

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	rdi, QWORD PTR [rbx+8]
	sub	rax, r11
	add	r10, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN33@r_section
$LN34@r_section:

; 2521 : 			_Count = _Count2;

	mov	r10, r11
$LN33@r_section:

; 2508 : 	while (0 < _Count)

	test	r10, r10
	jg	SHORT $LL36@r_section
$LN35@r_section:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rdi, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 341  : 	if (!(I!=DATA.end() && xr_strcmp(*(*I)->Name,section)==0))

	je	SHORT $LN1@r_section
	mov	rax, QWORD PTR [rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN83@r_section
	lea	r8, QWORD PTR [rcx+12]
$LN83@r_section:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	lea	r9, QWORD PTR section$[rsp]
	sub	r9, r8
	npad	5
$LL94@r_section:
	movzx	edx, BYTE PTR [r8]
	movzx	ecx, BYTE PTR [r8+r9]
	sub	edx, ecx
	jne	SHORT $LN95@r_section
	inc	r8
	test	ecx, ecx
	jne	SHORT $LL94@r_section
$LN95@r_section:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 341  : 	if (!(I!=DATA.end() && xr_strcmp(*(*I)->Name,section)==0))

	test	edx, edx
	je	SHORT $LN2@r_section
$LN1@r_section:

; 342  : 		Debug.fatal(DEBUG_INFO,"Can't open section '%s'",S);

	lea	rax, OFFSET FLAT:??_C@_0BI@PGHMEHEA@Can?8t?5open?5section?5?8?$CFs?8?$AA@
	lea	r9, OFFSET FLAT:??_C@_0BE@BCNJJKHP@CInifile?3?3r_section?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	r8d, 342				; 00000156H
	mov	QWORD PTR [rsp+40], rbp
	mov	QWORD PTR [rsp+32], rax
	call	?fatal@xrDebug@@QEAAXPEBDH00ZZ		; xrDebug::fatal

; 343  : 	return	**I;

	mov	rax, QWORD PTR [rdi]
$LN2@r_section:

; 344  : }

	lea	r11, QWORD PTR [rsp+304]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ENDP		; CInifile::r_section
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
token_list$ = 72
?r_token@CInifile@@QEAAHPEBD0PEBUxr_token@@@Z PROC	; CInifile::r_token

; 476  : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rsi, r9

; 477  : 	LPCSTR		C = r_string(S,L);

	call	?r_string@CInifile@@QEAAPEBDPEBD0@Z	; CInifile::r_string

; 478  : 	for( int i=0; token_list[i].name; i++ )

	xor	edi, edi
	mov	rbp, rax
	cmp	QWORD PTR [rsi], rdi
	je	SHORT $LN2@r_token
	mov	ebx, edi
	mov	rcx, rsi
	npad	5
$LL4@r_token:

; 479  : 		if( !stricmp(C,token_list[i].name) )

	mov	rdx, QWORD PTR [rcx]
	mov	rcx, rbp
	call	QWORD PTR __imp_stricmp
	test	eax, eax
	je	SHORT $LN8@r_token

; 478  : 	for( int i=0; token_list[i].name; i++ )

	inc	rbx
	inc	edi
	mov	rcx, rbx
	shl	rcx, 4
	add	rcx, rsi
	cmp	QWORD PTR [rcx], 0
	jne	SHORT $LL4@r_token
$LN2@r_token:

; 481  : 	return 0;

	xor	eax, eax
$LN5@r_token:

; 482  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN8@r_token:

; 480  : 			return token_list[i].id;

	movsxd	rax, edi
	add	rax, rax
	mov	eax, DWORD PTR [rsi+rax*8+8]
	jmp	SHORT $LN5@r_token
?r_token@CInifile@@QEAAHPEBD0PEBUxr_token@@@Z ENDP	; CInifile::r_token
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
N$ = 72
V$ = 80
?r_line@CInifile@@QEAAHPEBDHPEAPEBD1@Z PROC		; CInifile::r_line

; 484  : {

$LN69:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, r9
	mov	ebx, r8d

; 485  : 	Sect&	SS = r_section(S);

	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+16]
	sub	rcx, QWORD PTR [rax+8]
	sar	rcx, 4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 486  : 	if (L>=(int)SS.Data.size() || L<0 ) return FALSE;

	cmp	ebx, ecx
	jge	SHORT $LN5@r_line
	test	ebx, ebx
	js	SHORT $LN5@r_line

; 487  : 	for (SectCIt I=SS.Data.begin(); I!=SS.Data.end(); I++)

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rcx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 487  : 	for (SectCIt I=SS.Data.begin(); I!=SS.Data.end(); I++)

	je	SHORT $LN5@r_line
$LL23@r_line:

; 488  : 		if (!(L--)){

	mov	eax, ebx
	dec	ebx
	test	eax, eax
	je	SHORT $LN64@r_line
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rcx, 16

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rcx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 487  : 	for (SectCIt I=SS.Data.begin(); I!=SS.Data.end(); I++)

	jne	SHORT $LL23@r_line
$LN5@r_line:

; 486  : 	if (L>=(int)SS.Data.size() || L<0 ) return FALSE;

	xor	eax, eax

; 491  : 			return TRUE;
; 492  : 		}
; 493  : 	return FALSE;
; 494  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN64@r_line:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rcx]
	xor	edx, edx
	test	rax, rax
	je	SHORT $LN49@r_line
	add	rax, 12
	jmp	SHORT $LN50@r_line
$LN49@r_line:
	mov	rax, rdx
$LN50@r_line:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 489  : 			*N = *I->first;

	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN61@r_line
	lea	rdx, QWORD PTR [rax+12]
$LN61@r_line:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 490  : 			*V = *I->second;

	mov	rax, QWORD PTR V$[rsp]

; 491  : 			return TRUE;
; 492  : 		}
; 493  : 	return FALSE;
; 494  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rax], rdx
	mov	eax, 1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?r_line@CInifile@@QEAAHPEBDHPEAPEBD1@Z ENDP		; CInifile::r_line
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 48
S$ = 56
L$ = 64
N$ = 72
V$ = 80
?r_line@CInifile@@QEAAHAEBVshared_str@@HPEAPEBD1@Z PROC	; CInifile::r_line

; 496  : {

$LN75:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rdx]
	xor	edi, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 496  : {

	mov	rsi, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	lea	rdx, QWORD PTR [rax+12]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 496  : {

	mov	ebx, r8d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	rax, rax
	jne	SHORT $LN6@r_line
	mov	edx, edi
$LN6@r_line:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 485  : 	Sect&	SS = r_section(S);

	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rcx, QWORD PTR [rax+16]
	sub	rcx, QWORD PTR [rax+8]
	sar	rcx, 4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 486  : 	if (L>=(int)SS.Data.size() || L<0 ) return FALSE;

	cmp	ebx, ecx
	jge	SHORT $LN11@r_line
	test	ebx, ebx
	js	SHORT $LN11@r_line

; 487  : 	for (SectCIt I=SS.Data.begin(); I!=SS.Data.end(); I++)

	mov	rcx, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rcx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 487  : 	for (SectCIt I=SS.Data.begin(); I!=SS.Data.end(); I++)

	je	SHORT $LN11@r_line
	npad	5
$LL29@r_line:

; 488  : 		if (!(L--)){

	mov	eax, ebx
	dec	ebx
	test	eax, eax
	je	SHORT $LN70@r_line
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 112  : 		++this->_Ptr;

	add	rcx, 16

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rcx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 487  : 	for (SectCIt I=SS.Data.begin(); I!=SS.Data.end(); I++)

	jne	SHORT $LL29@r_line
$LN11@r_line:

; 497  : 	return r_line(*S,L,N,V);

	mov	eax, edi

; 498  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN70@r_line:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN55@r_line
	add	rax, 12
	jmp	SHORT $LN56@r_line
$LN55@r_line:
	mov	rax, rdi
$LN56@r_line:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 489  : 			*N = *I->first;

	mov	QWORD PTR [rsi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN67@r_line
	lea	rdi, QWORD PTR [rax+12]
$LN67@r_line:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 490  : 			*V = *I->second;

	mov	rax, QWORD PTR V$[rsp]

; 498  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]

; 490  : 			*V = *I->second;

	mov	QWORD PTR [rax], rdi

; 497  : 	return r_line(*S,L,N,V);

	mov	eax, 1

; 498  : }

	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?r_line@CInifile@@QEAAHAEBVshared_str@@HPEAPEBD1@Z ENDP	; CInifile::r_line
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
I$ = 80
NEW$1 = 80
$T2 = 96
$T3 = 96
sect$ = 112
line$ = 368
value$ = 624
this$ = 928
S$ = 936
L$ = 944
V$ = 952
comment$ = 960
?w_string@CInifile@@QEAAXPEBD000@Z PROC			; CInifile::w_string

; 504  : {

$LN318:
	mov	rax, rsp
	push	rsi
	sub	rsp, 912				; 00000390H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rdi
	mov	QWORD PTR [rax-24], r13
	mov	QWORD PTR [rax-32], r14
	mov	QWORD PTR [rax-40], r15

; 505  : 	R_ASSERT	(!bReadOnly);

	xor	r15d, r15d
	mov	rbp, r9
	mov	r14, r8
	cmp	BYTE PTR ?ignore_always@?3??w_string@CInifile@@QEAAXPEBD000@Z@4_NA, r15b
	mov	rbx, rdx
	mov	rsi, rcx
	jne	SHORT $LN8@w_string
	cmp	DWORD PTR [rcx+40], r15d
	je	SHORT $LN8@w_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3??w_string@CInifile@@QEAAXPEBD000@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0L@MCBJLICI@?$CBbReadOnly?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	mov	QWORD PTR [rsp+64], rax
	lea	rax, OFFSET FLAT:??_C@_0BD@HEABFKIK@CInifile?3?3w_string?$AA@
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	mov	QWORD PTR [rsp+56], rax
	lea	rax, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 505			; 000001f9H
	mov	QWORD PTR [rsp+40], rax
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], r15
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN8@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 509  : 	_parse	(sect,S);

	lea	rcx, QWORD PTR sect$[rsp]
	mov	rdx, rbx
	call	?_parse@@YAXPEADPEBD@Z			; _parse

; 510  : 	_strlwr	(sect);

	lea	rcx, QWORD PTR sect$[rsp]
	call	QWORD PTR __imp__strlwr

; 511  : 	if (!section_exist(sect))	{

	lea	rdx, QWORD PTR sect$[rsp]
	mov	rcx, rsi
	call	?section_exist@CInifile@@QEAAHPEBD@Z	; CInifile::section_exist
	test	eax, eax
	jne	$LN101@w_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	edx, QWORD PTR [rax+32]
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	rbx, rax

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN16@w_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	mov	QWORD PTR [rax], r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	QWORD PTR NEW$1[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rax+8], r15

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rax+16], r15

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rax+24], r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	jmp	SHORT $LN17@w_string
$LN16@w_string:
	mov	rbx, r15
	mov	QWORD PTR NEW$1[rsp], rbx
$LN17@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	lea	rdx, QWORD PTR sect$[rsp]
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN36@w_string
	inc	DWORD PTR [rax]
$LN36@w_string:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN39@w_string
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rbx]
	cmp	DWORD PTR [rcx], r15d
	jne	SHORT $LN39@w_string
	mov	QWORD PTR [rbx], r15
$LN39@w_string:

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	rbx, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	r8, QWORD PTR [rsi+24]
	sub	r8, rbx
	sar	r8, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r8, r8
	jle	SHORT $LN73@w_string
	npad	11
$LL74@w_string:

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r8
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	r11, QWORD PTR [rbx+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	mov	rcx, QWORD PTR [r11]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN93@w_string
	add	rcx, 12
	jmp	SHORT $LN94@w_string
$LN93@w_string:
	mov	rcx, r15
$LN94@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	lea	r9, QWORD PTR sect$[rsp]
	sub	r9, rcx
	npad	2
$LL315@w_string:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r9]
	sub	edx, eax
	jne	SHORT $LN316@w_string
	inc	rcx
	test	eax, eax
	jne	SHORT $LL315@w_string
$LN316@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	test	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	jns	SHORT $LN72@w_string

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	rbx, QWORD PTR [r11+8]
	sub	rax, r10
	add	r8, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN71@w_string
$LN72@w_string:

; 2521 : 			_Count = _Count2;

	mov	r8, r10
$LN71@w_string:

; 2508 : 	while (0 < _Count)

	test	r8, r8
	jg	SHORT $LL74@w_string
$LN73@w_string:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	lea	rax, QWORD PTR NEW$1[rsp]
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR [rsi+16]
	mov	r8, rbx
	mov	QWORD PTR [rsp+32], rax
	call	?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n
$LN101@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 520  : 	char	line	[256];	_parse	(line,L);

	lea	rcx, QWORD PTR line$[rsp]
	mov	rdx, r14
	call	?_parse@@YAXPEADPEBD@Z			; _parse

; 521  : 	char	value	[256];	_parse	(value,V);

	lea	rcx, QWORD PTR value$[rsp]
	mov	rdx, rbp
	call	?_parse@@YAXPEADPEBD@Z			; _parse
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	xor	edx, edx
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	rdi, rax
	test	rax, rax
	je	SHORT $LN107@w_string
	inc	DWORD PTR [rax]
$LN107@w_string:
	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	xor	edx, edx
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN116@w_string
	inc	DWORD PTR [rax]
$LN116@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 525  : 	Sect&	data	= r_section	(sect);

	lea	rdx, QWORD PTR sect$[rsp]
	mov	rcx, rsi
	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section

; 526  : 	I.first			= (line[0]?line:0);

	cmp	BYTE PTR line$[rsp], r15b
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 526  : 	I.first			= (line[0]?line:0);

	lea	rdx, QWORD PTR line$[rsp]
	mov	r13, rax
	cmove	rdx, r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	rsi, rax
	test	rax, rax
	je	SHORT $LN125@w_string
	inc	DWORD PTR [rax]
$LN125@w_string:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rdi, rdi
	je	SHORT $LN128@w_string
	dec	DWORD PTR [rdi]
$LN128@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 527  : 	I.second		= (value[0]?value:0);

	cmp	BYTE PTR value$[rsp], r15b
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 527  : 	I.second		= (value[0]?value:0);

	lea	rdx, QWORD PTR value$[rsp]
	cmove	rdx, r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR I$[rsp], rax
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	rbp, rax
	test	rax, rax
	je	SHORT $LN134@w_string
	inc	DWORD PTR [rax]
$LN134@w_string:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rbx, rbx
	je	SHORT $LN137@w_string
	dec	DWORD PTR [rbx]
$LN137@w_string:
	mov	QWORD PTR [rsp+904], r12

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	QWORD PTR I$[rsp+8], rax

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	lea	r12, QWORD PTR [rsi+12]
	test	rsi, rsi
	jne	SHORT $LN144@w_string
	mov	r12, r15
$LN144@w_string:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	rdi, QWORD PTR [r13+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rbx, QWORD PTR [r13+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 531  : 	SectIt_	it		= std::lower_bound(data.Data.begin(),data.Data.end(),*I.first,item_pred);

	lea	r9, QWORD PTR [r13+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	rbx, rdi
	sar	rbx, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jle	$LN175@w_string
	npad	10
$LL176@w_string:

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	mov	r14, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	r15, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	add	r14, r14
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	mov	rcx, QWORD PTR [rdi+r14*8]
	test	rcx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 21   :     if ((!x.first) || (!val))	return x.first<val;

	je	SHORT $LN192@w_string
	test	r12, r12
	je	SHORT $LN192@w_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	add	rcx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, r12
	sub	r8, rcx
	npad	4
$LL313@w_string:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN314@w_string
	inc	rcx
	test	eax, eax
	jne	SHORT $LL313@w_string
$LN314@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 22   :     else				   		return xr_strcmp(*x.first,val)<0;

	test	edx, edx
	sets	cl
	jmp	SHORT $LN215@w_string
$LN192@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	mov	rdx, r12
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN203@w_string
	inc	DWORD PTR [rax]
$LN203@w_string:

; 67   : 	char				operator[]	(size_t id)						{	return p_->value[id];							}
; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}
; 69   : 
; 70   : 	// misc func
; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}
; 72   : 	void				swap		(shared_str & rhs)				{	str_value* tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}
; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}
; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}
; 94   : IC bool operator	!=	(shared_str const & a, shared_str const & b)		{ return a._get() != b._get();					}
; 95   : IC bool operator	<	(shared_str const & a, shared_str const & b)		{ return a._get() <  b._get();					}

	cmp	QWORD PTR [rdi+r14*8], rax
	setb	cl

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rax, rax
	je	SHORT $LN215@w_string
	dec	DWORD PTR [rax]
$LN215@w_string:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	test	cl, cl
	je	SHORT $LN174@w_string

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	rdi, QWORD PTR [rdi+r14*8]
	sub	rax, r15
	add	rdi, 16
	add	rbx, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN173@w_string
$LN174@w_string:

; 2521 : 			_Count = _Count2;

	mov	rbx, r15
$LN173@w_string:

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jg	$LL176@w_string
	lea	r9, QWORD PTR [r13+8]
	xor	r15d, r15d
$LN175@w_string:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	rdi, QWORD PTR [r13+16]
	mov	r14, QWORD PTR [rsp+888]
	mov	r12, QWORD PTR [rsp+904]
	mov	r13, QWORD PTR [rsp+896]
	mov	rbx, QWORD PTR [rsp+928]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 533  :     if (it != data.Data.end()) {

	je	SHORT $LN4@w_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	lea	r8, QWORD PTR [rsi+12]
	test	rsi, rsi
	jne	SHORT $LN246@w_string
	mov	r8, r15
$LN246@w_string:
	mov	rax, QWORD PTR [rdi]
	test	rax, rax
	je	SHORT $LN259@w_string
	add	rax, 12
	jmp	SHORT $LN260@w_string
$LN259@w_string:
	mov	rax, r15
$LN260@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	sub	r8, rax
	npad	1
$LL311@w_string:
	movzx	edx, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+r8]
	sub	edx, ecx
	jne	SHORT $LN312@w_string
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL311@w_string
$LN312@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 535  :     	if (0==xr_strcmp(*it->first,*I.first)) {

	test	edx, edx
	jne	SHORT $LN4@w_string
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	test	rsi, rsi
	je	SHORT $LN271@w_string
	inc	DWORD PTR [rsi]
$LN271@w_string:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rdi]
	test	rax, rax
	je	SHORT $LN274@w_string
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rdi]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN274@w_string
	mov	QWORD PTR [rdi], r15
$LN274@w_string:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rdi], rsi
	test	rbp, rbp
	je	SHORT $LN280@w_string
	inc	DWORD PTR [rbp]
$LN280@w_string:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rdi+8]
	test	rax, rax
	je	SHORT $LN283@w_string
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rdi+8]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN283@w_string
	mov	QWORD PTR [rdi+8], r15
$LN283@w_string:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rdi+8], rbp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 537  :         } else {

	jmp	SHORT $LN289@w_string
$LN4@w_string:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	lea	rax, QWORD PTR I$[rsp]
	lea	rdx, QWORD PTR $T2[rsp]
	mov	r8, rdi
	mov	rcx, r9
	mov	QWORD PTR [rsp+32], rax
	call	?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n
$LN289@w_string:
	mov	r15, QWORD PTR [rsp+880]
	mov	rdi, QWORD PTR [rsp+944]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rbp, rbp
	je	SHORT $LN295@w_string
	dec	DWORD PTR [rbp]
$LN295@w_string:
	mov	rbp, QWORD PTR [rsp+936]
	test	rsi, rsi
	je	SHORT $LN301@w_string
	dec	DWORD PTR [rsi]
$LN301@w_string:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 543  : }

	add	rsp, 912				; 00000390H
	pop	rsi
	ret	0
?w_string@CInifile@@QEAAXPEBD000@Z ENDP			; CInifile::w_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_u8@CInifile@@QEAAXPEBD0E0@Z PROC			; CInifile::w_u8

; 545  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 546  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d",V);

	lea	r8, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	movzx	r9d, r9b
	mov	edx, 128				; 00000080H
	call	QWORD PTR __imp_sprintf_s

; 547  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 548  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_u8@CInifile@@QEAAXPEBD0E0@Z ENDP			; CInifile::w_u8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_u16@CInifile@@QEAAXPEBD0G0@Z PROC			; CInifile::w_u16

; 550  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 551  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d",V);

	lea	r8, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	movzx	r9d, r9w
	mov	edx, 128				; 00000080H
	call	QWORD PTR __imp_sprintf_s

; 552  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 553  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_u16@CInifile@@QEAAXPEBD0G0@Z ENDP			; CInifile::w_u16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_u32@CInifile@@QEAAXPEBD0I0@Z PROC			; CInifile::w_u32

; 555  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 556  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d",V);

	lea	r8, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	call	QWORD PTR __imp_sprintf_s

; 557  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 558  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_u32@CInifile@@QEAAXPEBD0I0@Z ENDP			; CInifile::w_u32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_s8@CInifile@@QEAAXPEBD0C0@Z PROC			; CInifile::w_s8

; 560  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 561  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d",V);

	lea	r8, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	movsx	r9d, r9b
	mov	edx, 128				; 00000080H
	call	QWORD PTR __imp_sprintf_s

; 562  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 563  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_s8@CInifile@@QEAAXPEBD0C0@Z ENDP			; CInifile::w_s8
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_s16@CInifile@@QEAAXPEBD0F0@Z PROC			; CInifile::w_s16

; 565  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 566  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d",V);

	lea	r8, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	movsx	r9d, r9w
	mov	edx, 128				; 00000080H
	call	QWORD PTR __imp_sprintf_s

; 567  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 568  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_s16@CInifile@@QEAAXPEBD0F0@Z ENDP			; CInifile::w_s16
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_s32@CInifile@@QEAAXPEBD0H0@Z PROC			; CInifile::w_s32

; 570  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 571  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d",V);

	lea	r8, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	call	QWORD PTR __imp_sprintf_s

; 572  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 573  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_s32@CInifile@@QEAAXPEBD0H0@Z ENDP			; CInifile::w_s32
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_float@CInifile@@QEAAXPEBD0M0@Z PROC			; CInifile::w_float

; 575  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H

; 576  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%f",V);

	cvtss2sd xmm3, xmm3
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx
	lea	r8, OFFSET FLAT:??_C@_02NJPGOMH@?$CFf?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	movd	r9, xmm3
	mov	edx, 128				; 00000080H
	call	QWORD PTR __imp_sprintf_s

; 577  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 578  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_float@CInifile@@QEAAXPEBD0M0@Z ENDP			; CInifile::w_float
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 64
this$ = 208
S$ = 216
L$ = 224
V$ = 232
comment$ = 240
?w_fcolor@CInifile@@QEAAXPEBD0AEBU?$_color@M@@0@Z PROC	; CInifile::w_fcolor

; 580  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H
	movss	xmm3, DWORD PTR [r9]
	movss	xmm0, DWORD PTR [r9+12]
	movss	xmm1, DWORD PTR [r9+8]
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 581  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%f,%f,%f,%f", V.r, V.g, V.b, V.a);

	lea	r8, OFFSET FLAT:??_C@_0M@JJJBFJKB@?$CFf?0?$CFf?0?$CFf?0?$CFf?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	movss	xmm2, DWORD PTR [r9+4]
	cvtps2pd xmm3, xmm3
	cvtps2pd xmm0, xmm0
	movd	r9, xmm3
	movsdx	QWORD PTR [rsp+48], xmm0
	cvtps2pd xmm1, xmm1
	cvtps2pd xmm2, xmm2
	movsdx	QWORD PTR [rsp+40], xmm1
	movsdx	QWORD PTR [rsp+32], xmm2
	call	QWORD PTR __imp_sprintf_s

; 582  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 583  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_fcolor@CInifile@@QEAAXPEBD0AEBU?$_color@M@@0@Z ENDP	; CInifile::w_fcolor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 64
this$ = 208
S$ = 216
L$ = 224
V$ = 232
comment$ = 240
?w_color@CInifile@@QEAAXPEBD0I0@Z PROC			; CInifile::w_color

; 586  : {

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 587  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d,%d,%d,%d", color_get_R(V), color_get_G(V), color_get_B(V), color_get_A(V));

	mov	eax, r9d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	mov	ebx, r9d

; 19   : ICF	u32	color_get_B	(u32 rgba)						{	return ((rgba) & 0xff);			}

	movzx	r11d, r9b
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 587  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d,%d,%d,%d", color_get_R(V), color_get_G(V), color_get_B(V), color_get_A(V));

	shr	eax, 8
	mov	rdi, r8
	mov	rbp, rcx
	shr	r9d, 16
	mov	rsi, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h

; 18   : ICF	u32	color_get_G	(u32 rgba)						{	return (((rgba) >> 8) & 0xff);	}

	movzx	r10d, al

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	shr	ebx, 24
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 587  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d,%d,%d,%d", color_get_R(V), color_get_G(V), color_get_B(V), color_get_A(V));

	lea	r8, OFFSET FLAT:??_C@_0M@MLCONGPP@?$CFd?0?$CFd?0?$CFd?0?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	DWORD PTR [rsp+48], ebx
	mov	DWORD PTR [rsp+40], r11d
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h

; 17   : ICF	u32	color_get_R	(u32 rgba)						{	return (((rgba) >> 16) & 0xff);	}

	movzx	r9d, r9b
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 587  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d,%d,%d,%d", color_get_R(V), color_get_G(V), color_get_B(V), color_get_A(V));

	mov	edx, 128				; 00000080H
	mov	DWORD PTR [rsp+32], r10d
	call	QWORD PTR __imp_sprintf_s

; 588  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, rbp
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 589  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_color@CInifile@@QEAAXPEBD0I0@Z ENDP			; CInifile::w_color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_ivector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@H@@0@Z PROC ; CInifile::w_ivector2

; 592  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H

; 593  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d,%d", V.x, V.y);

	mov	eax, DWORD PTR [r9+4]
	mov	r9d, DWORD PTR [r9]
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx
	lea	r8, OFFSET FLAT:??_C@_05KABNCBHK@?$CFd?0?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR __imp_sprintf_s

; 594  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 595  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_ivector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@H@@0@Z ENDP ; CInifile::w_ivector2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_ivector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@H@@0@Z PROC ; CInifile::w_ivector3

; 598  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H

; 599  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d,%d,%d", V.x, V.y, V.z);

	mov	eax, DWORD PTR [r9+8]
	mov	rbx, r8
	mov	rsi, rcx
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r9+4]
	mov	r9d, DWORD PTR [r9]
	mov	rdi, rdx
	lea	r8, OFFSET FLAT:??_C@_08GDAMKODC@?$CFd?0?$CFd?0?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR __imp_sprintf_s

; 600  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 601  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_ivector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@H@@0@Z ENDP ; CInifile::w_ivector3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 64
this$ = 208
S$ = 216
L$ = 224
V$ = 232
comment$ = 240
?w_ivector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@H@@0@Z PROC ; CInifile::w_ivector4

; 604  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 605  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%d,%d,%d,%d", V.x, V.y, V.z, V.w);

	mov	eax, DWORD PTR [r9+12]
	mov	rbx, r8
	mov	rsi, rcx
	mov	DWORD PTR [rsp+48], eax
	mov	eax, DWORD PTR [r9+8]
	mov	rdi, rdx
	mov	DWORD PTR [rsp+40], eax
	mov	eax, DWORD PTR [r9+4]
	mov	r9d, DWORD PTR [r9]
	lea	r8, OFFSET FLAT:??_C@_0M@MLCONGPP@?$CFd?0?$CFd?0?$CFd?0?$CFd?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	mov	DWORD PTR [rsp+32], eax
	call	QWORD PTR __imp_sprintf_s

; 606  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 607  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_ivector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@H@@0@Z ENDP ; CInifile::w_ivector4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_fvector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@M@@0@Z PROC ; CInifile::w_fvector2

; 609  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	movss	xmm3, DWORD PTR [r9]
	movss	xmm0, DWORD PTR [r9+4]
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 610  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%f,%f", V.x, V.y);

	lea	r8, OFFSET FLAT:??_C@_05OIOLBAJI@?$CFf?0?$CFf?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	cvtps2pd xmm3, xmm3
	cvtps2pd xmm0, xmm0
	movd	r9, xmm3
	movsdx	QWORD PTR [rsp+32], xmm0
	call	QWORD PTR __imp_sprintf_s

; 611  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 612  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_fvector2@CInifile@@QEAAXPEBD0AEBU?$_vector2@M@@0@Z ENDP ; CInifile::w_fvector2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 48
this$ = 192
S$ = 200
L$ = 208
V$ = 216
comment$ = 224
?w_fvector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@M@@0@Z PROC ; CInifile::w_fvector3

; 615  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 176				; 000000b0H
	movss	xmm3, DWORD PTR [r9]
	movss	xmm0, DWORD PTR [r9+8]
	movss	xmm1, DWORD PTR [r9+4]
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 616  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%f,%f,%f", V.x, V.y, V.z);

	lea	r8, OFFSET FLAT:??_C@_08GJNPJIKN@?$CFf?0?$CFf?0?$CFf?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	cvtps2pd xmm3, xmm3
	cvtps2pd xmm0, xmm0
	cvtps2pd xmm1, xmm1
	movd	r9, xmm3
	movsdx	QWORD PTR [rsp+40], xmm0
	movsdx	QWORD PTR [rsp+32], xmm1
	call	QWORD PTR __imp_sprintf_s

; 617  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 618  : }

	lea	r11, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_fvector3@CInifile@@QEAAXPEBD0AEBU?$_vector3@M@@0@Z ENDP ; CInifile::w_fvector3
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
temp$ = 64
this$ = 208
S$ = 216
L$ = 224
V$ = 232
comment$ = 240
?w_fvector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@M@@0@Z PROC ; CInifile::w_fvector4

; 621  : {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H
	movss	xmm3, DWORD PTR [r9]
	movss	xmm0, DWORD PTR [r9+12]
	movss	xmm1, DWORD PTR [r9+8]
	mov	rbx, r8
	mov	rsi, rcx
	mov	rdi, rdx

; 622  : 	string128 temp; sprintf_s		(temp,sizeof(temp),"%f,%f,%f,%f", V.x, V.y, V.z, V.w);

	lea	r8, OFFSET FLAT:??_C@_0M@JJJBFJKB@?$CFf?0?$CFf?0?$CFf?0?$CFf?$AA@
	lea	rcx, QWORD PTR temp$[rsp]
	mov	edx, 128				; 00000080H
	movss	xmm2, DWORD PTR [r9+4]
	cvtps2pd xmm3, xmm3
	cvtps2pd xmm0, xmm0
	movd	r9, xmm3
	movsdx	QWORD PTR [rsp+48], xmm0
	cvtps2pd xmm1, xmm1
	cvtps2pd xmm2, xmm2
	movsdx	QWORD PTR [rsp+40], xmm1
	movsdx	QWORD PTR [rsp+32], xmm2
	call	QWORD PTR __imp_sprintf_s

; 623  : 	w_string	(S,L,temp,comment);

	mov	rax, QWORD PTR comment$[rsp]
	lea	r9, QWORD PTR temp$[rsp]
	mov	r8, rbx
	mov	rdx, rdi
	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], rax
	call	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string

; 624  : }

	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?w_fvector4@CInifile@@QEAAXPEBD0AEBU?$_vector4@M@@0@Z ENDP ; CInifile::w_fvector4
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 8
S$ = 16
L$ = 24
V$ = 32
comment$ = 40
?w_bool@CInifile@@QEAAXPEBD0H0@Z PROC			; CInifile::w_bool

; 627  : {

	mov	eax, r9d

; 628  : 	w_string	(S,L,V?"on":"off",comment);

	lea	r10, OFFSET FLAT:??_C@_02LIELOMNJ@on?$AA@
	lea	r9, OFFSET FLAT:??_C@_03MCADLMAF@off?$AA@
	test	eax, eax
	cmovne	r9, r10
	jmp	?w_string@CInifile@@QEAAXPEBD000@Z	; CInifile::w_string
?w_bool@CInifile@@QEAAXPEBD0H0@Z ENDP			; CInifile::w_bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
_TEXT	SEGMENT
this$ = 128
S$ = 136
L$ = 144
$T1 = 152
?remove_line@CInifile@@QEAAXPEBD0@Z PROC		; CInifile::remove_line

; 632  : {

$LN139:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 633  : 	R_ASSERT	(!bReadOnly);

	cmp	BYTE PTR ?ignore_always@?3??remove_line@CInifile@@QEAAXPEBD0@Z@4_NA, 0
	mov	rbx, rcx
	mov	rsi, r8
	lea	rcx, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	mov	rdi, rdx
	lea	rbp, OFFSET FLAT:??_C@_0BG@HJJEFCMD@CInifile?3?3remove_line?$AA@
	jne	SHORT $LN9@remove_lin
	cmp	DWORD PTR [rbx+40], 0
	je	SHORT $LN9@remove_lin
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?3??remove_line@CInifile@@QEAAXPEBD0@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0L@MCBJLICI@?$CBbReadOnly?$AA@
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], rbp
	mov	DWORD PTR [rsp+48], 633			; 00000279H
	mov	QWORD PTR [rsp+40], rcx
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN9@remove_lin:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 635  :     if (line_exist(S,L)){

	mov	r8, rsi
	mov	rdx, rdi
	mov	rcx, rbx
	call	?line_exist@CInifile@@QEAAHPEBD0@Z	; CInifile::line_exist
	test	eax, eax
	je	$LN6@remove_lin

; 636  : 		Sect&	data	= r_section	(S);

	mov	QWORD PTR [rsp+128], r12
	mov	rdx, rdi
	mov	rcx, rbx
	mov	QWORD PTR [rsp+136], r14
	mov	QWORD PTR [rsp+80], r15
	call	?r_section@CInifile@@QEAAAEAUSect@1@PEBD@Z ; CInifile::r_section
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2535 : 			_Dist_type(_First))));

	mov	r14, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	mov	rbx, QWORD PTR [rax+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 636  : 		Sect&	data	= r_section	(S);

	mov	r15, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	rbx, r14
	sar	rbx, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jle	$LN45@remove_lin
	npad	12
$LL46@remove_lin:

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, rbx
	cdq
	sub	rax, rdx
	sar	rax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rbp, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	add	rdi, rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	mov	rcx, QWORD PTR [r14+rdi*8]
	test	rcx, rcx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 21   :     if ((!x.first) || (!val))	return x.first<val;

	je	SHORT $LN62@remove_lin
	test	rsi, rsi
	je	SHORT $LN62@remove_lin
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	add	rcx, 12
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rsi
	sub	r8, rcx
	npad	4
$LL136@remove_lin:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN137@remove_lin
	inc	rcx
	test	eax, eax
	jne	SHORT $LL136@remove_lin
$LN137@remove_lin:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 22   :     else				   		return xr_strcmp(*x.first,val)<0;

	test	edx, edx
	sets	cl
	jmp	SHORT $LN85@remove_lin
$LN62@remove_lin:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
	mov	rdx, rsi
	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	test	rax, rax
	je	SHORT $LN73@remove_lin
	inc	DWORD PTR [rax]
$LN73@remove_lin:

; 67   : 	char				operator[]	(size_t id)						{	return p_->value[id];							}
; 68   : 	str_c				c_str		() const						{	return p_?p_->value:0;							}
; 69   : 
; 70   : 	// misc func
; 71   : 	u32					size		()						const	{	if (0==p_) return 0; else return p_->dwLength;	}
; 72   : 	void				swap		(shared_str & rhs)				{	str_value* tmp = p_; p_ = rhs.p_; rhs.p_ = tmp;	}
; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}
; 74   :     shared_str& __cdecl	sprintf		(const char* format, ...)		{
; 75   : 		string4096 	buf;
; 76   : 		va_list		p;
; 77   : 		va_start	(p,format);
; 78   : 		int vs_sz	= _vsnprintf(buf,sizeof(buf)-1,format,p); buf[sizeof(buf)-1]=0;
; 79   : 		va_end		(p);
; 80   : 		if (vs_sz)	_set(buf);	
; 81   : 		return 		(shared_str&)*this;
; 82   : 	}
; 83   : };
; 84   : 
; 85   : // res_ptr == res_ptr
; 86   : // res_ptr != res_ptr
; 87   : // const res_ptr == ptr
; 88   : // const res_ptr != ptr
; 89   : // ptr == const res_ptr
; 90   : // ptr != const res_ptr
; 91   : // res_ptr < res_ptr
; 92   : // res_ptr > res_ptr
; 93   : IC bool operator	==	(shared_str const & a, shared_str const & b)		{ return a._get() == b._get();					}
; 94   : IC bool operator	!=	(shared_str const & a, shared_str const & b)		{ return a._get() != b._get();					}
; 95   : IC bool operator	<	(shared_str const & a, shared_str const & b)		{ return a._get() <  b._get();					}

	cmp	QWORD PTR [r14+rdi*8], rax
	setb	cl

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rax, rax
	je	SHORT $LN85@remove_lin
	dec	DWORD PTR [rax]
$LN85@remove_lin:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	test	cl, cl
	je	SHORT $LN44@remove_lin

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	r14, QWORD PTR [r14+rdi*8]
	sub	rax, rbp
	add	r14, 16
	add	rbx, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN43@remove_lin
$LN44@remove_lin:

; 2521 : 			_Count = _Count2;

	mov	rbx, rbp
$LN43@remove_lin:

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jg	$LL46@remove_lin
	lea	rbp, OFFSET FLAT:??_C@_0BG@HJJEFCMD@CInifile?3?3remove_line?$AA@
$LN45@remove_lin:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 638  :     	R_ASSERT(A!=data.Data.end() && xr_strcmp(*A->first,L)==0);

	cmp	BYTE PTR ?ignore_always@?L@??remove_line@CInifile@@QEAAXPEBD0@Z@4_NA, 0
	jne	$LN4@remove_lin
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 205  : 		return (this->_Ptr == _Right._Ptr);

	cmp	r14, QWORD PTR [r15+16]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 638  :     	R_ASSERT(A!=data.Data.end() && xr_strcmp(*A->first,L)==0);

	je	SHORT $LN1@remove_lin
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rax, QWORD PTR [r14]
	test	rax, rax
	je	SHORT $LN126@remove_lin
	add	rax, 12
$LN126@remove_lin:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	sub	rsi, rax
	npad	5
$LL134@remove_lin:
	movzx	r8d, BYTE PTR [rax]
	movzx	ecx, BYTE PTR [rax+rsi]
	sub	r8d, ecx
	jne	SHORT $LN135@remove_lin
	inc	rax
	test	ecx, ecx
	jne	SHORT $LL134@remove_lin
$LN135@remove_lin:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 638  :     	R_ASSERT(A!=data.Data.end() && xr_strcmp(*A->first,L)==0);

	test	r8d, r8d
	je	SHORT $LN4@remove_lin
$LN1@remove_lin:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrdebugnew.cpp

; 452  : 	backend		("assertion failed",e1,0,0,file,line,function,ignore_always);

	lea	rax, OFFSET FLAT:?ignore_always@?L@??remove_line@CInifile@@QEAAXPEBD0@Z@4_NA
	lea	r8, OFFSET FLAT:??_C@_0DA@GAFJJPBK@A?$CB?$DNdata?4Data?4end?$CI?$CJ?5?$CG?$CG?5xr_strcmp?$CI@
	lea	rdx, OFFSET FLAT:??_C@_0BB@DBHFCHNO@assertion?5failed?$AA@
	mov	QWORD PTR [rsp+64], rax
	mov	QWORD PTR [rsp+56], rbp
	lea	rax, OFFSET FLAT:??_C@_0L@BOCIKDOE@Xr_ini?4cpp?$AA@
	mov	DWORD PTR [rsp+48], 638			; 0000027eH
	mov	QWORD PTR [rsp+40], rax
	lea	rcx, OFFSET FLAT:?Debug@@3VxrDebug@@A	; Debug
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], 0
	call	?backend@xrDebug@@QEAAXPEBD0000H0AEA_N@Z ; xrDebug::backend
$LN4@remove_lin:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 639  :         data.Data.erase(A);

	lea	rdx, QWORD PTR $T1[rsp]
	lea	rcx, QWORD PTR [r15+8]
	mov	r8, r14
	call	?erase@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::erase
	mov	r15, QWORD PTR [rsp+80]
	mov	r14, QWORD PTR [rsp+136]
	mov	r12, QWORD PTR [rsp+128]
$LN6@remove_lin:

; 640  :     }
; 641  : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?remove_line@CInifile@@QEAAXPEBD0@Z ENDP		; CInifile::remove_line
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ?size@?$xr_vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@@QEBAIXZ
_TEXT	SEGMENT
this$ = 8
?size@?$xr_vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@@QEBAIXZ PROC ; xr_vector<CInifile::Item,xalloc<CInifile::Item> >::size, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 4
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 125  : 	u32		size				() const							{ return (u32)inherited::size();} 

	ret	0
?size@?$xr_vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@@QEBAIXZ ENDP ; xr_vector<CInifile::Item,xalloc<CInifile::Item> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@XZ PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@XZ ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@XZ PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@XZ ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?insert@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@AEBUItem@CInifile@@@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Where$ = 80
_Val$ = 88
?insert@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@AEBUItem@CInifile@@@Z PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::insert, COMDAT

; 1327 : 		{	// insert _Val at _Where

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	mov	QWORD PTR [rsp+32], r9
	call	?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n
	mov	rax, rbx

; 1329 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?insert@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@AEBUItem@CInifile@@@Z ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?erase@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?erase@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::erase, COMDAT

; 1452 : 		{	// erase element at where

$LN119:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+32], rdi

; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));

	mov	r11, QWORD PTR [rcx+8]
	lea	r10, QWORD PTR [r8+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1452 : 		{	// erase element at where

	mov	QWORD PTR [rsp+24], r8
	mov	rdi, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	r10, r11
	je	SHORT $LN7@erase
	npad	7
$LL9@erase:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r9, QWORD PTR [r10]
	test	r9, r9
	je	SHORT $LN18@erase
	inc	DWORD PTR [r9]
$LN18@erase:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8]
	test	rax, rax
	je	SHORT $LN21@erase
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8]
	cmp	DWORD PTR [rax], esi
	jne	SHORT $LN21@erase
	mov	QWORD PTR [r8], rsi
$LN21@erase:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8], r9
	mov	rcx, QWORD PTR [r10+8]
	test	rcx, rcx
	je	SHORT $LN27@erase
	inc	DWORD PTR [rcx]
$LN27@erase:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN30@erase
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8+8]
	cmp	DWORD PTR [rax], esi
	jne	SHORT $LN30@erase
	mov	QWORD PTR [r8+8], rsi
$LN30@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r10, 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8+8], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 16
	cmp	r10, r11
	jne	SHORT $LL9@erase
	mov	r8, QWORD PTR _Where$[rsp]
$LN7@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);

	mov	rdx, QWORD PTR [rbx+8]
	lea	rax, QWORD PTR [rdx-16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 81   : 	for (; _First != _Last; ++_First)

	cmp	rax, rdx
	je	SHORT $LN40@erase
$LL42@erase:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	SHORT $LN62@erase
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax+8]
	cmp	DWORD PTR [rcx], esi
	jne	SHORT $LN62@erase
	mov	QWORD PTR [rax+8], rsi
$LN62@erase:
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN68@erase
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx], esi
	jne	SHORT $LN68@erase
	mov	QWORD PTR [rax], rsi
$LN68@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 81   : 	for (; _First != _Last; ++_First)

	add	rax, 16
	cmp	rax, rdx
	jne	SHORT $LL42@erase
	mov	r8, QWORD PTR _Where$[rsp]
$LN40@erase:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1456 : 		--this->_Mylast;

	add	QWORD PTR [rbx+8], -16

; 1458 : 		}

	mov	rsi, QWORD PTR [rsp+16]
	mov	rbx, QWORD PTR [rsp+8]

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rdi], r8

; 1457 : 		return (_Make_iter(_Where));

	mov	rax, rdi

; 1458 : 		}

	mov	rdi, QWORD PTR [rsp+32]
	ret	0
?erase@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xr_vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xr_vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@@QEAA@XZ PROC ; xr_vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::xr_vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 122  : 			xr_vector			()									: inherited	()					{}

	mov	rax, rcx
	ret	0
??0?$xr_vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@@QEAA@XZ ENDP ; xr_vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::xr_vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?begin@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@XZ PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 1025 : 		return (iterator(this->_Myfirst, this));

	mov	rax, rdx

; 1026 : 		}

	ret	0
?begin@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@XZ ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?end@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@XZ PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	rax, QWORD PTR [rcx+8]
	mov	QWORD PTR [rdx], rax

; 1035 : 		return (iterator(this->_Mylast, this));

	mov	rax, rdx

; 1036 : 		}

	ret	0
?end@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@XZ ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?insert@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@AEBQEAUSect@CInifile@@@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Where$ = 80
_Val$ = 88
?insert@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@AEBQEAUSect@CInifile@@@Z PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::insert, COMDAT

; 1327 : 		{	// insert _Val at _Where

$LN4:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	rbx, rdx

; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));

	mov	QWORD PTR [rsp+32], r9
	call	?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n
	mov	rax, rbx

; 1329 : 		}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?insert@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@AEBQEAUSect@CInifile@@@Z ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAAEBUItem@CInifile@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAAEBUItem@CInifile@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAAEBUItem@CInifile@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEBUItem@CInifile@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEBUItem@CInifile@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator->, COMDAT

; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

	mov	rax, QWORD PTR [rcx]

; 92   : 		}

	ret	0
??C?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEBUItem@CInifile@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++, COMDAT

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 16

; 113  : 		return (*this);

	mov	rax, rcx

; 114  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++, COMDAT

; 118  : 		_Myiter _Tmp = *this;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 112  : 		++this->_Ptr;

	add	rax, 16
	mov	QWORD PTR [rcx], rax

; 119  : 		++*this;
; 120  : 		return (_Tmp);

	mov	rax, rdx

; 121  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

	setne	al

; 211  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

	setne	al

; 211  : 		}

	ret	0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAAEAUItem@CInifile@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAAEAUItem@CInifile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAAEAUItem@CInifile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEAUItem@CInifile@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEAUItem@CInifile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator->, COMDAT

; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));

	mov	rax, QWORD PTR [rcx]

; 330  : 		}

	ret	0
??C?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEAUItem@CInifile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++, COMDAT

; 340  : 		_Myiter _Tmp = *this;

	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [rdx], rax

; 112  : 		++this->_Ptr;

	add	rax, 16
	mov	QWORD PTR [rcx], rax

; 341  : 		++*this;
; 342  : 		return (_Tmp);

	mov	rax, rdx

; 343  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAAEAPEAUSect@CInifile@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAAEAPEAUSect@CInifile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator*, COMDAT

; 324  : 		return ((reference)**(_Mybase *)this);

	mov	rax, QWORD PTR [rcx]

; 325  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAAEAPEAUSect@CInifile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator++, COMDAT

; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 8

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

	mov	rax, rcx

; 336  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Make_iter, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rdx], r8

; 1045 : 		return (iterator(_Where._Ptr, this));

	mov	rax, rdx

; 1046 : 		}

	ret	0
?_Make_iter@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@@Z ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z
_TEXT	SEGMENT
_Ncopied$1 = 48
$T2 = 56
_Tmp$3 = 64
p$ = 144
p$ = 144
_Newvec$4 = 144
this$ = 144
__$ReturnUdt$ = 152
_Where$ = 160
_Count$dead$ = 168
_Whereoff$5 = 168
_Val$ = 176
?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n, COMDAT

; 1653 : 		{	// insert _Count * _Val at _Where

$LN339:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T2[rsp], -2
	mov	rax, r8
	mov	r12, rcx

; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;

	mov	r10, QWORD PTR [rcx]
	mov	r13, r8
	sub	r13, r10

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rbx, QWORD PTR [rcx+16]
	mov	r9, QWORD PTR [rcx+8]
	mov	r8, rbx
	sub	r8, r9
	sar	r8, 4

; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)

	cmp	r8, 1
	jae	$LN10@Insert_n

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	r9, r10
	sar	r9, 4

; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)

	mov	rcx, 1152921504606846975		; 0fffffffffffffffH
	mov	rax, rcx
	sub	rax, r9
	cmp	rax, 1
	jae	SHORT $LN9@Insert_n

; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN9@Insert_n:

; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);

	inc	r9

; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rbx, r10
	sar	rbx, 4

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rbx
	shr	rax, 1
	sub	rcx, rax
	cmp	rcx, rbx
	jae	SHORT $LN47@Insert_n
	xor	r15d, r15d
	mov	ebx, r15d
	jmp	SHORT $LN48@Insert_n
$LN47@Insert_n:
	add	rbx, rax
	xor	r15d, r15d
$LN48@Insert_n:

; 1576 : 		if (_Capacity < _Count)

	cmp	rbx, r9
	cmovb	rbx, r9
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ebx
	shl	rdx, 4
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	r14, rax
	mov	QWORD PTR _Newvec$4[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

	mov	rdi, QWORD PTR _Where$[rsp]
	sub	rdi, QWORD PTR [r12]
	sar	rdi, 4
	mov	QWORD PTR _Whereoff$5[rsp], rdi

; 1672 : 			int _Ncopied = 0;

	mov	DWORD PTR _Ncopied$1[rsp], r15d

; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff

	mov	rcx, rdi
	shl	rcx, 4
	add	rcx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 635  : 		_Val_type(_First), _Ptr_cat(_First, _First));

	mov	r8, QWORD PTR _Val$[rsp]
	mov	esi, 1
	mov	edx, esi
	call	??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1677 : 			++_Ncopied;

	mov	DWORD PTR _Ncopied$1[rsp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, r14
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [r12]
	call	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1680 : 			++_Ncopied;

	mov	DWORD PTR _Ncopied$1[rsp], 2

; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix

	lea	r8, QWORD PTR [rdi+1]
	shl	r8, 4
	add	r8, r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	rdx, QWORD PTR [r12+8]
	mov	rcx, QWORD PTR _Where$[rsp]
	call	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	r8, QWORD PTR [r12+8]
	mov	rdx, QWORD PTR [r12]
	mov	rdi, r8
	sub	rdi, rdx
	sar	rdi, 4

; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();

	inc	rdi

; 1693 : 			if (this->_Myfirst != pointer())

	test	rdx, rdx
	je	SHORT $LN129@Insert_n

; 1694 : 				{	// destroy and deallocate old array
; 1695 : 				_Destroy(this->_Myfirst, this->_Mylast);

	call	?_Destroy@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAXPEAUItem@CInifile@@0@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Destroy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR [r12]
	mov	QWORD PTR p$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rsp]
	call	??$xr_free@UItem@CInifile@@@@YAXAEAPEAUItem@CInifile@@@Z ; xr_free<CInifile::Item>
$LN129@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1701 : 			this->_Myend = _Newvec + _Capacity;

	shl	rbx, 4
	add	rbx, r14
	mov	QWORD PTR [r12+16], rbx

; 1702 : 			this->_Mylast = _Newvec + _Count;

	shl	rdi, 4
	add	rdi, r14
	mov	QWORD PTR [r12+8], rdi

; 1703 : 			this->_Myfirst = _Newvec;

	mov	QWORD PTR [r12], r14

; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))

	jmp	$LN309@Insert_n
$LN10@Insert_n:

; 1706 : 			< _Count)

	sub	r9, rax
	sar	r9, 4
	cmp	r9, 1
	jae	$LN3@Insert_n
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rdi, QWORD PTR _Val$[rsp]
	mov	rbx, QWORD PTR [rdi]
	test	rbx, rbx
	je	SHORT $LN137@Insert_n
	inc	DWORD PTR [rbx]
	mov	rax, QWORD PTR _Where$[rsp]
$LN137@Insert_n:
	mov	QWORD PTR _Tmp$3[rsp], rbx
	mov	rdi, QWORD PTR [rdi+8]
	test	rdi, rdi
	je	SHORT $LN146@Insert_n
	inc	DWORD PTR [rdi]
	mov	rax, QWORD PTR _Where$[rsp]
$LN146@Insert_n:
	mov	QWORD PTR _Tmp$3[rsp+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix

	lea	r8, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	rdx, QWORD PTR [rcx+8]
	mov	rcx, rax
	call	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end

	mov	rcx, QWORD PTR [r12+8]
	mov	rax, rcx
	sub	rax, QWORD PTR _Where$[rsp]
	sar	rax, 4
	mov	esi, 1
	sub	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 635  : 		_Val_type(_First), _Ptr_cat(_First, _First));

	lea	r8, QWORD PTR _Tmp$3[rsp]
	mov	rdx, rsi
	call	??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>
	npad	1
	add	QWORD PTR [r12+8], 16
	mov	rdx, QWORD PTR [r12+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1726 : 				_Tmp);	// insert up to old end

	add	rdx, -16
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

	mov	rcx, QWORD PTR _Where$[rsp]

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN189@Insert_n
	xor	r15d, r15d
$LL191@Insert_n:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	test	rbx, rbx
	je	SHORT $LN198@Insert_n
	inc	DWORD PTR [rbx]
$LN198@Insert_n:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN201@Insert_n
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax], r15d
	jne	SHORT $LN201@Insert_n
	mov	QWORD PTR [rcx], r15
$LN201@Insert_n:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx], rbx
	test	rdi, rdi
	je	SHORT $LN207@Insert_n
	inc	DWORD PTR [rdi]
$LN207@Insert_n:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN210@Insert_n
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+8]
	cmp	DWORD PTR [rax], r15d
	jne	SHORT $LN210@Insert_n
	mov	QWORD PTR [rcx+8], r15
$LN210@Insert_n:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx+8], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	add	rcx, 16
	cmp	rcx, rdx
	jne	SHORT $LL191@Insert_n
$LN189@Insert_n:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	rdi, rdi
	je	SHORT $LN218@Insert_n
	dec	DWORD PTR [rdi]
$LN218@Insert_n:
	test	rbx, rbx
	je	$LN309@Insert_n
	dec	DWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1728 : 		else

	jmp	$LN309@Insert_n
$LN3@Insert_n:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r14, QWORD PTR _Val$[rsp]
	mov	rsi, QWORD PTR [r14]
	test	rsi, rsi
	je	SHORT $LN232@Insert_n
	inc	DWORD PTR [rsi]
$LN232@Insert_n:
	mov	r14, QWORD PTR [r14+8]
	test	r14, r14
	je	SHORT $LN241@Insert_n
	inc	DWORD PTR [r14]
$LN241@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1732 : 			pointer _Oldend = this->_Mylast;

	mov	rdi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, rdi
	mov	rdx, rdi
	lea	rcx, QWORD PTR [rdi-16]
	call	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1734 : 				this->_Mylast);	// copy suffix

	mov	QWORD PTR [r12+8], rax

; 1735 : 
; 1736 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1737 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1738 : 				_Oldend);	// copy hole

	mov	r8, rdi
	lea	rdx, QWORD PTR [rdi-16]
	mov	rcx, QWORD PTR _Where$[rsp]
	call	??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z ; std::_Copy_backward<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

	mov	rcx, QWORD PTR _Where$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

	lea	rax, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rax
	je	SHORT $LN274@Insert_n
	xor	r15d, r15d
$LL276@Insert_n:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	test	rsi, rsi
	je	SHORT $LN283@Insert_n
	inc	DWORD PTR [rsi]
$LN283@Insert_n:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN286@Insert_n
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax], r15d
	jne	SHORT $LN286@Insert_n
	mov	QWORD PTR [rcx], r15
$LN286@Insert_n:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx], rsi
	test	r14, r14
	je	SHORT $LN292@Insert_n
	inc	DWORD PTR [r14]
$LN292@Insert_n:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN295@Insert_n
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+8]
	cmp	DWORD PTR [rax], r15d
	jne	SHORT $LN295@Insert_n
	mov	QWORD PTR [rcx+8], r15
$LN295@Insert_n:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx+8], r14
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	add	rcx, 16
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 16
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rax
	jne	SHORT $LL276@Insert_n
$LN274@Insert_n:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	r14, r14
	je	SHORT $LN303@Insert_n
	dec	DWORD PTR [r14]
$LN303@Insert_n:
	test	rsi, rsi
	je	SHORT $LN309@Insert_n
	dec	DWORD PTR [rsi]
$LN309@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	and	r13, -16
	add	r13, QWORD PTR [r12]

; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	rax, QWORD PTR __$ReturnUdt$[rsp]
	mov	QWORD PTR [rax], r13

; 1741 : 			}
; 1742 : 		return (begin() + _Off);
; 1743 : 		}

	add	rsp, 80					; 00000050H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN338@Insert_n:
?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
_Ncopied$1 = 48
$T2 = 56
_Tmp$3 = 64
p$ = 144
p$ = 144
_Newvec$4 = 144
this$ = 144
__$ReturnUdt$ = 152
_Where$ = 160
_Count$dead$ = 168
_Whereoff$5 = 168
_Val$ = 176
?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA PROC ; `std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n'::`1'::catch$0

; 1683 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H
	mov	rbp, rdx
__catch$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z$0:

; 1684 : 			if (1 < _Ncopied)

	mov	esi, DWORD PTR _Ncopied$1[rbp]

; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	rbx, QWORD PTR _Whereoff$5[rbp]
	mov	rdi, QWORD PTR _Newvec$4[rbp]

; 1684 : 			if (1 < _Ncopied)

	cmp	esi, 1
	jle	SHORT $LN7@catch$0

; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	r8, rbx
	shl	r8, 4
	add	r8, rdi
	mov	rdx, rdi
	call	?_Destroy@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAXPEAUItem@CInifile@@0@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Destroy
$LN7@catch$0:

; 1686 : 			if (0 < _Ncopied)

	test	esi, esi
	jle	SHORT $LN6@catch$0

; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	lea	r8, QWORD PTR [rbx+1]
	shl	r8, 4
	add	r8, rdi
	add	rbx, rbx
	lea	rdx, QWORD PTR [rdi+rbx*8]
	call	?_Destroy@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAXPEAUItem@CInifile@@0@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Destroy
$LN6@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$[rbp], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rbp]
	call	??$xr_free@UItem@CInifile@@@@YAXAEAPEAUItem@CInifile@@@Z ; xr_free<CInifile::Item>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1689 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA ENDP ; `std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ncopied$1 = 48
$T2 = 56
_Tmp$3 = 64
p$ = 144
p$ = 144
_Newvec$4 = 144
this$ = 144
__$ReturnUdt$ = 152
_Where$ = 160
_Count$dead$ = 168
_Whereoff$5 = 168
_Val$ = 176
?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA PROC ; `std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n'::`1'::catch$1

; 1717 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z$2:

; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);

	mov	rax, QWORD PTR this$[rbp]
	mov	r8, QWORD PTR [rax+8]
	add	r8, 16
	mov	rdx, QWORD PTR _Where$[rbp]
	add	rdx, 16
	call	?_Destroy@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAXPEAUItem@CInifile@@0@Z ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Destroy

; 1720 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$1@?0??_Insert_n@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@2@_KAEBUItem@CInifile@@@Z@4HA ENDP ; `std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Insert_n'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEAUItem@CInifile@@@std@@SAPEAUItem@CInifile@@AEAU34@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAUItem@CInifile@@@std@@SAPEAUItem@CInifile@@AEAU34@@Z PROC ; std::pointer_traits<CInifile::Item * __ptr64>::pointer_to, COMDAT

; 234  : 		return (_STD addressof(_Val));

	mov	rax, rcx

; 235  : 		}

	ret	0
?pointer_to@?$pointer_traits@PEAUItem@CInifile@@@std@@SAPEAUItem@CInifile@@AEAU34@@Z ENDP ; std::pointer_traits<CInifile::Item * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA@XZ PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >, COMDAT

; 482  : 		_Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rcx], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+8], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+16], rax

; 681  : 		}

	mov	rax, rcx
	ret	0
??0?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAA@XZ ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z
_TEXT	SEGMENT
_Ncopied$1 = 48
$T2 = 56
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$dead$ = 136
p$ = 136
p$ = 136
_Tmp$3 = 136
_Newvec$4 = 136
_Val$ = 144
?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n, COMDAT

; 1653 : 		{	// insert _Count * _Val at _Where

$LN248:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T2[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+120], rsi
	mov	rax, r8
	mov	r13, rdx
	mov	rdi, rcx

; 1654 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1655 : 		if (_VICONT(_Where) != this
; 1656 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1657 : 			|| this->_Mylast < _VIPTR(_Where))
; 1658 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1659 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1660 : 
; 1661 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;

	mov	r9, QWORD PTR [rcx]
	mov	r12, r8
	sub	r12, r9
	sar	r12, 3

; 1011 : 		}
; 1012 : 
; 1013 : 	size_type _Unused_capacity() const _NOEXCEPT
; 1014 : 		{	// micro-optimization for capacity() - size()
; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rbx, QWORD PTR [rcx+16]
	mov	rsi, QWORD PTR [rcx+8]
	mov	r8, rbx
	sub	r8, rsi
	sar	r8, 3

; 1662 : 		if (_Count == 0)
; 1663 : 			;
; 1664 : 		else if (_Unused_capacity() < _Count)

	cmp	r8, 1
	jae	$LN10@Insert_n

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	sub	rsi, r9
	sar	rsi, 3

; 1665 : 			{	// not enough room, reallocate
; 1666 : 			if (max_size() - size() < _Count)

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	mov	rax, rcx
	sub	rax, rsi
	cmp	rax, 1
	jae	SHORT $LN9@Insert_n

; 1744 : 
; 1745 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1746 : 		{	// copy initializing _Count * _Val, using allocator
; 1747 : 		_Alty _Alval(this->_Getal());
; 1748 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1749 : 		return (_Ptr + _Count);
; 1750 : 		}
; 1751 : 
; 1752 : 	__declspec(noreturn) void _Xlen() const
; 1753 : 		{	// report a length_error
; 1754 : 		_Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN9@Insert_n:

; 1667 : 				_Xlen();	// result too long
; 1668 : 
; 1669 : 			size_type _Capacity = _Grow_to(size() + _Count);

	inc	rsi

; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 443  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 444  : 
; 445  : 
; 446  : 	typedef typename _Alty::pointer _Tptr;
; 447  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 448  : 
; 449  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 450  : 		_Simple_types<typename _Alty::value_type>,
; 451  : 		_Vec_iter_types<typename _Alty::value_type,
; 452  : 			typename _Alty::size_type,
; 453  : 			typename _Alty::difference_type,
; 454  : 			typename _Alty::pointer,
; 455  : 			typename _Alty::const_pointer,
; 456  : 			typename _Alty::reference,
; 457  : 			typename _Alty::const_reference> >::type
; 458  : 		_Val_types;
; 459  : 	};
; 460  : 
; 461  : 		// TEMPLATE CLASS _Vector_val
; 462  : template<class _Val_types>
; 463  : 	class _Vector_val
; 464  : 		: public _Container_base
; 465  : 	{	// base class for vector to hold data
; 466  : public:
; 467  : 	typedef _Vector_val<_Val_types> _Myt;
; 468  : 
; 469  : 	typedef typename _Val_types::value_type value_type;
; 470  : 	typedef typename _Val_types::size_type size_type;
; 471  : 	typedef typename _Val_types::difference_type difference_type;
; 472  : 	typedef typename _Val_types::pointer pointer;
; 473  : 	typedef typename _Val_types::const_pointer const_pointer;
; 474  : 	typedef typename _Val_types::reference reference;
; 475  : 	typedef typename _Val_types::const_reference const_reference;
; 476  : 
; 477  : 	typedef _Vector_iterator<_Myt> iterator;
; 478  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 479  : 
; 480  : 	_Vector_val()
; 481  : 		{	// initialize values
; 482  : 		_Myfirst = pointer();
; 483  : 		_Mylast = pointer();
; 484  : 		_Myend = pointer();
; 485  : 		}
; 486  : 
; 487  : 	pointer _Myfirst;	// pointer to beginning of array
; 488  : 	pointer _Mylast;	// pointer to current end of sequence
; 489  : 	pointer _Myend;	// pointer to end of array
; 490  : 	};
; 491  : 
; 492  : 		// TEMPLATE CLASS _Vector_alloc
; 493  : template<bool _Al_has_storage,
; 494  : 	class _Alloc_types>
; 495  : 	class _Vector_alloc
; 496  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 497  : 	{	// base class for vector to hold allocator with storage
; 498  : public:
; 499  : 	typename _Alloc_types::_Alty _Alval;	// allocator object
; 500  : 
; 501  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 502  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 503  : 	typedef typename _Alloc_types::_Alty _Alty;
; 504  : 
; 505  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 506  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 507  : 		: _Alval(_Al)
; 508  : 		{	// construct allocator from _Al
; 509  : 		}
; 510  : 
; 511  : 	void _Change_alloc(const _Alty& _Al)
; 512  : 		{	// replace old allocator
; 513  : 		this->_Alval = _Al;
; 514  : 		}
; 515  : 
; 516  : 	void _Swap_alloc(_Myt& _Right)
; 517  : 		{	// swap allocators
; 518  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 519  : 		}
; 520  : 
; 521  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 522  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 523  : 		: _Alval(_Al)
; 524  : 		{	// construct allocator from _Al
; 525  : 		_Alloc_proxy();
; 526  : 		}
; 527  : 
; 528  : 	~_Vector_alloc() _NOEXCEPT
; 529  : 		{	// destroy proxy
; 530  : 		_Free_proxy();
; 531  : 		}
; 532  : 
; 533  : 	void _Change_alloc(const _Alty& _Al)
; 534  : 		{	// replace old allocator
; 535  : 		_Free_proxy();
; 536  : 		this->_Alval = _Al;
; 537  : 		_Alloc_proxy();
; 538  : 		}
; 539  : 
; 540  : 	void _Swap_alloc(_Myt& _Right)
; 541  : 		{	// swap allocators
; 542  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 543  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 544  : 		}
; 545  : 
; 546  : 	void _Alloc_proxy()
; 547  : 		{	// construct proxy from _Alval
; 548  : 		typename _Alty::template rebind<_Container_proxy>::other
; 549  : 			_Alproxy(this->_Alval);
; 550  : 		this->_Myproxy = _Alproxy.allocate(1);
; 551  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 552  : 		this->_Myproxy->_Mycont = this;
; 553  : 		}
; 554  : 
; 555  : 	void _Free_proxy()
; 556  : 		{	// destroy proxy
; 557  : 		typename _Alty::template rebind<_Container_proxy>::other
; 558  : 			_Alproxy(this->_Alval);
; 559  : 		this->_Orphan_all();
; 560  : 		_Alproxy.destroy(this->_Myproxy);
; 561  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 562  : 		this->_Myproxy = 0;
; 563  : 		}
; 564  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 565  : 
; 566  : 	_Alty& _Getal()
; 567  : 		{	// get reference to allocator
; 568  : 		return (this->_Alval);
; 569  : 		}
; 570  : 
; 571  : 	const _Alty& _Getal() const
; 572  : 		{	// get reference to allocator
; 573  : 		return (this->_Alval);
; 574  : 		}
; 575  : 	};
; 576  : 
; 577  : template<class _Alloc_types>
; 578  : 	class _Vector_alloc<false, _Alloc_types>
; 579  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 580  : 	{	// base class for vector to hold allocator with no storage
; 581  : public:
; 582  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 583  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 584  : 
; 585  : 	typedef typename _Alloc_types::_Alty _Alty;
; 586  : 
; 587  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 588  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 589  : 		{	// construct allocator from _Al
; 590  : 		}
; 591  : 
; 592  : 	void _Change_alloc(const _Alty&)
; 593  : 		{	// replace old allocator
; 594  : 		}
; 595  : 
; 596  : 	void _Swap_alloc(_Myt&)
; 597  : 		{	// swap allocators
; 598  : 		}
; 599  : 
; 600  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 601  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 602  : 		{	// construct allocator from _Al
; 603  : 		_Alloc_proxy();
; 604  : 		}
; 605  : 
; 606  : 	~_Vector_alloc() _NOEXCEPT
; 607  : 		{	// destroy proxy
; 608  : 		_Free_proxy();
; 609  : 		}
; 610  : 
; 611  : 	void _Change_alloc(const _Alty&)
; 612  : 		{	// replace old allocator
; 613  : 		}
; 614  : 
; 615  : 	void _Swap_alloc(_Myt& _Right)
; 616  : 		{	// swap allocators
; 617  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 618  : 		}
; 619  : 
; 620  : 	void _Alloc_proxy()
; 621  : 		{	// construct proxy from _Alval
; 622  : 		typename _Alty::template rebind<_Container_proxy>::other
; 623  : 			_Alproxy;
; 624  : 		this->_Myproxy = _Alproxy.allocate(1);
; 625  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 626  : 		this->_Myproxy->_Mycont = this;
; 627  : 		}
; 628  : 
; 629  : 	void _Free_proxy()
; 630  : 		{	// destroy proxy
; 631  : 		typename _Alty::template rebind<_Container_proxy>::other
; 632  : 			_Alproxy;
; 633  : 		this->_Orphan_all();
; 634  : 		_Alproxy.destroy(this->_Myproxy);
; 635  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 636  : 		this->_Myproxy = 0;
; 637  : 		}
; 638  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 639  : 
; 640  : 	_Alty _Getal() const
; 641  : 		{	// get reference to allocator
; 642  : 		return (_Alty());
; 643  : 		}
; 644  : 	};
; 645  : 
; 646  : 		// TEMPLATE CLASS vector
; 647  : template<class _Ty,
; 648  : 	class _Alloc = allocator<_Ty> >
; 649  : 	class vector
; 650  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 651  : 			_Vec_base_types<_Ty, _Alloc> >
; 652  : 	{	// varying size array of values
; 653  : public:
; 654  : 	typedef vector<_Ty, _Alloc> _Myt;
; 655  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 657  : 	typedef _Alloc allocator_type;
; 658  : 
; 659  : 	typedef typename _Mybase::_Alty _Alty;
; 660  : 
; 661  : 	typedef typename _Mybase::value_type value_type;
; 662  : 	typedef typename _Mybase::size_type size_type;
; 663  : 	typedef typename _Mybase::difference_type difference_type;
; 664  : 	typedef typename _Mybase::pointer pointer;
; 665  : 	typedef typename _Mybase::const_pointer const_pointer;
; 666  : 	typedef typename _Mybase::reference reference;
; 667  : 	typedef typename _Mybase::const_reference const_reference;
; 668  : 
; 669  :  #define _VICONT(it)	it._Getcont()
; 670  :  #define _VIPTR(it)	(it)._Ptr
; 671  : 
; 672  : 	typedef typename _Mybase::iterator iterator;
; 673  : 	typedef typename _Mybase::const_iterator const_iterator;
; 674  : 
; 675  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 676  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 677  : 
; 678  : 	vector()
; 679  : 		: _Mybase()
; 680  : 		{	// construct empty vector
; 681  : 		}
; 682  : 
; 683  : 	explicit vector(const _Alloc& _Al)
; 684  : 		: _Mybase(_Al)
; 685  : 		{	// construct empty vector, allocator
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(size_type _Count)
; 689  : 		: _Mybase()
; 690  : 		{	// construct from _Count * value_type()
; 691  : 		if (_Buy(_Count))
; 692  : 			{	// nonzero, fill it
; 693  : 			_Alty _Alval(this->_Getal());
; 694  : 			_TRY_BEGIN
; 695  : 			_Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
; 696  : 			this->_Mylast += _Count;
; 697  : 			_CATCH_ALL
; 698  : 			_Tidy();
; 699  : 			_RERAISE;
; 700  : 			_CATCH_END
; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 	vector(size_type _Count, const value_type& _Val)
; 705  : 		: _Mybase()
; 706  : 		{	// construct from _Count * _Val
; 707  : 		_Construct_n(_Count, _STD addressof(_Val));
; 708  : 		}
; 709  : 
; 710  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 711  : 		: _Mybase(_Al)
; 712  : 		{	// construct from _Count * _Val, allocator
; 713  : 		_Construct_n(_Count, _STD addressof(_Val));
; 714  : 		}
; 715  : 
; 716  : 	vector(const _Myt& _Right)
; 717  : 
; 718  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 719  : 
; 720  : 
; 721  : 		{	// construct by copying _Right
; 722  : 		if (_Buy(_Right.size()))
; 723  : 			_TRY_BEGIN
; 724  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 725  : 				this->_Myfirst);
; 726  : 			_CATCH_ALL
; 727  : 			_Tidy();
; 728  : 			_RERAISE;
; 729  : 			_CATCH_END
; 730  : 		}
; 731  : 
; 732  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 733  : 		: _Mybase(_Al)
; 734  : 		{	// construct by copying _Right, allocator
; 735  : 		if (_Buy(_Right.size()))
; 736  : 			_TRY_BEGIN
; 737  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 738  : 				this->_Myfirst);
; 739  : 			_CATCH_ALL
; 740  : 			_Tidy();
; 741  : 			_RERAISE;
; 742  : 			_CATCH_END
; 743  : 		}
; 744  : 
; 745  : 	template<class _Iter,
; 746  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 			void>:: type>
; 748  : 		vector(_Iter _First, _Iter _Last)
; 749  : 		: _Mybase()
; 750  : 		{	// construct from [_First, _Last)
; 751  : 		_Construct(_First, _Last);
; 752  : 		}
; 753  : 
; 754  : 	template<class _Iter,
; 755  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 			void>:: type>
; 757  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
; 758  : 		: _Mybase(_Al)
; 759  : 		{	// construct from [_First, _Last) with allocator
; 760  : 		_Construct(_First, _Last);
; 761  : 		}
; 762  : 
; 763  : 	template<class _Iter>
; 764  : 		void _Construct(_Iter _First, _Iter _Last)
; 765  : 		{	// initialize with [_First, _Last)
; 766  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 767  : 		}
; 768  : 
; 769  : 	template<class _Iter>
; 770  : 		void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
; 771  : 		{	// initialize with [_First, _Last), input iterators
; 772  : 		_TRY_BEGIN
; 773  : 
; 774  : 		for (; _First != _Last; ++_First)
; 775  : 			emplace_back(*_First);
; 776  : 
; 777  : 		_CATCH_ALL
; 778  : 		_Tidy();
; 779  : 		_RERAISE;
; 780  : 		_CATCH_END
; 781  : 		}
; 782  : 
; 783  : 	template<class _Iter>
; 784  : 		void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
; 785  : 		{	// initialize with [_First, _Last), forward iterators
; 786  : 		if (_Buy(_STD distance(_First, _Last)))
; 787  : 			{	// nonzero, fill it
; 788  : 			_TRY_BEGIN
; 789  : 			this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 790  : 			_CATCH_ALL
; 791  : 			_Tidy();
; 792  : 			_RERAISE;
; 793  : 			_CATCH_END
; 794  : 			}
; 795  : 		}
; 796  : 
; 797  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 798  : 		{	// construct from _Count * *_Pval
; 799  : 		if (_Buy(_Count))
; 800  : 			{	// nonzero, fill it
; 801  : 			_TRY_BEGIN
; 802  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 803  : 			_CATCH_ALL
; 804  : 			_Tidy();
; 805  : 			_RERAISE;
; 806  : 			_CATCH_END
; 807  : 			}
; 808  : 		}
; 809  : 
; 810  : 	vector(_Myt&& _Right)
; 811  : 		: _Mybase(_Right._Getal())
; 812  : 		{	// construct by moving _Right
; 813  : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 814  : 		}
; 815  : 
; 816  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 817  : 		: _Mybase(_Al)
; 818  : 		{	// construct by moving _Right, allocator
; 819  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 820  : 		}
; 821  : 
; 822  : 	_Myt& operator=(_Myt&& _Right)
; 823  : 		{	// assign by moving _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, assign it
; 826  : 			_Tidy();
; 827  : 			if (_Alty::propagate_on_container_move_assignment::value
; 828  : 				&& this->_Getal() != _Right._Getal())
; 829  : 				this->_Change_alloc(_Right._Getal());
; 830  : 
; 831  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 832  : 			}
; 833  : 		return (*this);
; 834  : 		}
; 835  : 
; 836  : 	void _Assign_rv(_Myt&& _Right, true_type)
; 837  : 		{	// move from _Right, stealing its contents
; 838  : 		this->_Swap_all((_Myt&)_Right);
; 839  : 		this->_Myfirst = _Right._Myfirst;
; 840  : 		this->_Mylast = _Right._Mylast;
; 841  : 		this->_Myend = _Right._Myend;
; 842  : 
; 843  : 		_Right._Myfirst = pointer();
; 844  : 		_Right._Mylast = pointer();
; 845  : 		_Right._Myend = pointer();
; 846  : 		}
; 847  : 
; 848  : 	void _Assign_rv(_Myt&& _Right, false_type)
; 849  : 		{	// move from _Right, possibly moving its contents
; 850  : 		if (get_allocator() == _Right.get_allocator())
; 851  : 			_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 852  : 		else
; 853  : 			_Construct(_STD make_move_iterator(_Right.begin()),
; 854  : 				_STD make_move_iterator(_Right.end()));
; 855  : 		}
; 856  : 
; 857  : 	void _Assign_rv(_Myt&& _Right)
; 858  : 		{	// assign by moving _Right
; 859  : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 860  : 			typename _Alty::propagate_on_container_move_assignment());
; 861  : 		}
; 862  : 
; 863  : 
; 864  : 	void push_back(value_type&& _Val)
; 865  : 		{	// insert by moving into element at end
; 866  : 		if (_Inside(_STD addressof(_Val)))
; 867  : 			{	// push back an element
; 868  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 869  : 			if (this->_Mylast == this->_Myend)
; 870  : 				_Reserve(1);
; 871  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 872  : 			this->_Getal().construct(this->_Mylast,
; 873  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 874  : 			++this->_Mylast;
; 875  : 			}
; 876  : 		else
; 877  : 			{	// push back a non-element
; 878  : 			if (this->_Mylast == this->_Myend)
; 879  : 				_Reserve(1);
; 880  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 881  : 			this->_Getal().construct(this->_Mylast,
; 882  : 				_STD forward<value_type>(_Val));
; 883  : 			++this->_Mylast;
; 884  : 			}
; 885  : 		}
; 886  : 
; 887  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 888  : 		{	// insert by moving _Val at _Where
; 889  : 		return (emplace(_Where, _STD move(_Val)));
; 890  : 		}
; 891  : 
; 892  : 	template<class... _Valty>
; 893  : 		void emplace_back(_Valty&&... _Val)
; 894  : 		{	// insert by moving into element at end
; 895  : 		if (this->_Mylast == this->_Myend)
; 896  : 			_Reserve(1);
; 897  : 		_Orphan_range(this->_Mylast, this->_Mylast);
; 898  : 		this->_Getal().construct(this->_Mylast,
; 899  : 			_STD forward<_Valty>(_Val)...);
; 900  : 		++this->_Mylast;
; 901  : 		}
; 902  : 
; 903  : 	template<class... _Valty>
; 904  : 		iterator emplace(const_iterator _Where, _Valty&&... _Val)
; 905  : 		{	// insert by moving _Val at _Where
; 906  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 907  : 
; 908  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 909  : 		if (size() < _Off)
; 910  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 911  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 912  : 
; 913  : 		emplace_back(_STD forward<_Valty>(_Val)...);
; 914  : 		_STD rotate(begin() + _Off, end() - 1, end());
; 915  : 		return (begin() + _Off);
; 916  : 		}
; 917  : 
; 918  : 
; 919  : 	vector(_XSTD initializer_list<value_type> _Ilist,
; 920  : 		const _Alloc& _Al = allocator_type())
; 921  : 		: _Mybase(_Al)
; 922  : 		{	// construct from initializer_list
; 923  : 		insert(begin(), _Ilist.begin(), _Ilist.end());
; 924  : 		}
; 925  : 
; 926  : 	_Myt& operator=(_XSTD initializer_list<value_type> _Ilist)
; 927  : 		{	// assign initializer_list
; 928  : 		assign(_Ilist.begin(), _Ilist.end());
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	void assign(_XSTD initializer_list<value_type> _Ilist)
; 933  : 		{	// assign initializer_list
; 934  : 		assign(_Ilist.begin(), _Ilist.end());
; 935  : 		}
; 936  : 
; 937  : 	iterator insert(const_iterator _Where,
; 938  : 		_XSTD initializer_list<value_type> _Ilist)
; 939  : 		{	// insert initializer_list
; 940  : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 941  : 		}
; 942  : 
; 943  : 	~vector() _NOEXCEPT
; 944  : 		{	// destroy the object
; 945  : 		_Tidy();
; 946  : 		}
; 947  : 
; 948  : 	_Myt& operator=(const _Myt& _Right)
; 949  : 		{	// assign _Right
; 950  : 		if (this != &_Right)
; 951  : 			{	// different, assign it
; 952  : 			if (this->_Getal() != _Right._Getal()
; 953  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 954  : 				{	// change allocator before copying
; 955  : 				_Tidy();
; 956  : 				this->_Change_alloc(_Right._Getal());
; 957  : 				}
; 958  : 
; 959  : 			this->_Orphan_all();
; 960  : 
; 961  : 			if (_Right.empty())
; 962  : 				clear();	// new sequence empty, erase existing sequence
; 963  : 			else if (_Right.size() <= size())
; 964  : 				{	// enough elements, copy new and destroy old
; 965  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 966  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 967  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 968  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 969  : 				}
; 970  : 			else if (_Right.size() <= capacity())
; 971  : 				{	// enough room, copy and construct new
; 972  : 				pointer _Ptr = _Right._Myfirst + size();
; 973  : 				_Copy_impl(_Right._Myfirst,
; 974  : 					_Ptr, this->_Myfirst);
; 975  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 976  : 				}
; 977  : 			else
; 978  : 				{	// not enough room, allocate new array and construct new
; 979  : 				if (this->_Myfirst != pointer())
; 980  : 					{	// discard old array
; 981  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 982  : 					this->_Getal().deallocate(this->_Myfirst,
; 983  : 						this->_Myend - this->_Myfirst);
; 984  : 					}
; 985  : 				if (_Buy(_Right.size()))
; 986  : 					_TRY_BEGIN
; 987  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 988  : 						this->_Myfirst);
; 989  : 					_CATCH_ALL
; 990  : 					_Tidy();
; 991  : 					_RERAISE;
; 992  : 					_CATCH_END
; 993  : 				}
; 994  : 			}
; 995  : 		return (*this);
; 996  : 		}
; 997  : 
; 998  : 	void reserve(size_type _Count)
; 999  : 		{	// determine new minimum length of allocated storage
; 1000 : 		if (capacity() < _Count)
; 1001 : 			{	// something to do, check and reallocate
; 1002 : 			if (max_size() < _Count)
; 1003 : 				_Xlen();
; 1004 : 			_Reallocate(_Count);
; 1005 : 			}
; 1006 : 		}
; 1007 : 
; 1008 : 	size_type capacity() const _NOEXCEPT
; 1009 : 		{	// return current length of allocated storage
; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	rbx, r9
	sar	rbx, 3

; 1149 : 		}
; 1150 : 
; 1151 : 	size_type max_size() const _NOEXCEPT
; 1152 : 		{	// return maximum possible length of sequence
; 1153 : 		return (this->_Getal().max_size());
; 1154 : 		}
; 1155 : 
; 1156 : 	bool empty() const _NOEXCEPT
; 1157 : 		{	// test if sequence is empty
; 1158 : 		return (this->_Myfirst == this->_Mylast);
; 1159 : 		}
; 1160 : 
; 1161 : 	_Alloc get_allocator() const _NOEXCEPT
; 1162 : 		{	// return allocator object for values
; 1163 : 		return (this->_Getal());
; 1164 : 		}
; 1165 : 
; 1166 : 	const_reference at(size_type _Pos) const
; 1167 : 		{	// subscript nonmutable sequence with checking
; 1168 : 		if (size() <= _Pos)
; 1169 : 			_Xran();
; 1170 : 		return (*(this->_Myfirst + _Pos));
; 1171 : 		}
; 1172 : 
; 1173 : 	reference at(size_type _Pos)
; 1174 : 		{	// subscript mutable sequence with checking
; 1175 : 		if (size() <= _Pos)
; 1176 : 			_Xran();
; 1177 : 		return (*(this->_Myfirst + _Pos));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reference operator[](size_type _Pos) const
; 1181 : 		{	// subscript nonmutable sequence
; 1182 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1183 : 		if (size() <= _Pos)
; 1184 : 			{	// report error
; 1185 : 			_DEBUG_ERROR("vector subscript out of range");
; 1186 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1187 : 			}
; 1188 : 
; 1189 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1190 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1191 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1192 : 
; 1193 : 		return (*(this->_Myfirst + _Pos));
; 1194 : 		}
; 1195 : 
; 1196 : 	reference operator[](size_type _Pos)
; 1197 : 		{	// subscript mutable sequence
; 1198 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1199 : 		if (size() <= _Pos)
; 1200 : 			{	// report error
; 1201 : 			_DEBUG_ERROR("vector subscript out of range");
; 1202 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1203 : 			}
; 1204 : 
; 1205 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1206 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1207 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1208 : 
; 1209 : 		return (*(this->_Myfirst + _Pos));
; 1210 : 		}
; 1211 : 
; 1212 : 	pointer data() _NOEXCEPT
; 1213 : 		{	// return address of first element
; 1214 : 		return (this->_Myfirst);
; 1215 : 		}
; 1216 : 
; 1217 : 	const_pointer data() const _NOEXCEPT
; 1218 : 		{	// return address of first element
; 1219 : 		return (this->_Myfirst);
; 1220 : 		}
; 1221 : 
; 1222 : 	reference front()
; 1223 : 		{	// return first element of mutable sequence
; 1224 : 		return (*begin());
; 1225 : 		}
; 1226 : 
; 1227 : 	const_reference front() const
; 1228 : 		{	// return first element of nonmutable sequence
; 1229 : 		return (*begin());
; 1230 : 		}
; 1231 : 
; 1232 : 	reference back()
; 1233 : 		{	// return last element of mutable sequence
; 1234 : 		return (*(end() - 1));
; 1235 : 		}
; 1236 : 
; 1237 : 	const_reference back() const
; 1238 : 		{	// return last element of nonmutable sequence
; 1239 : 		return (*(end() - 1));
; 1240 : 		}
; 1241 : 
; 1242 : 	void push_back(const value_type& _Val)
; 1243 : 		{	// insert element at end
; 1244 : 		if (_Inside(_STD addressof(_Val)))
; 1245 : 			{	// push back an element
; 1246 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1247 : 			if (this->_Mylast == this->_Myend)
; 1248 : 				_Reserve(1);
; 1249 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1250 : 			this->_Getal().construct(this->_Mylast,
; 1251 : 				this->_Myfirst[_Idx]);
; 1252 : 			++this->_Mylast;
; 1253 : 			}
; 1254 : 		else
; 1255 : 			{	// push back a non-element
; 1256 : 			if (this->_Mylast == this->_Myend)
; 1257 : 				_Reserve(1);
; 1258 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1259 : 			this->_Getal().construct(this->_Mylast,
; 1260 : 				_Val);
; 1261 : 			++this->_Mylast;
; 1262 : 			}
; 1263 : 		}
; 1264 : 
; 1265 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1266 : 	void pop_back()
; 1267 : 		{	// erase element at end
; 1268 : 		if (empty())
; 1269 : 			_DEBUG_ERROR("vector empty before pop");
; 1270 : 		else
; 1271 : 			{	// erase last element
; 1272 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1273 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1274 : 			--this->_Mylast;
; 1275 : 			}
; 1276 : 		}
; 1277 : 
; 1278 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1279 : 	void pop_back()
; 1280 : 		{	// erase element at end
; 1281 : 		this->_Getal().destroy(this->_Mylast - 1);
; 1282 : 		--this->_Mylast;
; 1283 : 		}
; 1284 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1285 : 
; 1286 : 	template<class _Iter>
; 1287 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1288 : 			void>::type
; 1289 : 		assign(_Iter _First, _Iter _Last)
; 1290 : 		{	// assign [_First, _Last)
; 1291 : 		clear();
; 1292 : 		_Assign(_First, _Last, _Iter_cat(_First));
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
; 1297 : 		{	// assign [_First, _Last), input iterators
; 1298 : 		for (; _First != _Last; ++_First)
; 1299 : 			emplace_back(*_First);
; 1300 : 		}
; 1301 : 
; 1302 : 	template<class _Iter>
; 1303 : 		void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
; 1304 : 		{	// assign [_First, _Last), forward iterators
; 1305 : 		if (_First == _Last)
; 1306 : 			return;	// nothing to do
; 1307 : 
; 1308 : 		size_type _Newsize = _STD distance(_First, _Last);
; 1309 : 
; 1310 : 		if (capacity() < _Newsize)
; 1311 : 			{	// need more room, try to get it
; 1312 : 			size_type _Newcapacity = _Grow_to(_Newsize);
; 1313 : 			_Tidy();
; 1314 : 			_Buy(_Newcapacity);
; 1315 : 			}
; 1316 : 
; 1317 : 		this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
; 1318 : 		}
; 1319 : 
; 1320 : 	void assign(size_type _Count, const value_type& _Val)
; 1321 : 		{	// assign _Count * _Val
; 1322 : 		clear();
; 1323 : 		insert(begin(), _Count, _Val);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1327 : 		{	// insert _Val at _Where
; 1328 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1329 : 		}
; 1330 : 
; 1331 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1332 : 		const _Ty& _Val)
; 1333 : 		{	// insert _Count * _Val at _Where
; 1334 : 		return (_Insert_n(_Where, _Count, _Val));
; 1335 : 		}
; 1336 : 
; 1337 : 	template<class _Iter>
; 1338 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1339 : 			iterator>::type
; 1340 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1341 : 		{	// insert [_First, _Last) at _Where
; 1342 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1343 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1344 : 		return (begin() + _Off);
; 1345 : 		}
; 1346 : 
; 1347 : 	template<class _Iter>
; 1348 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1349 : 			input_iterator_tag)
; 1350 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1351 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1352 : 
; 1353 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1354 : 		if (size() < _Off)
; 1355 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1356 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1357 : 
; 1358 : 		if (_First != _Last)
; 1359 : 			{	// worth doing, gather at end and rotate into place
; 1360 : 			size_type _Oldsize = size();
; 1361 : 
; 1362 : 			_TRY_BEGIN
; 1363 : 			for (; _First != _Last; ++_First)
; 1364 : 				push_back(*_First);	// append
; 1365 : 
; 1366 : 			_CATCH_ALL
; 1367 : 			erase(begin() + _Oldsize, end());
; 1368 : 			_RERAISE;
; 1369 : 			_CATCH_END
; 1370 : 
; 1371 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1372 : 			}
; 1373 : 		}
; 1374 : 
; 1375 : 	template<class _Iter>
; 1376 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1377 : 			forward_iterator_tag)
; 1378 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1379 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1380 : 		if (_VICONT(_Where) != this
; 1381 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1382 : 			|| this->_Mylast < _VIPTR(_Where))
; 1383 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1384 : 		_DEBUG_RANGE(_First, _Last);
; 1385 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1386 : 
; 1387 : 		size_type _Count = 0;
; 1388 : 		_Distance(_First, _Last, _Count);
; 1389 : 
; 1390 : 		if (_Count == 0)
; 1391 : 			;
; 1392 : 		else if (_Unused_capacity() < _Count)
; 1393 : 			{	// not enough room, reallocate
; 1394 : 			if (max_size() - size() < _Count)
; 1395 : 				_Xlen();	// result too long
; 1396 : 
; 1397 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1398 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1399 : 			pointer _Ptr = _Newvec;
; 1400 : 
; 1401 : 			_TRY_BEGIN
; 1402 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1403 : 				_Newvec);	// copy prefix
; 1404 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1405 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1406 : 				_Ptr);	// copy suffix
; 1407 : 			_CATCH_ALL
; 1408 : 			_Destroy(_Newvec, _Ptr);
; 1409 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1410 : 			_RERAISE;
; 1411 : 			_CATCH_END
; 1412 : 
; 1413 : 			_Count += size();
; 1414 : 			if (this->_Myfirst != pointer())
; 1415 : 				{	// destroy and deallocate old array
; 1416 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1417 : 				this->_Getal().deallocate(this->_Myfirst,
; 1418 : 					this->_Myend - this->_Myfirst);
; 1419 : 				}
; 1420 : 
; 1421 : 			this->_Orphan_all();
; 1422 : 			this->_Myend = _Newvec + _Capacity;
; 1423 : 			this->_Mylast = _Newvec + _Count;
; 1424 : 			this->_Myfirst = _Newvec;
; 1425 : 			}
; 1426 : 		else
; 1427 : 			{	// new stuff fits, append and rotate into place
; 1428 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1429 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1430 : 				this->_Mylast + _Count);
; 1431 : 			this->_Mylast += _Count;
; 1432 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1433 : 			}
; 1434 : 		}
; 1435 : 
; 1436 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 	iterator erase(const_iterator _Where)
; 1438 : 		{	// erase element at where
; 1439 : 		if (_VICONT(_Where) != this
; 1440 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1441 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1442 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1443 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1444 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1445 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1446 : 		--this->_Mylast;
; 1447 : 		return (_Make_iter(_Where));
; 1448 : 		}
; 1449 : 
; 1450 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 	iterator erase(const_iterator _Where)
; 1452 : 		{	// erase element at where
; 1453 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1454 : 			_VIPTR(_Where));
; 1455 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1456 : 		--this->_Mylast;
; 1457 : 		return (_Make_iter(_Where));
; 1458 : 		}
; 1459 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1460 : 
; 1461 : 	iterator erase(const_iterator _First_arg,
; 1462 : 		const_iterator _Last_arg)
; 1463 : 		{	// erase [_First, _Last)
; 1464 : 		if (_First_arg == begin() && _Last_arg == end())
; 1465 : 			clear();
; 1466 : 		else if (_First_arg != _Last_arg)
; 1467 : 			{	// clear partial
; 1468 : 			iterator _First = _Make_iter(_First_arg);
; 1469 : 			iterator _Last = _Make_iter(_Last_arg);
; 1470 : 
; 1471 : 			if (_First != _Last)
; 1472 : 				{	// worth doing, copy down over hole
; 1473 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1474 : 				if (_Last < _First || _VICONT(_First) != this
; 1475 : 					|| _VIPTR(_First) < this->_Myfirst
; 1476 : 					|| this->_Mylast < _VIPTR(_Last))
; 1477 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1478 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1479 : 					_VIPTR(_First));
; 1480 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1484 : 					_VIPTR(_First));
; 1485 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1486 : 
; 1487 : 				_Destroy(_Ptr, this->_Mylast);
; 1488 : 				this->_Mylast = _Ptr;
; 1489 : 				}
; 1490 : 			}
; 1491 : 		return (_Make_iter(_First_arg));
; 1492 : 		}
; 1493 : 
; 1494 : 	void _Pop_back_n(size_type _Count)
; 1495 : 		{	// erase _Count elements at end
; 1496 : 		pointer _Ptr = this->_Mylast - _Count;
; 1497 : 
; 1498 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1499 : 		_Orphan_range(_Ptr, this->_Mylast);
; 1500 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1501 : 
; 1502 : 		_Destroy(_Ptr, this->_Mylast);
; 1503 : 		this->_Mylast = _Ptr;
; 1504 : 		}
; 1505 : 
; 1506 : 	void clear() _NOEXCEPT
; 1507 : 		{	// erase all
; 1508 : 		this->_Orphan_all();
; 1509 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1510 : 		this->_Mylast = this->_Myfirst;
; 1511 : 		}
; 1512 : 
; 1513 : 	void swap(_Myt& _Right)
; 1514 : 		{	// exchange contents with _Right
; 1515 : 		if (this == &_Right)
; 1516 : 			;	// same object, do nothing
; 1517 : 		else if (this->_Getal() == _Right._Getal())
; 1518 : 			{	// same allocator, swap control information
; 1519 : 			this->_Swap_all(_Right);
; 1520 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1521 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1522 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1523 : 			}
; 1524 : 
; 1525 : 		else if (_Alty::propagate_on_container_swap::value)
; 1526 : 			{	// swap allocators and control information
; 1527 : 			this->_Swap_alloc(_Right);
; 1528 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1529 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1530 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1531 : 			}
; 1532 : 
; 1533 : 		else
; 1534 : 			{	// containers are incompatible
; 1535 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1536 : 			_DEBUG_ERROR("vector containers incompatible for swap");
; 1537 : 
; 1538 :  #else /* ITERATOR_DEBUG_LEVEL == 2 */
; 1539 : 			_XSTD terminate();
; 1540 :  #endif /* ITERATOR_DEBUG_LEVEL == 2 */
; 1541 : 			}
; 1542 : 		}
; 1543 : 
; 1544 : protected:
; 1545 : 	bool _Buy(size_type _Capacity)
; 1546 : 		{	// allocate array with _Capacity elements
; 1547 : 		this->_Myfirst = pointer();
; 1548 : 		this->_Mylast = pointer();
; 1549 : 		this->_Myend = pointer();
; 1550 : 
; 1551 : 		if (_Capacity == 0)
; 1552 : 			return (false);
; 1553 : 		else if (max_size() < _Capacity)
; 1554 : 			_Xlen();	// result too long
; 1555 : 		else
; 1556 : 			{	// nonempty array, allocate storage
; 1557 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1558 : 			this->_Mylast = this->_Myfirst;
; 1559 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1560 : 			}
; 1561 : 		return (true);
; 1562 : 		}
; 1563 : 
; 1564 : 	void _Destroy(pointer _First, pointer _Last)
; 1565 : 		{	// destroy [_First, _Last) using allocator
; 1566 : 		_Alty _Alval(this->_Getal());
; 1567 : 		_Destroy_range(_First, _Last, _Alval);
; 1568 : 		}
; 1569 : 
; 1570 : 	size_type _Grow_to(size_type _Count) const
; 1571 : 		{	// grow by 50% or at least to _Count
; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, rbx
	shr	rax, 1
	sub	rcx, rax
	cmp	rcx, rbx
	jae	SHORT $LN47@Insert_n
	xor	ebx, ebx
	jmp	SHORT $LN48@Insert_n
$LN47@Insert_n:
	add	rbx, rax
$LN48@Insert_n:

; 1576 : 		if (_Capacity < _Count)

	cmp	rbx, rsi
	cmovb	rbx, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 107  : 	IC T*		xr_alloc	(u32 count)				{	return  (T*)Memory.mem_alloc(count*sizeof(T));	}

	mov	edx, ebx
	shl	rdx, 3
	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	r14, rax
	mov	QWORD PTR _Newvec$4[rsp], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1671 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

	mov	r15, QWORD PTR _Where$[rsp]
	sub	r15, QWORD PTR [rdi]
	sar	r15, 3

; 1672 : 			int _Ncopied = 0;
; 1673 : 
; 1674 : 			_TRY_BEGIN
; 1675 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1676 : 				_STD addressof(_Val));	// add new stuff

	lea	rcx, QWORD PTR [rax+r15*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	mov	r8, QWORD PTR _Val$[rsp]
	mov	esi, 1
	mov	edx, esi
	call	??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1677 : 			++_Ncopied;

	mov	DWORD PTR _Ncopied$1[rsp], esi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r14
	mov	rdx, QWORD PTR _Where$[rsp]
	mov	rcx, QWORD PTR [rdi]
	call	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1680 : 			++_Ncopied;

	mov	DWORD PTR _Ncopied$1[rsp], 2

; 1681 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1682 : 				_Newvec + (_Whereoff + _Count));	// copy suffix

	lea	r8, QWORD PTR [r15+1]
	lea	r8, QWORD PTR [r14+r8*8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rdx, QWORD PTR [rdi+8]
	mov	rcx, QWORD PTR _Where$[rsp]
	call	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1148 : 		return (this->_Mylast - this->_Myfirst);

	mov	rax, QWORD PTR [rdi]
	mov	rsi, QWORD PTR [rdi+8]
	sub	rsi, rax
	sar	rsi, 3

; 1683 : 			_CATCH_ALL
; 1684 : 			if (1 < _Ncopied)
; 1685 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1686 : 			if (0 < _Ncopied)
; 1687 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1688 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1689 : 			_RERAISE;
; 1690 : 			_CATCH_END
; 1691 : 
; 1692 : 			_Count += size();

	inc	rsi

; 1693 : 			if (this->_Myfirst != pointer())

	test	rax, rax
	je	SHORT $LN135@Insert_n
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rsp]
	call	??$xr_free@PEAUSect@CInifile@@@@YAXAEAPEAPEAUSect@CInifile@@@Z ; xr_free<CInifile::Sect * __ptr64>
$LN135@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1701 : 			this->_Myend = _Newvec + _Capacity;

	lea	rax, QWORD PTR [r14+rbx*8]
	mov	QWORD PTR [rdi+16], rax

; 1702 : 			this->_Mylast = _Newvec + _Count;

	lea	rax, QWORD PTR [r14+rsi*8]
	mov	QWORD PTR [rdi+8], rax

; 1703 : 			this->_Myfirst = _Newvec;

	mov	QWORD PTR [rdi], r14

; 1704 : 			}
; 1705 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))

	jmp	$LN218@Insert_n
$LN10@Insert_n:

; 1706 : 			< _Count)

	mov	rcx, rsi
	sub	rcx, rax
	sar	rcx, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rdx, rsi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1706 : 			< _Count)

	cmp	rcx, 1
	jae	$LN3@Insert_n

; 1707 : 			{	// new stuff spills off end
; 1708 : 			value_type _Tmp = _Val;	// in case _Val is in sequence

	mov	rcx, QWORD PTR _Val$[rsp]
	mov	r14, QWORD PTR [rcx]
	mov	QWORD PTR _Tmp$3[rsp], r14

; 1709 : 
; 1710 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1711 : 				_VIPTR(_Where) + _Count);	// copy suffix

	lea	r8, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	rcx, rax
	call	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
	npad	1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1716 : 				_STD addressof(_Tmp));	// insert new stuff off end

	mov	rcx, QWORD PTR [rdi+8]
	mov	rax, rcx
	sub	rax, QWORD PTR _Where$[rsp]
	sar	rax, 3
	mov	esi, 1
	sub	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	lea	r8, QWORD PTR _Tmp$3[rsp]
	mov	rdx, rsi
	call	??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
	npad	1
	add	QWORD PTR [rdi+8], 8
	mov	rax, QWORD PTR [rdi+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1726 : 				_Tmp);	// insert up to old end

	add	rax, -8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

	mov	rcx, QWORD PTR _Where$[rsp]
	xor	ebx, ebx
	mov	rdx, rax
	sub	rdx, rcx
	add	rdx, 7
	shr	rdx, 3
	cmp	rcx, rax
	cmova	rdx, rbx

; 2599 : 	for (; _First != _Last; ++_First)

	test	rdx, rdx
	je	$LN218@Insert_n
	npad	11
$LL241@Insert_n:

; 2600 : 		*_First = _Val;

	mov	QWORD PTR [rcx], r14
	lea	rcx, QWORD PTR [rcx+8]

; 2599 : 	for (; _First != _Last; ++_First)

	inc	rbx
	cmp	rbx, rdx
	jne	SHORT $LL241@Insert_n
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1728 : 		else

	jmp	SHORT $LN218@Insert_n
$LN3@Insert_n:

; 1729 : 			{	// new stuff can all be assigned
; 1730 : 			value_type _Tmp = _Val;	// in case _Val is in sequence

	mov	rax, QWORD PTR _Val$[rsp]
	mov	r14, QWORD PTR [rax]

; 1734 : 				this->_Mylast);	// copy suffix

	lea	rbx, QWORD PTR [rsi-8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, rsi
	mov	rcx, rbx
	call	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1734 : 				this->_Mylast);	// copy suffix

	mov	QWORD PTR [rdi+8], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	mov	rdx, QWORD PTR _Where$[rsp]
	sub	rbx, rdx
	sar	rbx, 3

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rbx*8]
	sub	rsi, r8
	mov	rcx, rsi
	call	QWORD PTR __imp_memmove

; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

	mov	rcx, QWORD PTR _Where$[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

	lea	rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rax
	je	SHORT $LN218@Insert_n
	npad	13
$LL220@Insert_n:

; 2600 : 		*_First = _Val;

	mov	QWORD PTR [rcx], r14

; 2599 : 	for (; _First != _Last; ++_First)

	add	rcx, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1740 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

	mov	rax, QWORD PTR _Where$[rsp]
	add	rax, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rax
	jne	SHORT $LL220@Insert_n
$LN218@Insert_n:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rdi]
	lea	rcx, QWORD PTR [rax+r12*8]

; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	QWORD PTR [r13], rcx

; 1741 : 			}
; 1742 : 		return (begin() + _Off);

	mov	rax, r13

; 1743 : 		}

	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	ret	0
$LN247@Insert_n:
?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT text$x
text$x	SEGMENT
_Ncopied$1 = 48
$T2 = 56
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$dead$ = 136
p$ = 136
p$ = 136
_Tmp$3 = 136
_Newvec$4 = 136
_Val$ = 144
?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA PROC ; `std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n'::`1'::catch$0

; 1683 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR _Newvec$4[rbp]
	mov	QWORD PTR p$[rbp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$[rbp]
	call	??$xr_free@PEAUSect@CInifile@@@@YAXAEAPEAPEAUSect@CInifile@@@Z ; xr_free<CInifile::Sect * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1689 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA ENDP ; `std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ncopied$1 = 48
$T2 = 56
this$ = 112
__$ReturnUdt$ = 120
_Where$ = 128
_Count$dead$ = 136
p$ = 136
p$ = 136
_Tmp$3 = 136
_Newvec$4 = 136
_Val$ = 144
?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA PROC ; `std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n'::`1'::catch$1

; 1717 : 			_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 48					; 00000030H
	mov	rbp, rdx
__catch$?_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z$2:

; 1718 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1719 : 				this->_Mylast + _Count);
; 1720 : 			_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$1@?0??_Insert_n@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@2@_KAEBQEAUSect@CInifile@@@Z@4HA ENDP ; `std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Insert_n'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 206  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAAEBQEAUSect@CInifile@@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAAEBQEAUSect@CInifile@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator*, COMDAT

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);

	mov	rax, QWORD PTR [rcx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAAEBQEAUSect@CInifile@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator++, COMDAT

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 8

; 113  : 		return (*this);

	mov	rax, rcx

; 114  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al

; 206  : 		}

	ret	0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA@PEAUItem@CInifile@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA@PEAUItem@CInifile@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAA@PEAUItem@CInifile@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++, COMDAT

; 112  : 		++this->_Ptr;

	add	QWORD PTR [rcx], 16

; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);

	mov	rax, rcx

; 336  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAA@PEAPEAUSect@CInifile@@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAA@PEAPEAUSect@CInifile@@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 307  : 		}

	mov	rax, rcx
	ret	0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAA@PEAPEAUSect@CInifile@@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEBUItem@CInifile@@@std@@SAPEBUItem@CInifile@@AEBU34@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEBUItem@CInifile@@@std@@SAPEBUItem@CInifile@@AEBU34@@Z PROC ; std::pointer_traits<CInifile::Item const * __ptr64>::pointer_to, COMDAT

; 234  : 		return (_STD addressof(_Val));

	mov	rax, rcx

; 235  : 		}

	ret	0
?pointer_to@?$pointer_traits@PEBUItem@CInifile@@@std@@SAPEBUItem@CInifile@@AEBU34@@Z ENDP ; std::pointer_traits<CInifile::Item const * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEBA_KXZ PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 4

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@QEBA_KXZ ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEBA_K_K@Z PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 1152921504606846975		; 0fffffffffffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r8, QWORD PTR [rcx]
	sar	r8, 4

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to
	xor	r8d, r8d

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU34@_KPEBU34@@Z
_TEXT	SEGMENT
this$dead$ = 64
_Ptr$ = 72
_Count$ = 80
_Pval$ = 88
?_Ufill@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU34@_KPEBU34@@Z PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Ufill, COMDAT

; 1746 : 		{	// copy initializing _Count * _Val, using allocator

$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, r8
	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 635  : 		_Val_type(_First), _Ptr_cat(_First, _First));

	mov	r8, r9
	mov	rdx, rdi
	mov	rcx, rbx
	call	??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1749 : 		return (_Ptr + _Count);

	add	rdi, rdi
	lea	rax, QWORD PTR [rbx+rdi*8]

; 1750 : 		}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_Ufill@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU34@_KPEBU34@@Z ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEBAXPEAUItem@CInifile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEBAXPEAUItem@CInifile@@0@Z PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEBAXPEAUItem@CInifile@@0@Z ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEBA_KXZ PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Unused_capacity, COMDAT

; 1015 : 		return (this->_Myend - this->_Mylast);

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx+8]
	sar	rax, 3

; 1016 : 		}

	ret	0
?_Unused_capacity@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEBA_KXZ ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEBA_K_K@Z PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Grow_to, COMDAT

; 1010 : 		return (this->_Myend - this->_Myfirst);

	mov	r8, QWORD PTR [rcx+16]

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1010 : 		return (this->_Myend - this->_Myfirst);

	sub	r8, QWORD PTR [rcx]
	sar	r8, 3

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	rax, r8
	jae	SHORT $LN4@Grow_to
	xor	r8d, r8d

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
$LN4@Grow_to:

; 1572 : 		size_type _Capacity = capacity();
; 1573 : 
; 1574 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1575 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	add	r8, rcx

; 1576 : 		if (_Capacity < _Count)

	cmp	r8, rdx
	cmovb	r8, rdx

; 1577 : 			_Capacity = _Count;
; 1578 : 		return (_Capacity);

	mov	rax, r8

; 1579 : 		}

	ret	0
?_Grow_to@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEBA_K_K@Z ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU34@_KPEBQEAU34@@Z
_TEXT	SEGMENT
this$dead$ = 64
_Ptr$ = 72
_Count$ = 80
_Pval$ = 88
?_Ufill@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU34@_KPEBQEAU34@@Z PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Ufill, COMDAT

; 1746 : 		{	// copy initializing _Count * _Val, using allocator

$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, r8
	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	mov	r8, r9
	mov	rdx, rdi
	mov	rcx, rbx
	call	??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1749 : 		return (_Ptr + _Count);

	lea	rax, QWORD PTR [rbx+rdi*8]

; 1750 : 		}

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_Ufill@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU34@_KPEBQEAU34@@Z ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEBAXPEAPEAUSect@CInifile@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEBAXPEAPEAUSect@CInifile@@0@Z PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Orphan_range, COMDAT

; 1781 : 		}

	ret	0
?_Orphan_range@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEBAXPEAPEAUSect@CInifile@@0@Z ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Compat, COMDAT

; 255  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Compat, COMDAT

; 255  : 		}

	ret	0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+, COMDAT

; 170  : 		_Ptr += _Off;

	shl	r8, 4

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	rax, rdx

; 170  : 		_Ptr += _Off;

	add	r8, QWORD PTR [rcx]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	QWORD PTR [rdx], r8

; 368  : 		}

	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+, COMDAT

; 170  : 		_Ptr += _Off;

	mov	rax, QWORD PTR [rcx]
	lea	rcx, QWORD PTR [rax+r8*8]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

	mov	rax, rdx
	mov	QWORD PTR [rdx], rcx

; 368  : 		}

	ret	0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	shl	rdx, 4

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 170  : 		_Ptr += _Off;

	add	QWORD PTR [rcx], rdx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

	mov	rax, rcx

; 362  : 		}

	ret	0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	shl	rdx, 4

; 171  : 		return (*this);

	mov	rax, rcx
	add	QWORD PTR [rcx], rdx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 171  : 		return (*this);

	mov	rax, rcx

; 172  : 		}

	ret	0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@VCInifile@@PEBDH@@YAPEAVCInifile@@AEBQEBDAEBH@Z
_TEXT	SEGMENT
p1$ = 64
p2$ = 72
??$xr_new@VCInifile@@PEBDH@@YAPEAVCInifile@@AEBQEBDAEBH@Z PROC ; xr_new<CInifile,char const * __ptr64,int>, COMDAT

; 79   : IC	T*		xr_new		(const P1& p1, const P2& p2) {

$LN8:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	rbx, rdx

; 80   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 48					; 00000030H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc

; 81   : 	return new (ptr) T(p1,p2);

	test	rax, rax
	je	SHORT $LN3@xr_new
	mov	r8d, DWORD PTR [rbx]
	mov	rdx, QWORD PTR [rdi]
	mov	r9d, 1
	mov	rcx, rax
	mov	DWORD PTR [rsp+32], 1
	call	??0CInifile@@QEAA@PEBDHHH@Z		; CInifile::CInifile

; 82   : }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN3@xr_new:
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$xr_new@VCInifile@@PEBDH@@YAPEAVCInifile@@AEBQEBDAEBH@Z ENDP ; xr_new<CInifile,char const * __ptr64,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z
_TEXT	SEGMENT
ptr$ = 48
??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z PROC	; xr_delete<CInifile>, COMDAT

; 150  : {

$LN32:
	push	rsi
	sub	rsp, 32					; 00000020H
	mov	rsi, rcx

; 151  : 	if (ptr) 

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN1@xr_delete
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+56], rdi

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR [rsi]
	xor	edx, edx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rdi, QWORD PTR [rax-1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 133  : 		ptr->~T			();

	mov	r8, QWORD PTR [rcx]
	call	QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN8@xr_delete
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN29@xr_delete

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN29@xr_delete
$LN8@xr_delete:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN29@xr_delete:
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 154  : 		ptr = NULL;

	mov	QWORD PTR [rsi], 0
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$xr_delete@VCInifile@@@@YAXAEAPEAVCInifile@@@Z ENDP	; xr_delete<CInifile>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@PEBDP6A_NAEBUItem@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NAEBUItem@CInifile@@PEBD@Z@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Val$ = 88
_Pred$dead$ = 96
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@PEBDP6A_NAEBUItem@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NAEBUItem@CInifile@@PEBD@Z@Z PROC ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >,char const * __ptr64,bool (__cdecl*)(CInifile::Item const & __ptr64,char const * __ptr64)>, COMDAT

; 2531 : 	{	// find first element not before _Val, using _Pred

$LN18:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	r10, r8
	mov	rax, rdx
	mov	rbx, rcx

; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));

	mov	rdx, r10
	mov	rcx, rax
	mov	r8, r9
	call	??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z ; std::_Lower_bound<CInifile::Item * __ptr64,char const * __ptr64,__int64,bool (__cdecl*)(CInifile::Item const & __ptr64,char const * __ptr64)>
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 2536 : 	}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@PEBDP6A_NAEBUItem@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NAEBUItem@CInifile@@PEBD@Z@Z ENDP ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >,char const * __ptr64,bool (__cdecl*)(CInifile::Item const & __ptr64,char const * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z
_TEXT	SEGMENT
ptr$ = 48
??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z PROC ; xr_delete<CInifile::Sect>, COMDAT

; 150  : {

$LN49:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	sub	rsp, 32					; 00000020H

; 151  : 	if (ptr) 

	mov	rbx, QWORD PTR [rcx]
	mov	rsi, rcx
	test	rbx, rbx
	je	$LN1@xr_delete
	lea	rcx, QWORD PTR [rbx+8]
	mov	QWORD PTR [rsp+48], rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 945  : 		_Tidy();

	call	?_Tidy@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAXXZ ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rbx]
	test	rax, rax
	je	SHORT $LN17@xr_delete
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN17@xr_delete
	mov	QWORD PTR [rbx], 0
$LN17@xr_delete:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	rdi, QWORD PTR [rsi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN25@xr_delete
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN46@xr_delete

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 300  : 
; 301  : 	/* ptr is the pointer to the start of memory block*/
; 302  : 	ptr = *((uintptr_t *)ptr);
; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
	call	QWORD PTR __imp_free
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 157  : 	} else {

	jmp	SHORT $LN46@xr_delete
$LN25@xr_delete:

; 158  : 		// pooled
; 159  : 		VERIFY2					(pool<mem_pools_count,"Memory corruption");
; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN46@xr_delete:
	mov	rdi, QWORD PTR [rsp+48]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 154  : 		ptr = NULL;

	mov	QWORD PTR [rsi], 0
$LN1@xr_delete:

; 155  : 	}
; 156  : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
??$xr_delete@USect@CInifile@@@@YAXAEAPEAUSect@CInifile@@@Z ENDP ; xr_delete<CInifile::Sect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@PEBDP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Val$ = 88
_Pred$dead$ = 96
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@PEBDP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z PROC ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >,char const * __ptr64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>, COMDAT

; 2531 : 	{	// find first element not before _Val, using _Pred

$LN18:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	r10, r8
	mov	rax, rdx
	mov	rbx, rcx

; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));

	mov	rdx, r10
	mov	rcx, rax
	mov	r8, r9
	call	??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z ; std::_Lower_bound<CInifile::Sect * __ptr64 * __ptr64,char const * __ptr64,__int64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 2536 : 	}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@PEBDP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEBQEBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z ENDP ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >,char const * __ptr64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??$xr_new@USect@CInifile@@@@YAPEAUSect@CInifile@@XZ
_TEXT	SEGMENT
??$xr_new@USect@CInifile@@@@YAPEAUSect@CInifile@@XZ PROC ; xr_new<CInifile::Sect>, COMDAT

; 67   : {

$LN22:
	sub	rsp, 40					; 00000028H

; 68   : 	T* ptr	= (T*)Memory.mem_alloc(sizeof(T));

	lea	rcx, OFFSET FLAT:?Memory@@3VxrMemory@@A	; Memory
	mov	edx, 32					; 00000020H
	call	?mem_alloc@xrMemory@@QEAAPEAX_K@Z	; xrMemory::mem_alloc
	mov	rcx, rax

; 69   : 	return new (ptr) T();

	test	rax, rax
	je	SHORT $LN3@xr_new
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 57   : 						shared_str	()								{	p_ = 0;											}

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 482  : 		_Myfirst = pointer();

	mov	QWORD PTR [rcx+8], rax

; 483  : 		_Mylast = pointer();

	mov	QWORD PTR [rcx+16], rax

; 484  : 		_Myend = pointer();

	mov	QWORD PTR [rcx+24], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 69   : 	return new (ptr) T();

	mov	rax, rcx

; 70   : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@xr_new:
	add	rsp, 40					; 00000028H
	ret	0
??$xr_new@USect@CInifile@@@@YAPEAUSect@CInifile@@XZ ENDP ; xr_new<CInifile::Sect>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@$$BY0BAA@DP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEAY0BAA@$$CBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 64
_First$ = 72
_Last$ = 80
_Val$ = 88
_Pred$dead$ = 96
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@$$BY0BAA@DP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEAY0BAA@$$CBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z PROC ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >,char [256],bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>, COMDAT

; 2531 : 	{	// find first element not before _Val, using _Pred

$LN18:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	r10, r8
	mov	rax, rdx
	mov	rbx, rcx

; 2532 : //	_DEBUG_ORDER_PRED(_First, _Last, _Pred);
; 2533 : 	return (_Rechecked(_First,
; 2534 : 		_Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
; 2535 : 			_Dist_type(_First))));

	mov	rdx, r10
	mov	rcx, rax
	mov	r8, r9
	call	??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z ; std::_Lower_bound<CInifile::Sect * __ptr64 * __ptr64,char const [256],__int64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx

; 2536 : 	}

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$lower_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@$$BY0BAA@DP6A_NPEBUSect@CInifile@@PEBD@Z@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@V10@0AEAY0BAA@$$CBDP6A_NPEBUSect@CInifile@@PEBD@Z@Z ENDP ; std::lower_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >,char [256],bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ??$strcpy_s@$0CAA@@@YAHAEAY0CAA@DPEBD@Z
_TEXT	SEGMENT
_Dest$ = 8
_Source$ = 16
??$strcpy_s@$0CAA@@@YAHAEAY0CAA@DPEBD@Z PROC		; strcpy_s<512>, COMDAT

; 111  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Post_z_ char, _Dest, _In_z_ const char *, _Source)

	mov	r8, rdx
	mov	edx, 512				; 00000200H
	rex_jmp	QWORD PTR __imp_strcpy_s
??$strcpy_s@$0CAA@@@YAHAEAY0CAA@DPEBD@Z ENDP		; strcpy_s<512>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Move@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z PROC ; std::_Move<CInifile::Item * __ptr64,CInifile::Item * __ptr64>, COMDAT

; 2439 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

	mov	r9, rcx

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN36@Move
	sub	r9, r8
	xor	r10d, r10d
	npad	2
$LL7@Move:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rcx, QWORD PTR [r9+r8]
	test	rcx, rcx
	je	SHORT $LN16@Move
	inc	DWORD PTR [rcx]
$LN16@Move:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8]
	test	rax, rax
	je	SHORT $LN19@Move
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8]
	cmp	DWORD PTR [rax], r10d
	jne	SHORT $LN19@Move
	mov	QWORD PTR [r8], r10
$LN19@Move:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8], rcx
	mov	rcx, QWORD PTR [r9+r8+8]
	test	rcx, rcx
	je	SHORT $LN25@Move
	inc	DWORD PTR [rcx]
$LN25@Move:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN28@Move
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8+8]
	cmp	DWORD PTR [rax], r10d
	jne	SHORT $LN28@Move
	mov	QWORD PTR [r8+8], r10
$LN28@Move:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8+8], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 16
	lea	rax, QWORD PTR [r9+r8]
	cmp	rax, rdx
	jne	SHORT $LL7@Move
$LN36@Move:

; 2440 : 	return (_Move(_First, _Last,
; 2441 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, r8

; 2442 : 	}

	ret	0
??$_Move@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z ENDP ; std::_Move<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUItem@CInifile@@@std@@YAPEBUItem@CInifile@@AEBU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBUItem@CInifile@@@std@@YAPEBUItem@CInifile@@AEBU12@@Z PROC ; std::addressof<CInifile::Item const >, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@$$CBUItem@CInifile@@@std@@YAPEBUItem@CInifile@@AEBU12@@Z ENDP ; std::addressof<CInifile::Item const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAUItem@CInifile@@@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU23@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAUItem@CInifile@@@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU23@00@Z PROC ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Umove<CInifile::Item * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN20:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAUItem@CInifile@@@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAPEAUItem@CInifile@@PEAU23@00@Z ENDP ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Umove<CInifile::Item * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@UItem@CInifile@@@std@@YAPEAUItem@CInifile@@AEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@UItem@CInifile@@@std@@YAPEAUItem@CInifile@@AEAU12@@Z PROC ; std::addressof<CInifile::Item>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@UItem@CInifile@@@std@@YAPEAUItem@CInifile@@AEAU12@@Z ENDP ; std::addressof<CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$fill@PEAUItem@CInifile@@U12@@std@@YAXPEAUItem@CInifile@@0AEBU12@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$fill@PEAUItem@CInifile@@U12@@std@@YAXPEAUItem@CInifile@@0AEBU12@@Z PROC ; std::fill<CInifile::Item * __ptr64,CInifile::Item>, COMDAT

; 2621 : 	{	// copy _Val through [_First, _Last)

	mov	r10, rdx

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN7@fill
	xor	r11d, r11d
	npad	5
$LL9@fill:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r9, QWORD PTR [r8]
	test	r9, r9
	je	SHORT $LN16@fill
	inc	DWORD PTR [r9]
$LN16@fill:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN19@fill
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN19@fill
	mov	QWORD PTR [rcx], r11
$LN19@fill:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx], r9
	mov	rdx, QWORD PTR [r8+8]
	test	rdx, rdx
	je	SHORT $LN25@fill
	inc	DWORD PTR [rdx]
$LN25@fill:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN28@fill
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+8]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN28@fill
	mov	QWORD PTR [rcx+8], r11
$LN28@fill:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx+8], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	add	rcx, 16
	cmp	rcx, r10
	jne	SHORT $LL9@fill
$LN7@fill:

; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}

	ret	0
??$fill@PEAUItem@CInifile@@U12@@std@@YAXPEAUItem@CInifile@@0AEBU12@@Z ENDP ; std::fill<CInifile::Item * __ptr64,CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z PROC ; std::_Copy_backward<CInifile::Item * __ptr64,CInifile::Item * __ptr64>, COMDAT

; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

	mov	r9, rdx
	mov	r10, rcx

; 2345 : 	while (_First != _Last)

	cmp	rcx, rdx
	je	SHORT $LN33@Copy_backw
	sub	r9, r8
	xor	r11d, r11d
	npad	15
$LL6@Copy_backw:

; 2346 : 		*--_Dest = *--_Last;

	sub	r8, 16
	lea	rdx, QWORD PTR [r9+r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rcx, QWORD PTR [rdx]
	test	rcx, rcx
	je	SHORT $LN13@Copy_backw
	inc	DWORD PTR [rcx]
$LN13@Copy_backw:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8]
	test	rax, rax
	je	SHORT $LN16@Copy_backw
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN16@Copy_backw
	mov	QWORD PTR [r8], r11
$LN16@Copy_backw:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8], rcx
	mov	rcx, QWORD PTR [r9+r8+8]
	test	rcx, rcx
	je	SHORT $LN22@Copy_backw
	inc	DWORD PTR [rcx]
$LN22@Copy_backw:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN25@Copy_backw
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8+8]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN25@Copy_backw
	mov	QWORD PTR [r8+8], r11
$LN25@Copy_backw:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8+8], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2345 : 	while (_First != _Last)

	cmp	rdx, r10
	jne	SHORT $LL6@Copy_backw
$LN33@Copy_backw:

; 2366 : 	return (_Copy_backward(_First, _Last,
; 2367 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, r8

; 2368 : 	}

	ret	0
??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00@Z ENDP ; std::_Copy_backward<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@QEAUSect@CInifile@@@std@@YAPEBQEAUSect@CInifile@@AEBQEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@QEAUSect@CInifile@@@std@@YAPEBQEAUSect@CInifile@@AEBQEAU12@@Z PROC ; std::addressof<CInifile::Sect * __ptr64 const>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@QEAUSect@CInifile@@@std@@YAPEBQEAUSect@CInifile@@AEBQEAU12@@Z ENDP ; std::addressof<CInifile::Sect * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Umove@PEAPEAUSect@CInifile@@@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU23@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAPEAUSect@CInifile@@@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU23@00@Z PROC ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Umove<CInifile::Sect * __ptr64 * __ptr64>, COMDAT

; 1644 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN22:
	sub	rsp, 56					; 00000038H
	mov	rax, r8
	mov	rcx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	mov	r8, r9
	mov	rdx, rax
	call	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 1649 : 		}

	add	rsp, 56					; 00000038H
	ret	0
??$_Umove@PEAPEAUSect@CInifile@@@?$vector@PEAUSect@CInifile@@V?$xalloc@PEAUSect@CInifile@@@@@std@@IEAAPEAPEAUSect@CInifile@@PEAPEAU23@00@Z ENDP ; std::vector<CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64> >::_Umove<CInifile::Sect * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
;	COMDAT ??$addressof@PEAUSect@CInifile@@@std@@YAPEAPEAUSect@CInifile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAUSect@CInifile@@@std@@YAPEAPEAUSect@CInifile@@AEAPEAU12@@Z PROC ; std::addressof<CInifile::Sect * __ptr64>, COMDAT

; 93   : 	return (reinterpret_cast<_Ty *>(
; 94   : 		(&const_cast<char&>(
; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	rax, rcx

; 96   : 	}

	ret	0
??$addressof@PEAUSect@CInifile@@@std@@YAPEAPEAUSect@CInifile@@AEAPEAU12@@Z ENDP ; std::addressof<CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$fill@PEAPEAUSect@CInifile@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@0AEBQEAU12@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$fill@PEAPEAUSect@CInifile@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@0AEBQEAU12@@Z PROC ; std::fill<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64>, COMDAT

; 2621 : 	{	// copy _Val through [_First, _Last)

	xor	r9d, r9d
	mov	r10, rdx
	sub	r10, rcx
	add	r10, 7
	shr	r10, 3
	cmp	rcx, rdx
	cmova	r10, r9

; 2599 : 	for (; _First != _Last; ++_First)

	test	r10, r10
	je	SHORT $LN7@fill
	npad	3
$LL9@fill:

; 2600 : 		*_First = _Val;

	mov	rax, QWORD PTR [r8]
	inc	r9
	lea	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx-8], rax
	cmp	r9, r10
	jne	SHORT $LL9@fill
$LN7@fill:

; 2622 : 	_DEBUG_RANGE(_First, _Last);
; 2623 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2624 : 	}

	ret	0
??$fill@PEAPEAUSect@CInifile@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@0AEBQEAU12@@Z ENDP ; std::fill<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00@Z PROC ; std::_Copy_backward<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64>, COMDAT

; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx

; 2365 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

	mov	rbx, r8

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sar	rdx, 3

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rdx*8]
	mov	rdx, rcx
	sub	rbx, r8
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove

; 2366 : 	return (_Copy_backward(_First, _Last,
; 2367 : 		_Dest, _Ptr_cat(_First, _Dest)));

	mov	rax, rbx

; 2368 : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00@Z ENDP ; std::_Copy_backward<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PEAUItem@CInifile@@_KU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
??$_Uninitialized_fill_n@PEAUItem@CInifile@@_KU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z PROC ; std::_Uninitialized_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,std::_Wrap_alloc<xalloc<CInifile::Item> > >, COMDAT

; 633  : 	{	// copy _Count * *_Pval to raw _First, using _Al

$LN8:
	sub	rsp, 56					; 00000038H

; 634  : 	_Uninit_fill_n(_First, _Count, _Pval, _Al,
; 635  : 		_Val_type(_First), _Ptr_cat(_First, _First));

	call	??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>

; 636  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_fill_n@PEAUItem@CInifile@@_KU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,std::_Wrap_alloc<xalloc<CInifile::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
??$_Uninitialized_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z PROC ; std::_Uninitialized_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >, COMDAT

; 633  : 	{	// copy _Count * *_Pval to raw _First, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	call	??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>

; 634  : 	_Uninit_fill_n(_First, _Count, _Pval, _Al,
; 635  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 636  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z ENDP ; std::_Uninitialized_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$00VCInifile@@@@QEAAXAEAPEAVCInifile@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$ = 56
??R?$xr_special_free@$00VCInifile@@@@QEAAXAEAPEAVCInifile@@@Z PROC ; xr_special_free<1,CInifile>::operator(), COMDAT

; 131  : 	{

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 132  : 		void*	_real_ptr	= dynamic_cast<void*>(ptr);

	mov	rcx, QWORD PTR [rdx]
	mov	rbx, rdx
	call	__RTCastToVoid

; 133  : 		ptr->~T			();

	mov	rcx, QWORD PTR [rbx]
	xor	edx, edx
	mov	r8, QWORD PTR [rcx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	lea	rdi, QWORD PTR [rax-1]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 133  : 		ptr->~T			();

	call	QWORD PTR [r8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi]

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN5@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN26@operator

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 135  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 303  : 	free((void *)ptr);

	rex_jmp	QWORD PTR __imp_free
$LN5@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN26@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 135  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$xr_special_free@$00VCInifile@@@@QEAAXAEAPEAVCInifile@@@Z ENDP ; xr_special_free<1,CInifile>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h
;	COMDAT ??R?$xr_special_free@$0A@USect@CInifile@@@@QEAAXAEAPEAUSect@CInifile@@@Z
_TEXT	SEGMENT
this$dead$ = 48
ptr$ = 56
??R?$xr_special_free@$0A@USect@CInifile@@@@QEAAXAEAPEAUSect@CInifile@@@Z PROC ; xr_special_free<0,CInifile::Sect>::operator(), COMDAT

; 142  : 	{

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 143  : 		ptr->~T			();

	mov	rbx, QWORD PTR [rdx]
	mov	rdi, rdx
	lea	rcx, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 945  : 		_Tidy();

	call	?_Tidy@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAXXZ ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rbx]
	test	rax, rax
	je	SHORT $LN14@operator
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [rax], 0
	jne	SHORT $LN14@operator
	mov	QWORD PTR [rbx], 0
$LN14@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 144  : 		Memory.mem_free	(ptr);

	mov	rdi, QWORD PTR [rdi]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 130  : 	stat_calls++;

	inc	DWORD PTR ?Memory@@3VxrMemory@@A

; 25   : ICF	u32		get_header			(void* P)	{	return	(u32)*acc_header(P);				}

	movzx	eax, BYTE PTR [rdi-1]

; 24   : ICF	u8*		acc_header			(void* P)	{	u8*		_P		= (u8*)P;	return	_P-1;	}

	dec	rdi

; 131  : #ifdef USE_MEMORY_MONITOR
; 132  : 	memory_monitor::monitor_free(P);
; 133  : #endif // USE_MEMORY_MONITOR
; 134  : 
; 135  : #ifdef PURE_ALLOC
; 136  : 	if (g_use_pure_alloc) {
; 137  : 		free					(P);
; 138  : 		return;
; 139  : 	}
; 140  : #endif // PURE_ALLOC
; 141  : 
; 142  : #ifdef DEBUG_MEMORY_MANAGER
; 143  : 	if(g_globalCheckAddr==P)
; 144  : 		__asm int 3;
; 145  : #endif // DEBUG_MEMORY_MANAGER
; 146  : 
; 147  : #ifdef DEBUG_MEMORY_MANAGER
; 148  : 	if (mem_initialized)		debug_cs.Enter		();
; 149  : #endif // DEBUG_MEMORY_MANAGER
; 150  : 	if		(debug_mode)		dbg_unregister	(P);
; 151  : 	u32	pool					= get_header	(P);
; 152  : 	void* _real					= (void*)(((u8*)P)-1);
; 153  : 	if (mem_generic==pool)		

	cmp	eax, 55					; 00000037H
	jne	SHORT $LN22@operator
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 293  : 	if (memblock == NULL)

	test	rdi, rdi
	je	SHORT $LN43@operator

; 294  : 		return;
; 295  : 
; 296  : 	ptr = (uintptr_t)memblock;
; 297  : 
; 298  : 	/* ptr points to the pointer to starting of the memory block */
; 299  : 	ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

	and	rdi, -8

; 303  : 	free((void *)ptr);

	mov	rcx, QWORD PTR [rdi-8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 145  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_align.cpp

; 303  : 	free((void *)ptr);

	rex_jmp	QWORD PTR __imp_free
$LN22@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.cpp

; 160  : 		mem_pools[pool].destroy	(_real);

	lea	rcx, QWORD PTR [rax+rax*4]
	lea	rax, OFFSET FLAT:?mem_pools@@3PAVMEMPOOL@@A ; mem_pools
	lea	rbx, QWORD PTR [rax+rcx*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 64   : 	EnterCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rax+rcx*8]
	call	QWORD PTR __imp_EnterCriticalSection
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 46   : 		*access(P)		= list;

	mov	rax, QWORD PTR [rbx+32]
	mov	QWORD PTR [rdi], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_pool.h

; 47   : 		list			= (u8*)P;

	mov	QWORD PTR [rbx+32], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrsyncronize.cpp

; 69   : 	LeaveCriticalSection			( (CRITICAL_SECTION*)pmutex );

	call	QWORD PTR __imp_LeaveCriticalSection
$LN43@operator:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory_subst_msvc.h

; 145  : 	}

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R?$xr_special_free@$0A@USect@CInifile@@@@QEAAXAEAPEAUSect@CInifile@@@Z ENDP ; xr_special_free<0,CInifile::Sect>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
;	COMDAT ??_GSect@CInifile@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GSect@CInifile@@QEAAPEAXI@Z PROC			; CInifile::Sect::`scalar deleting destructor', COMDAT
$LN21:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	add	rcx, 8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector

; 945  : 		_Tidy();

	call	?_Tidy@?$vector@UItem@CInifile@@V?$xalloc@UItem@CInifile@@@@@std@@IEAAXXZ ; std::vector<CInifile::Item,xalloc<CInifile::Item> >::_Tidy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rbx]
	test	rax, rax
	je	SHORT $LN19@scalar
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rbx]
	cmp	DWORD PTR [rax], 0
	mov	rax, rbx
	jne	SHORT $LN12@scalar
	mov	QWORD PTR [rbx], 0
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN19@scalar:
	mov	rax, rbx
$LN12@scalar:
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_GSect@CInifile@@QEAAPEAXI@Z ENDP			; CInifile::Sect::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@YAPEAUItem@CInifile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Iter$ = 8
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@YAPEAUItem@CInifile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CInifile::Item> > >, COMDAT

; 396  : 	return (_Iter._Unchecked());

	mov	rax, rcx

; 397  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@YAPEAUItem@CInifile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CInifile::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > > >, COMDAT

; 706  : 	return (0);

	xor	eax, eax

; 707  : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Val$ = 64
_Pred$dead$ = 72
__formal$dead$ = 80
??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z PROC ; std::_Lower_bound<CInifile::Item * __ptr64,char const * __ptr64,__int64,bool (__cdecl*)(CInifile::Item const & __ptr64,char const * __ptr64)>, COMDAT

; 2504 : 	{	// find first element not before _Val, using _Pred

$LN58:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rbp
	push	r14
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	r14, r8
	mov	rbp, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	rbx, rcx
	sar	rbx, 4
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jle	SHORT $LN56@Lower_boun
	mov	QWORD PTR [rsp+48], rsi
	mov	QWORD PTR [rsp+56], rdi
	npad	1
$LL4@Lower_boun:

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, rbx
	cdq
	sub	rax, rdx

; 2514 : 		if (_Pred(*_Mid, _Val))

	mov	rdx, QWORD PTR [r14]
	sar	rax, 1
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	mov	rdi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rsi, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	shl	rdi, 4
	add	rdi, rbp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	mov	rcx, rdi
	call	?item_pred@@YA_NAEBUItem@CInifile@@PEBD@Z ; item_pred
	test	al, al
	je	SHORT $LN2@Lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rcx, -1
	lea	rbp, QWORD PTR [rdi+16]
	sub	rcx, rsi
	add	rbx, rcx

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2521 : 			_Count = _Count2;

	mov	rbx, rsi
$LN1@Lower_boun:

; 2508 : 	while (0 < _Count)

	test	rbx, rbx
	jg	SHORT $LL4@Lower_boun
	mov	rdi, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+48]
$LN56@Lower_boun:

; 2522 : 		}
; 2523 : 	return (_First);
; 2524 : 	}

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rbp
	mov	rbp, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
??$_Lower_bound@PEAUItem@CInifile@@PEBD_JP6A_NAEBU12@PEBD@Z@std@@YAPEAUItem@CInifile@@PEAU12@0AEBQEBDP6A_NAEBU12@PEBD@ZPEA_J@Z ENDP ; std::_Lower_bound<CInifile::Item * __ptr64,char const * __ptr64,__int64,bool (__cdecl*)(CInifile::Item const & __ptr64,char const * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@AEAV10@PEAUItem@CInifile@@@Z
_TEXT	SEGMENT
_Iter$ = 8
_Right$ = 16
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@AEAV10@PEAUItem@CInifile@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CInifile::Item> > >, COMDAT

; 313  : 		this->_Ptr = _Right;

	mov	QWORD PTR [rcx], rdx

; 405  : 	return (_Iter._Rechecked(_Right));

	mov	rax, rcx

; 406  : 	}

	ret	0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@0@AEAV10@PEAUItem@CInifile@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CInifile::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@YAPEAPEAUSect@CInifile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_Iter$ = 8
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@YAPEAPEAUSect@CInifile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >, COMDAT

; 396  : 	return (_Iter._Unchecked());

	mov	rax, rcx

; 397  : 	}

	ret	0
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@YAPEAPEAUSect@CInifile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > > >, COMDAT

; 706  : 	return (0);

	xor	eax, eax

; 707  : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@@std@@YAPEA_JV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
_Pred$dead$ = 40
__formal$dead$ = 48
??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z PROC ; std::_Lower_bound<CInifile::Sect * __ptr64 * __ptr64,char const * __ptr64,__int64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>, COMDAT

; 2504 : 	{	// find first element not before _Val, using _Pred

$LN34:
	sub	rsp, 8
	mov	r9, rdx
	mov	r11, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	r9, rcx
	sar	r9, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jle	SHORT $LN32@Lower_boun

; 2514 : 		if (_Pred(*_Mid, _Val))

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp], rdi
	mov	rdi, QWORD PTR [r8]
$LL4@Lower_boun:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	rbx, QWORD PTR [r11+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN24@Lower_boun
	add	rcx, 12
$LN24@Lower_boun:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rdi
	sub	r8, rcx
	npad	7
$LL30@Lower_boun:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN31@Lower_boun
	inc	rcx
	test	eax, eax
	jne	SHORT $LL30@Lower_boun
$LN31@Lower_boun:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	test	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	jns	SHORT $LN2@Lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	r11, QWORD PTR [rbx+8]
	sub	rax, r10
	add	r9, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2521 : 			_Count = _Count2;

	mov	r9, r10
$LN1@Lower_boun:

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jg	SHORT $LL4@Lower_boun
	mov	rdi, QWORD PTR [rsp]
	mov	rbx, QWORD PTR [rsp+16]
$LN32@Lower_boun:

; 2522 : 		}
; 2523 : 	return (_First);

	mov	rax, r11

; 2524 : 	}

	add	rsp, 8
	ret	0
??$_Lower_bound@PEAPEAUSect@CInifile@@PEBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEBQEBDP6A_NPEBU12@PEBD@ZPEA_J@Z ENDP ; std::_Lower_bound<CInifile::Sect * __ptr64 * __ptr64,char const * __ptr64,__int64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@AEAV10@PEAPEAUSect@CInifile@@@Z
_TEXT	SEGMENT
_Iter$ = 8
_Right$ = 16
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@AEAV10@PEAPEAUSect@CInifile@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >, COMDAT

; 313  : 		this->_Ptr = _Right;

	mov	QWORD PTR [rcx], rdx

; 405  : 	return (_Iter._Rechecked(_Right));

	mov	rax, rcx

; 406  : 	}

	ret	0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@YAAEAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@0@AEAV10@PEAPEAUSect@CInifile@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm
;	COMDAT ??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z
_TEXT	SEGMENT
_First$ = 16
_Last$ = 24
_Val$ = 32
_Pred$dead$ = 40
__formal$dead$ = 48
??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z PROC ; std::_Lower_bound<CInifile::Sect * __ptr64 * __ptr64,char const [256],__int64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>, COMDAT

; 2504 : 	{	// find first element not before _Val, using _Pred

$LN34:
	push	rdi
	mov	r9, rdx
	mov	rdi, r8
	mov	r11, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 750  : 	_Off += _Last - _First;

	sub	r9, rcx
	sar	r9, 3
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jle	SHORT $LN32@Lower_boun
	mov	QWORD PTR [rsp+16], rbx
	npad	4
$LL4@Lower_boun:

; 2509 : 		{	// divide and conquer, find half that contains answer
; 2510 : 		_Diff _Count2 = _Count / 2;

	mov	rax, r9
	cdq
	sub	rax, rdx
	sar	rax, 1
	mov	r10, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 690  : 	_Where += _Off;

	lea	rbx, QWORD PTR [r11+rax*8]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	mov	rcx, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	mov	rcx, QWORD PTR [rcx]
	test	rcx, rcx
	je	SHORT $LN24@Lower_boun
	add	rcx, 12
$LN24@Lower_boun:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 279  : {	return (int)strcmp(S1,S2);  }

	mov	r8, rdi
	sub	r8, rcx
	npad	9
$LL30@Lower_boun:
	movzx	edx, BYTE PTR [rcx]
	movzx	eax, BYTE PTR [rcx+r8]
	sub	edx, eax
	jne	SHORT $LN31@Lower_boun
	inc	rcx
	test	eax, eax
	jne	SHORT $LL30@Lower_boun
$LN31@Lower_boun:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_ini.cpp

; 16   : 	return xr_strcmp(*x->Name,val)<0;

	test	edx, edx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\algorithm

; 2514 : 		if (_Pred(*_Mid, _Val))

	jns	SHORT $LN2@Lower_boun

; 2515 : //		if (_DEBUG_LT_PRED(_Pred, *_Mid, _Val))
; 2516 : 			{	// try top half
; 2517 : 			_First = ++_Mid;
; 2518 : 			_Count -= _Count2 + 1;

	or	rax, -1
	lea	r11, QWORD PTR [rbx+8]
	sub	rax, r10
	add	r9, rax

; 2519 : 			}
; 2520 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2521 : 			_Count = _Count2;

	mov	r9, r10
$LN1@Lower_boun:

; 2508 : 	while (0 < _Count)

	test	r9, r9
	jg	SHORT $LL4@Lower_boun
	mov	rbx, QWORD PTR [rsp+16]
$LN32@Lower_boun:

; 2522 : 		}
; 2523 : 	return (_First);

	mov	rax, r11

; 2524 : 	}

	pop	rdi
	ret	0
??$_Lower_bound@PEAPEAUSect@CInifile@@$$BY0BAA@$$CBD_JP6A_NPEBU12@PEBD@Z@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@0AEAY0BAA@$$CBDP6A_NPEBU12@PEBD@ZPEA_J@Z ENDP ; std::_Lower_bound<CInifile::Sect * __ptr64 * __ptr64,char const [256],__int64,bool (__cdecl*)(CInifile::Sect const * __ptr64,char const * __ptr64)>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Move@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Move@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CInifile::Item * __ptr64,CInifile::Item * __ptr64>, COMDAT

; 2418 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	r10, rcx

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN32@Move
	xor	r11d, r11d
	npad	5
$LL3@Move:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r9, QWORD PTR [r10]
	test	r9, r9
	je	SHORT $LN12@Move
	inc	DWORD PTR [r9]
$LN12@Move:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8]
	test	rax, rax
	je	SHORT $LN15@Move
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN15@Move
	mov	QWORD PTR [r8], r11
$LN15@Move:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8], r9
	mov	rcx, QWORD PTR [r10+8]
	test	rcx, rcx
	je	SHORT $LN21@Move
	inc	DWORD PTR [rcx]
$LN21@Move:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN24@Move
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8+8]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN24@Move
	mov	QWORD PTR [r8+8], r11
$LN24@Move:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r10, 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8+8], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2419 : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 16
	cmp	r10, rdx
	jne	SHORT $LL3@Move
$LN32@Move:

; 2420 : 		*_Dest = _STD move(*_First);
; 2421 : 	return (_Dest);

	mov	rax, r8

; 2422 : 	}

	ret	0
??$_Move@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z PROC ; std::_Uninitialized_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Item> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN18:
	sub	rsp, 56					; 00000038H

; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	call	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z ENDP ; std::_Uninitialized_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill@PEAUItem@CInifile@@U12@@std@@YAXPEAUItem@CInifile@@0AEBU12@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Fill@PEAUItem@CInifile@@U12@@std@@YAXPEAUItem@CInifile@@0AEBU12@@Z PROC ; std::_Fill<CInifile::Item * __ptr64,CInifile::Item>, COMDAT

; 2598 : 	{	// copy _Val through [_First, _Last)

	mov	r10, rdx

; 2599 : 	for (; _First != _Last; ++_First)

	cmp	rcx, rdx
	je	SHORT $LN1@Fill
	xor	r11d, r11d
	npad	5
$LL3@Fill:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r9, QWORD PTR [r8]
	test	r9, r9
	je	SHORT $LN10@Fill
	inc	DWORD PTR [r9]
$LN10@Fill:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN13@Fill
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN13@Fill
	mov	QWORD PTR [rcx], r11
$LN13@Fill:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx], r9
	mov	rdx, QWORD PTR [r8+8]
	test	rdx, rdx
	je	SHORT $LN19@Fill
	inc	DWORD PTR [rdx]
$LN19@Fill:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN22@Fill
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+8]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN22@Fill
	mov	QWORD PTR [rcx+8], r11
$LN22@Fill:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx+8], rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2599 : 	for (; _First != _Last; ++_First)

	add	rcx, 16
	cmp	rcx, r10
	jne	SHORT $LL3@Fill
$LN1@Fill:

; 2600 : 		*_First = _Val;
; 2601 : 	}

	ret	0
??$_Fill@PEAUItem@CInifile@@U12@@std@@YAXPEAUItem@CInifile@@0AEBU12@@Z ENDP ; std::_Fill<CInifile::Item * __ptr64,CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<CInifile::Item * __ptr64,CInifile::Item * __ptr64>, COMDAT

; 2344 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	mov	r10, rcx

; 2345 : 	while (_First != _Last)

	cmp	rcx, rdx
	je	SHORT $LN29@Copy_backw
	xor	r11d, r11d
	npad	5
$LL2@Copy_backw:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r9, QWORD PTR [rdx-16]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2346 : 		*--_Dest = *--_Last;

	sub	rdx, 16
	sub	r8, 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	test	r9, r9
	je	SHORT $LN9@Copy_backw
	inc	DWORD PTR [r9]
$LN9@Copy_backw:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8]
	test	rax, rax
	je	SHORT $LN12@Copy_backw
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN12@Copy_backw
	mov	QWORD PTR [r8], r11
$LN12@Copy_backw:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8], r9
	mov	rcx, QWORD PTR [rdx+8]
	test	rcx, rcx
	je	SHORT $LN18@Copy_backw
	inc	DWORD PTR [rcx]
$LN18@Copy_backw:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN21@Copy_backw
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8+8]
	cmp	DWORD PTR [rax], r11d
	jne	SHORT $LN21@Copy_backw
	mov	QWORD PTR [r8+8], r11
$LN21@Copy_backw:

; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8+8], rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility

; 2345 : 	while (_First != _Last)

	cmp	rdx, r10
	jne	SHORT $LL2@Copy_backw
$LN29@Copy_backw:

; 2347 : 	return (_Dest);

	mov	rax, r8

; 2348 : 	}

	ret	0
??$_Copy_backward@PEAUItem@CInifile@@PEAU12@@std@@YAPEAUItem@CInifile@@PEAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<CInifile::Item * __ptr64,CInifile::Item * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z PROC ; std::_Uninitialized_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >, COMDAT

; 492  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN20:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>

; 493  : 	return (_Rechecked(_Dest,
; 494  : 		_Uninit_move(_Unchecked(_First), _Unchecked(_Last),
; 495  : 			_Unchecked(_Dest), _Al)));
; 496  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninitialized_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z ENDP ; std::_Uninitialized_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Fill@PEAPEAUSect@CInifile@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@0AEBQEAU12@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Fill@PEAPEAUSect@CInifile@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@0AEBQEAU12@@Z PROC ; std::_Fill<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64>, COMDAT

; 2598 : 	{	// copy _Val through [_First, _Last)

	xor	r9d, r9d
	mov	r10, rdx
	sub	r10, rcx
	add	r10, 7
	shr	r10, 3
	cmp	rcx, rdx
	cmova	r10, r9

; 2599 : 	for (; _First != _Last; ++_First)

	test	r10, r10
	je	SHORT $LN1@Fill
	npad	3
$LL3@Fill:

; 2600 : 		*_First = _Val;

	mov	rax, QWORD PTR [r8]
	inc	r9
	lea	rcx, QWORD PTR [rcx+8]
	mov	QWORD PTR [rcx-8], rax
	cmp	r9, r10
	jne	SHORT $LL3@Fill
$LN1@Fill:

; 2601 : 	}

	ret	0
??$_Fill@PEAPEAUSect@CInifile@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@0AEBQEAU12@@Z ENDP ; std::_Fill<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64>, COMDAT

; 2354 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2355 : 	ptrdiff_t _Count = _Last - _First;

	sub	rdx, rcx
	mov	rbx, r8
	sar	rdx, 3

; 2356 : 	_CSTD memmove(&*_Dest - _Count, &*_First,
; 2357 : 		_Count * sizeof (*_First));

	lea	r8, QWORD PTR [rdx*8]
	mov	rdx, rcx
	sub	rbx, r8
	mov	rcx, rbx
	call	QWORD PTR __imp_memmove

; 2358 : 	return (_Dest - _Count);

	mov	rax, rbx

; 2359 : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Copy_backward@PEAPEAUSect@CInifile@@PEAPEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAUItem@CInifile@@@std@@YAPEAUItem@CInifile@@PEAU12@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAUItem@CInifile@@@std@@YAPEAUItem@CInifile@@PEAU12@@Z PROC ; std::_Val_type<CInifile::Item * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAUItem@CInifile@@@std@@YAPEAUItem@CInifile@@PEAU12@@Z ENDP ; std::_Val_type<CInifile::Item * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
_Next$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>, COMDAT

; 585  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

$LN93:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 586  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 587  : //	if (_Count < 0)
; 588  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 589  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 590  : 
; 591  : 	_FwdIt _Next = _First;

	mov	QWORD PTR _Next$[rsp], rcx

; 592  : 
; 593  : 	_TRY_BEGIN

	xor	r10d, r10d
$LL6@Uninit_fil:

; 594  : 	for (; 0 < _Count; --_Count, ++_First)

	test	r9, r9
	je	SHORT $LN4@Uninit_fil
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN30@Uninit_fil
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	QWORD PTR [rcx], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rdx, QWORD PTR [r8]
	test	rdx, rdx
	je	SHORT $LN40@Uninit_fil
	inc	DWORD PTR [rdx]
$LN40@Uninit_fil:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx]
	test	rax, rax
	je	SHORT $LN43@Uninit_fil
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx]
	cmp	DWORD PTR [rax], r10d
	jne	SHORT $LN43@Uninit_fil
	mov	QWORD PTR [rcx], r10
$LN43@Uninit_fil:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx], rdx

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	QWORD PTR [rcx+8], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rdx, QWORD PTR [r8+8]
	test	rdx, rdx
	je	SHORT $LN49@Uninit_fil
	inc	DWORD PTR [rdx]
$LN49@Uninit_fil:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rcx+8]
	test	rax, rax
	je	SHORT $LN52@Uninit_fil
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rcx+8]
	cmp	DWORD PTR [rax], r10d
	jne	SHORT $LN52@Uninit_fil
	mov	QWORD PTR [rcx+8], r10
$LN52@Uninit_fil:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rcx+8], rdx
$LN30@Uninit_fil:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 594  : 	for (; 0 < _Count; --_Count, ++_First)

	dec	r9
	mov	QWORD PTR _Count$[rsp], r9
	add	rcx, 16
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_fil
$LN4@Uninit_fil:

; 595  : 		_Al.construct(_First, *_Pval);
; 596  : 	_CATCH_ALL
; 597  : 	for (; _Next != _First; ++_Next)
; 598  : 		_Al.destroy(_Next);
; 599  : 	_RERAISE;
; 600  : 	_CATCH_END
; 601  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN92@Uninit_fil:
??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
_Next$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>'::`1'::catch$0

; 596  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 597  : 	for (; _Next != _First; ++_Next)

	mov	rax, QWORD PTR _Next$[rbp]
	mov	rdx, QWORD PTR _First$[rbp]
	cmp	rax, rdx
	je	SHORT $LN1@catch$0
	npad	6
$LL3@catch$0:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	SHORT $LN73@catch$0
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax+8]
	cmp	DWORD PTR [rcx], 0
	jne	SHORT $LN73@catch$0
	mov	QWORD PTR [rax+8], 0
$LN73@catch$0:
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN79@catch$0
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx], 0
	jne	SHORT $LN79@catch$0
	mov	QWORD PTR [rax], 0
$LN79@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 597  : 	for (; _Next != _First; ++_Next)

	add	rax, 16
	cmp	rax, rdx
	jne	SHORT $LL3@catch$0
$LN1@catch$0:

; 598  : 		_Al.destroy(_Next);
; 599  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_fill_n@PEAUItem@CInifile@@_KU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAXPEAUItem@CInifile@@_KPEBU12@AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_fill_n<CInifile::Item * __ptr64,unsigned __int64,CInifile::Item,xalloc<CInifile::Item>,CInifile::Item>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAUSect@CInifile@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAUSect@CInifile@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@@Z PROC ; std::_Val_type<CInifile::Sect * __ptr64 * __ptr64>, COMDAT

; 646  : 	return (0);

	xor	eax, eax

; 647  : 	}

	ret	0
??$_Val_type@PEAPEAUSect@CInifile@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@@Z ENDP ; std::_Val_type<CInifile::Sect * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>, COMDAT

; 611  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

$LN4:
	sub	rsp, 56					; 00000038H

; 612  : 	_Uninit_fill_n(_First, _Count,
; 613  : 		_Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());

	call	??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>

; 614  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV12@PEAUItem@CInifile@@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV12@PEAUItem@CInifile@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Rechecked, COMDAT

; 313  : 		this->_Ptr = _Right;

	mov	QWORD PTR [rcx], rdx

; 314  : 		return (*this);

	mov	rax, rcx

; 315  : 		}

	ret	0
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEAAAEAV12@PEAUItem@CInifile@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEAUItem@CInifile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEAUItem@CInifile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Unchecked, COMDAT

; 319  : 		return (_Unchecked_type(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 320  : 		}

	ret	0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UItem@CInifile@@@std@@@std@@@std@@QEBAPEAUItem@CInifile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Item> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAUSect@CInifile@@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAUSect@CInifile@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Rechecked, COMDAT

; 313  : 		this->_Ptr = _Right;

	mov	QWORD PTR [rcx], rdx

; 314  : 		return (*this);

	mov	rax, rcx

; 315  : 		}

	ret	0
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEAAAEAV12@PEAPEAUSect@CInifile@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAPEAPEAUSect@CInifile@@XZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAPEAPEAUSect@CInifile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Unchecked, COMDAT

; 319  : 		return (_Unchecked_type(this->_Ptr));

	mov	rax, QWORD PTR [rcx]

; 320  : 		}

	ret	0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PEAUSect@CInifile@@@std@@@std@@@std@@QEBAPEAPEAUSect@CInifile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInifile::Sect * __ptr64> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance@PEAUItem@CInifile@@_J@std@@YAXPEAUItem@CInifile@@0AEA_J@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
??$_Distance@PEAUItem@CInifile@@_J@std@@YAXPEAUItem@CInifile@@0AEA_J@Z PROC ; std::_Distance<CInifile::Item * __ptr64,__int64>, COMDAT

; 750  : 	_Off += _Last - _First;

	sub	rdx, rcx
	sar	rdx, 4
	add	QWORD PTR [r8], rdx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 767  : 	}

	ret	0
??$_Distance@PEAUItem@CInifile@@_J@std@@YAXPEAUItem@CInifile@@0AEA_J@Z ENDP ; std::_Distance<CInifile::Item * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$advance@PEAUItem@CInifile@@_J@std@@YAXAEAPEAUItem@CInifile@@_J@Z
_TEXT	SEGMENT
_Where$ = 8
_Off$ = 16
??$advance@PEAUItem@CInifile@@_J@std@@YAXAEAPEAUItem@CInifile@@_J@Z PROC ; std::advance<CInifile::Item * __ptr64,__int64>, COMDAT

; 690  : 	_Where += _Off;

	shl	rdx, 4
	add	QWORD PTR [rcx], rdx

; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));
; 698  : 	}

	ret	0
??$advance@PEAUItem@CInifile@@_J@std@@YAXAEAPEAUItem@CInifile@@_J@Z ENDP ; std::advance<CInifile::Item * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance@PEAPEAUSect@CInifile@@_J@std@@YAXPEAPEAUSect@CInifile@@0AEA_J@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
??$_Distance@PEAPEAUSect@CInifile@@_J@std@@YAXPEAPEAUSect@CInifile@@0AEA_J@Z PROC ; std::_Distance<CInifile::Sect * __ptr64 * __ptr64,__int64>, COMDAT

; 750  : 	_Off += _Last - _First;

	sub	rdx, rcx
	sar	rdx, 3
	add	QWORD PTR [r8], rdx

; 766  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 767  : 	}

	ret	0
??$_Distance@PEAPEAUSect@CInifile@@_J@std@@YAXPEAPEAUSect@CInifile@@0AEA_J@Z ENDP ; std::_Distance<CInifile::Sect * __ptr64 * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$advance@PEAPEAUSect@CInifile@@_J@std@@YAXAEAPEAPEAUSect@CInifile@@_J@Z
_TEXT	SEGMENT
_Where$ = 8
_Off$ = 16
??$advance@PEAPEAUSect@CInifile@@_J@std@@YAXAEAPEAPEAUSect@CInifile@@_J@Z PROC ; std::advance<CInifile::Sect * __ptr64 * __ptr64,__int64>, COMDAT

; 690  : 	_Where += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 697  : 	_Advance(_Where, _Off, _Iter_cat(_Where));
; 698  : 	}

	ret	0
??$advance@PEAPEAUSect@CInifile@@_J@std@@YAXAEAPEAPEAUSect@CInifile@@_J@Z ENDP ; std::advance<CInifile::Sect * __ptr64 * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$move@AEAUItem@CInifile@@@std@@YA$$QEAUItem@CInifile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAUItem@CInifile@@@std@@YA$$QEAUItem@CInifile@@AEAU12@@Z PROC ; std::move<CInifile::Item & __ptr64>, COMDAT

; 1520 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

	mov	rax, rcx

; 1521 : 	}

	ret	0
??$move@AEAUItem@CInifile@@@std@@YA$$QEAUItem@CInifile@@AEAU12@@Z ENDP ; std::move<CInifile::Item & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z PROC ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Item> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
	sub	rsp, 56					; 00000038H

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

	call	??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>

; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAUItem@CInifile@@PEAU12@U?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@@Z ENDP ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Item> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z PROC ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >, COMDAT

; 482  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN10:
	sub	rsp, 56					; 00000038H

; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>

; 483  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 484  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));
; 485  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@U?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@@Z ENDP ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>, COMDAT

; 585  : 	{	// copy _Count * *_Pval to raw _First, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_fil:

; 594  : 	for (; 0 < _Count; --_Count, ++_First)

	test	rdx, rdx
	je	SHORT $LN4@Uninit_fil
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rcx, rcx
	je	SHORT $LN30@Uninit_fil
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rcx], rax
$LN30@Uninit_fil:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 594  : 	for (; 0 < _Count; --_Count, ++_First)

	dec	rdx
	mov	QWORD PTR _Count$[rsp], rdx
	add	rcx, 8
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_fil
$LN4@Uninit_fil:

; 595  : 		_Al.construct(_First, *_Pval);
; 596  : 	_CATCH_ALL
; 597  : 	for (; _Next != _First; ++_Next)
; 598  : 		_Al.destroy(_Next);
; 599  : 	_RERAISE;
; 600  : 	_CATCH_END
; 601  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_fil:
??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>'::`1'::catch$0

; 596  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 597  : 	for (; _Next != _First; ++_Next)
; 598  : 		_Al.destroy(_Next);
; 599  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_fill_n@PEAPEAUSect@CInifile@@_KPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAXPEAPEAUSect@CInifile@@_KPEBQEAU12@AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_fill_n<CInifile::Sect * __ptr64 * __ptr64,unsigned __int64,CInifile::Sect * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PEAUItem@CInifile@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAUItem@CInifile@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$dead$ = 16
??$_Iter_cat@PEAUItem@CInifile@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAUItem@CInifile@@@Z PROC ; std::_Iter_cat<CInifile::Item * __ptr64>, COMDAT

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	rax, rcx

; 408  : 	}

	ret	0
??$_Iter_cat@PEAUItem@CInifile@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAUItem@CInifile@@@Z ENDP ; std::_Iter_cat<CInifile::Item * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance2@PEAUItem@CInifile@@_J@std@@YAXPEAUItem@CInifile@@0AEA_JUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
__formal$dead$ = 32
??$_Distance2@PEAUItem@CInifile@@_J@std@@YAXPEAUItem@CInifile@@0AEA_JUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CInifile::Item * __ptr64,__int64>, COMDAT

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

	sub	rdx, rcx
	sar	rdx, 4
	add	QWORD PTR [r8], rdx

; 751  : 	}

	ret	0
??$_Distance2@PEAUItem@CInifile@@_J@std@@YAXPEAUItem@CInifile@@0AEA_JUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CInifile::Item * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Advance@PEAUItem@CInifile@@_J@std@@YAXAEAPEAUItem@CInifile@@_JUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_Where$ = 8
_Off$ = 16
__formal$dead$ = 24
??$_Advance@PEAUItem@CInifile@@_J@std@@YAXAEAPEAUItem@CInifile@@_JUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CInifile::Item * __ptr64,__int64>, COMDAT

; 690  : 	_Where += _Off;

	shl	rdx, 4
	add	QWORD PTR [rcx], rdx

; 691  : 	}

	ret	0
??$_Advance@PEAUItem@CInifile@@_J@std@@YAXAEAPEAUItem@CInifile@@_JUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CInifile::Item * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PEAPEAUSect@CInifile@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAPEAUSect@CInifile@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$dead$ = 16
??$_Iter_cat@PEAPEAUSect@CInifile@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAPEAUSect@CInifile@@@Z PROC ; std::_Iter_cat<CInifile::Sect * __ptr64 * __ptr64>, COMDAT

; 406  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 407  : 	return (_Cat);

	mov	rax, rcx

; 408  : 	}

	ret	0
??$_Iter_cat@PEAPEAUSect@CInifile@@@std@@YA?AUrandom_access_iterator_tag@0@AEBQEAPEAUSect@CInifile@@@Z ENDP ; std::_Iter_cat<CInifile::Sect * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Distance2@PEAPEAUSect@CInifile@@_J@std@@YAXPEAPEAUSect@CInifile@@0AEA_JUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
__formal$dead$ = 32
??$_Distance2@PEAPEAUSect@CInifile@@_J@std@@YAXPEAPEAUSect@CInifile@@0AEA_JUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CInifile::Sect * __ptr64 * __ptr64,__int64>, COMDAT

; 742  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 743  : 	if (_First != _Last)
; 744  : 		{	// check for null pointers
; 745  : 		_DEBUG_POINTER(_First);
; 746  : 		_DEBUG_POINTER(_Last);
; 747  : 		}
; 748  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 749  : 
; 750  : 	_Off += _Last - _First;

	sub	rdx, rcx
	sar	rdx, 3
	add	QWORD PTR [r8], rdx

; 751  : 	}

	ret	0
??$_Distance2@PEAPEAUSect@CInifile@@_J@std@@YAXPEAPEAUSect@CInifile@@0AEA_JUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CInifile::Sect * __ptr64 * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xutility
;	COMDAT ??$_Advance@PEAPEAUSect@CInifile@@_J@std@@YAXAEAPEAPEAUSect@CInifile@@_JUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
_Where$ = 8
_Off$ = 16
__formal$dead$ = 24
??$_Advance@PEAPEAUSect@CInifile@@_J@std@@YAXAEAPEAPEAUSect@CInifile@@_JUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CInifile::Sect * __ptr64 * __ptr64,__int64>, COMDAT

; 690  : 	_Where += _Off;

	lea	rax, QWORD PTR [rdx*8]
	add	QWORD PTR [rcx], rax

; 691  : 	}

	ret	0
??$_Advance@PEAPEAUSect@CInifile@@_J@std@@YAXAEAPEAPEAUSect@CInifile@@_JUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CInifile::Sect * __ptr64 * __ptr64,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
_Next$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN93:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	mov	r9, rdx

; 438  : 	_DEBUG_RANGE(_First, _Last);
; 439  : 	_DEBUG_POINTER(_Dest);
; 440  : 	_FwdIt _Next = _Dest;

	mov	QWORD PTR _Next$[rsp], r8

; 441  : 
; 442  : 	_TRY_BEGIN

	xor	r10d, r10d
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, r9
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	QWORD PTR [r8], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rdx, QWORD PTR [rcx]
	test	rdx, rdx
	je	SHORT $LN40@Uninit_mov
	inc	DWORD PTR [rdx]
$LN40@Uninit_mov:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8]
	test	rax, rax
	je	SHORT $LN43@Uninit_mov
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8]
	cmp	DWORD PTR [rax], r10d
	jne	SHORT $LN43@Uninit_mov
	mov	QWORD PTR [r8], r10
$LN43@Uninit_mov:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8], rdx

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	QWORD PTR [r8+8], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rdx, QWORD PTR [rcx+8]
	test	rdx, rdx
	je	SHORT $LN49@Uninit_mov
	inc	DWORD PTR [rdx]
$LN49@Uninit_mov:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN52@Uninit_mov
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8+8]
	cmp	DWORD PTR [rax], r10d
	jne	SHORT $LN52@Uninit_mov
	mov	QWORD PTR [r8+8], r10
$LN52@Uninit_mov:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8+8], rdx
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 16
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 16
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN92@Uninit_mov:
??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
_Next$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)

	mov	rax, QWORD PTR _Next$[rbp]
	mov	rdx, QWORD PTR _Dest$[rbp]
	cmp	rax, rdx
	je	SHORT $LN1@catch$0
	npad	6
$LL3@catch$0:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rcx, QWORD PTR [rax+8]
	test	rcx, rcx
	je	SHORT $LN73@catch$0
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax+8]
	cmp	DWORD PTR [rcx], 0
	jne	SHORT $LN73@catch$0
	mov	QWORD PTR [rax+8], 0
$LN73@catch$0:
	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN79@catch$0
	dec	DWORD PTR [rcx]
	mov	rcx, QWORD PTR [rax]
	cmp	DWORD PTR [rcx], 0
	jne	SHORT $LN79@catch$0
	mov	QWORD PTR [rax], 0
$LN79@catch$0:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 446  : 	for (; _Next != _Dest; ++_Next)

	add	rax, 16
	cmp	rax, rdx
	jne	SHORT $LL3@catch$0
$LN1@catch$0:

; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAUItem@CInifile@@PEAU12@V?$xalloc@UItem@CInifile@@@@U12@@std@@YAPEAUItem@CInifile@@PEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<CInifile::Item * __ptr64,CInifile::Item * __ptr64,xalloc<CInifile::Item>,CInifile::Item>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>, COMDAT

; 459  : 	{	// move [_First, _Last) to raw _Dest, using _Al, scalar type

$LN4:
	sub	rsp, 56					; 00000038H

; 460  : 	return (_Uninit_move(_First, _Last, _Dest,
; 461  : 		_Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));

	call	??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>

; 462  : 	}

	add	rsp, 56					; 00000038H
	ret	0
??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UItem@CInifile@@U12@@?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@QEAAXPEAUItem@CInifile@@$$QEAU23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UItem@CInifile@@U12@@?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@QEAAXPEAUItem@CInifile@@$$QEAU23@@Z PROC ; std::_Wrap_alloc<xalloc<CInifile::Item> >::construct<CInifile::Item,CInifile::Item>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	xor	r10d, r10d
	mov	QWORD PTR [rdx], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r9, QWORD PTR [r8]
	test	r9, r9
	je	SHORT $LN27@construct
	inc	DWORD PTR [r9]
$LN27@construct:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN30@construct
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rdx]
	cmp	DWORD PTR [rax], r10d
	mov	rcx, rax
	cmove	rcx, r10
	mov	QWORD PTR [rdx], rcx
$LN30@construct:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rdx], r9

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	QWORD PTR [rdx+8], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r8, QWORD PTR [r8+8]
	test	r8, r8
	je	SHORT $LN36@construct
	inc	DWORD PTR [r8]
$LN36@construct:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rdx+8]
	test	rax, rax
	je	SHORT $LN39@construct
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rdx+8]
	cmp	DWORD PTR [rax], r10d
	mov	rcx, rax
	cmove	rcx, r10
	mov	QWORD PTR [rdx+8], rcx
$LN39@construct:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rdx+8], r8
$LN17@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 873  : 		}

	ret	0
??$construct@UItem@CInifile@@U12@@?$_Wrap_alloc@V?$xalloc@UItem@CInifile@@@@@std@@QEAAXPEAUItem@CInifile@@$$QEAU23@@Z ENDP ; std::_Wrap_alloc<xalloc<CInifile::Item> >::construct<CInifile::Item,CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>, COMDAT

; 437  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

$LN44:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T1[rsp], -2
	npad	3
$LL6@Uninit_mov:

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	rcx, rdx
	je	SHORT $LN4@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN30@Uninit_mov
	mov	rax, QWORD PTR [rcx]
	mov	QWORD PTR [r8], rax
$LN30@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory

; 443  : 	for (; _First != _Last; ++_Dest, ++_First)

	add	r8, 8
	mov	QWORD PTR _Dest$[rsp], r8
	add	rcx, 8
	mov	QWORD PTR _First$[rsp], rcx
	jmp	SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 444  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 445  : 	_CATCH_ALL
; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;
; 449  : 	_CATCH_END
; 450  : 	return (_Dest);

	mov	rax, r8

; 451  : 	}

	add	rsp, 56					; 00000038H
	ret	0
$LN43@Uninit_mov:
??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
__formal$dead$ = 96
__formal$dead$ = 104
?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA PROC ; `std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>'::`1'::catch$0

; 445  : 	_CATCH_ALL

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0:

; 446  : 	for (; _Next != _Dest; ++_Next)
; 447  : 		_Al.destroy(_Next);
; 448  : 	_RERAISE;

	xor	edx, edx
	xor	ecx, ecx
	call	_CxxThrowException
	npad	1
?catch$0@?0???$_Uninit_move@PEAPEAUSect@CInifile@@PEAPEAU12@V?$xalloc@PEAUSect@CInifile@@@@PEAU12@@std@@YAPEAPEAUSect@CInifile@@PEAPEAU12@00AEAU?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z@4HA ENDP ; `std::_Uninit_move<CInifile::Sect * __ptr64 * __ptr64,CInifile::Sect * __ptr64 * __ptr64,xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@UItem@CInifile@@@std@@YA$$QEAUItem@CInifile@@AEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@UItem@CInifile@@@std@@YA$$QEAUItem@CInifile@@AEAU12@@Z PROC ; std::forward<CInifile::Item>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@UItem@CInifile@@@std@@YA$$QEAUItem@CInifile@@AEAU12@@Z ENDP ; std::forward<CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@UItem@CInifile@@U12@@?$allocator_traits@V?$xalloc@UItem@CInifile@@@@@std@@SAXAEAV?$xalloc@UItem@CInifile@@@@PEAUItem@CInifile@@$$QEAU34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@UItem@CInifile@@U12@@?$allocator_traits@V?$xalloc@UItem@CInifile@@@@@std@@SAXAEAV?$xalloc@UItem@CInifile@@@@PEAUItem@CInifile@@$$QEAU34@@Z PROC ; std::allocator_traits<xalloc<CInifile::Item> >::construct<CInifile::Item,CInifile::Item>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	xor	r10d, r10d
	mov	QWORD PTR [rdx], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r9, QWORD PTR [r8]
	test	r9, r9
	je	SHORT $LN23@construct
	inc	DWORD PTR [r9]
$LN23@construct:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN26@construct
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rdx]
	cmp	DWORD PTR [rax], r10d
	mov	rcx, rax
	cmove	rcx, r10
	mov	QWORD PTR [rdx], rcx
$LN26@construct:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rdx], r9

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	QWORD PTR [rdx+8], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	r8, QWORD PTR [r8+8]
	test	r8, r8
	je	SHORT $LN32@construct
	inc	DWORD PTR [r8]
$LN32@construct:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [rdx+8]
	test	rax, rax
	je	SHORT $LN35@construct
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [rdx+8]
	cmp	DWORD PTR [rax], r10d
	mov	rcx, rax
	cmove	rcx, r10
	mov	QWORD PTR [rdx+8], rcx
$LN35@construct:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [rdx+8], r8
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 470  : 		}

	ret	0
??$construct@UItem@CInifile@@U12@@?$allocator_traits@V?$xalloc@UItem@CInifile@@@@@std@@SAXAEAV?$xalloc@UItem@CInifile@@@@PEAUItem@CInifile@@$$QEAU34@@Z ENDP ; std::allocator_traits<xalloc<CInifile::Item> >::construct<CInifile::Item,CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAUSect@CInifile@@PEAU12@@?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAAXPEAPEAUSect@CInifile@@$$QEAPEAU23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAUSect@CInifile@@PEAU12@@?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAAXPEAPEAUSect@CInifile@@$$QEAPEAU23@@Z PROC ; std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> >::construct<CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN17@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN17@construct:

; 869  : 			_Types&&... _Args)
; 870  : 		{	// construct _Ty(_Types...) at _Ptr
; 871  : 		_Mytraits::construct(*this, _Ptr,
; 872  : 			_STD forward<_Types>(_Args)...);
; 873  : 		}

	ret	0
??$construct@PEAUSect@CInifile@@PEAU12@@?$_Wrap_alloc@V?$xalloc@PEAUSect@CInifile@@@@@std@@QEAAXPEAPEAUSect@CInifile@@$$QEAPEAU23@@Z ENDP ; std::_Wrap_alloc<xalloc<CInifile::Sect * __ptr64> >::construct<CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@UItem@CInifile@@@@UItem@CInifile@@U23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@UItem@CInifile@@@@PEAUItem@CInifile@@$$QEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@UItem@CInifile@@@@UItem@CInifile@@U23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@UItem@CInifile@@@@PEAUItem@CInifile@@$$QEAU34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CInifile::Item>,CInifile::Item,CInifile::Item>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	xor	r10d, r10d
	mov	QWORD PTR [r8], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rdx, QWORD PTR [r9]
	test	rdx, rdx
	je	SHORT $LN19@Fn
	inc	DWORD PTR [rdx]
$LN19@Fn:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8]
	test	rax, rax
	je	SHORT $LN22@Fn
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8]
	cmp	DWORD PTR [rax], r10d
	mov	rcx, rax
	cmove	rcx, r10
	mov	QWORD PTR [r8], rcx
$LN22@Fn:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8], rdx

; 59   : 						shared_str	(shared_str const &rhs)			{	p_ = 0;	_set(rhs);								}

	mov	QWORD PTR [r8+8], r10

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	rdx, QWORD PTR [r9+8]
	test	rdx, rdx
	je	SHORT $LN28@Fn
	inc	DWORD PTR [rdx]
$LN28@Fn:

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	mov	rax, QWORD PTR [r8+8]
	test	rax, rax
	je	SHORT $LN31@Fn
	dec	DWORD PTR [rax]
	mov	rax, QWORD PTR [r8+8]
	cmp	DWORD PTR [rax], r10d
	mov	rcx, rax
	cmove	rcx, r10
	mov	QWORD PTR [r8+8], rcx
$LN31@Fn:

; 51   : public:
; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}
; 53   : 	void				_set		(shared_str const &rhs)			{	str_value* v = rhs.p_; if (0!=v) v->dwReference++; _dec(); p_ = v;							}

	mov	QWORD PTR [r8+8], rdx
$LN9@Fn:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@UItem@CInifile@@@@UItem@CInifile@@U23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@UItem@CInifile@@@@PEAUItem@CInifile@@$$QEAU34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CInifile::Item>,CInifile::Item,CInifile::Item>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\type_traits
;	COMDAT ??$forward@PEAUSect@CInifile@@@std@@YA$$QEAPEAUSect@CInifile@@AEAPEAU12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@PEAUSect@CInifile@@@std@@YA$$QEAPEAUSect@CInifile@@AEAPEAU12@@Z PROC ; std::forward<CInifile::Sect * __ptr64>, COMDAT

; 1505 : 	return (static_cast<_Ty&&>(_Arg));

	mov	rax, rcx

; 1506 : 	}

	ret	0
??$forward@PEAUSect@CInifile@@@std@@YA$$QEAPEAUSect@CInifile@@AEAPEAU12@@Z ENDP ; std::forward<CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAUSect@CInifile@@PEAU12@@?$allocator_traits@V?$xalloc@PEAUSect@CInifile@@@@@std@@SAXAEAV?$xalloc@PEAUSect@CInifile@@@@PEAPEAUSect@CInifile@@$$QEAPEAU34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEAUSect@CInifile@@PEAU12@@?$allocator_traits@V?$xalloc@PEAUSect@CInifile@@@@@std@@SAXAEAV?$xalloc@PEAUSect@CInifile@@@@PEAPEAUSect@CInifile@@$$QEAPEAU34@@Z PROC ; std::allocator_traits<xalloc<CInifile::Sect * __ptr64> >::construct<CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	rdx, rdx
	je	SHORT $LN13@construct
	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
$LN13@construct:

; 466  : 			_Types&&... _Args)
; 467  : 		{	// construct _Ty(_Types...) at _Ptr
; 468  : 		_Alloc_construct::_Fn(0, _Al, _Ptr,
; 469  : 			_STD forward<_Types>(_Args)...);
; 470  : 		}

	ret	0
??$construct@PEAUSect@CInifile@@PEAU12@@?$allocator_traits@V?$xalloc@PEAUSect@CInifile@@@@@std@@SAXAEAV?$xalloc@PEAUSect@CInifile@@@@PEAPEAUSect@CInifile@@$$QEAPEAU34@@Z ENDP ; std::allocator_traits<xalloc<CInifile::Sect * __ptr64> >::construct<CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
;	COMDAT ??$_Fn@V?$xalloc@PEAUSect@CInifile@@@@PEAUSect@CInifile@@PEAU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAUSect@CInifile@@@@PEAPEAUSect@CInifile@@$$QEAPEAU34@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
<_Args_0>$ = 32
??$_Fn@V?$xalloc@PEAUSect@CInifile@@@@PEAUSect@CInifile@@PEAU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAUSect@CInifile@@@@PEAPEAUSect@CInifile@@$$QEAPEAU34@@Z PROC ; std::_Alloc_construct::_Fn<xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>, COMDAT

; 40   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

	test	r8, r8
	je	SHORT $LN9@Fn
	mov	rax, QWORD PTR [r9]
	mov	QWORD PTR [r8], rax
$LN9@Fn:

; 338  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 339  : 		}

	ret	0
??$_Fn@V?$xalloc@PEAUSect@CInifile@@@@PEAUSect@CInifile@@PEAU23@@_Alloc_construct@std@@SAXHAEAV?$xalloc@PEAUSect@CInifile@@@@PEAPEAUSect@CInifile@@$$QEAPEAU34@@Z ENDP ; std::_Alloc_construct::_Fn<xalloc<CInifile::Sect * __ptr64>,CInifile::Sect * __ptr64,CInifile::Sect * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
;	COMDAT ?color_get_R@@YAII@Z
_TEXT	SEGMENT
rgba$ = 8
?color_get_R@@YAII@Z PROC				; color_get_R, COMDAT

; 17   : ICF	u32	color_get_R	(u32 rgba)						{	return (((rgba) >> 16) & 0xff);	}

	shr	ecx, 16
	movzx	eax, cl
	ret	0
?color_get_R@@YAII@Z ENDP				; color_get_R
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
;	COMDAT ?color_get_G@@YAII@Z
_TEXT	SEGMENT
rgba$ = 8
?color_get_G@@YAII@Z PROC				; color_get_G, COMDAT

; 18   : ICF	u32	color_get_G	(u32 rgba)						{	return (((rgba) >> 8) & 0xff);	}

	shr	ecx, 8
	movzx	eax, cl
	ret	0
?color_get_G@@YAII@Z ENDP				; color_get_G
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
;	COMDAT ?color_get_B@@YAII@Z
_TEXT	SEGMENT
rgba$ = 8
?color_get_B@@YAII@Z PROC				; color_get_B, COMDAT

; 19   : ICF	u32	color_get_B	(u32 rgba)						{	return ((rgba) & 0xff);			}

	movzx	eax, cl
	ret	0
?color_get_B@@YAII@Z ENDP				; color_get_B
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
;	COMDAT ?color_get_A@@YAII@Z
_TEXT	SEGMENT
rgba$ = 8
?color_get_A@@YAII@Z PROC				; color_get_A, COMDAT

; 20   : ICF	u32 color_get_A (u32 rgba)						{	return ((rgba) >> 24);			}

	shr	ecx, 24
	mov	eax, ecx
	ret	0
?color_get_A@@YAII@Z ENDP				; color_get_A
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
;	COMDAT ?color_argb@@YAIIIII@Z
_TEXT	SEGMENT
a$ = 8
r$ = 16
g$ = 24
b$ = 32
?color_argb@@YAIIIII@Z PROC				; color_argb, COMDAT

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	ecx, 8
	movzx	eax, dl
	or	eax, ecx
	movzx	ecx, r8b
	shl	eax, 8
	or	eax, ecx
	movzx	ecx, r9b
	shl	eax, 8
	or	eax, ecx
	ret	0
?color_argb@@YAIIIII@Z ENDP				; color_argb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_color.h
;	COMDAT ?color_rgba@@YAIIIII@Z
_TEXT	SEGMENT
r$ = 8
g$ = 16
b$ = 24
a$ = 32
?color_rgba@@YAIIIII@Z PROC				; color_rgba, COMDAT

; 6    : ICF u32	color_rgba	(u32 r, u32 g, u32 b, u32 a)	{	return color_argb(a,r,g,b);		}

	movzx	eax, cl
	movzx	ecx, dl
	shl	r9d, 8
	or	eax, r9d

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	shl	eax, 8

; 6    : ICF u32	color_rgba	(u32 r, u32 g, u32 b, u32 a)	{	return color_argb(a,r,g,b);		}

	or	eax, ecx

; 5    : ICF u32	color_argb	(u32 a, u32 r, u32 g, u32 b)	{	return ((a&0xff)<<24)|((r&0xff)<<16)|((g&0xff)<<8)|(b&0xff);	}

	movzx	ecx, r8b
	shl	eax, 8
	or	eax, ecx

; 6    : ICF u32	color_rgba	(u32 r, u32 g, u32 b, u32 a)	{	return color_argb(a,r,g,b);		}

	ret	0
?color_rgba@@YAIIIII@Z ENDP				; color_rgba
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\string.h
;	COMDAT ?strchr@@YAPEADPEADH@Z
_TEXT	SEGMENT
_Str$ = 8
_Ch$ = 16
?strchr@@YAPEADPEADH@Z PROC				; strchr, COMDAT

; 222  :         { return (char*)strchr((const char*)_Str, _Ch); }

	rex_jmp	QWORD PTR __imp_strchr
?strchr@@YAPEADPEADH@Z ENDP				; strchr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
;	COMDAT ?equal@shared_str@@QEBA_NAEBV1@@Z
_TEXT	SEGMENT
this$ = 8
rhs$ = 16
?equal@shared_str@@QEBA_NAEBV1@@Z PROC			; shared_str::equal, COMDAT

; 73   : 	bool				equal		(const shared_str & rhs) const	{	return (p_ == rhs.p_);							}

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	sete	al
	ret	0
?equal@shared_str@@QEBA_NAEBV1@@Z ENDP			; shared_str::equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
;	COMDAT ??M@YA_NAEBVshared_str@@0@Z
_TEXT	SEGMENT
a$ = 8
b$ = 16
??M@YA_NAEBVshared_str@@0@Z PROC			; operator<, COMDAT

; 95   : IC bool operator	<	(shared_str const & a, shared_str const & b)		{ return a._get() <  b._get();					}

	mov	rdx, QWORD PTR [rdx]
	cmp	QWORD PTR [rcx], rdx
	setb	al
	ret	0
??M@YA_NAEBVshared_str@@0@Z ENDP			; operator<
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
;	COMDAT ??7shared_str@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??7shared_str@@QEBA_NXZ PROC				; shared_str::operator!, COMDAT

; 66   : 	bool				operator!	() const						{	return p_ == 0;									}

	xor	eax, eax
	cmp	QWORD PTR [rcx], rax
	sete	al
	ret	0
??7shared_str@@QEBA_NXZ ENDP				; shared_str::operator!
_TEXT	ENDS
END
