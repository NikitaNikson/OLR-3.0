; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_GetVersion:PROC
PUBLIC	?_cpuid@@YAHPEAU_processor_info@@@Z		; _cpuid
pdata	SEGMENT
$pdata$?_cpuid@@YAHPEAU_processor_info@@@Z DD imagerel $LN13
	DD	imagerel $LN13+440
	DD	imagerel $unwind$?_cpuid@@YAHPEAU_processor_info@@@Z
pdata	ENDS
xdata	SEGMENT
$unwind$?_cpuid@@YAHPEAU_processor_info@@@Z DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\cpuid.cpp
xdata	ENDS
_TEXT	SEGMENT
cpinfo$ = 32
?_cpuid@@YAHPEAU_processor_info@@@Z PROC		; _cpuid

; 9    : {

$LN13:
	push	rbx
	sub	rsp, 48					; 00000030H

; 10   : 	_processor_info&	P	= *pinfo;
; 11   : 
; 12   : 	/*
; 13   : 	strcpy				(P.v_name,		"AuthenticAMD");
; 14   : 	strcpy				(P.model_name,	"AMD64 family");
; 15   : 	P.family			=	8;
; 16   : 	P.model				=	8;
; 17   : 	P.stepping			=	0;
; 18   : 	P.feature			=	_CPU_FEATURE_SSE | _CPU_FEATURE_SSE2;
; 19   : 	P.os_support		=	_CPU_FEATURE_SSE | _CPU_FEATURE_SSE2;
; 20   : 	return P.feature;
; 21   : 	*/
; 22   : 
; 23   : 	ZeroMemory(&P, sizeof(_processor_info));

	xor	edx, edx
	lea	rcx, OFFSET FLAT:?ID@CPU@@3U_processor_info@@A ; CPU::ID
	lea	r8d, QWORD PTR [rdx+116]
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16

; 24   : 
; 25   : 	int cpinfo[4];
; 26   : 	// detect cpu vendor
; 27   : 	__cpuid(cpinfo, 0);

	xor	eax, eax
	xor	ecx, ecx
	cpuid
	mov	DWORD PTR cpinfo$[rsp], eax

; 28   : 
; 29   : 	memcpy(P.v_name, &(cpinfo[1]), sizeof(int));
; 30   : 	memcpy(P.v_name+sizeof(int), &(cpinfo[3]), sizeof(int));
; 31   : 	memcpy(P.v_name+2*sizeof(int), &(cpinfo[2]), sizeof(int));

	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+8, ecx

; 32   : 
; 33   : 	// detect cpu model
; 34   : 	__cpuid(cpinfo, 0x80000002);

	xor	ecx, ecx
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A, ebx
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+4, edx
	mov	eax, -2147483646			; ffffffff80000002H
	cpuid
	mov	DWORD PTR cpinfo$[rsp], eax
	mov	DWORD PTR cpinfo$[rsp+8], ecx

; 35   : 	memcpy(P.model_name, cpinfo, sizeof(cpinfo));
; 36   : 	__cpuid(cpinfo, 0x80000003);

	xor	ecx, ecx
	mov	DWORD PTR cpinfo$[rsp+4], ebx
	mov	DWORD PTR cpinfo$[rsp+12], edx
	mov	eax, -2147483645			; ffffffff80000003H
	movups	xmm0, XMMWORD PTR cpinfo$[rsp]
	cpuid
	movaps	XMMWORD PTR ?ID@CPU@@3U_processor_info@@A+32, xmm0
	mov	DWORD PTR cpinfo$[rsp], eax
	mov	DWORD PTR cpinfo$[rsp+8], ecx

; 37   : 	memcpy(P.model_name+16, cpinfo, sizeof(cpinfo));
; 38   : 	__cpuid(cpinfo, 0x80000004);

	xor	ecx, ecx
	mov	DWORD PTR cpinfo$[rsp+4], ebx
	mov	DWORD PTR cpinfo$[rsp+12], edx
	mov	eax, -2147483644			; ffffffff80000004H
	movups	xmm0, XMMWORD PTR cpinfo$[rsp]
	cpuid
	movaps	XMMWORD PTR ?ID@CPU@@3U_processor_info@@A+48, xmm0
	mov	DWORD PTR cpinfo$[rsp], eax
	mov	DWORD PTR cpinfo$[rsp+8], ecx

; 39   : 	memcpy(P.model_name+32, cpinfo, sizeof(cpinfo));
; 40   : 
; 41   : 	// detect cpu main features
; 42   : 	__cpuid(cpinfo, 1);

	xor	ecx, ecx
	mov	DWORD PTR cpinfo$[rsp+4], ebx
	mov	DWORD PTR cpinfo$[rsp+12], edx
	mov	eax, 1
	movups	xmm0, XMMWORD PTR cpinfo$[rsp]
	cpuid
	movaps	XMMWORD PTR ?ID@CPU@@3U_processor_info@@A+64, xmm0
	mov	r8d, eax

; 43   : 
; 44   : 	P.stepping = cpinfo[0] & 0xf;

	and	eax, 15
	mov	r9d, ecx
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+104, eax

; 45   :     P.model = (u8)((cpinfo[0] >> 4) & 0xf) | ((u8)((cpinfo[0] >> 16) & 0xf) << 4);

	mov	eax, r8d
	mov	ecx, r8d
	sar	eax, 16
	sar	ecx, 4
	mov	DWORD PTR cpinfo$[rsp+4], ebx
	and	ecx, 15
	and	eax, 15
	shl	eax, 4
	or	eax, ecx

; 46   :     P.family = (u8)((cpinfo[0] >> 8) & 0xf) | ((u8)((cpinfo[0] >> 20) & 0xff) << 4);

	mov	ecx, r8d
	sar	r8d, 20
	sar	ecx, 8
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+100, eax
	movzx	eax, r8b

; 47   : 
; 48   : 	if (cpinfo[3] & (1 << 23))
; 49   : 		P.feature |= _CPU_FEATURE_MMX;

	mov	r8d, DWORD PTR ?ID@CPU@@3U_processor_info@@A+108
	shl	eax, 4
	and	ecx, 15
	or	ecx, eax
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+96, ecx
	bt	edx, 23
	jae	SHORT $LN8@cpuid
	or	r8d, 2
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+108, r8d
$LN8@cpuid:

; 50   : 	if (cpinfo[3] & (1 << 25))

	bt	edx, 25
	jae	SHORT $LN7@cpuid

; 51   : 		P.feature |= _CPU_FEATURE_SSE;

	or	r8d, 4
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+108, r8d
$LN7@cpuid:

; 52   : 	if (cpinfo[3] & (1 << 26))

	bt	edx, 26
	jae	SHORT $LN6@cpuid

; 53   : 		P.feature |= _CPU_FEATURE_SSE2;

	or	r8d, 8
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+108, r8d
$LN6@cpuid:

; 54   : 	if (cpinfo[2] & 0x1)

	test	r9b, 1
	je	SHORT $LN5@cpuid

; 55   : 		P.feature |= _CPU_FEATURE_SSE3;

	or	r8d, 16
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+108, r8d
$LN5@cpuid:

; 56   : 	if (cpinfo[2] & 0x80000)

	bt	r9d, 19
	jae	SHORT $LN4@cpuid

; 57   : 		P.feature |= _CPU_FEATURE_SSE41;

	or	r8d, 32					; 00000020H
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+108, r8d
$LN4@cpuid:

; 58   : 	if (cpinfo[2] & 0x100000)

	bt	r9d, 20
	jae	SHORT $LN3@cpuid

; 59   : 		P.feature |= _CPU_FEATURE_SSE42;

	or	r8d, 64					; 00000040H
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+108, r8d
$LN3@cpuid:

; 60   : 
; 61   : 	// and check 3DNow! support
; 62   : 	__cpuid(cpinfo, 0x80000001);

	xor	ecx, ecx
	mov	eax, -2147483647			; ffffffff80000001H
	cpuid
	mov	DWORD PTR cpinfo$[rsp], eax
	mov	DWORD PTR cpinfo$[rsp+4], ebx
	mov	DWORD PTR cpinfo$[rsp+8], ecx

; 63   : 	if (cpinfo[3] & (1 << 31))

	test	edx, edx
	jns	SHORT $LN2@cpuid

; 64   : 		P.feature |= _CPU_FEATURE_3DNOW;

	or	r8d, 1
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+108, r8d
$LN2@cpuid:

; 65   : 
; 66   : 	P.os_support = P.feature;

	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+112, r8d

; 67   : 
; 68   : 	// get version of OS
; 69   : 	DWORD dwMajorVersion = 0;
; 70   : 	DWORD dwVersion = 0;
; 71   : 	dwVersion = GetVersion();

	call	QWORD PTR __imp_GetVersion

; 72   : 
; 73   : 	dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
; 74   : 
; 75   : 	if (dwMajorVersion <= 5)		// XP don't support SSE3+ instruction sets

	cmp	al, 5
	ja	SHORT $LN11@cpuid

; 76   : 	{
; 77   : 		P.os_support	&= ~_CPU_FEATURE_SSE3	;

	mov	eax, DWORD PTR ?ID@CPU@@3U_processor_info@@A+112

; 78   : 		P.os_support	&= ~_CPU_FEATURE_SSE41	;
; 79   : 		P.os_support	&= ~_CPU_FEATURE_SSE42	;

	and	eax, -113				; ffffffffffffff8fH
	mov	DWORD PTR ?ID@CPU@@3U_processor_info@@A+112, eax
$LN11@cpuid:

; 80   : 	}
; 81   : 
; 82   : 	return P.feature;

	mov	eax, DWORD PTR ?ID@CPU@@3U_processor_info@@A+108

; 83   : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?_cpuid@@YAHPEAU_processor_info@@@Z ENDP		; _cpuid
END
