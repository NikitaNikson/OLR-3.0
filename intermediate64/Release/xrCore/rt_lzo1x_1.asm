; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	lzo1x_1_compress
pdata	SEGMENT
$pdata$?do_compress@@YA_KPEBE_KPEAEPEA_KPEAX@Z DD imagerel ?do_compress@@YA_KPEBE_KPEAEPEA_KPEAX@Z
	DD	imagerel ?do_compress@@YA_KPEBE_KPEAEPEA_KPEAX@Z+908
	DD	imagerel $unwind$?do_compress@@YA_KPEBE_KPEAEPEA_KPEAX@Z
$pdata$lzo1x_1_compress DD imagerel $LN34
	DD	imagerel $LN34+290
	DD	imagerel $unwind$lzo1x_1_compress
xdata	SEGMENT
$unwind$?do_compress@@YA_KPEBE_KPEAEPEA_KPEAX@Z DD 0a1e01H
	DD	08541eH
	DD	07341eH
	DD	0e01cf01eH
	DD	0c018d01aH
	DD	060157016H
$unwind$lzo1x_1_compress DD 081501H
	DD	0a7415H
	DD	096415H
	DD	083415H
	DD	0e0115215H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\rt_lzo1x_c.ch
_TEXT	SEGMENT
in$ = 64
in_len$ = 72
out$ = 80
out_len$ = 88
wrkmem$ = 96
lzo1x_1_compress PROC

; 297  : {

$LN34:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	r14, r9
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx

; 298  :     lzo_bytep op = out;

	mov	r10, r8

; 299  :     lzo_uint t;
; 300  : 
; 301  :     if __lzo_unlikely(in_len <= M2_MAX_LEN + 5)

	cmp	rdx, 13
	ja	SHORT $LN14@lzo1x_1_co

; 302  :         t = in_len;

	mov	r11, rdx

; 303  :     else

	jmp	SHORT $LN13@lzo1x_1_co
$LN14@lzo1x_1_co:

; 304  :     {
; 305  :         t = do_compress(in,in_len,op,out_len,wrkmem);

	mov	rax, QWORD PTR wrkmem$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	?do_compress@@YA_KPEBE_KPEAEPEA_KPEAX@Z	; do_compress

; 306  :         op += *out_len;

	mov	r10, QWORD PTR [r14]
	add	r10, rsi
	mov	r11, rax
$LN13@lzo1x_1_co:

; 307  :     }
; 308  : 
; 309  :     if (t > 0)

	test	r11, r11
	je	$LN1@lzo1x_1_co

; 310  :     {
; 311  :         const lzo_bytep ii = in + in_len - t;

	sub	rbx, r11
	add	rbx, rdi

; 312  : 
; 313  :         if (op == out && t <= 238)

	cmp	r10, rsi
	jne	SHORT $LN11@lzo1x_1_co
	cmp	r11, 238				; 000000eeH
	ja	SHORT $LN11@lzo1x_1_co

; 314  :             *op++ = LZO_BYTE(17 + t);

	lea	eax, DWORD PTR [r11+17]
	mov	BYTE PTR [r10], al
	jmp	SHORT $LN32@lzo1x_1_co
$LN11@lzo1x_1_co:

; 315  :         else if (t <= 3)

	cmp	r11, 3
	ja	SHORT $LN9@lzo1x_1_co

; 316  :             op[-2] |= LZO_BYTE(t);

	or	BYTE PTR [r10-2], r11b
	jmp	SHORT $LL3@lzo1x_1_co
$LN9@lzo1x_1_co:

; 317  :         else if (t <= 18)

	cmp	r11, 18
	ja	SHORT $LN7@lzo1x_1_co

; 318  :             *op++ = LZO_BYTE(t - 3);

	lea	eax, DWORD PTR [r11-3]
	mov	BYTE PTR [r10], al

; 319  :         else

	jmp	SHORT $LN32@lzo1x_1_co
$LN7@lzo1x_1_co:

; 320  :         {
; 321  :             lzo_uint tt = t - 18;

	lea	r8, QWORD PTR [r11-18]

; 322  : 
; 323  :             *op++ = 0;

	mov	BYTE PTR [r10], 0
	inc	r10

; 324  :             while (tt > 255)

	cmp	r8, 255					; 000000ffH
	jbe	SHORT $LN5@lzo1x_1_co

; 320  :         {
; 321  :             lzo_uint tt = t - 18;

	lea	rcx, QWORD PTR [r8-256]
	mov	rdi, r10
	mov	rax, -9187201950435737471		; 8080808080808081H
	mul	rcx
	xor	eax, eax
	shr	rdx, 7
	inc	rdx
	mov	rcx, rdx

; 324  :             while (tt > 255)

	add	r10, rdx
	rep stosb
	imul	rax, rdx, -255				; ffffffffffffff01H
	add	r8, rax
$LN5@lzo1x_1_co:

; 325  :             {
; 326  :                 tt -= 255;
; 327  :                 *op++ = 0;
; 328  :             }
; 329  :             assert(tt > 0);
; 330  :             *op++ = LZO_BYTE(tt);

	mov	BYTE PTR [r10], r8b
$LN32@lzo1x_1_co:
	inc	r10
	npad	12
$LL3@lzo1x_1_co:

; 331  :         }
; 332  :         do *op++ = *ii++; while (--t > 0);

	movzx	eax, BYTE PTR [rbx]
	inc	r10
	lea	rbx, QWORD PTR [rbx+1]
	mov	BYTE PTR [r10-1], al
	dec	r11
	jne	SHORT $LL3@lzo1x_1_co
$LN1@lzo1x_1_co:

; 333  :     }
; 334  : 
; 335  :     *op++ = M4_MARKER | 1;
; 336  :     *op++ = 0;
; 337  :     *op++ = 0;
; 338  : 
; 339  :     *out_len = pd(op, out);
; 340  :     return LZO_E_OK;
; 341  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+80]
	mov	WORD PTR [r10], 17
	add	r10, 2
	mov	BYTE PTR [r10], 0
	sub	r10, rsi
	mov	rsi, QWORD PTR [rsp+72]
	inc	r10
	xor	eax, eax
	mov	QWORD PTR [r14], r10
	add	rsp, 48					; 00000030H
	pop	r14
	ret	0
lzo1x_1_compress ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\rt_lzo1x_c.ch
_TEXT	SEGMENT
in$ = 56
in_len$ = 64
out$ = 72
out_len$ = 80
wrkmem$ = 88
?do_compress@@YA_KPEBE_KPEAEPEA_KPEAX@Z PROC		; do_compress

; 46   : {

	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15

; 47   :     register const lzo_bytep ip;
; 48   :     lzo_bytep op;
; 49   :     const lzo_bytep const in_end = in + in_len;

	lea	r14, QWORD PTR [rdx+rcx]
	mov	r11, r8
	mov	r13, rcx

; 50   :     const lzo_bytep const ip_end = in + in_len - M2_MAX_LEN - 5;
; 51   :     const lzo_bytep ii;
; 52   :     lzo_dict_p const dict = (lzo_dict_p) wrkmem;
; 53   : 
; 54   :     op = out;
; 55   :     ip = in;
; 56   :     ii = ip;

	mov	rbx, rcx

; 57   : 
; 58   :     ip += 4;

	lea	r10, QWORD PTR [rcx+4]
	lea	r12, QWORD PTR [r14-13]
	npad	13
$LL50@do_compres:

; 59   :     for (;;)
; 60   :     {
; 61   :         register const lzo_bytep m_pos;
; 62   :         lzo_uint m_off;
; 63   :         lzo_uint m_len;
; 64   :         lzo_uint dindex;
; 65   : 
; 66   :         DINDEX1(dindex,ip);

	movzx	eax, BYTE PTR [r10+1]
	movzx	edi, BYTE PTR [r10+3]
	movzx	ebp, BYTE PTR [r10+2]
	lea	r15, QWORD PTR [r10+3]
	mov	ecx, edi
	lea	rsi, QWORD PTR [r10+1]
	shl	rcx, 6
	xor	rcx, rbp
	shl	rcx, 5
	xor	rcx, rax
	movzx	eax, BYTE PTR [r10]
	shl	rcx, 5
	xor	rcx, rax

; 67   :         GINDEX(m_pos,m_off,dict,dindex,in);

	mov	rax, QWORD PTR wrkmem$[rsp]
	imul	rdx, rcx, 33				; 00000021H
	shr	rdx, 5
	and	edx, 16383				; 00003fffH
	lea	rcx, QWORD PTR [rax+rdx*8]
	mov	r9, QWORD PTR [rcx]

; 68   :         if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M4_MAX_OFFSET))

	cmp	r9, r13
	jb	$literal$111
	mov	r8, r10
	sub	r8, r9
	lea	rax, QWORD PTR [r8-1]
	cmp	rax, 49150				; 0000bffeH
	ja	$literal$111

; 69   :             goto literal;
; 70   : #if 1
; 71   :         if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])

	cmp	r8, 2048				; 00000800H
	jbe	SHORT $try_match$112
	cmp	BYTE PTR [r9+3], dil
	je	SHORT $try_match$112

; 72   :             goto try_match;
; 73   :         DINDEX2(dindex,ip);
; 74   : #endif
; 75   :         GINDEX(m_pos,m_off,dict,dindex,in);

	mov	rax, QWORD PTR wrkmem$[rsp]
	and	edx, 2047				; 000007ffH
	xor	rdx, 8223				; 0000201fH
	lea	rcx, QWORD PTR [rax+rdx*8]
	mov	r9, QWORD PTR [rcx]

; 76   :         if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M4_MAX_OFFSET))

	cmp	r9, r13
	jb	$literal$111
	mov	r8, r10
	sub	r8, r9
	lea	rax, QWORD PTR [r8-1]
	cmp	rax, 49150				; 0000bffeH
	ja	$literal$111

; 77   :             goto literal;
; 78   :         if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])

	cmp	r8, 2048				; 00000800H
	jbe	SHORT $try_match$112
	cmp	BYTE PTR [r9+3], dil
	jne	$literal$111
$try_match$112:

; 79   :             goto try_match;
; 80   :         goto literal;
; 81   : 
; 82   : 
; 83   : try_match:
; 84   : #if 1 && defined(LZO_UNALIGNED_OK_2)
; 85   :         if (* (const lzo_ushortp) m_pos != * (const lzo_ushortp) ip)

	movzx	eax, WORD PTR [r10]
	cmp	WORD PTR [r9], ax
	jne	$literal$111

; 86   : #else
; 87   :         if (m_pos[0] != ip[0] || m_pos[1] != ip[1])
; 88   : #endif
; 89   :         {
; 90   :         }
; 91   :         else
; 92   :         {
; 93   :             if __lzo_likely(m_pos[2] == ip[2])

	cmp	BYTE PTR [r9+2], bpl
	jne	$literal$111

; 143  :             break;
; 144  :         continue;
; 145  : 
; 146  : 
; 147  :     /* a match */
; 148  : match:
; 149  :         UPDATE_I(dict,0,dindex,ip,in);

	mov	QWORD PTR [rcx], r10
$match$113:

; 150  :         /* store current literal run */
; 151  :         if (pd(ip,ii) > 0)

	sub	r10, rbx
	je	SHORT $LN22@do_compres

; 152  :         {
; 153  :             register lzo_uint t = pd(ip,ii);
; 154  : 
; 155  :             if (t <= 3)

	cmp	r10, 3
	ja	SHORT $LN30@do_compres

; 156  :             {
; 157  :                 assert(op - 2 > out);
; 158  :                 op[-2] |= LZO_BYTE(t);

	or	BYTE PTR [r11-2], r10b
	jmp	SHORT $LL24@do_compres
$LN30@do_compres:

; 159  :             }
; 160  :             else if (t <= 18)

	cmp	r10, 18
	ja	SHORT $LN28@do_compres

; 161  :                 *op++ = LZO_BYTE(t - 3);

	lea	eax, DWORD PTR [r10-3]
	mov	BYTE PTR [r11], al

; 162  :             else

	jmp	SHORT $LN104@do_compres
$LN28@do_compres:

; 163  :             {
; 164  :                 register lzo_uint tt = t - 18;

	lea	rsi, QWORD PTR [r10-18]

; 165  : 
; 166  :                 *op++ = 0;

	mov	BYTE PTR [r11], 0
	inc	r11

; 167  :                 while (tt > 255)

	cmp	rsi, 255				; 000000ffH
	jbe	SHORT $LN26@do_compres

; 163  :             {
; 164  :                 register lzo_uint tt = t - 18;

	lea	rcx, QWORD PTR [rsi-256]
	mov	rdi, r11
	mov	rax, -9187201950435737471		; 8080808080808081H
	mul	rcx
	xor	eax, eax
	shr	rdx, 7
	inc	rdx
	mov	rcx, rdx

; 167  :                 while (tt > 255)

	add	r11, rdx
	rep stosb
	imul	rax, rdx, -255				; ffffffffffffff01H
	add	rsi, rax
$LN26@do_compres:

; 168  :                 {
; 169  :                     tt -= 255;
; 170  :                     *op++ = 0;
; 171  :                 }
; 172  :                 assert(tt > 0);
; 173  :                 *op++ = LZO_BYTE(tt);

	mov	BYTE PTR [r11], sil
$LN104@do_compres:
	inc	r11
	npad	4
$LL24@do_compres:

; 174  :             }
; 175  :             do *op++ = *ii++; while (--t > 0);

	movzx	eax, BYTE PTR [rbx]
	inc	r11
	inc	rbx
	mov	BYTE PTR [r11-1], al
	dec	r10
	jne	SHORT $LL24@do_compres
$LN22@do_compres:

; 176  :         }
; 177  : 
; 178  :         /* code the match */
; 179  :         assert(ii == ip);
; 180  :         ip += 3;
; 181  :         if (m_pos[3] != *ip++ || m_pos[4] != *ip++ || m_pos[5] != *ip++ ||
; 182  :             m_pos[6] != *ip++ || m_pos[7] != *ip++ || m_pos[8] != *ip++
; 183  : #ifdef LZO1Y
; 184  :             || m_pos[ 9] != *ip++ || m_pos[10] != *ip++ || m_pos[11] != *ip++
; 185  :             || m_pos[12] != *ip++ || m_pos[13] != *ip++ || m_pos[14] != *ip++
; 186  : #endif
; 187  :            )

	movzx	eax, BYTE PTR [r15]
	lea	r10, QWORD PTR [r15+1]
	cmp	BYTE PTR [r9+3], al
	jne	$LN20@do_compres
	movzx	eax, BYTE PTR [r10]
	inc	r10
	cmp	BYTE PTR [r9+4], al
	jne	$LN20@do_compres
	movzx	eax, BYTE PTR [r10]
	inc	r10
	cmp	BYTE PTR [r9+5], al
	jne	$LN20@do_compres
	movzx	eax, BYTE PTR [r10]
	inc	r10
	cmp	BYTE PTR [r9+6], al
	jne	$LN20@do_compres
	movzx	eax, BYTE PTR [r10]
	inc	r10
	cmp	BYTE PTR [r9+7], al
	jne	$LN20@do_compres
	movzx	eax, BYTE PTR [r10]
	inc	r10
	cmp	BYTE PTR [r9+8], al
	jne	$LN20@do_compres

; 217  :                 goto m3_m4_offset;
; 218  :             }
; 219  : #elif defined(LZO1Y)
; 220  :                 goto m4_match;
; 221  : #endif
; 222  :         }
; 223  :         else
; 224  :         {
; 225  :             {
; 226  :                 const lzo_bytep end = in_end;
; 227  :                 const lzo_bytep m = m_pos + M2_MAX_LEN + 1;

	lea	rcx, QWORD PTR [r9+9]

; 228  :                 while (ip < end && *m == *ip)

	cmp	r10, r14
	jae	SHORT $LN101@do_compres
$LL12@do_compres:
	movzx	eax, BYTE PTR [r10]
	cmp	BYTE PTR [rcx], al
	jne	SHORT $LN101@do_compres

; 229  :                     m++, ip++;

	inc	r10
	inc	rcx
	cmp	r10, r14
	jb	SHORT $LL12@do_compres
$LN101@do_compres:

; 230  :                 m_len = pd(ip, ii);

	mov	r9, r10
	sub	r9, rbx

; 231  :             }
; 232  :             assert(m_len > M2_MAX_LEN);
; 233  : 
; 234  :             if (m_off <= M3_MAX_OFFSET)

	cmp	r8, 16384				; 00004000H
	ja	SHORT $LN10@do_compres

; 235  :             {
; 236  :                 m_off -= 1;

	dec	r8

; 237  :                 if (m_len <= 33)

	cmp	r9, 33					; 00000021H
	ja	SHORT $LN9@do_compres

; 238  :                     *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));

	sub	r9b, 2
	or	r9b, 32					; 00000020H
	mov	BYTE PTR [r11], r9b

; 244  :                 }
; 245  :             }
; 246  :             else

	jmp	$LN105@do_compres
$LN9@do_compres:

; 239  :                 else
; 240  :                 {
; 241  :                     m_len -= 33;

	sub	r9, 33					; 00000021H

; 242  :                     *op++ = M3_MARKER | 0;

	mov	BYTE PTR [r11], 32			; 00000020H

; 243  :                     goto m3_m4_len;

	jmp	SHORT $LN106@do_compres
$LN10@do_compres:

; 247  :             {
; 248  : #if defined(LZO1Y)
; 249  : m4_match:
; 250  : #endif
; 251  :                 m_off -= 0x4000;

	sub	r8, 16384				; 00004000H

; 252  :                 assert(m_off > 0); assert(m_off <= 0x7fff);
; 253  :                 if (m_len <= M4_MAX_LEN)
; 254  :                     *op++ = LZO_BYTE(M4_MARKER |
; 255  :                                      ((m_off & 0x4000) >> 11) | (m_len - 2));

	mov	rax, r8
	shr	rax, 11
	and	al, 8
	cmp	r9, 9
	ja	SHORT $LN5@do_compres
	sub	r9b, 2
	or	al, r9b

; 256  :                 else

	jmp	$LN107@do_compres
$LN5@do_compres:

; 257  :                 {
; 258  :                     m_len -= M4_MAX_LEN;

	sub	r9, 9

; 259  :                     *op++ = LZO_BYTE(M4_MARKER | ((m_off & 0x4000) >> 11));

	or	al, 16
	mov	BYTE PTR [r11], al
$LN106@do_compres:
	inc	r11
$m3_m4_len$114:

; 260  : m3_m4_len:
; 261  :                     while (m_len > 255)

	cmp	r9, 255					; 000000ffH
	jbe	SHORT $LN3@do_compres
	lea	rcx, QWORD PTR [r9-256]
	mov	rdi, r11
	mov	rax, -9187201950435737471		; 8080808080808081H
	mul	rcx
	xor	eax, eax
	shr	rdx, 7
	inc	rdx
	mov	rcx, rdx
	add	r11, rdx
	rep stosb
	imul	rax, rdx, -255				; ffffffffffffff01H
	add	r9, rax
$LN3@do_compres:

; 262  :                     {
; 263  :                         m_len -= 255;
; 264  :                         *op++ = 0;
; 265  :                     }
; 266  :                     assert(m_len > 0);
; 267  :                     *op++ = LZO_BYTE(m_len);

	mov	BYTE PTR [r11], r9b

; 268  :                 }
; 269  :             }
; 270  : 
; 271  : m3_m4_offset:

	jmp	SHORT $LN105@do_compres
$LN20@do_compres:

; 188  :         {
; 189  :             --ip;

	dec	r10

; 190  :             m_len = pd(ip, ii);

	mov	rcx, r10
	sub	rcx, rbx

; 191  :             assert(m_len >= 3); assert(m_len <= M2_MAX_LEN);
; 192  : 
; 193  :             if (m_off <= M2_MAX_OFFSET)

	cmp	r8, 2048				; 00000800H
	ja	SHORT $LN19@do_compres

; 194  :             {
; 195  :                 m_off -= 1;

	dec	r8

; 196  : #if defined(LZO1X)
; 197  :                 *op++ = LZO_BYTE(((m_len - 1) << 5) | ((m_off & 7) << 2));

	add	cl, 255					; 000000ffH

; 273  :             *op++ = LZO_BYTE(m_off >> 6);

	add	r11, 2
	movzx	eax, r8b
	shl	cl, 5
	shr	r8, 3
	shl	al, 2

; 274  :         }
; 275  : 
; 276  : #if 0
; 277  : match_done:
; 278  : #endif
; 279  :         ii = ip;

	mov	rbx, r10
	and	al, 28
	or	cl, al

; 280  :         if __lzo_unlikely(ip >= ip_end)

	cmp	r10, r12
	mov	BYTE PTR [r11-2], cl
	mov	BYTE PTR [r11-1], r8b

; 281  :             break;
; 282  :     }

	jmp	SHORT $LN109@do_compres
$LN19@do_compres:

; 198  :                 *op++ = LZO_BYTE(m_off >> 3);
; 199  : #elif defined(LZO1Y)
; 200  :                 *op++ = LZO_BYTE(((m_len + 1) << 4) | ((m_off & 3) << 2));
; 201  :                 *op++ = LZO_BYTE(m_off >> 2);
; 202  : #endif
; 203  :             }
; 204  :             else if (m_off <= M3_MAX_OFFSET)
; 205  :             {
; 206  :                 m_off -= 1;
; 207  :                 *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));

	sub	cl, 2
	cmp	r8, 16384				; 00004000H
	ja	SHORT $LN17@do_compres
	dec	r8
	or	cl, 32					; 00000020H
	mov	BYTE PTR [r11], cl

; 208  :                 goto m3_m4_offset;

	jmp	SHORT $LN105@do_compres
$LN17@do_compres:

; 209  :             }
; 210  :             else
; 211  : #if defined(LZO1X)
; 212  :             {
; 213  :                 m_off -= 0x4000;

	sub	r8, 16384				; 00004000H

; 214  :                 assert(m_off > 0); assert(m_off <= 0x7fff);
; 215  :                 *op++ = LZO_BYTE(M4_MARKER |
; 216  :                                  ((m_off & 0x4000) >> 11) | (m_len - 2));

	mov	rax, r8
	shr	rax, 11
	and	al, 8
	or	al, cl
$LN107@do_compres:
	or	al, 16
	mov	BYTE PTR [r11], al
$LN105@do_compres:
	inc	r11

; 272  :             *op++ = LZO_BYTE((m_off & 63) << 2);

	movzx	eax, r8b

; 273  :             *op++ = LZO_BYTE(m_off >> 6);

	shr	r8, 6
	shl	al, 2
	add	r11, 2
$m3_m4_offset$115:
	and	al, 252					; 000000fcH

; 280  :         if __lzo_unlikely(ip >= ip_end)

	cmp	r10, r12
	mov	rbx, r10
	mov	BYTE PTR [r11-2], al
	mov	BYTE PTR [r11-1], r8b

; 281  :             break;
; 282  :     }

	jmp	SHORT $LN109@do_compres
$literal$111:

; 94   :             {
; 95   : #if 0
; 96   :                 if (m_off <= M2_MAX_OFFSET)
; 97   :                     goto match;
; 98   :                 if (lit <= 3)
; 99   :                     goto match;
; 100  :                 if (lit == 3)           /* better compression, but slower */
; 101  :                 {
; 102  :                     assert(op - 2 > out); op[-2] |= LZO_BYTE(3);
; 103  :                     *op++ = *ii++; *op++ = *ii++; *op++ = *ii++;
; 104  :                     goto code_match;
; 105  :                 }
; 106  :                 if (m_pos[3] == ip[3])
; 107  : #endif
; 108  :                     goto match;
; 109  :             }
; 110  :             else
; 111  :             {
; 112  :                 /* still need a better way for finding M1 matches */
; 113  : #if 0
; 114  :                 /* a M1 match */
; 115  : #if 0
; 116  :                 if (m_off <= M1_MAX_OFFSET && lit > 0 && lit <= 3)
; 117  : #else
; 118  :                 if (m_off <= M1_MAX_OFFSET && lit == 3)
; 119  : #endif
; 120  :                 {
; 121  :                     register lzo_uint t;
; 122  : 
; 123  :                     t = lit;
; 124  :                     assert(op - 2 > out); op[-2] |= LZO_BYTE(t);
; 125  :                     do *op++ = *ii++; while (--t > 0);
; 126  :                     assert(ii == ip);
; 127  :                     m_off -= 1;
; 128  :                     *op++ = LZO_BYTE(M1_MARKER | ((m_off & 3) << 2));
; 129  :                     *op++ = LZO_BYTE(m_off >> 2);
; 130  :                     ip += 2;
; 131  :                     goto match_done;
; 132  :                 }
; 133  : #endif
; 134  :             }
; 135  :         }
; 136  : 
; 137  : 
; 138  :     /* a literal */
; 139  : literal:
; 140  :         UPDATE_I(dict,0,dindex,ip,in);

	mov	QWORD PTR [rcx], r10

; 141  :         ++ip;
; 142  :         if __lzo_unlikely(ip >= ip_end)

	cmp	rsi, r12
	mov	r10, rsi
$LN109@do_compres:
	jb	$LL50@do_compres

; 283  : 
; 284  :     *out_len = pd(op, out);

	mov	rax, QWORD PTR out_len$[rsp]
	sub	r11, QWORD PTR out$[rsp]

; 285  :     return pd(in_end,ii);
; 286  : }

	mov	rbp, QWORD PTR [rsp+64]
	sub	r14, rbx
	mov	rbx, QWORD PTR [rsp+56]
	mov	QWORD PTR [rax], r11
	mov	rax, r14
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
?do_compress@@YA_KPEBE_KPEAEPEA_KPEAX@Z ENDP		; do_compress
_TEXT	ENDS
END
