; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?xr_EFS@@3PEAVEFS_Utils@@EA			; xr_EFS
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_02GFKOMOKH@?5?$CI?$AA@			; `string'
PUBLIC	??_C@_0M@IAFBEOBH@Open?5a?5File?$AA@		; `string'
PUBLIC	??_C@_0BI@KCPLAHKE@Too?5many?5file?5selected?4?$AA@ ; `string'
PUBLIC	??_C@_0M@KIPHFBFH@Save?5a?5File?$AA@		; `string'
PUBLIC	??_C@_08DPIBIONE@?$CFs?$CF02d?$CFs?$AA@		; `string'
PUBLIC	??_C@_0L@FILKDGJI@?$CFs?$CFs?$CF02d?$CFs?$AA@	; `string'
EXTRN	__imp_GetSaveFileNameA:PROC
EXTRN	__imp_strlwr:PROC
EXTRN	__imp_CommDlgExtendedError:PROC
EXTRN	__imp_GetOpenFileNameA:PROC
EXTRN	__imp_GetForegroundWindow:PROC
EXTRN	__imp_strrchr:PROC
?xr_EFS@@3PEAVEFS_Utils@@EA DQ 01H DUP (?)		; xr_EFS
_BSS	ENDS
;	COMDAT ??_C@_0L@FILKDGJI@?$CFs?$CFs?$CF02d?$CFs?$AA@
CONST	SEGMENT
??_C@_0L@FILKDGJI@?$CFs?$CFs?$CF02d?$CFs?$AA@ DB '%s%s%02d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPIBIONE@?$CFs?$CF02d?$CFs?$AA@
CONST	SEGMENT
??_C@_08DPIBIONE@?$CFs?$CF02d?$CFs?$AA@ DB '%s%02d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KIPHFBFH@Save?5a?5File?$AA@
CONST	SEGMENT
??_C@_0M@KIPHFBFH@Save?5a?5File?$AA@ DB 'Save a File', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KCPLAHKE@Too?5many?5file?5selected?4?$AA@
CONST	SEGMENT
??_C@_0BI@KCPLAHKE@Too?5many?5file?5selected?4?$AA@ DB 'Too many file sel'
	DB	'ected.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IAFBEOBH@Open?5a?5File?$AA@
CONST	SEGMENT
??_C@_0M@IAFBEOBH@Open?5a?5File?$AA@ DB 'Open a File', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GFKOMOKH@?5?$CI?$AA@
CONST	SEGMENT
??_C@_02GFKOMOKH@?5?$CI?$AA@ DB ' (', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
PUBLIC	?strext@@YAPEADPEBD@Z				; strext
PUBLIC	?strconcat@@YAPEBDHPEADPEBD111@Z		; strconcat
PUBLIC	?strconcat@@YAPEBDHPEADPEBD11@Z			; strconcat
PUBLIC	??$?HDU?$char_traits@D@std@@V?$xalloc@D@@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@0@$$QEAV10@PEBD@Z ; std::operator+<char,std::char_traits<char>,xalloc<char> >
PUBLIC	??0?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@QEAA@XZ ; xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >::xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@1@AEBV?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >,0> >
PUBLIC	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@QEAA@XZ ; std::map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >::map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >
PUBLIC	?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z	; EFS_Utils::GenerateName
PUBLIC	?AppendFolderToName@EFS_Utils@@QEAAPEBDPEBDPEADHH@Z ; EFS_Utils::AppendFolderToName
PUBLIC	?AppendFolderToName@EFS_Utils@@QEAAPEBDPEADHH@Z	; EFS_Utils::AppendFolderToName
PUBLIC	?GetSaveName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@D0H@Z ; EFS_Utils::GetSaveName
PUBLIC	?GetOpenName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@DH_N0H@Z ; EFS_Utils::GetOpenName
PUBLIC	?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z		; MakeFilter
PUBLIC	?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@AEBV23@PEBD@Z ; EFS_Utils::ChangeFileExt
PUBLIC	?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z ; EFS_Utils::ChangeFileExt
PUBLIC	?ExcludeBasePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z ; EFS_Utils::ExcludeBasePath
PUBLIC	?ExtractFilePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z ; EFS_Utils::ExtractFilePath
PUBLIC	?ExtractFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z ; EFS_Utils::ExtractFileExt
PUBLIC	?ExtractFileName@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z ; EFS_Utils::ExtractFileName
PUBLIC	??0?$xr_map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@@QEAA@XZ ; xr_map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >::xr_map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >
PUBLIC	??0EFS_Utils@@QEAA@XZ				; EFS_Utils::EFS_Utils
PUBLIC	??1EFS_Utils@@UEAA@XZ				; EFS_Utils::~EFS_Utils
;	COMDAT pdata
pdata	SEGMENT
$pdata$?strconcat@@YAPEBDHPEADPEBD111@Z DD imagerel $LN13
	DD	imagerel $LN13+197
	DD	imagerel $unwind$?strconcat@@YAPEBDHPEADPEBD111@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?strconcat@@YAPEBDHPEADPEBD11@Z DD imagerel $LN11
	DD	imagerel $LN11+156
	DD	imagerel $unwind$?strconcat@@YAPEBDHPEADPEBD11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$xalloc@D@@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@0@$$QEAV10@PEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+73
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$xalloc@D@@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@0@$$QEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@1@AEBV?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@Z DD imagerel $LN12
	DD	imagerel $LN12+35
	DD	imagerel $unwind$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@1@AEBV?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+35
	DD	imagerel $unwind$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD imagerel $LN29
	DD	imagerel $LN29+10
	DD	imagerel $unwind$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$pdata$3$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD imagerel $LN29+10
	DD	imagerel $LN29+46
	DD	imagerel $chain$3$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$pdata$5$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD imagerel $LN29+46
	DD	imagerel $LN29+170
	DD	imagerel $chain$5$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$pdata$6$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD imagerel $LN29+170
	DD	imagerel $LN29+400
	DD	imagerel $chain$6$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$pdata$7$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD imagerel $LN29+400
	DD	imagerel $LN29+424
	DD	imagerel $chain$7$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$pdata$?AppendFolderToName@EFS_Utils@@QEAAPEBDPEBDPEADHH@Z DD imagerel $LN46
	DD	imagerel $LN46+220
	DD	imagerel $unwind$?AppendFolderToName@EFS_Utils@@QEAAPEBDPEBDPEADHH@Z
$pdata$?AppendFolderToName@EFS_Utils@@QEAAPEBDPEADHH@Z DD imagerel $LN8
	DD	imagerel $LN8+76
	DD	imagerel $unwind$?AppendFolderToName@EFS_Utils@@QEAAPEBDPEADHH@Z
$pdata$?GetSaveName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@D0H@Z DD imagerel $LN288
	DD	imagerel $LN288+475
	DD	imagerel $unwind$?GetSaveName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@D0H@Z
$pdata$?GetOpenName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@DH_N0H@Z DD imagerel $LN430
	DD	imagerel $LN430+1486
	DD	imagerel $unwind$?GetOpenName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@DH_N0H@Z
$pdata$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z DD imagerel $LN101
	DD	imagerel $LN101+173
	DD	imagerel $unwind$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z
$pdata$1$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z DD imagerel $LN101+173
	DD	imagerel $LN101+739
	DD	imagerel $chain$1$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z
$pdata$2$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z DD imagerel $LN101+739
	DD	imagerel $LN101+764
	DD	imagerel $chain$2$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z
$pdata$?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@AEBV23@PEBD@Z DD imagerel $LN12
	DD	imagerel $LN12+33
	DD	imagerel $unwind$?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@AEBV23@PEBD@Z
$pdata$?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z DD imagerel $LN156
	DD	imagerel $LN156+269
	DD	imagerel $unwind$?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z
$pdata$?ExcludeBasePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z DD imagerel $LN109
	DD	imagerel $LN109+184
	DD	imagerel $unwind$?ExcludeBasePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z
$pdata$?ExtractFilePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z DD imagerel $LN104
	DD	imagerel $LN104+231
	DD	imagerel $unwind$?ExtractFilePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z
$pdata$?ExtractFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z DD imagerel $LN54
	DD	imagerel $LN54+115
	DD	imagerel $unwind$?ExtractFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z
$pdata$?ExtractFileName@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z DD imagerel $LN54
	DD	imagerel $LN54+116
	DD	imagerel $unwind$?ExtractFileName@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$xr_map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@@QEAA@XZ DD imagerel $LN18
	DD	imagerel $LN18+35
	DD	imagerel $unwind$??0?$xr_map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@@QEAA@XZ
pdata	ENDS
pdata	SEGMENT
$pdata$??0EFS_Utils@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+47
	DD	imagerel $unwind$??0EFS_Utils@@QEAA@XZ
$pdata$??1EFS_Utils@@UEAA@XZ DD imagerel $LN68
	DD	imagerel $LN68+66
	DD	imagerel $unwind$??1EFS_Utils@@UEAA@XZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$xr_map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
xdata	SEGMENT
$unwind$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD 020a01H
	DD	04d010aH
$chain$3$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD 081221H
	DD	04af412H
	DD	04be40cH
	DD	0506408H
	DD	04e3404H
	DD	imagerel $LN29
	DD	imagerel $LN29+10
	DD	imagerel $unwind$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$chain$5$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD 040821H
	DD	04c7408H
	DD	04f5404H
	DD	imagerel $LN29+10
	DD	imagerel $LN29+46
	DD	imagerel $chain$3$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$chain$6$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD 021H
	DD	imagerel $LN29+10
	DD	imagerel $LN29+46
	DD	imagerel $chain$3$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$chain$7$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z DD 021H
	DD	imagerel $LN29
	DD	imagerel $LN29+10
	DD	imagerel $unwind$?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z
$unwind$?AppendFolderToName@EFS_Utils@@QEAAPEBDPEBDPEADHH@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?AppendFolderToName@EFS_Utils@@QEAAPEBDPEADHH@Z DD 030901H
	DD	0260109H
	DD	03002H
$unwind$?GetSaveName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@D0H@Z DD 0b1d01H
	DD	0121741dH
	DD	0120641dH
	DD	011f541dH
	DD	011e341dH
	DD	011c011dH
	DD	0e016H
$unwind$?GetOpenName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@DH_N0H@Z DD 0d2d01H
	DD	0334742dH
	DD	0333642dH
	DD	0332342dH
	DD	032c012dH
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
$unwind$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z DD 081701H
	DD	0175417H
	DD	0f013d217H
	DD	0d00fe011H
	DD	0600bc00dH
$chain$1$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z DD 041721H
	DD	0167417H
	DD	0153408H
	DD	imagerel $LN101
	DD	imagerel $LN101+173
	DD	imagerel $unwind$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z
$chain$2$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z DD 021H
	DD	imagerel $LN101
	DD	imagerel $LN101+173
	DD	imagerel $unwind$?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z
$unwind$?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@AEBV23@PEBD@Z DD 020601H
	DD	030023206H
$unwind$?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z DD 081201H
	DD	0e5412H
	DD	0c3412H
	DD	0e00e7212H
	DD	0600b700cH
$unwind$?ExcludeBasePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
$unwind$?ExtractFilePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z DD 050d01H
	DD	090340dH
	DD	08e010dH
	DD	07006H
$unwind$?ExtractFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z DD 030901H
	DD	0480109H
	DD	03002H
$unwind$?ExtractFileName@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z DD 050d01H
	DD	04a340dH
	DD	048010dH
	DD	07006H
$unwind$??0EFS_Utils@@QEAA@XZ DD 020601H
	DD	030023206H
$unwind$??1EFS_Utils@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@1@AEBV?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$xalloc@D@@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@0@$$QEAV10@PEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?strconcat@@YAPEBDHPEADPEBD11@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?strconcat@@YAPEBDHPEADPEBD111@Z DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
p$1 = 48
$T2 = 48
this$ = 48
??1EFS_Utils@@UEAA@XZ PROC				; EFS_Utils::~EFS_Utils

; 18   : {

$LN68:
	push	rbx
	sub	rsp, 32					; 00000020H

; 19   : }

	lea	rbx, QWORD PTR [rcx+8]
	lea	rax, OFFSET FLAT:??_7EFS_Utils@@6B@
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

	lea	rdx, QWORD PTR $T2[rsp]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 18   : {

	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 2230 : 		erase(begin(), end());

	mov	r8, QWORD PTR [rbx]
	mov	rcx, rbx
	mov	r9, r8
	mov	r8, QWORD PTR [r8]
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR [rbx]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	lea	rcx, QWORD PTR p$1[rsp]
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	QWORD PTR p$1[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h

; 82   : 							void					deallocate		(pointer p, size_type n) const			{	xr_free	(p);				}

	call	??$xr_free@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@PEAX@std@@@@YAXAEAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@PEAX@std@@@Z ; xr_free<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> > const ,void * __ptr64>,void * __ptr64> >
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 19   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??1EFS_Utils@@UEAA@XZ ENDP				; EFS_Utils::~EFS_Utils
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
this$ = 48
??0EFS_Utils@@QEAA@XZ PROC				; EFS_Utils::EFS_Utils

; 14   : {

$LN20:
	push	rbx
	sub	rsp, 32					; 00000020H
	lea	rax, OFFSET FLAT:??_7EFS_Utils@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	xor	eax, eax
	mov	QWORD PTR [rcx+8], rax

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> > const ,void * __ptr64>,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > > >::_Buyheadnode
	mov	QWORD PTR [rbx+8], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 15   : }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0EFS_Utils@@QEAA@XZ ENDP				; EFS_Utils::EFS_Utils
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$xr_map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$xr_map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@@QEAA@XZ PROC ; xr_map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >::xr_map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >, COMDAT
$LN18:
	push	rbx
	sub	rsp, 32					; 00000020H

; 569  : 		this->_Myhead = 0;

	xor	eax, eax
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rcx+8], rax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> > const ,void * __ptr64>,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > > >::_Buyheadnode
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$xr_map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@@QEAA@XZ ENDP ; xr_map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >::xr_map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
name$ = 48
this$ = 592
__$ReturnUdt$ = 600
src$ = 608
?ExtractFileName@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z PROC ; EFS_Utils::ExtractFileName

; 22   : {

$LN54:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 576				; 00000240H
	mov	rcx, r8
	mov	rdi, rdx

; 23   : 	string_path name;
; 24   : 	_splitpath	(src,0,0,name,0);

	lea	r9, QWORD PTR name$[rsp]
	xor	ebx, ebx
	xor	r8d, r8d
	xor	edx, edx
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp__splitpath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdi+16], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdi], bl

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR name$[rsp], bl
	je	SHORT $LN51@ExtractFil
	lea	rax, QWORD PTR name$[rsp]
	or	rbx, -1
$LL52@ExtractFil:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL52@ExtractFil
$LN51@ExtractFil:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, QWORD PTR name$[rsp]
	mov	r8, rbx
	mov	rcx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 26   : }

	mov	rbx, QWORD PTR [rsp+592]
	mov	rax, rdi
	add	rsp, 576				; 00000240H
	pop	rdi
	ret	0
?ExtractFileName@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z ENDP ; EFS_Utils::ExtractFileName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
ext$ = 48
this$ = 592
__$ReturnUdt$ = 600
src$ = 608
?ExtractFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z PROC ; EFS_Utils::ExtractFileExt

; 29   : {

$LN54:
	push	rbx
	sub	rsp, 576				; 00000240H
	mov	rax, r8

; 30   : 	string_path ext;
; 31   : 	_splitpath	(src,0,0,0,ext);

	lea	rcx, QWORD PTR ext$[rsp]
	mov	rbx, rdx
	mov	QWORD PTR [rsp+32], rcx
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rcx, rax
	xor	edx, edx
	call	QWORD PTR __imp__splitpath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	r8d, r8d

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], r8b

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR ext$[rsp], r8b
	je	SHORT $LN51@ExtractFil
	lea	rax, QWORD PTR ext$[rsp]
	or	r8, -1
	npad	4
$LL52@ExtractFil:
	inc	r8
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL52@ExtractFil
$LN51@ExtractFil:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, QWORD PTR ext$[rsp]
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 32   :     return xr_string(ext);

	mov	rax, rbx

; 33   : }

	add	rsp, 576				; 00000240H
	pop	rbx
	ret	0
?ExtractFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z ENDP ; EFS_Utils::ExtractFileExt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
$T1 = 48
drive$ = 80
dir$ = 608
this$ = 1152
p$2 = 1160
__$ReturnUdt$ = 1160
src$ = 1168
?ExtractFilePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z PROC ; EFS_Utils::ExtractFilePath

; 36   : {

$LN104:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 1136				; 00000470H
	mov	rcx, r8
	mov	rdi, rdx

; 37   : 	string_path drive,dir;
; 38   : 	_splitpath	(src,drive,dir,0,0);

	lea	r8, QWORD PTR dir$[rsp]
	lea	rdx, QWORD PTR drive$[rsp]
	xor	ebx, ebx
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	call	QWORD PTR __imp__splitpath
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T1[rsp+24], 15

; 1170 : 		}
; 1171 : 
; 1172 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1173 : 		{	// assign _Count * _Ch
; 1174 : 		if (_Count == npos)
; 1175 : 			_Xlen();	// result too long
; 1176 : 
; 1177 : 		if (_Grow(_Count))
; 1178 : 			{	// make room and assign new stuff
; 1179 : 			_Chassign(0, _Count, _Ch);
; 1180 : 			_Eos(_Count);
; 1181 : 			}
; 1182 : 		return (*this);
; 1183 : 		}
; 1184 : 
; 1185 : 	template<class _Iter>
; 1186 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1187 : 			_Myt&>::type
; 1188 : 		assign(_Iter _First, _Iter _Last)
; 1189 : 		{	// assign [_First, _Last), input iterators
; 1190 : 		return (replace(begin(), end(), _First, _Last));
; 1191 : 		}
; 1192 : 
; 1193 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1194 : 		{	// assign [_First, _Last), const pointers
; 1195 : 		return (replace(begin(), end(), _First, _Last));
; 1196 : 		}
; 1197 : 
; 1198 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1199 : 		{	// assign [_First, _Last), const_iterators
; 1200 : 		return (replace(begin(), end(), _First, _Last));
; 1201 : 		}
; 1202 : 
; 1203 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1204 : 		{	// insert _Right at _Off
; 1205 : 		return (insert(_Off, _Right, 0, npos));
; 1206 : 		}
; 1207 : 
; 1208 : 	_Myt& insert(size_type _Off,
; 1209 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1210 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1211 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1212 : 			_Xran();	// _Off or _Roff off end
; 1213 : 		size_type _Num = _Right.size() - _Roff;
; 1214 : 		if (_Num < _Count)
; 1215 : 			_Count = _Num;	// trim _Count to size
; 1216 : 		if (npos - this->_Mysize <= _Count)
; 1217 : 			_Xlen();	// result too long
; 1218 : 
; 1219 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1220 : 			{	// make room and insert new stuff
; 1221 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1222 : 				this->_Myptr() + _Off,
; 1223 : 				this->_Mysize - _Off);	// empty out hole
; 1224 : 			if (this == &_Right)
; 1225 : 				_Traits::move(this->_Myptr() + _Off,
; 1226 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1227 : 						_Count);	// substring
; 1228 : 			else
; 1229 : 				_Traits::copy(this->_Myptr() + _Off,
; 1230 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1231 : 			_Eos(_Num);
; 1232 : 			}
; 1233 : 		return (*this);
; 1234 : 		}
; 1235 : 
; 1236 : 	_Myt& insert(size_type _Off,
; 1237 : 		const _Elem *_Ptr, size_type _Count)
; 1238 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1239 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1240 : 		if (_Count != 0)
; 1241 : 			_DEBUG_POINTER(_Ptr);
; 1242 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1243 : 
; 1244 : 		if (_Inside(_Ptr))
; 1245 : 			return (insert(_Off, *this,
; 1246 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1264 : 		{	// insert [_Ptr, <null>) at _Off
; 1265 : 		_DEBUG_POINTER(_Ptr);
; 1266 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1267 : 		}
; 1268 : 
; 1269 : 	_Myt& insert(size_type _Off,
; 1270 : 		size_type _Count, _Elem _Ch)
; 1271 : 		{	// insert _Count * _Ch at _Off
; 1272 : 		if (this->_Mysize < _Off)
; 1273 : 			_Xran();	// _Off off end
; 1274 : 		if (npos - this->_Mysize <= _Count)
; 1275 : 			_Xlen();	// result too long
; 1276 : 		size_type _Num;
; 1277 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1278 : 			{	// make room and insert new stuff
; 1279 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1280 : 				this->_Myptr() + _Off,
; 1281 : 				this->_Mysize - _Off);	// empty out hole
; 1282 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1283 : 			_Eos(_Num);
; 1284 : 			}
; 1285 : 		return (*this);
; 1286 : 		}
; 1287 : 
; 1288 : 	iterator insert(const_iterator _Where)
; 1289 : 		{	// insert <null> at _Where
; 1290 : 		return (insert(_Where, _Elem()));
; 1291 : 		}
; 1292 : 
; 1293 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1294 : 		{	// insert _Ch at _Where
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		insert(_Off, 1, _Ch);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1301 : 		{	// insert _Count * _Elem at _Where
; 1302 : 		size_type _Off = _Pdif(_Where, begin());
; 1303 : 		insert(_Off, _Count, _Ch);
; 1304 : 		return (begin() + _Off);
; 1305 : 		}
; 1306 : 
; 1307 : 	template<class _Iter>
; 1308 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1309 : 			iterator>::type
; 1310 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1311 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1312 : 		size_type _Off = _Pdif(_Where, begin());
; 1313 : 		replace(_Where, _Where, _First, _Last);
; 1314 : 		return (begin() + _Off);
; 1315 : 		}
; 1316 : 
; 1317 : 	iterator insert(const_iterator _Where,
; 1318 : 		const_pointer _First, const_pointer _Last)
; 1319 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1320 : 		size_type _Off = _Pdif(_Where, begin());
; 1321 : 		replace(_Where, _Where, _First, _Last);
; 1322 : 		return (begin() + _Off);
; 1323 : 		}
; 1324 : 
; 1325 : 	iterator insert(const_iterator _Where,
; 1326 : 		const_iterator _First, const_iterator _Last)
; 1327 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1328 : 		size_type _Off = _Pdif(_Where, begin());
; 1329 : 		replace(_Where, _Where, _First, _Last);
; 1330 : 		return (begin() + _Off);
; 1331 : 		}
; 1332 : 
; 1333 : 	_Myt& erase(size_type _Off = 0)
; 1334 : 		{	// erase elements [_Off, ...)
; 1335 : 		if (this->_Mysize < _Off)
; 1336 : 			_Xran();	// _Off off end
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		if (this->_Mysize < _Off)
; 1344 : 			_Xran();	// _Off off end
; 1345 : 		if (this->_Mysize - _Off <= _Count)
; 1346 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1347 : 		else if (0 < _Count)
; 1348 : 			{	// move elements down
; 1349 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1350 : 			size_type _Newsize = this->_Mysize - _Count;
; 1351 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1352 : 			_Eos(_Newsize);
; 1353 : 			}
; 1354 : 		return (*this);
; 1355 : 		}
; 1356 : 
; 1357 : 	iterator erase(const_iterator _Where)
; 1358 : 		{	// erase element at _Where
; 1359 : 		size_type _Count = _Pdif(_Where, begin());
; 1360 : 		erase(_Count, 1);
; 1361 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1362 : 		}
; 1363 : 
; 1364 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1365 : 		{	// erase substring [_First, _Last)
; 1366 : 		_DEBUG_RANGE(_First, _Last);
; 1367 : 		size_type _Count = _Pdif(_First, begin());
; 1368 : 		erase(_Count, _Pdif(_Last, _First));
; 1369 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1370 : 		}
; 1371 : 
; 1372 : 	void clear() _NOEXCEPT
; 1373 : 		{	// erase all
; 1374 : 		_Eos(0);
; 1375 : 		}
; 1376 : 
; 1377 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1378 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1379 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1380 : 		}
; 1381 : 
; 1382 : 	_Myt& replace(size_type _Off,
; 1383 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1386 : 			_Xran();	// _Off or _Roff off end
; 1387 : 		if (this->_Mysize - _Off < _N0)
; 1388 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1389 : 		size_type _Num = _Right.size() - _Roff;
; 1390 : 		if (_Num < _Count)
; 1391 : 			_Count = _Num;	// trim _Count to size
; 1392 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1393 : 			_Xlen();	// result too long
; 1394 : 
; 1395 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1396 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1397 : 		if (this->_Mysize < _Newsize)
; 1398 : 			_Grow(_Newsize);
; 1399 : 
; 1400 : 		if (this != &_Right)
; 1401 : 			{	// no overlap, just move down and copy in new stuff
; 1402 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1403 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1404 : 			_Traits::copy(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (_Count <= _N0)
; 1408 : 			{	// hole doesn't get larger, just copy in substring
; 1409 : 			_Traits::move(this->_Myptr() + _Off,
; 1410 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1411 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1412 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1413 : 			}
; 1414 : 		else if (_Roff <= _Off)
; 1415 : 			{	// hole gets larger, substring begins before hole
; 1416 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1417 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1418 : 			_Traits::move(this->_Myptr() + _Off,
; 1419 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1420 : 			}
; 1421 : 		else if (_Off + _N0 <= _Roff)
; 1422 : 			{	// hole gets larger, substring begins after hole
; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1424 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1425 : 			_Traits::move(this->_Myptr() + _Off,
; 1426 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1427 : 				_Count);	// fill hole
; 1428 : 			}
; 1429 : 		else
; 1430 : 			{	// hole gets larger, substring begins in hole
; 1431 : 			_Traits::move(this->_Myptr() + _Off,
; 1432 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1434 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1436 : 				this->_Myptr() + _Roff + _Count,
; 1437 : 				_Count - _N0);	// fill rest of new hole
; 1438 : 			}
; 1439 : 
; 1440 : 		_Eos(_Newsize);
; 1441 : 		return (*this);
; 1442 : 		}
; 1443 : 
; 1444 : 	_Myt& replace(size_type _Off,
; 1445 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1446 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1447 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1448 : 		if (_Count != 0)
; 1449 : 			_DEBUG_POINTER(_Ptr);
; 1450 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1451 : 
; 1452 : 		if (_Inside(_Ptr))
; 1453 : 			return (replace(_Off, _N0, *this,
; 1454 : 				_Ptr - this->_Myptr(),
; 1455 : 				_Count));	// substring, replace carefully
; 1456 : 		if (this->_Mysize < _Off)
; 1457 : 			_Xran();	// _Off off end
; 1458 : 		if (this->_Mysize - _Off < _N0)
; 1459 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1460 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1461 : 			_Xlen();	// result too long
; 1462 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1463 : 
; 1464 : 		if (_Count < _N0)
; 1465 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1466 : 				this->_Myptr() + _Off + _N0,
; 1467 : 				_Nm);	// smaller hole, move tail up
; 1468 : 		size_type _Num;
; 1469 : 		if ((0 < _Count || 0 < _N0)
; 1470 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1471 : 			{	// make room and rearrange
; 1472 : 			if (_N0 < _Count)
; 1473 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1474 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1475 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1476 : 			_Eos(_Num);
; 1477 : 			}
; 1478 : 		return (*this);
; 1479 : 		}
; 1480 : 
; 1481 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1482 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1483 : 		_DEBUG_POINTER(_Ptr);
; 1484 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1485 : 		}
; 1486 : 
; 1487 : 	_Myt& replace(size_type _Off,
; 1488 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1489 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1490 : 		if (this->_Mysize < _Off)
; 1491 : 			_Xran();	// _Off off end
; 1492 : 		if (this->_Mysize - _Off < _N0)
; 1493 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1494 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1495 : 			_Xlen();	// result too long
; 1496 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1497 : 
; 1498 : 		if (_Count < _N0)
; 1499 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1500 : 				this->_Myptr() + _Off + _N0,
; 1501 : 				_Nm);	// smaller hole, move tail up
; 1502 : 		size_type _Num;
; 1503 : 		if ((0 < _Count || 0 < _N0)
; 1504 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1505 : 			{	// make room and rearrange
; 1506 : 			if (_N0 < _Count)
; 1507 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1508 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1509 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1510 : 			_Eos(_Num);
; 1511 : 			}
; 1512 : 		return (*this);
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Myt& _Right)
; 1517 : 		{	// replace [_First, _Last) with _Right
; 1518 : 		return (replace(
; 1519 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1520 : 		}
; 1521 : 
; 1522 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1523 : 		const _Elem *_Ptr, size_type _Count)
; 1524 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1525 : 		return (replace(
; 1526 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const _Elem *_Ptr)
; 1531 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1532 : 		return (replace(
; 1533 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1534 : 		}
; 1535 : 
; 1536 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1537 : 		size_type _Count, _Elem _Ch)
; 1538 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1539 : 		return (replace(
; 1540 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1541 : 		}
; 1542 : 
; 1543 : 	template<class _Iter>
; 1544 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1545 : 			_Myt&>::type
; 1546 : 		replace(const_iterator _First, const_iterator _Last,
; 1547 : 			_Iter _First2, _Iter _Last2)
; 1548 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1549 : 		_Myt _Right(_First2, _Last2);
; 1550 : 		replace(_First, _Last, _Right);
; 1551 : 		return (*this);
; 1552 : 		}
; 1553 : 
; 1554 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1555 : 		const_pointer _First2, const_pointer _Last2)
; 1556 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1557 : 		if (_First2 == _Last2)
; 1558 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1559 : 		else
; 1560 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1561 : 				&*_First2, _Last2 - _First2);
; 1562 : 		return (*this);
; 1563 : 		}
; 1564 : 
; 1565 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1566 : 		pointer _First2, pointer _Last2)
; 1567 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1568 : 		if (_First2 == _Last2)
; 1569 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1570 : 		else
; 1571 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1572 : 				&*_First2, _Last2 - _First2);
; 1573 : 		return (*this);
; 1574 : 		}
; 1575 : 
; 1576 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1577 : 		const_iterator _First2, const_iterator _Last2)
; 1578 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1579 : 		if (_First2 == _Last2)
; 1580 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1581 : 		else
; 1582 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1583 : 				&*_First2, _Last2 - _First2);
; 1584 : 		return (*this);
; 1585 : 		}
; 1586 : 
; 1587 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1588 : 		iterator _First2, iterator _Last2)
; 1589 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1590 : 		if (_First2 == _Last2)
; 1591 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1592 : 		else
; 1593 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1594 : 				&*_First2, _Last2 - _First2);
; 1595 : 		return (*this);
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator begin() _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of mutable sequence
; 1600 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator begin() const _NOEXCEPT
; 1604 : 		{	// return iterator for beginning of nonmutable sequence
; 1605 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1606 : 		}
; 1607 : 
; 1608 : 	iterator end() _NOEXCEPT
; 1609 : 		{	// return iterator for end of mutable sequence
; 1610 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_iterator end() const _NOEXCEPT
; 1614 : 		{	// return iterator for end of nonmutable sequence
; 1615 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rbegin() _NOEXCEPT
; 1619 : 		{	// return iterator for beginning of reversed mutable sequence
; 1620 : 		return (reverse_iterator(end()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1624 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(end()));
; 1626 : 		}
; 1627 : 
; 1628 : 	reverse_iterator rend() _NOEXCEPT
; 1629 : 		{	// return iterator for end of reversed mutable sequence
; 1630 : 		return (reverse_iterator(begin()));
; 1631 : 		}
; 1632 : 
; 1633 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of reversed nonmutable sequence
; 1635 : 		return (const_reverse_iterator(begin()));
; 1636 : 		}
; 1637 : 
; 1638 : 	const_iterator cbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of nonmutable sequence
; 1640 : 		return (((const _Myt *)this)->begin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_iterator cend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of nonmutable sequence
; 1645 : 		return (((const _Myt *)this)->end());
; 1646 : 		}
; 1647 : 
; 1648 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1649 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1650 : 		return (((const _Myt *)this)->rbegin());
; 1651 : 		}
; 1652 : 
; 1653 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1654 : 		{	// return iterator for end of reversed nonmutable sequence
; 1655 : 		return (((const _Myt *)this)->rend());
; 1656 : 		}
; 1657 : 
; 1658 : 	void shrink_to_fit()
; 1659 : 		{	// reduce capacity
; 1660 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1661 : 			{	// worth shrinking, do it
; 1662 : 			_Myt _Tmp(*this);
; 1663 : 			swap(_Tmp);
; 1664 : 			}
; 1665 : 		}
; 1666 : 
; 1667 : 	reference at(size_type _Off)
; 1668 : 		{	// subscript mutable sequence with checking
; 1669 : 		if (this->_Mysize <= _Off)
; 1670 : 			_Xran();	// _Off off end
; 1671 : 		return (this->_Myptr()[_Off]);
; 1672 : 		}
; 1673 : 
; 1674 : 	const_reference at(size_type _Off) const
; 1675 : 		{	// subscript nonmutable sequence with checking
; 1676 : 		if (this->_Mysize <= _Off)
; 1677 : 			_Xran();	// _Off off end
; 1678 : 		return (this->_Myptr()[_Off]);
; 1679 : 		}
; 1680 : 
; 1681 : 	reference operator[](size_type _Off)
; 1682 : 		{	// subscript mutable sequence
; 1683 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1684 : 		if (this->_Mysize < _Off)	// sic
; 1685 : 			_DEBUG_ERROR("string subscript out of range");
; 1686 : 
; 1687 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1688 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1689 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1690 : 
; 1691 : 		return (this->_Myptr()[_Off]);
; 1692 : 		}
; 1693 : 
; 1694 : 	const_reference operator[](size_type _Off) const
; 1695 : 		{	// subscript nonmutable sequence
; 1696 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1697 : 		if (this->_Mysize < _Off)	// sic
; 1698 : 			_DEBUG_ERROR("string subscript out of range");
; 1699 : 
; 1700 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1701 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1702 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1703 : 
; 1704 : 		return (this->_Myptr()[_Off]);
; 1705 : 		}
; 1706 : 
; 1707 : 	void push_back(_Elem _Ch)
; 1708 : 		{	// insert element at end
; 1709 : 		insert(end(), _Ch);
; 1710 : 		}
; 1711 : 
; 1712 : 	void pop_back()
; 1713 : 		{	// erase element at end
; 1714 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1715 : 		}
; 1716 : 
; 1717 : 	reference front()
; 1718 : 		{	// return first element of mutable sequence
; 1719 : 		return (*begin());
; 1720 : 		}
; 1721 : 
; 1722 : 	const_reference front() const
; 1723 : 		{	// return first element of nonmutable sequence
; 1724 : 		return (*begin());
; 1725 : 		}
; 1726 : 
; 1727 : 	reference back()
; 1728 : 		{	// return last element of mutable sequence
; 1729 : 		return (*(end() - 1));
; 1730 : 		}
; 1731 : 
; 1732 : 	const_reference back() const
; 1733 : 		{	// return last element of nonmutable sequence
; 1734 : 		return (*(end() - 1));
; 1735 : 		}
; 1736 : 
; 1737 : 	const _Elem *c_str() const _NOEXCEPT
; 1738 : 		{	// return pointer to null-terminated nonmutable array
; 1739 : 		return (this->_Myptr());
; 1740 : 		}
; 1741 : 
; 1742 : 	const _Elem *data() const _NOEXCEPT
; 1743 : 		{	// return pointer to nonmutable array
; 1744 : 		return (c_str());
; 1745 : 		}
; 1746 : 
; 1747 : 	size_type length() const _NOEXCEPT
; 1748 : 		{	// return length of sequence
; 1749 : 		return (this->_Mysize);
; 1750 : 		}
; 1751 : 
; 1752 : 	size_type size() const _NOEXCEPT
; 1753 : 		{	// return length of sequence
; 1754 : 		return (this->_Mysize);
; 1755 : 		}
; 1756 : 
; 1757 : 	size_type max_size() const _NOEXCEPT
; 1758 : 		{	// return maximum possible length of sequence
; 1759 : 		size_type _Num = this->_Getal().max_size();
; 1760 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1761 : 		}
; 1762 : 
; 1763 : 	void resize(size_type _Newsize)
; 1764 : 		{	// determine new length, padding with null elements as needed
; 1765 : 		resize(_Newsize, _Elem());
; 1766 : 		}
; 1767 : 
; 1768 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1769 : 		{	// determine new length, padding with _Ch elements as needed
; 1770 : 		if (_Newsize <= this->_Mysize)
; 1771 : 			_Eos(_Newsize);
; 1772 : 		else
; 1773 : 			append(_Newsize - this->_Mysize, _Ch);
; 1774 : 		}
; 1775 : 
; 1776 : 	size_type capacity() const _NOEXCEPT
; 1777 : 		{	// return current length of allocated storage
; 1778 : 		return (this->_Myres);
; 1779 : 		}
; 1780 : 
; 1781 : 	void reserve(size_type _Newcap = 0)
; 1782 : 		{	// determine new minimum length of allocated storage
; 1783 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1784 : 			{	// change reservation
; 1785 : 			size_type _Size = this->_Mysize;
; 1786 : 			if (_Grow(_Newcap, true))
; 1787 : 				_Eos(_Size);
; 1788 : 			}
; 1789 : 		}
; 1790 : 
; 1791 : 	bool empty() const _NOEXCEPT
; 1792 : 		{	// test if sequence is empty
; 1793 : 		return (this->_Mysize == 0);
; 1794 : 		}
; 1795 : 
; 1796 : 	_SCL_INSECURE_DEPRECATE
; 1797 : 
; 1798 : 	size_type copy(_Elem *_Ptr,
; 1799 : 		size_type _Count, size_type _Off = 0) const
; 1800 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1801 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1802 : 		if (_Count != 0)
; 1803 : 			_DEBUG_POINTER(_Ptr);
; 1804 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1805 : 
; 1806 : 		if (this->_Mysize < _Off)
; 1807 : 			_Xran();	// _Off off end
; 1808 : 		if (this->_Mysize - _Off < _Count)
; 1809 : 			_Count = this->_Mysize - _Off;
; 1810 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1811 : 		return (_Count);
; 1812 : 		}
; 1813 : 
; 1814 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1815 : 		size_type _Count, size_type _Off = 0) const
; 1816 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1817 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1818 : 		if (_Count != 0)
; 1819 : 			_DEBUG_POINTER(_Dest);
; 1820 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1821 : 
; 1822 : 		if (this->_Mysize < _Off)
; 1823 : 			_Xran();	// _Off off end
; 1824 : 		if (this->_Mysize - _Off < _Count)
; 1825 : 			_Count = this->_Mysize - _Off;
; 1826 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1827 : 		return (_Count);
; 1828 : 		}
; 1829 : 
; 1830 : 	void _Swap_bx(_Myt& _Right)
; 1831 : 		{	// exchange _Bx with _Right._Bx
; 1832 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1833 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1834 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1835 : 			else
; 1836 : 				{	// swap large with small
; 1837 : 				pointer _Ptr = this->_Bx._Ptr;
; 1838 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1839 : 				_Traits::copy(this->_Bx._Buf,
; 1840 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1841 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1842 : 				}
; 1843 : 		else
; 1844 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1845 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1846 : 			else
; 1847 : 				{	// swap small with large
; 1848 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1849 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1850 : 				_Traits::copy(_Right._Bx._Buf,
; 1851 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1852 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1853 : 				}
; 1854 : 		}
; 1855 : 
; 1856 : 	void swap(_Myt& _Right)
; 1857 : 		{	// exchange contents with _Right
; 1858 : 		if (this == &_Right)
; 1859 : 			;	// same object, do nothing
; 1860 : 		else if (this->_Getal() == _Right._Getal())
; 1861 : 			{	// same allocator, swap control information
; 1862 : 			this->_Swap_all(_Right);
; 1863 : 			_Swap_bx(_Right);
; 1864 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1865 : 			_STD swap(this->_Myres, _Right._Myres);
; 1866 : 			}
; 1867 : 
; 1868 : 		else if (_Alty::propagate_on_container_swap::value)
; 1869 : 			{	// swap allocators and control information
; 1870 : 			this->_Swap_alloc(_Right);
; 1871 : 			_Swap_bx(_Right);
; 1872 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1873 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1874 : 			_STD swap(this->_Myres, _Right._Myres);
; 1875 : 			}
; 1876 : 
; 1877 : 		else
; 1878 : 			{	// different allocator, do multiple assigns
; 1879 : 			_Myt _Tmp = *this;
; 1880 : 
; 1881 : 			*this = _Right;
; 1882 : 			_Right = _Tmp;
; 1883 : 			}
; 1884 : 		}
; 1885 : 
; 1886 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1887 : 		{	// look for _Right beginning at or after _Off
; 1888 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr,
; 1892 : 		size_type _Off, size_type _Count) const
; 1893 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1894 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1895 : 		if (_Count != 0)
; 1896 : 			_DEBUG_POINTER(_Ptr);
; 1897 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1898 : 
; 1899 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1900 : 			return (_Off);	// null string always matches (if inside string)
; 1901 : 
; 1902 : 		size_type _Nm;
; 1903 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1904 : 			{	// room for match, look for it
; 1905 : 			const _Elem *_Uptr, *_Vptr;
; 1906 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1907 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1908 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1909 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1910 : 					return (_Uptr - this->_Myptr());	// found a match
; 1911 : 			}
; 1912 : 
; 1913 : 		return (npos);	// no match
; 1914 : 		}
; 1915 : 
; 1916 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1917 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1918 : 		_DEBUG_POINTER(_Ptr);
; 1919 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1920 : 		}
; 1921 : 
; 1922 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1923 : 		{	// look for _Ch at or after _Off
; 1924 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1925 : 		}
; 1926 : 
; 1927 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1928 : 		{	// look for _Right beginning before _Off
; 1929 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1930 : 		}
; 1931 : 
; 1932 : 	size_type rfind(const _Elem *_Ptr,
; 1933 : 		size_type _Off, size_type _Count) const
; 1934 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1935 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1936 : 		if (_Count != 0)
; 1937 : 			_DEBUG_POINTER(_Ptr);
; 1938 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1939 : 
; 1940 : 		if (_Count == 0)
; 1941 : 			return (_Off < this->_Mysize ? _Off
; 1942 : 				: this->_Mysize);	// null always matches
; 1943 : 		if (_Count <= this->_Mysize)
; 1944 : 			{	// room for match, look for it
; 1945 : 			const _Elem *_Uptr = this->_Myptr() +
; 1946 : 				(_Off < this->_Mysize - _Count ? _Off
; 1947 : 					: this->_Mysize - _Count);
; 1948 : 			for (; ; --_Uptr)
; 1949 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1950 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1951 : 					return (_Uptr - this->_Myptr());	// found a match
; 1952 : 				else if (_Uptr == this->_Myptr())
; 1953 : 					break;	// at beginning, no more chance for match
; 1954 : 			}
; 1955 : 
; 1956 : 		return (npos);	// no match
; 1957 : 		}
; 1958 : 
; 1959 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1960 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1961 : 		_DEBUG_POINTER(_Ptr);
; 1962 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1963 : 		}
; 1964 : 
; 1965 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1966 : 		{	// look for _Ch before _Off
; 1967 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(const _Myt& _Right,
; 1971 : 		size_type _Off = 0) const _NOEXCEPT
; 1972 : 		{	// look for one of _Right at or after _Off
; 1973 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_first_of(const _Elem *_Ptr,
; 1977 : 		size_type _Off, size_type _Count) const
; 1978 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1979 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1980 : 		if (_Count != 0)
; 1981 : 			_DEBUG_POINTER(_Ptr);
; 1982 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1983 : 
; 1984 : 		if (0 < _Count && _Off < this->_Mysize)
; 1985 : 			{	// room for match, look for it
; 1986 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1987 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1988 : 				_Uptr < _Vptr; ++_Uptr)
; 1989 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1990 : 					return (_Uptr - this->_Myptr());	// found a match
; 1991 : 			}
; 1992 : 
; 1993 : 		return (npos);	// no match
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_first_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off = 0) const
; 1998 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1999 : 		_DEBUG_POINTER(_Ptr);
; 2000 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2001 : 		}
; 2002 : 
; 2003 : 	size_type find_first_of(_Elem _Ch,
; 2004 : 		size_type _Off = 0) const
; 2005 : 		{	// look for _Ch at or after _Off
; 2006 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 2007 : 		}
; 2008 : 
; 2009 : 	size_type find_last_of(const _Myt& _Right,
; 2010 : 		size_type _Off = npos) const _NOEXCEPT
; 2011 : 		{	// look for one of _Right before _Off
; 2012 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 2013 : 		}
; 2014 : 
; 2015 : 	size_type find_last_of(const _Elem *_Ptr,
; 2016 : 		size_type _Off, size_type _Count) const
; 2017 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 2018 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2019 : 		if (_Count != 0)
; 2020 : 			_DEBUG_POINTER(_Ptr);
; 2021 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2022 : 
; 2023 : 		if (0 < _Count && 0 < this->_Mysize)
; 2024 : 			{	// worth searching, do it
; 2025 : 			const _Elem *_Uptr = this->_Myptr()
; 2026 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2027 : 			for (; ; --_Uptr)
; 2028 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2029 : 					return (_Uptr - this->_Myptr());	// found a match
; 2030 : 				else if (_Uptr == this->_Myptr())
; 2031 : 					break;	// at beginning, no more chance for match
; 2032 : 			}
; 2033 : 
; 2034 : 		return (npos);	// no match
; 2035 : 		}
; 2036 : 
; 2037 : 	size_type find_last_of(const _Elem *_Ptr,
; 2038 : 		size_type _Off = npos) const
; 2039 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2040 : 		_DEBUG_POINTER(_Ptr);
; 2041 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2042 : 		}
; 2043 : 
; 2044 : 	size_type find_last_of(_Elem _Ch,
; 2045 : 		size_type _Off = npos) const
; 2046 : 		{	// look for _Ch before _Off
; 2047 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2048 : 		}
; 2049 : 
; 2050 : 	size_type find_first_not_of(const _Myt& _Right,
; 2051 : 		size_type _Off = 0) const _NOEXCEPT
; 2052 : 		{	// look for none of _Right at or after _Off
; 2053 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2054 : 			_Right.size()));
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off, size_type _Count) const
; 2059 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2060 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2061 : 		if (_Count != 0)
; 2062 : 			_DEBUG_POINTER(_Ptr);
; 2063 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2064 : 
; 2065 : 		if (_Off < this->_Mysize)
; 2066 : 			{	// room for match, look for it
; 2067 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2068 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2069 : 				_Uptr < _Vptr; ++_Uptr)
; 2070 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2071 : 					return (_Uptr - this->_Myptr());
; 2072 : 			}
; 2073 : 		return (npos);
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off = 0) const
; 2078 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2079 : 		_DEBUG_POINTER(_Ptr);
; 2080 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2081 : 		}
; 2082 : 
; 2083 : 	size_type find_first_not_of(_Elem _Ch,
; 2084 : 		size_type _Off = 0) const
; 2085 : 		{	// look for non _Ch at or after _Off
; 2086 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2087 : 		}
; 2088 : 
; 2089 : 	size_type find_last_not_of(const _Myt& _Right,
; 2090 : 		size_type _Off = npos) const _NOEXCEPT
; 2091 : 		{	// look for none of _Right before _Off
; 2092 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2093 : 		}
; 2094 : 
; 2095 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2096 : 		size_type _Off, size_type _Count) const
; 2097 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2098 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2099 : 		if (_Count != 0)
; 2100 : 			_DEBUG_POINTER(_Ptr);
; 2101 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2102 : 
; 2103 : 		if (0 < this->_Mysize)
; 2104 : 			{	// worth searching, do it
; 2105 : 			const _Elem *_Uptr = this->_Myptr()
; 2106 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2107 : 			for (; ; --_Uptr)
; 2108 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2109 : 					return (_Uptr - this->_Myptr());
; 2110 : 				else if (_Uptr == this->_Myptr())
; 2111 : 					break;
; 2112 : 			}
; 2113 : 		return (npos);
; 2114 : 		}
; 2115 : 
; 2116 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2117 : 		size_type _Off = npos) const
; 2118 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2119 : 		_DEBUG_POINTER(_Ptr);
; 2120 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2121 : 		}
; 2122 : 
; 2123 : 	size_type find_last_not_of(_Elem _Ch,
; 2124 : 		size_type _Off = npos) const
; 2125 : 		{	// look for non _Ch before _Off
; 2126 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2127 : 		}
; 2128 : 
; 2129 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2130 : 		{	// return [_Off, _Off + _Count) as new string
; 2131 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2132 : 		}
; 2133 : 
; 2134 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2135 : 		{	// compare [0, _Mysize) with _Right
; 2136 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2137 : 		}
; 2138 : 
; 2139 : 	int compare(size_type _Off, size_type _N0,
; 2140 : 		const _Myt& _Right) const
; 2141 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2142 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2143 : 		}
; 2144 : 
; 2145 : 	int compare(size_type _Off,
; 2146 : 		size_type _N0, const _Myt& _Right,
; 2147 : 		size_type _Roff, size_type _Count) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2149 : 		if (_Right.size() < _Roff)
; 2150 : 			_Xran();	// _Off off end
; 2151 : 		if (_Right._Mysize - _Roff < _Count)
; 2152 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2153 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2154 : 		}
; 2155 : 
; 2156 : 	int compare(const _Elem *_Ptr) const
; 2157 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2158 : 		_DEBUG_POINTER(_Ptr);
; 2159 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2160 : 		}
; 2161 : 
; 2162 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2163 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2164 : 		_DEBUG_POINTER(_Ptr);
; 2165 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2166 : 		}
; 2167 : 
; 2168 : 	int compare(size_type _Off,
; 2169 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2170 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2171 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2172 : 		if (_Count != 0)
; 2173 : 			_DEBUG_POINTER(_Ptr);
; 2174 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2175 : 
; 2176 : 		if (this->_Mysize < _Off)
; 2177 : 			_Xran();	// _Off off end
; 2178 : 		if (this->_Mysize - _Off < _N0)
; 2179 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2180 : 
; 2181 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2182 : 			_N0 < _Count ? _N0 : _Count);
; 2183 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2184 : 			: _N0 == _Count ? 0 : +1);
; 2185 : 		}
; 2186 : 
; 2187 : 	allocator_type get_allocator() const _NOEXCEPT
; 2188 : 		{	// return allocator object for values
; 2189 : 		return (this->_Getal());
; 2190 : 		}
; 2191 : 
; 2192 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2193 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2194 : 		if (_Count == 1)
; 2195 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2196 : 		else
; 2197 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2198 : 		}
; 2199 : 
; 2200 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2201 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2202 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2203 : 		if (max_size() < _Newres)
; 2204 : 			_Newres = _Newsize;	// undo roundup if too big
; 2205 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2206 : 			;
; 2207 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2208 : 			_Newres = this->_Myres
; 2209 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2210 : 		else
; 2211 : 			_Newres = max_size();	// settle for max_size()
; 2212 : 
; 2213 : 		_Elem *_Ptr;
; 2214 : 		_TRY_BEGIN
; 2215 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2216 : 		_CATCH_ALL
; 2217 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2218 : 			_TRY_BEGIN
; 2219 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2220 : 			_CATCH_ALL
; 2221 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2222 : 			_RERAISE;
; 2223 : 			_CATCH_END
; 2224 : 		_CATCH_END
; 2225 : 
; 2226 : 		if (0 < _Oldlen)
; 2227 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2228 : 				_Oldlen);	// copy existing elements
; 2229 : 		_Tidy(true);
; 2230 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2231 : 		this->_Myres = _Newres;
; 2232 : 		_Eos(_Oldlen);
; 2233 : 		}
; 2234 : 
; 2235 : 	void _Eos(size_type _Newsize)
; 2236 : 		{	// set new length and null terminator
; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T1[rsp+16], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T1[rsp], bl

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR drive$[rsp], bl
	jne	SHORT $LN50@ExtractFil
	mov	r8d, ebx
	jmp	SHORT $LN51@ExtractFil
$LN50@ExtractFil:
	lea	rax, QWORD PTR drive$[rsp]
	or	r8, -1
$LL100@ExtractFil:
	inc	r8
	cmp	BYTE PTR [rax+r8], bl
	jne	SHORT $LL100@ExtractFil
$LN51@ExtractFil:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, QWORD PTR drive$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR dir$[rsp], bl
	je	SHORT $LN59@ExtractFil
	lea	rax, QWORD PTR dir$[rsp]
	or	rbx, -1
$LL99@ExtractFil:
	inc	rbx
	cmp	BYTE PTR [rax+rbx], 0
	jne	SHORT $LL99@ExtractFil
$LN59@ExtractFil:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	lea	rdx, QWORD PTR dir$[rsp]
	lea	rcx, QWORD PTR $T1[rsp]
	mov	r8, rbx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::append

; 2285 : 		_Eos(_Newsize);
; 2286 : 		}
; 2287 : 
; 2288 : 	__declspec(noreturn) void _Xlen() const
; 2289 : 		{	// report a length_error
; 2290 : 		_Xlength_error("string too long");
; 2291 : 		}
; 2292 : 
; 2293 : 	__declspec(noreturn) void _Xran() const
; 2294 : 		{	// report an out_of_range error
; 2295 : 		_Xout_of_range("invalid string position");
; 2296 : 		}
; 2297 : 	};
; 2298 : 
; 2299 : 		// STATIC npos OBJECT
; 2300 : template<class _Elem,
; 2301 : 	class _Traits,
; 2302 : 	class _Alloc>
; 2303 : 	_PGLOBAL const typename basic_string<_Elem, _Traits, _Alloc>::size_type
; 2304 : 		basic_string<_Elem, _Traits, _Alloc>::npos =
; 2305 : 			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);
; 2306 : 
; 2307 : 		// basic_string TEMPLATE OPERATORS
; 2308 : 
; 2309 : template<class _Elem,
; 2310 : 	class _Traits,
; 2311 : 	class _Alloc> inline
; 2312 : 	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2313 : 		basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2314 : 	{	// swap _Left and _Right strings
; 2315 : 	_Left.swap(_Right);
; 2316 : 	}
; 2317 : 
; 2318 : template<class _Elem,
; 2319 : 	class _Traits,
; 2320 : 	class _Alloc> inline
; 2321 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2322 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2323 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2324 : 	{	// return string + string
; 2325 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2326 : 	_Ans.reserve(_Left.size() + _Right.size());
; 2327 : 	_Ans += _Left;
; 2328 : 	_Ans += _Right;
; 2329 : 	return (_Ans);
; 2330 : 	}
; 2331 : 
; 2332 : template<class _Elem,
; 2333 : 	class _Traits,
; 2334 : 	class _Alloc> inline
; 2335 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2336 : 		const _Elem *_Left,
; 2337 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2338 : 	{	// return NTCS + string
; 2339 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2340 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());
; 2341 : 	_Ans += _Left;
; 2342 : 	_Ans += _Right;
; 2343 : 	return (_Ans);
; 2344 : 	}
; 2345 : 
; 2346 : template<class _Elem,
; 2347 : 	class _Traits,
; 2348 : 	class _Alloc> inline
; 2349 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2350 : 		const _Elem _Left,
; 2351 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2352 : 	{	// return character + string
; 2353 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2354 : 	_Ans.reserve(1 + _Right.size());
; 2355 : 	_Ans += _Left;
; 2356 : 	_Ans += _Right;
; 2357 : 	return (_Ans);
; 2358 : 	}
; 2359 : 
; 2360 : template<class _Elem,
; 2361 : 	class _Traits,
; 2362 : 	class _Alloc> inline
; 2363 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2364 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2365 : 		const _Elem *_Right)
; 2366 : 	{	// return string + NTCS
; 2367 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2368 : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));
; 2369 : 	_Ans += _Left;
; 2370 : 	_Ans += _Right;
; 2371 : 	return (_Ans);
; 2372 : 	}
; 2373 : 
; 2374 : template<class _Elem,
; 2375 : 	class _Traits,
; 2376 : 	class _Alloc> inline
; 2377 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2378 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2379 : 		const _Elem _Right)
; 2380 : 	{	// return string + character
; 2381 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2382 : 	_Ans.reserve(_Left.size() + 1);
; 2383 : 	_Ans += _Left;
; 2384 : 	_Ans += _Right;
; 2385 : 	return (_Ans);
; 2386 : 	}
; 2387 : 
; 2388 : template<class _Elem,
; 2389 : 	class _Traits,
; 2390 : 	class _Alloc> inline
; 2391 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2392 : 		const basic_string<_Elem, _Traits, _Alloc>& _Left,
; 2393 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2394 : 	{	// return string + string
; 2395 : 	return (_STD move(_Right.insert(0, _Left)));
; 2396 : 	}
; 2397 : 
; 2398 : template<class _Elem,
; 2399 : 	class _Traits,
; 2400 : 	class _Alloc> inline
; 2401 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2402 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2403 : 		const basic_string<_Elem, _Traits, _Alloc>& _Right)
; 2404 : 	{	// return string + string
; 2405 : 	return (_STD move(_Left.append(_Right)));
; 2406 : 	}
; 2407 : 
; 2408 : template<class _Elem,
; 2409 : 	class _Traits,
; 2410 : 	class _Alloc> inline
; 2411 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2412 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2413 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2414 : 	{	// return string + string
; 2415 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 2416 : 		|| _Right.capacity() - _Right.size() < _Left.size())
; 2417 : 		return (_STD move(_Left.append(_Right)));
; 2418 : 	else
; 2419 : 		return (_STD move(_Right.insert(0, _Left)));
; 2420 : 	}
; 2421 : 
; 2422 : template<class _Elem,
; 2423 : 	class _Traits,
; 2424 : 	class _Alloc> inline
; 2425 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2426 : 		const _Elem *_Left,
; 2427 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2428 : 	{	// return NTCS + string
; 2429 : 	return (_STD move(_Right.insert(0, _Left)));
; 2430 : 	}
; 2431 : 
; 2432 : template<class _Elem,
; 2433 : 	class _Traits,
; 2434 : 	class _Alloc> inline
; 2435 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2436 : 		const _Elem _Left,
; 2437 : 		basic_string<_Elem, _Traits, _Alloc>&& _Right)
; 2438 : 	{	// return character + string
; 2439 : 	return (_STD move(_Right.insert(0, 1, _Left)));
; 2440 : 	}
; 2441 : 
; 2442 : template<class _Elem,
; 2443 : 	class _Traits,
; 2444 : 	class _Alloc> inline
; 2445 : 	basic_string<_Elem, _Traits, _Alloc> operator+(
; 2446 : 		basic_string<_Elem, _Traits, _Alloc>&& _Left,
; 2447 : 		const _Elem *_Right)
; 2448 : 	{	// return string + NTCS
; 2449 : 	return (_STD move(_Left.append(_Right)));

	mov	rcx, rdi
	mov	rdx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::basic_string<char,std::char_traits<char>,xalloc<char> >

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T1[rsp+24], 16
	jb	SHORT $LN102@ExtractFil
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR p$2[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rax, rax
	je	SHORT $LN102@ExtractFil
	lea	rcx, QWORD PTR p$2[rsp]
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
$LN102@ExtractFil:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 39   :     return xr_string(drive)+dir;

	mov	rax, rdi

; 40   : }

	mov	rbx, QWORD PTR [rsp+1152]
	add	rsp, 1136				; 00000470H
	pop	rdi
	ret	0
?ExtractFilePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD@Z ENDP ; EFS_Utils::ExtractFilePath
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
full_path$ = 64
excl_path$ = 72
?ExcludeBasePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z PROC ; EFS_Utils::ExcludeBasePath

; 43   : {

$LN109:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 44   :     LPCSTR sub		= strstr(full_path,excl_path);

	mov	rcx, r8
	mov	rdx, r9
	mov	rsi, r9
	mov	rdi, r8
	call	QWORD PTR __imp_strstr

; 45   : 	if (0!=sub) 	return xr_string(sub+xr_strlen(excl_path));

	test	rax, rax
	je	SHORT $LN2@ExcludeBas
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rcx, -1
	npad	3
$LL107@ExcludeBas:
	inc	rcx
	cmp	BYTE PTR [rsi+rcx], 0
	jne	SHORT $LL107@ExcludeBas
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	r8d, r8d

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 45   : 	if (0!=sub) 	return xr_string(sub+xr_strlen(excl_path));

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 45   : 	if (0!=sub) 	return xr_string(sub+xr_strlen(excl_path));

	add	rdx, rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], r8b

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rdx], r8b
	je	SHORT $LN55@ExcludeBas
	or	r8, -1
	npad	7
$LL106@ExcludeBas:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL106@ExcludeBas
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 45   : 	if (0!=sub) 	return xr_string(sub+xr_strlen(excl_path));

	jmp	SHORT $LN55@ExcludeBas
$LN2@ExcludeBas:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	r8d, r8d

; 2238 : 		}
; 2239 : 
; 2240 : 	bool _Grow(size_type _Newsize,
; 2241 : 		bool _Trim = false)
; 2242 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2243 : 		if (max_size() < _Newsize)
; 2244 : 			_Xlen();	// result too long
; 2245 : 		if (this->_Myres < _Newsize)
; 2246 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2247 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2248 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2249 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2250 : 		else if (_Newsize == 0)
; 2251 : 			_Eos(0);	// new size is zero, just null terminate
; 2252 : 		return (0 < _Newsize);	// return true only if more work to do
; 2253 : 		}
; 2254 : 
; 2255 : 	bool _Inside(const _Elem *_Ptr)
; 2256 : 		{	// test if _Ptr points inside string
; 2257 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2258 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2259 : 			return (false);	// don't ask
; 2260 : 		else
; 2261 : 			return (true);
; 2262 : 		}
; 2263 : 
; 2264 : 	static size_type _Pdif(const_iterator _P2,
; 2265 : 		const_iterator _P1)
; 2266 : 		{	// compute safe iterator difference
; 2267 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2268 : 		}
; 2269 : 
; 2270 : 	void _Tidy(bool _Built = false,
; 2271 : 		size_type _Newsize = 0)
; 2272 : 		{	// initialize buffer, deallocating any storage
; 2273 : 		if (!_Built)
; 2274 : 			;
; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2276 : 			{	// copy any leftovers to small buffer and deallocate
; 2277 : 			pointer _Ptr = this->_Bx._Ptr;
; 2278 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2279 : 			if (0 < _Newsize)
; 2280 : 				_Traits::copy(this->_Bx._Buf,
; 2281 : 					_STD addressof(*_Ptr), _Newsize);
; 2282 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2283 : 			}
; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rbx+16], r8
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rbx], r8b

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rdi], r8b
	je	SHORT $LN104@ExcludeBas
	or	r8, -1
	npad	9
$LL105@ExcludeBas:
	inc	r8
	cmp	BYTE PTR [rdi+r8], 0
	jne	SHORT $LL105@ExcludeBas
$LN104@ExcludeBas:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	rdx, rdi
$LN55@ExcludeBas:
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 47   : }

	mov	rsi, QWORD PTR [rsp+56]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?ExcludeBasePath@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z ENDP ; EFS_Utils::ExcludeBasePath
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
$T1 = 32
this$ = 96
p$2 = 104
__$ReturnUdt$ = 104
src$ = 112
ext$ = 120
?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z PROC ; EFS_Utils::ChangeFileExt

; 50   : {

$LN156:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 64					; 00000040H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	xor	ebx, ebx

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 50   : {

	mov	r14, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rdx+16], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR [rdx], bl
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 267  : {	return (char*) strrchr(S,'.');	}

	lea	edx, QWORD PTR [rbx+46]
	mov	rcx, r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 50   : {

	mov	rsi, r9
	mov	rdi, r8
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 267  : {	return (char*) strrchr(S,'.');	}

	call	QWORD PTR __imp_strrchr
	mov	rbp, rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 53   :     if (src_ext){

	test	rax, rax
	je	SHORT $LN2@ChangeFile

; 54   : 	    size_t		ext_pos	= src_ext-src;

	sub	rbp, rdi
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2284 : 		this->_Myres = this->_BUF_SIZE - 1;

	mov	QWORD PTR $T1[rsp+24], 15

; 2237 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

	mov	QWORD PTR $T1[rsp+16], rbx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

	mov	BYTE PTR $T1[rsp], bl

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rdi], bl
	jne	SHORT $LN97@ChangeFile
	mov	r8d, ebx
	jmp	SHORT $LN98@ChangeFile
$LN97@ChangeFile:
	or	r8, -1
$LL154@ChangeFile:
	inc	r8
	cmp	BYTE PTR [rdi+r8], bl
	jne	SHORT $LL154@ChangeFile
$LN98@ChangeFile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	lea	rcx, QWORD PTR $T1[rsp]
	mov	rdx, rdi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 55   :         tmp.assign	(src,0,ext_pos);

	lea	rdx, QWORD PTR $T1[rsp]
	mov	r9, rbp
	xor	r8d, r8d
	mov	rcx, r14
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2275 : 		else if (this->_BUF_SIZE <= this->_Myres)

	cmp	QWORD PTR $T1[rsp+24], 16
	jb	SHORT $LN136@ChangeFile
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xmemory0

; 858  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR p$2[rsp], rax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrmemory.h

; 109  : 	IC void		xr_free		(T* &P)					{	if (P) { Memory.mem_free((void*)P); P=NULL;	};	}

	test	rax, rax
	je	SHORT $LN136@ChangeFile
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 56   :     }else{

	lea	rcx, QWORD PTR p$2[rsp]
	call	??$xr_free@D@@YAXAEAPEAD@Z		; xr_free<char>
	jmp	SHORT $LN136@ChangeFile
$LN2@ChangeFile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rdi], bl
	jne	SHORT $LN142@ChangeFile
	mov	r8, rbx
	jmp	SHORT $LN143@ChangeFile
$LN142@ChangeFile:
	or	r8, -1
	npad	6
$LL153@ChangeFile:
	inc	r8
	cmp	BYTE PTR [rdi+r8], bl
	jne	SHORT $LL153@ChangeFile
$LN143@ChangeFile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1169 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	rdx, rdi
	mov	rcx, r14
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::assign
$LN136@ChangeFile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [rsi], bl
	je	SHORT $LN151@ChangeFile
	or	rbx, -1
	npad	4
$LL152@ChangeFile:
	inc	rbx
	cmp	BYTE PTR [rsi+rbx], 0
	jne	SHORT $LL152@ChangeFile
$LN151@ChangeFile:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	r8, rbx
	mov	rdx, rsi
	mov	rcx, r14
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::append
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 61   : }

	mov	rbx, QWORD PTR [rsp+96]
	mov	rbp, QWORD PTR [rsp+112]
	mov	rax, r14
	add	rsp, 64					; 00000040H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z ENDP ; EFS_Utils::ChangeFileExt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
src$ = 64
ext$ = 72
?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@AEBV23@PEBD@Z PROC ; EFS_Utils::ChangeFileExt

; 64   : {

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	cmp	QWORD PTR [r8+24], 16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 64   : {

	mov	rbx, rdx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 520  : 			: this->_Bx._Buf);

	jb	SHORT $LN7@ChangeFile
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstddef

; 95   : 		reinterpret_cast<const volatile char&>(_Val)))));

	mov	r8, QWORD PTR [r8]
$LN7@ChangeFile:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 65   : 	return ChangeFileExt(src.c_str(),ext);

	call	?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEBD0@Z ; EFS_Utils::ChangeFileExt
	mov	rax, rbx

; 66   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?ChangeFileExt@EFS_Utils@@QEAA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@AEBV23@PEBD@Z ENDP ; EFS_Utils::ChangeFileExt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
buf$1 = 48
dest$ = 160
info$ = 168
ext$ = 176
?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z PROC		; MakeFilter

; 70   : {

$LN101:
	mov	QWORD PTR [rsp+32], rbp
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 112				; 00000070H
	mov	r14, rdx
	mov	r12, rcx

; 71   : 	ZeroMemory(dest,sizeof(dest));
; 72   :     if (ext){
; 73   :         int icnt=_GetItemCount(ext,';');

	mov	dl, 59					; 0000003bH
	mov	rcx, r8
	mov	r15, r8
	call	?_GetItemCount@@YAHPEBDD@Z		; _GetItemCount

; 74   : 		LPSTR dst=dest;

	mov	rsi, r12
	mov	r13d, eax

; 75   :         if (icnt>1)

	lea	rax, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ?$AA@
	cmp	r13d, 1
	jle	SHORT $LN4@MakeFilter

; 76   : 		{
; 77   :             strconcat		(sizeof(dest),dst,info," (",ext,")");

	mov	QWORD PTR [rsp+40], rax
	lea	r9, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI?$AA@
	mov	r8, r14
	mov	rdx, r12
	mov	ecx, 1024				; 00000400H
	mov	QWORD PTR [rsp+32], r15
	call	?strconcat@@YAPEBDHPEADPEBD111@Z	; strconcat
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
$LL97@MakeFilter:
	cmp	BYTE PTR [r12+rax+1], 0
	lea	rax, QWORD PTR [rax+1]
	jne	SHORT $LL97@MakeFilter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 79   :             strcpy			(dst,ext);

	lea	esi, DWORD PTR [rax+1]
	mov	rcx, r15
	add	rsi, r12
	mov	rdx, rsi
	sub	rdx, r15
	npad	3
$LL8@MakeFilter:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx+rcx-1], al
	test	al, al
	jne	SHORT $LL8@MakeFilter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
$LL96@MakeFilter:
	inc	rax
	cmp	BYTE PTR [r15+rax], 0
	jne	SHORT $LL96@MakeFilter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 80   :             dst				+= (xr_strlen(ext)+1);

	inc	eax
	add	rsi, rax
$LN4@MakeFilter:

; 82   :         for (int i=0; i<icnt; i++)

	xor	ebp, ebp
	test	r13d, r13d
	jle	$LN98@MakeFilter
	mov	QWORD PTR [rsp+168], rbx
	lea	r12, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	QWORD PTR [rsp+176], rdi
$LL3@MakeFilter:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 33   : 	u32		p			= 0;

	xor	edi, edi
	mov	rbx, r15

; 34   : 	while( (p<pos) && (0!=(res=strchr(res,separator))) )

	test	ebp, ebp
	je	SHORT $LN23@MakeFilter
	npad	3
$LL24@MakeFilter:
	mov	edx, 59					; 0000003bH
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN19@MakeFilter

; 35   : 	{
; 36   : 		res		++;
; 37   : 		p		++;

	inc	edi
	inc	rbx
	cmp	edi, ebp
	jb	SHORT $LL24@MakeFilter
$LN23@MakeFilter:

; 52   : 
; 53   : int	_GetItemCount ( LPCSTR src, char separator )
; 54   : {
; 55   : 	u32		cnt			= 0;
; 56   : 	if (src&&src[0]){
; 57   : 		LPCSTR	res			= src;
; 58   : 		LPCSTR	last_res	= res;
; 59   : 		while( 0!=(res=strchr(res,separator)) )
; 60   : 		{
; 61   : 			res		++;
; 62   : 			last_res=res;
; 63   : 			cnt		++;
; 64   : 			if (res[0]==separator) break;
; 65   : 		}
; 66   : 		if (xr_strlen(last_res)) cnt++;
; 67   : 	}
; 68   : 	return		cnt;
; 69   : }
; 70   : 
; 71   : LPSTR _GetItem ( LPCSTR src, int index, LPSTR dst, char separator, LPCSTR def, bool trim )
; 72   : {
; 73   : 	LPCSTR	ptr;
; 74   : 	ptr			= _SetPos	( src, index, separator );
; 75   : 	if( ptr )	_CopyVal	( ptr, dst, separator );

	test	rbx, rbx
	je	SHORT $LN19@MakeFilter

; 38   : 	}
; 39   : 	return		res;
; 40   : }
; 41   : 
; 42   : LPCSTR _CopyVal ( LPCSTR src, LPSTR dst, char separator )
; 43   : {
; 44   : 	LPCSTR	p;
; 45   : 	size_t	n;
; 46   : 	p			= strchr	( src, separator );

	mov	edx, 59					; 0000003bH
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rdi, rax

; 47   : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	test	rax, rax
	je	SHORT $LN29@MakeFilter
	sub	rdi, rbx
	jmp	SHORT $LN30@MakeFilter
$LN29@MakeFilter:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
$LL95@MakeFilter:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL95@MakeFilter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 47   : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	mov	edi, eax
$LN30@MakeFilter:

; 48   : 	strncpy		( dst, src, n );

	lea	rcx, QWORD PTR buf$1[rsp]
	mov	r8, rdi
	mov	rdx, rbx
	call	QWORD PTR __imp_strncpy

; 49   : 	dst[n]		= 0;

	mov	BYTE PTR buf$1[rsp+rdi], 0

; 50   : 	return		dst;
; 51   : }

	jmp	SHORT $LN18@MakeFilter
$LN19@MakeFilter:

; 76   : 		else	strcpy		( dst, def );

	xor	ecx, ecx
	npad	8
$LL22@MakeFilter:
	movzx	eax, BYTE PTR [rcx+r12]
	inc	rcx
	mov	BYTE PTR buf$1[rsp+rcx-1], al
	test	al, al
	jne	SHORT $LL22@MakeFilter
$LN18@MakeFilter:

; 7    : 	while( *p && (u8(*p)<=u8(' ')) ) p++;

	movzx	ecx, BYTE PTR buf$1[rsp]
	lea	rax, QWORD PTR buf$1[rsp]
	test	cl, cl
	je	SHORT $LN38@MakeFilter
	npad	2
$LL40@MakeFilter:
	cmp	cl, 32					; 00000020H
	ja	SHORT $LN39@MakeFilter
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL40@MakeFilter
$LN39@MakeFilter:

; 8    :     if (p!=str){

	lea	rcx, QWORD PTR buf$1[rsp]
	cmp	rax, rcx
	je	SHORT $LN38@MakeFilter

; 9    :         for (LPSTR t=str; *p; t++,p++) *t=*p;

	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR buf$1[rsp]
	test	dl, dl
	je	SHORT $LN35@MakeFilter
	lea	r8, QWORD PTR buf$1[rsp]
	sub	rax, r8
	npad	2
$LL37@MakeFilter:
	mov	BYTE PTR [rcx], dl
	movzx	edx, BYTE PTR [rax+rcx+1]
	inc	rcx
	test	dl, dl
	jne	SHORT $LL37@MakeFilter
$LN35@MakeFilter:

; 10   :         *t = 0;

	mov	BYTE PTR [rcx], 0
$LN38@MakeFilter:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR buf$1[rsp]
	or	rax, -1
	npad	6
$LL94@MakeFilter:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL94@MakeFilter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 17   : 	LPSTR p 	= str+xr_strlen(str);

	mov	eax, eax
	lea	rcx, QWORD PTR buf$1[rsp]
	add	rcx, rax

; 18   : 	while( (p!=str) && (u8(*p)<=u8(' ')) ) p--;

	lea	rax, QWORD PTR buf$1[rsp]
	cmp	rcx, rax
	je	SHORT $LN99@MakeFilter
	npad	3
$LL44@MakeFilter:
	cmp	BYTE PTR [rcx], 32			; 00000020H
	ja	SHORT $LN99@MakeFilter
	lea	rax, QWORD PTR buf$1[rsp]
	dec	rcx
	cmp	rcx, rax
	jne	SHORT $LL44@MakeFilter
$LN99@MakeFilter:

; 19   :     *(++p) 		= 0;

	mov	BYTE PTR [rcx+1], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rbx, -1
	npad	6
$LL93@MakeFilter:
	inc	rbx
	cmp	BYTE PTR [r14+rbx], 0
	jne	SHORT $LL93@MakeFilter
	lea	rax, QWORD PTR buf$1[rsp]
	or	rdi, -1
$LL92@MakeFilter:
	inc	rdi
	cmp	BYTE PTR [rax+rdi], 0
	jne	SHORT $LL92@MakeFilter

; 198  : 	strcpy_s(dest,dest_sz,S1);

	mov	r8, r14
	mov	edx, 1024				; 00000400H
	mov	rcx, rsi
	call	QWORD PTR __imp_strcpy_s

; 199  : 	strcat_s(dest,dest_sz-l1,S2);

	mov	edx, 1024				; 00000400H
	lea	r8, OFFSET FLAT:??_C@_02GFKOMOKH@?5?$CI?$AA@
	sub	edx, ebx
	mov	rcx, rsi
	call	QWORD PTR __imp_strcat_s

; 200  : 	strcat_s(dest,dest_sz-l1-l2,S3);

	mov	edx, 1022				; 000003feH
	lea	r8, QWORD PTR buf$1[rsp]
	sub	edx, ebx
	mov	rcx, rsi
	call	QWORD PTR __imp_strcat_s

; 201  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);

	mov	edx, 1022				; 000003feH
	lea	r8, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ?$AA@
	sub	edx, edi
	mov	rcx, rsi
	sub	edx, ebx
	call	QWORD PTR __imp_strcat_s

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
$LL91@MakeFilter:
	inc	rax
	cmp	BYTE PTR [rsi+rax], 0
	jne	SHORT $LL91@MakeFilter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 88   :             strcpy			(dst, buf);

	inc	eax
	lea	rcx, QWORD PTR buf$1[rsp]
	add	rsi, rax
	lea	rax, QWORD PTR buf$1[rsp]
	mov	rdx, rsi
	sub	rdx, rax
	npad	12
$LL9@MakeFilter:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx+rcx-1], al
	test	al, al
	jne	SHORT $LL9@MakeFilter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR buf$1[rsp]
	or	rax, -1
	npad	8
$LL90@MakeFilter:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL90@MakeFilter
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 82   :         for (int i=0; i<icnt; i++)

	inc	eax
	inc	ebp

; 89   :             dst				+= (xr_strlen(buf)+1);

	add	rsi, rax
	cmp	ebp, r13d
	jl	$LL3@MakeFilter

; 90   :         }
; 91   :     }
; 92   : 	return dest;

	mov	rax, QWORD PTR dest$[rsp]
	mov	rdi, QWORD PTR [rsp+176]
	mov	rbx, QWORD PTR [rsp+168]
	jmp	SHORT $LN1@MakeFilter
$LN98@MakeFilter:
	mov	rax, r12
$LN1@MakeFilter:

; 93   : }

	mov	rbp, QWORD PTR [rsp+184]
	add	rsp, 112				; 00000070H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	ret	0
?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z ENDP		; MakeFilter
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
buf$1 = 48
ofn$ = 112
dir$2 = 272
path$ = 336
dr$3 = 848
flt$ = 1376
fns$4 = 2400
this$ = 6544
initial$ = 6552
buffer$ = 6560
sz_buf$ = 6568
bMulti$ = 6576
offset$ = 6584
start_flt_ext$ = 6592
?GetOpenName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@DH_N0H@Z PROC ; EFS_Utils::GetOpenName

; 99   : {

$LN430:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	mov	QWORD PTR [rsp+24], rdi
	push	rbp
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rsp-6240]
	mov	eax, 6496				; 00001960H
	call	__chkstk
	sub	rsp, rax

; 100  : 	VERIFY(buffer&&(sz_buf>0));
; 101  : 	FS_Path& P			= *FS.get_path(initial);

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	mov	r14d, r9d
	mov	r15, r8
	call	?get_path@CLocatorAPI@@QEAAPEAVFS_Path@@PEBD@Z ; CLocatorAPI::get_path

; 102  : 	string1024 flt;
; 103  : 	MakeFilter(flt,P.m_FilterCaption?P.m_FilterCaption:"",P.m_DefExt);

	lea	r13, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 71   : 	ZeroMemory(dest,sizeof(dest));

	mov	r8d, 1024				; 00000400H

; 102  : 	string1024 flt;
; 103  : 	MakeFilter(flt,P.m_FilterCaption?P.m_FilterCaption:"",P.m_DefExt);

	mov	rcx, QWORD PTR [rax+32]
	mov	rsi, QWORD PTR [rax+24]
	mov	rdi, r13
	test	rcx, rcx
	mov	rbx, rax
	cmovne	rdi, rcx

; 71   : 	ZeroMemory(dest,sizeof(dest));

	lea	rcx, QWORD PTR flt$[rbp-256]
	xor	edx, edx
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16

; 72   :     if (ext){

	test	rsi, rsi
	je	SHORT $LN31@GetOpenNam
	lea	rcx, QWORD PTR flt$[rbp-256]
	mov	r8, rsi
	mov	rdx, rdi
	call	?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z	; MakeFilter
$LN31@GetOpenNam:

; 104  : 
; 105  : 	OPENFILENAME ofn;
; 106  : 	Memory.mem_fill		( &ofn, 0, sizeof(ofn) );

	lea	rcx, QWORD PTR ofn$[rsp]
	xor	edx, edx
	mov	r8d, 152				; 00000098H
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
	npad	2
$LL426@GetOpenNam:
	inc	rax
	cmp	BYTE PTR [r15+rax], 0
	jne	SHORT $LL426@GetOpenNam
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 107  :     if (xr_strlen(buffer)){ 

	test	eax, eax
	je	SHORT $LN10@GetOpenNam

; 108  :         string_path		dr;
; 109  :         if (!(buffer[0]=='\\' && buffer[1]=='\\')){ // if !network

	cmp	BYTE PTR [r15], 92			; 0000005cH
	jne	SHORT $LN11@GetOpenNam
	cmp	BYTE PTR [r15+1], 92			; 0000005cH
	je	SHORT $LN10@GetOpenNam
$LN11@GetOpenNam:

; 110  :             _splitpath		(buffer,dr,0,0,0);

	lea	rdx, QWORD PTR dr$3[rbp-256]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rcx, r15
	mov	QWORD PTR [rsp+32], 0
	call	QWORD PTR __imp__splitpath

; 111  :             if (0==dr[0])	P._update(buffer,buffer); 

	cmp	BYTE PTR dr$3[rbp-256], 0
	jne	SHORT $LN10@GetOpenNam
	mov	r8, r15
	mov	rdx, r15
	mov	rcx, rbx
	call	?_update@FS_Path@@QEBAPEBDAEAY0CAI@DPEBD@Z ; FS_Path::_update
$LN10@GetOpenNam:

; 112  :         }
; 113  :     }
; 114  :     ofn.lStructSize		= sizeof(OPENFILENAME);

	mov	DWORD PTR ofn$[rsp], 152		; 00000098H

; 115  : 	ofn.hwndOwner 		= GetForegroundWindow();

	call	QWORD PTR __imp_GetForegroundWindow

; 116  : 	ofn.lpstrDefExt 	= P.m_DefExt;
; 117  : 	ofn.lpstrFile 		= buffer;
; 118  : 	ofn.nMaxFile 		= sz_buf;
; 119  : 	ofn.lpstrFilter 	= flt;
; 120  : 	ofn.nFilterIndex 	= start_flt_ext+2;
; 121  :     ofn.lpstrTitle      = "Open a File";
; 122  :     string512 path; 
; 123  : 	strcpy				(path,(offset&&offset[0])?offset:P.m_Path);

	mov	rcx, QWORD PTR offset$[rbp-256]
	mov	QWORD PTR ofn$[rsp+8], rax
	mov	rax, QWORD PTR [rbx+24]
	mov	QWORD PTR ofn$[rbp-208], r15
	mov	QWORD PTR ofn$[rbp-152], rax
	lea	rax, QWORD PTR flt$[rbp-256]
	mov	DWORD PTR ofn$[rbp-200], r14d
	mov	QWORD PTR ofn$[rbp-232], rax
	mov	eax, DWORD PTR start_flt_ext$[rbp-256]
	add	eax, 2
	mov	DWORD PTR ofn$[rbp-212], eax
	lea	rax, OFFSET FLAT:??_C@_0M@IAFBEOBH@Open?5a?5File?$AA@
	mov	QWORD PTR ofn$[rbp-168], rax
	test	rcx, rcx
	je	SHORT $LN21@GetOpenNam
	cmp	BYTE PTR [rcx], 0
	jne	SHORT $LN22@GetOpenNam
$LN21@GetOpenNam:
	mov	rcx, QWORD PTR [rbx]
$LN22@GetOpenNam:
	lea	rdx, QWORD PTR path$[rbp-256]
	sub	rdx, rcx
$LL23@GetOpenNam:
	movzx	eax, BYTE PTR [rcx]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR [rdx+rcx-1], al
	test	al, al
	jne	SHORT $LL23@GetOpenNam

; 124  : 	ofn.lpstrInitialDir = path;
; 125  : 	ofn.Flags =
; 126  :     	OFN_PATHMUSTEXIST|
; 127  :     	OFN_FILEMUSTEXIST|
; 128  : 		OFN_HIDEREADONLY|
; 129  : 		OFN_FILEMUSTEXIST|
; 130  : 		OFN_NOCHANGEDIR|(bMulti?OFN_ALLOWMULTISELECT|OFN_EXPLORER:0);

	movzx	ebx, BYTE PTR bMulti$[rbp-256]
	lea	rax, QWORD PTR path$[rbp-256]

; 131  :     ofn.FlagsEx			= OFN_EX_NOPLACESBAR;

	mov	DWORD PTR ofn$[rbp-108], 1
	mov	QWORD PTR ofn$[rbp-176], rax
	movzx	eax, bl
	neg	al
	sbb	ecx, ecx
	and	ecx, 524800				; 00080200H
	or	ecx, 6156				; 0000180cH
	mov	DWORD PTR ofn$[rbp-160], ecx

; 132  :     
; 133  : 	bool bRes = !!GetOpenFileName( &ofn );

	lea	rcx, QWORD PTR ofn$[rsp]
	call	QWORD PTR __imp_GetOpenFileNameA
	test	eax, eax
	setne	r12b

; 134  :     if (!bRes){

	test	r12b, r12b
	jne	SHORT $LN412@GetOpenNam

; 135  : 	    u32 err = CommDlgExtendedError();

	call	QWORD PTR __imp_CommDlgExtendedError

; 136  : 	    switch(err){

	cmp	eax, 12291				; 00003003H
	jne	$LN4@GetOpenNam

; 137  :         case FNERR_BUFFERTOOSMALL: 	Log("Too many file selected."); break;

	lea	rcx, OFFSET FLAT:??_C@_0BI@KCPLAHKE@Too?5many?5file?5selected?4?$AA@
	call	?Log@@YAXPEBD@Z				; Log

; 138  :         }
; 139  : 	}
; 140  :     if (bRes&&bMulti){

	jmp	$LN4@GetOpenNam
$LN412@GetOpenNam:
	test	bl, bl
	je	$LN4@GetOpenNam

; 141  : 		int cnt		= _GetItemCount(buffer,0x0);

	xor	edx, edx
	mov	rcx, r15
	call	?_GetItemCount@@YAHPEBDD@Z		; _GetItemCount
	mov	r14d, eax

; 142  :         if (cnt>1){

	cmp	eax, 1
	jle	$LN4@GetOpenNam

; 143  :             string64  	buf;
; 144  :             string64  	dir;
; 145  :             string4096 	fns;
; 146  :             strcpy		(dir, buffer);

	lea	r8, QWORD PTR dir$2[rbp-256]
	mov	rdx, r15
	sub	r8, r15
	npad	4
$LL24@GetOpenNam:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rdx+r8-1], cl
	test	cl, cl
	jne	SHORT $LL24@GetOpenNam

; 147  :             strcpy		(fns,dir);

	xor	ecx, ecx
	npad	14
$LL25@GetOpenNam:
	movzx	eax, BYTE PTR dir$2[rbp+rcx-256]
	lea	rcx, QWORD PTR [rcx+1]
	mov	BYTE PTR fns$4[rbp+rcx-257], al
	test	al, al
	jne	SHORT $LL25@GetOpenNam

; 148  :             strcat		(fns,"\\");

	lea	rcx, QWORD PTR fns$4[rbp-256]
	dec	rcx
	npad	2
$LL425@GetOpenNam:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL425@GetOpenNam
	movzx	eax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 32   : 	LPCSTR	res			= src;

	mov	rbx, r15

; 33   : 	u32		p			= 0;

	xor	edi, edi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 148  :             strcat		(fns,"\\");

	mov	WORD PTR [rcx], ax
	npad	7
$LL301@GetOpenNam:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 34   : 	while( (p<pos) && (0!=(res=strchr(res,separator))) )

	xor	edx, edx
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN296@GetOpenNam

; 35   : 	{
; 36   : 		res		++;
; 37   : 		p		++;

	inc	edi
	inc	rbx
	cmp	edi, 1
	jb	SHORT $LL301@GetOpenNam

; 50   : 	return		dst;
; 51   : }
; 52   : 
; 53   : int	_GetItemCount ( LPCSTR src, char separator )
; 54   : {
; 55   : 	u32		cnt			= 0;
; 56   : 	if (src&&src[0]){
; 57   : 		LPCSTR	res			= src;
; 58   : 		LPCSTR	last_res	= res;
; 59   : 		while( 0!=(res=strchr(res,separator)) )
; 60   : 		{
; 61   : 			res		++;
; 62   : 			last_res=res;
; 63   : 			cnt		++;
; 64   : 			if (res[0]==separator) break;
; 65   : 		}
; 66   : 		if (xr_strlen(last_res)) cnt++;
; 67   : 	}
; 68   : 	return		cnt;
; 69   : }
; 70   : 
; 71   : LPSTR _GetItem ( LPCSTR src, int index, LPSTR dst, char separator, LPCSTR def, bool trim )
; 72   : {
; 73   : 	LPCSTR	ptr;
; 74   : 	ptr			= _SetPos	( src, index, separator );
; 75   : 	if( ptr )	_CopyVal	( ptr, dst, separator );

	test	rbx, rbx
	je	SHORT $LN296@GetOpenNam

; 38   : 	}
; 39   : 	return		res;
; 40   : }
; 41   : 
; 42   : LPCSTR _CopyVal ( LPCSTR src, LPSTR dst, char separator )
; 43   : {
; 44   : 	LPCSTR	p;
; 45   : 	size_t	n;
; 46   : 	p			= strchr	( src, separator );

	xor	edx, edx
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rdi, rax

; 47   : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	test	rax, rax
	je	SHORT $LN306@GetOpenNam
	sub	rdi, rbx
	jmp	SHORT $LN307@GetOpenNam
$LN306@GetOpenNam:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
	npad	2
$LL424@GetOpenNam:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL424@GetOpenNam
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 47   : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	mov	edi, eax
$LN307@GetOpenNam:

; 48   : 	strncpy		( dst, src, n );

	lea	rcx, QWORD PTR buf$1[rsp]
	mov	r8, rdi
	mov	rdx, rbx
	call	QWORD PTR __imp_strncpy

; 49   : 	dst[n]		= 0;

	mov	BYTE PTR buf$1[rsp+rdi], 0

; 76   : 		else	strcpy		( dst, def );

	jmp	SHORT $LN295@GetOpenNam
$LN296@GetOpenNam:
	xor	ecx, ecx
	npad	11
$LL299@GetOpenNam:
	movzx	eax, BYTE PTR [rcx+r13]
	inc	rcx
	mov	BYTE PTR buf$1[rsp+rcx-1], al
	test	al, al
	jne	SHORT $LL299@GetOpenNam
$LN295@GetOpenNam:

; 7    : 	while( *p && (u8(*p)<=u8(' ')) ) p++;

	movzx	ecx, BYTE PTR buf$1[rsp]
	lea	rax, QWORD PTR buf$1[rsp]
	test	cl, cl
	je	SHORT $LN315@GetOpenNam
	npad	2
$LL317@GetOpenNam:
	cmp	cl, 32					; 00000020H
	ja	SHORT $LN316@GetOpenNam
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL317@GetOpenNam
$LN316@GetOpenNam:

; 8    :     if (p!=str){

	lea	rcx, QWORD PTR buf$1[rsp]
	cmp	rax, rcx
	je	SHORT $LN315@GetOpenNam

; 9    :         for (LPSTR t=str; *p; t++,p++) *t=*p;

	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR buf$1[rsp]
	test	dl, dl
	je	SHORT $LN312@GetOpenNam
	lea	r8, QWORD PTR buf$1[rsp]
	sub	rax, r8
	npad	2
$LL314@GetOpenNam:
	mov	BYTE PTR [rcx], dl
	movzx	edx, BYTE PTR [rax+rcx+1]
	inc	rcx
	test	dl, dl
	jne	SHORT $LL314@GetOpenNam
$LN312@GetOpenNam:

; 10   :         *t = 0;

	mov	BYTE PTR [rcx], 0
$LN315@GetOpenNam:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR buf$1[rsp]
	or	rax, -1
	npad	6
$LL423@GetOpenNam:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL423@GetOpenNam
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 17   : 	LPSTR p 	= str+xr_strlen(str);

	mov	eax, eax
	lea	rcx, QWORD PTR buf$1[rsp]
	add	rcx, rax

; 18   : 	while( (p!=str) && (u8(*p)<=u8(' ')) ) p--;

	lea	rax, QWORD PTR buf$1[rsp]
	cmp	rcx, rax
	je	SHORT $LN427@GetOpenNam
	npad	3
$LL321@GetOpenNam:
	cmp	BYTE PTR [rcx], 32			; 00000020H
	ja	SHORT $LN427@GetOpenNam
	lea	rax, QWORD PTR buf$1[rsp]
	dec	rcx
	cmp	rcx, rax
	jne	SHORT $LL321@GetOpenNam
$LN427@GetOpenNam:

; 19   :     *(++p) 		= 0;

	mov	BYTE PTR [rcx+1], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 149  :             strcat		(fns,_GetItem(buffer,1,buf,0x0));

	lea	rcx, QWORD PTR fns$4[rbp-256]
	dec	rcx
$LL421@GetOpenNam:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL421@GetOpenNam
	lea	r8, QWORD PTR buf$1[rsp]
	xor	edx, edx
$LL422@GetOpenNam:
	movzx	eax, BYTE PTR [r8+rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rcx+rdx-1], al
	test	al, al
	jne	SHORT $LL422@GetOpenNam

; 150  :             for (int i=2; i<cnt; i++){

	mov	esi, 2
	cmp	r14d, esi
	jle	$LN1@GetOpenNam
$LL3@GetOpenNam:

; 151  :                 strcat	(fns,",");

	lea	rcx, QWORD PTR fns$4[rbp-256]
	dec	rcx
	npad	6
$LL420@GetOpenNam:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL420@GetOpenNam
	movzx	eax, WORD PTR ??_C@_01IHBHIGKO@?0?$AA@
	mov	WORD PTR [rcx], ax

; 152  :                 strcat	(fns,dir);

	lea	rcx, QWORD PTR fns$4[rbp-256]
	dec	rcx
	npad	2
$LL418@GetOpenNam:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL418@GetOpenNam
	lea	r8, QWORD PTR dir$2[rbp-256]
	xor	edx, edx
$LL419@GetOpenNam:
	movzx	eax, BYTE PTR [r8+rdx]
	inc	rdx
	mov	BYTE PTR [rcx+rdx-1], al
	test	al, al
	jne	SHORT $LL419@GetOpenNam

; 153  :                 strcat	(fns,"\\");

	lea	rcx, QWORD PTR fns$4[rbp-256]
	dec	rcx
	npad	6
$LL417@GetOpenNam:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL417@GetOpenNam
	movzx	eax, WORD PTR ??_C@_01KICIPPFI@?2?$AA@
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 33   : 	u32		p			= 0;

	xor	edi, edi
	mov	rbx, r15
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 153  :                 strcat	(fns,"\\");

	mov	WORD PTR [rcx], ax
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 34   : 	while( (p<pos) && (0!=(res=strchr(res,separator))) )

	test	esi, esi
	je	SHORT $LN332@GetOpenNam
	npad	3
$LL333@GetOpenNam:
	xor	edx, edx
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rbx, rax
	test	rax, rax
	je	SHORT $LN328@GetOpenNam

; 35   : 	{
; 36   : 		res		++;
; 37   : 		p		++;

	inc	edi
	inc	rbx
	cmp	edi, esi
	jb	SHORT $LL333@GetOpenNam
$LN332@GetOpenNam:

; 50   : 	return		dst;
; 51   : }
; 52   : 
; 53   : int	_GetItemCount ( LPCSTR src, char separator )
; 54   : {
; 55   : 	u32		cnt			= 0;
; 56   : 	if (src&&src[0]){
; 57   : 		LPCSTR	res			= src;
; 58   : 		LPCSTR	last_res	= res;
; 59   : 		while( 0!=(res=strchr(res,separator)) )
; 60   : 		{
; 61   : 			res		++;
; 62   : 			last_res=res;
; 63   : 			cnt		++;
; 64   : 			if (res[0]==separator) break;
; 65   : 		}
; 66   : 		if (xr_strlen(last_res)) cnt++;
; 67   : 	}
; 68   : 	return		cnt;
; 69   : }
; 70   : 
; 71   : LPSTR _GetItem ( LPCSTR src, int index, LPSTR dst, char separator, LPCSTR def, bool trim )
; 72   : {
; 73   : 	LPCSTR	ptr;
; 74   : 	ptr			= _SetPos	( src, index, separator );
; 75   : 	if( ptr )	_CopyVal	( ptr, dst, separator );

	test	rbx, rbx
	je	SHORT $LN328@GetOpenNam

; 38   : 	}
; 39   : 	return		res;
; 40   : }
; 41   : 
; 42   : LPCSTR _CopyVal ( LPCSTR src, LPSTR dst, char separator )
; 43   : {
; 44   : 	LPCSTR	p;
; 45   : 	size_t	n;
; 46   : 	p			= strchr	( src, separator );

	xor	edx, edx
	mov	rcx, rbx
	call	QWORD PTR __imp_strchr
	mov	rdi, rax

; 47   : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	test	rax, rax
	je	SHORT $LN338@GetOpenNam
	sub	rdi, rbx
	jmp	SHORT $LN339@GetOpenNam
$LN338@GetOpenNam:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
	npad	3
$LL416@GetOpenNam:
	inc	rax
	cmp	BYTE PTR [rbx+rax], 0
	jne	SHORT $LL416@GetOpenNam
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 47   : 	n			= (p>0) ? (p-src) : xr_strlen(src);

	mov	edi, eax
$LN339@GetOpenNam:

; 48   : 	strncpy		( dst, src, n );

	lea	rcx, QWORD PTR buf$1[rsp]
	mov	r8, rdi
	mov	rdx, rbx
	call	QWORD PTR __imp_strncpy

; 49   : 	dst[n]		= 0;

	mov	BYTE PTR buf$1[rsp+rdi], 0

; 76   : 		else	strcpy		( dst, def );

	jmp	SHORT $LN327@GetOpenNam
$LN328@GetOpenNam:
	xor	ecx, ecx
	npad	11
$LL331@GetOpenNam:
	movzx	eax, BYTE PTR [rcx+r13]
	inc	rcx
	mov	BYTE PTR buf$1[rsp+rcx-1], al
	test	al, al
	jne	SHORT $LL331@GetOpenNam
$LN327@GetOpenNam:

; 7    : 	while( *p && (u8(*p)<=u8(' ')) ) p++;

	movzx	ecx, BYTE PTR buf$1[rsp]
	lea	rax, QWORD PTR buf$1[rsp]
	test	cl, cl
	je	SHORT $LN347@GetOpenNam
	npad	2
$LL349@GetOpenNam:
	cmp	cl, 32					; 00000020H
	ja	SHORT $LN348@GetOpenNam
	movzx	ecx, BYTE PTR [rax+1]
	inc	rax
	test	cl, cl
	jne	SHORT $LL349@GetOpenNam
$LN348@GetOpenNam:

; 8    :     if (p!=str){

	lea	rcx, QWORD PTR buf$1[rsp]
	cmp	rax, rcx
	je	SHORT $LN347@GetOpenNam

; 9    :         for (LPSTR t=str; *p; t++,p++) *t=*p;

	movzx	edx, BYTE PTR [rax]
	lea	rcx, QWORD PTR buf$1[rsp]
	test	dl, dl
	je	SHORT $LN344@GetOpenNam
	lea	r8, QWORD PTR buf$1[rsp]
	sub	rax, r8
	npad	2
$LL346@GetOpenNam:
	mov	BYTE PTR [rcx], dl
	movzx	edx, BYTE PTR [rax+rcx+1]
	inc	rcx
	test	dl, dl
	jne	SHORT $LL346@GetOpenNam
$LN344@GetOpenNam:

; 10   :         *t = 0;

	mov	BYTE PTR [rcx], 0
$LN347@GetOpenNam:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	lea	rcx, QWORD PTR buf$1[rsp]
	or	rax, -1
	npad	6
$LL415@GetOpenNam:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL415@GetOpenNam
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xr_trims.cpp

; 17   : 	LPSTR p 	= str+xr_strlen(str);

	mov	eax, eax
	lea	rcx, QWORD PTR buf$1[rsp]
	add	rcx, rax

; 18   : 	while( (p!=str) && (u8(*p)<=u8(' ')) ) p--;

	lea	rax, QWORD PTR buf$1[rsp]
	cmp	rcx, rax
	je	SHORT $LN428@GetOpenNam
	npad	3
$LL353@GetOpenNam:
	cmp	BYTE PTR [rcx], 32			; 00000020H
	ja	SHORT $LN428@GetOpenNam
	lea	rax, QWORD PTR buf$1[rsp]
	dec	rcx
	cmp	rcx, rax
	jne	SHORT $LL353@GetOpenNam
$LN428@GetOpenNam:

; 19   :     *(++p) 		= 0;

	mov	BYTE PTR [rcx+1], 0
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 154  :                 strcat	(fns,_GetItem(buffer,i,buf,0x0));

	lea	rcx, QWORD PTR fns$4[rbp-256]
	dec	rcx
$LL413@GetOpenNam:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL413@GetOpenNam
	lea	r8, QWORD PTR buf$1[rsp]
	xor	edx, edx
$LL414@GetOpenNam:
	movzx	eax, BYTE PTR [r8+rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rcx+rdx-1], al
	test	al, al
	jne	SHORT $LL414@GetOpenNam

; 150  :             for (int i=2; i<cnt; i++){

	inc	esi
	cmp	esi, r14d
	jl	$LL3@GetOpenNam
$LN1@GetOpenNam:

; 155  :             }
; 156  :             strcpy		(buffer,fns);

	lea	rax, QWORD PTR fns$4[rbp-256]
	mov	r8, r15
	lea	rdx, QWORD PTR fns$4[rbp-256]
	sub	r8, rax
	npad	15
$LL26@GetOpenNam:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [r8+rdx-1], cl
	test	cl, cl
	jne	SHORT $LL26@GetOpenNam
$LN4@GetOpenNam:

; 157  :         }
; 158  :     }
; 159  :     strlwr(buffer);

	mov	rcx, r15
	call	QWORD PTR __imp_strlwr

; 160  :     return bRes;
; 161  : }

	lea	r11, QWORD PTR [rsp+6496]
	movzx	eax, r12b
	mov	rbx, QWORD PTR [r11+48]
	mov	rsi, QWORD PTR [r11+56]
	mov	rdi, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rbp
	ret	0
?GetOpenName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@DH_N0H@Z ENDP ; EFS_Utils::GetOpenName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
ofn$ = 48
path$ = 208
dr$1 = 720
flt$ = 1248
this$ = 2288
initial$ = 2296
buffer$ = 2304
offset$ = 2312
start_flt_ext$ = 2320
?GetSaveName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@D0H@Z PROC	; EFS_Utils::GetSaveName

; 164  : {

$LN288:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 2272				; 000008e0H

; 165  : 	FS_Path& P			= *FS.get_path(initial);

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	mov	rbx, r9
	mov	rdi, r8
	call	?get_path@CLocatorAPI@@QEAAPEAVFS_Path@@PEBD@Z ; CLocatorAPI::get_path

; 166  : 	string1024 flt;
; 167  : 	MakeFilter(flt,P.m_FilterCaption?P.m_FilterCaption:"",P.m_DefExt);

	lea	rbp, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@

; 71   : 	ZeroMemory(dest,sizeof(dest));

	mov	r8d, 1024				; 00000400H

; 166  : 	string1024 flt;
; 167  : 	MakeFilter(flt,P.m_FilterCaption?P.m_FilterCaption:"",P.m_DefExt);

	mov	rcx, QWORD PTR [rax+32]
	mov	r14, QWORD PTR [rax+24]
	mov	rsi, rax
	test	rcx, rcx
	cmovne	rbp, rcx

; 71   : 	ZeroMemory(dest,sizeof(dest));

	lea	rcx, QWORD PTR flt$[rsp]
	xor	edx, edx
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16

; 72   :     if (ext){

	test	r14, r14
	je	SHORT $LN20@GetSaveNam
	lea	rcx, QWORD PTR flt$[rsp]
	mov	r8, r14
	mov	rdx, rbp
	call	?MakeFilter@@YAPEBDAEAY0EAA@DPEBD1@Z	; MakeFilter
$LN20@GetSaveNam:

; 168  : 	OPENFILENAME ofn;
; 169  : 	Memory.mem_fill		( &ofn, 0, sizeof(ofn) );

	lea	rcx, QWORD PTR ofn$[rsp]
	xor	edx, edx
	mov	r8d, 152				; 00000098H
	call	QWORD PTR ?Memory@@3VxrMemory@@A+16
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rax, -1
	npad	3
$LL286@GetSaveNam:
	inc	rax
	cmp	BYTE PTR [rdi+rax], 0
	jne	SHORT $LL286@GetSaveNam
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 170  :     if (xr_strlen(buffer)){ 

	test	eax, eax
	je	SHORT $LN5@GetSaveNam

; 171  :         string_path		dr;
; 172  :         if (!(buffer[0]=='\\' && buffer[1]=='\\')){ // if !network

	cmp	BYTE PTR [rdi], 92			; 0000005cH
	jne	SHORT $LN6@GetSaveNam
	cmp	BYTE PTR [rdi+1], 92			; 0000005cH
	je	SHORT $LN5@GetSaveNam
$LN6@GetSaveNam:

; 173  :             _splitpath		(buffer,dr,0,0,0);

	lea	rdx, QWORD PTR dr$1[rsp]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rcx, rdi
	mov	QWORD PTR [rsp+32], 0
	call	QWORD PTR __imp__splitpath

; 174  :             if (0==dr[0])	P._update(buffer,buffer); 

	cmp	BYTE PTR dr$1[rsp], 0
	jne	SHORT $LN5@GetSaveNam
	mov	r8, rdi
	mov	rdx, rdi
	mov	rcx, rsi
	call	?_update@FS_Path@@QEBAPEBDAEAY0CAI@DPEBD@Z ; FS_Path::_update
$LN5@GetSaveNam:

; 175  :         }
; 176  :     }
; 177  : 	ofn.hwndOwner 		= GetForegroundWindow();

	call	QWORD PTR __imp_GetForegroundWindow
	mov	QWORD PTR ofn$[rsp+8], rax

; 178  : 	ofn.lpstrDefExt 	= P.m_DefExt;

	mov	rax, QWORD PTR [rsi+24]

; 179  : 	ofn.lpstrFile 		= buffer;

	mov	QWORD PTR ofn$[rsp+48], rdi
	mov	QWORD PTR ofn$[rsp+104], rax

; 180  : 	ofn.lpstrFilter 	= flt;

	lea	rax, QWORD PTR flt$[rsp]

; 181  : 	ofn.lStructSize 	= sizeof(ofn);

	mov	DWORD PTR ofn$[rsp], 152		; 00000098H
	mov	QWORD PTR ofn$[rsp+24], rax

; 182  : 	ofn.nMaxFile 		= sizeof(buffer);
; 183  : 	ofn.nFilterIndex 	= start_flt_ext+2;

	mov	eax, DWORD PTR start_flt_ext$[rsp]
	mov	DWORD PTR ofn$[rsp+56], 520		; 00000208H
	add	eax, 2
	mov	DWORD PTR ofn$[rsp+44], eax

; 184  :     ofn.lpstrTitle      = "Save a File";

	lea	rax, OFFSET FLAT:??_C@_0M@KIPHFBFH@Save?5a?5File?$AA@
	mov	QWORD PTR ofn$[rsp+88], rax

; 185  :     string512 path; strcpy(path,(offset&&offset[0])?offset:P.m_Path);

	test	rbx, rbx
	je	SHORT $LN13@GetSaveNam
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LN14@GetSaveNam
$LN13@GetSaveNam:
	mov	rbx, QWORD PTR [rsi]
$LN14@GetSaveNam:
	lea	rcx, QWORD PTR path$[rsp]
	sub	rcx, rbx
	npad	2
$LL15@GetSaveNam:
	movzx	eax, BYTE PTR [rbx]
	inc	rbx
	mov	BYTE PTR [rcx+rbx-1], al
	test	al, al
	jne	SHORT $LL15@GetSaveNam

; 186  : 	ofn.lpstrInitialDir = path;

	lea	rax, QWORD PTR path$[rsp]

; 187  : 	ofn.Flags 			= OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT|OFN_NOCHANGEDIR;
; 188  :     ofn.FlagsEx			= OFN_EX_NOPLACESBAR;
; 189  : 
; 190  : 	bool bRes = !!GetSaveFileName( &ofn );

	lea	rcx, QWORD PTR ofn$[rsp]
	mov	DWORD PTR ofn$[rsp+96], 14
	mov	QWORD PTR ofn$[rsp+80], rax
	mov	DWORD PTR ofn$[rsp+148], 1
	call	QWORD PTR __imp_GetSaveFileNameA
	test	eax, eax
	setne	bl

; 191  :     if (!bRes){

	test	bl, bl
	jne	SHORT $LN2@GetSaveNam

; 192  : 	    u32 err = CommDlgExtendedError();

	call	QWORD PTR __imp_CommDlgExtendedError

; 193  : 	    switch(err){

	cmp	eax, 12291				; 00003003H
	jne	SHORT $LN2@GetSaveNam

; 194  :         case FNERR_BUFFERTOOSMALL: 	Log("Too many file selected."); break;

	lea	rcx, OFFSET FLAT:??_C@_0BI@KCPLAHKE@Too?5many?5file?5selected?4?$AA@
	call	?Log@@YAXPEBD@Z				; Log
$LN2@GetSaveNam:

; 195  :         }
; 196  : 	}
; 197  :     strlwr(buffer);

	mov	rcx, rdi
	call	QWORD PTR __imp_strlwr

; 198  : 	return bRes;
; 199  : }

	lea	r11, QWORD PTR [rsp+2272]
	movzx	eax, bl
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	mov	rsp, r11
	pop	r14
	ret	0
?GetSaveName@EFS_Utils@@QEAA_NPEBDAEAY0CAI@D0H@Z ENDP	; EFS_Utils::GetSaveName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
_fn$ = 48
this$ = 320
tex_name$ = 328
depth$ = 336
full_name$ = 344
?AppendFolderToName@EFS_Utils@@QEAAPEBDPEADHH@Z PROC	; EFS_Utils::AppendFolderToName

; 202  : {

$LN8:
	push	rbx
	sub	rsp, 304				; 00000130H

; 203  : 	string256 _fn;
; 204  : 	strcpy(tex_name,AppendFolderToName(tex_name, _fn, depth, full_name));

	mov	DWORD PTR [rsp+32], r9d
	mov	r9d, r8d
	lea	r8, QWORD PTR _fn$[rsp]
	mov	rbx, rdx
	call	?AppendFolderToName@EFS_Utils@@QEAAPEBDPEBDPEADHH@Z ; EFS_Utils::AppendFolderToName
	mov	r8, rbx
	sub	r8, rax
	npad	12
$LL3@AppendFold:
	movzx	ecx, BYTE PTR [rax]
	lea	rax, QWORD PTR [rax+1]
	mov	BYTE PTR [r8+rax-1], cl
	test	cl, cl
	jne	SHORT $LL3@AppendFold

; 205  : 	return tex_name;

	mov	rax, rbx

; 206  : }

	add	rsp, 304				; 00000130H
	pop	rbx
	ret	0
?AppendFolderToName@EFS_Utils@@QEAAPEBDPEADHH@Z ENDP	; EFS_Utils::AppendFolderToName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
this$ = 48
src_name$ = 56
dest_name$ = 64
depth$ = 72
full_name$ = 80
?AppendFolderToName@EFS_Utils@@QEAAPEBDPEBDPEADHH@Z PROC ; EFS_Utils::AppendFolderToName

; 209  : {

$LN46:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	mov	rcx, QWORD PTR ?g_pStringContainer@@3PEAVstr_container@@EA ; g_pStringContainer
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 209  : {

	mov	edi, r9d
	mov	rsi, r8
	mov	rbx, rdx
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 52   : 	void				_set		(str_c rhs) 					{	str_value* v = g_pStringContainer->dock(rhs); if (0!=v) v->dwReference++; _dec(); p_ = v;	}

	call	?dock@str_container@@QEAAPEAUstr_value@@PEBD@Z ; str_container::dock
	mov	r9, rax
	test	rax, rax
	je	SHORT $LN19@AppendFold
	inc	DWORD PTR [rax]
$LN19@AppendFold:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 214  : 	for (; *s&&depth; s++, d++){

	cmp	BYTE PTR [rbx], 0
	mov	rcx, rsi
	mov	edx, edi
	je	SHORT $LN44@AppendFold
$LL11@AppendFold:
	test	edi, edi
	je	SHORT $LN44@AppendFold

; 215  : 		if (*s=='_'){depth--; *d='\\';}else{*d=*s;}

	movzx	eax, BYTE PTR [rbx]
	cmp	al, 95					; 0000005fH
	jne	SHORT $LN8@AppendFold
	dec	edi
	mov	BYTE PTR [rcx], 92			; 0000005cH
	jmp	SHORT $LN10@AppendFold
$LN8@AppendFold:
	mov	BYTE PTR [rcx], al
$LN10@AppendFold:

; 214  : 	for (; *s&&depth; s++, d++){

	inc	rbx
	inc	rcx
	cmp	BYTE PTR [rbx], 0
	jne	SHORT $LL11@AppendFold
$LN44@AppendFold:

; 216  : 	}
; 217  : 	if (full_name){

	cmp	DWORD PTR full_name$[rsp], 0
	je	SHORT $LN6@AppendFold

; 218  : 		*d			= 0;

	mov	BYTE PTR [rcx], 0

; 219  : 		if (depth<sv_depth)	strcat(dest_name,*tmp);

	cmp	edi, edx
	jge	SHORT $LN4@AppendFold
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 65   : 	str_c				operator*	() const						{	return p_?p_->value:0;							}

	test	r9, r9
	je	SHORT $LN25@AppendFold
	lea	r8, QWORD PTR [r9+12]
	jmp	SHORT $LN26@AppendFold
$LN25@AppendFold:
	xor	r8d, r8d
$LN26@AppendFold:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 219  : 		if (depth<sv_depth)	strcat(dest_name,*tmp);

	lea	rcx, QWORD PTR [rsi-1]
	npad	9
$LL41@AppendFold:
	cmp	BYTE PTR [rcx+1], 0
	lea	rcx, QWORD PTR [rcx+1]
	jne	SHORT $LL41@AppendFold
	xor	edx, edx
	npad	4
$LL42@AppendFold:
	movzx	eax, BYTE PTR [r8+rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [rcx+rdx-1], al
	test	al, al
	jne	SHORT $LL42@AppendFold

; 220  : 	}else{

	jmp	SHORT $LN4@AppendFold
$LN6@AppendFold:

; 221  : 		for (; *s; s++, d++) *d=*s;

	movzx	eax, BYTE PTR [rbx]
	test	al, al
	je	SHORT $LN1@AppendFold
	sub	rbx, rcx
	npad	3
$LL3@AppendFold:
	mov	BYTE PTR [rcx], al
	movzx	eax, BYTE PTR [rbx+rcx+1]
	inc	rcx
	test	al, al
	jne	SHORT $LL3@AppendFold
$LN1@AppendFold:

; 222  : 		*d			= 0;

	mov	BYTE PTR [rcx], 0
$LN4@AppendFold:

; 223  : 	}
; 224  :     return dest_name;

	mov	rax, rsi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\xrstring.h

; 50   : 	void				_dec		()								{	if (0==p_) return;	p_->dwReference--; 	if (0==p_->dwReference)	p_=0;						}

	test	r9, r9
	je	SHORT $LN29@AppendFold
	dec	DWORD PTR [r9]
$LN29@AppendFold:
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 225  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?AppendFolderToName@EFS_Utils@@QEAAPEBDPEBDPEADHH@Z ENDP ; EFS_Utils::AppendFolderToName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp
_TEXT	SEGMENT
fn$ = 64
this$ = 624
base_path$ = 632
base_name$ = 640
def_ext$ = 648
out_name$ = 656
?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z PROC	; EFS_Utils::GenerateName

; 228  : {

$LN29:
	mov	rax, rsp
	sub	rsp, 616				; 00000268H
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax-16], r14

; 229  :     int cnt = 0;

	xor	ebx, ebx
	mov	QWORD PTR [rax-24], r15
	mov	rsi, r8
	mov	r15, r9
	mov	r14, rdx

; 230  : 	string_path fn;
; 231  :     if (base_name)	

	test	r8, r8
	je	$LN6@GenerateNa
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax-8], rdi
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h

; 270  : {	return (u32)strlen(S);			}

	or	rdi, -1
	mov	rbp, rdi
	npad	3
$LL23@GenerateNa:
	inc	rbp
	cmp	BYTE PTR [rdx+rbp], bl
	jne	SHORT $LL23@GenerateNa
	npad	8
$LL22@GenerateNa:
	inc	rdi
	cmp	BYTE PTR [r8+rdi], bl
	jne	SHORT $LL22@GenerateNa

; 184  : 	strcpy_s(dest,dest_sz,S1);

	mov	r8, rdx
	lea	rcx, QWORD PTR fn$[rsp]
	mov	edx, 520				; 00000208H
	call	QWORD PTR __imp_strcpy_s

; 185  : 	strcat_s(dest,dest_sz-l1,S2);

	mov	edx, 520				; 00000208H
	lea	rcx, QWORD PTR fn$[rsp]
	sub	edx, ebp
	mov	r8, rsi
	call	QWORD PTR __imp_strcat_s

; 186  : 	strcat_s(dest,dest_sz-l1-l2,S3);

	mov	edx, 520				; 00000208H
	lea	rcx, QWORD PTR fn$[rsp]
	sub	edx, edi
	mov	r8, r15
	sub	edx, ebp
	call	QWORD PTR __imp_strcat_s
	mov	rdi, QWORD PTR [rsp+608]
	mov	rbp, QWORD PTR [rsp+632]
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\filesystem.cpp

; 233  : 	else 			

	jmp	SHORT $LN16@GenerateNa
$LN6@GenerateNa:

; 234  : 		sprintf_s		(fn, sizeof(fn), "%s%02d%s",base_path,cnt++,def_ext);

	mov	QWORD PTR [rsp+40], r9
	mov	r9, rdx
	lea	r8, OFFSET FLAT:??_C@_08DPIBIONE@?$CFs?$CF02d?$CFs?$AA@
	lea	rcx, QWORD PTR fn$[rsp]
	mov	edx, 520				; 00000208H
	mov	DWORD PTR [rsp+32], ebx
	call	QWORD PTR __imp_sprintf_s
	mov	ebx, 1
$LN16@GenerateNa:

; 235  : 
; 236  : 	while (FS.exist(fn))

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	lea	rdx, QWORD PTR fn$[rsp]
	call	?exist@CLocatorAPI@@QEAAPEBUfile@1@PEBD@Z ; CLocatorAPI::exist
	test	rax, rax
	je	SHORT $LN3@GenerateNa
	npad	8
$LL4@GenerateNa:

; 237  : 	    if (base_name)	
; 238  : 			sprintf_s	(fn, sizeof(fn),"%s%s%02d%s",base_path,base_name,cnt++,def_ext);

	mov	r9, r14
	mov	edx, 520				; 00000208H
	lea	rcx, QWORD PTR fn$[rsp]
	test	rsi, rsi
	je	SHORT $LN2@GenerateNa
	mov	QWORD PTR [rsp+48], r15
	lea	r8, OFFSET FLAT:??_C@_0L@FILKDGJI@?$CFs?$CFs?$CF02d?$CFs?$AA@
	mov	DWORD PTR [rsp+40], ebx
	mov	QWORD PTR [rsp+32], rsi
	call	QWORD PTR __imp_sprintf_s

; 239  :         else 			

	jmp	SHORT $LN27@GenerateNa
$LN2@GenerateNa:

; 240  : 			sprintf_s	(fn, sizeof(fn), "%s%02d%s",base_path,cnt++,def_ext);

	lea	r8, OFFSET FLAT:??_C@_08DPIBIONE@?$CFs?$CF02d?$CFs?$AA@
	mov	QWORD PTR [rsp+40], r15
	mov	DWORD PTR [rsp+32], ebx
	call	QWORD PTR __imp_sprintf_s
$LN27@GenerateNa:

; 235  : 
; 236  : 	while (FS.exist(fn))

	mov	rcx, QWORD PTR ?xr_FS@@3PEAVCLocatorAPI@@EA ; xr_FS
	lea	rdx, QWORD PTR fn$[rsp]

; 240  : 			sprintf_s	(fn, sizeof(fn), "%s%02d%s",base_path,cnt++,def_ext);

	inc	ebx
	call	?exist@CLocatorAPI@@QEAAPEBUfile@1@PEBD@Z ; CLocatorAPI::exist
	test	rax, rax
	jne	SHORT $LL4@GenerateNa
$LN3@GenerateNa:

; 241  :     strcpy(out_name,fn);

	mov	rax, QWORD PTR out_name$[rsp]
	mov	r15, QWORD PTR [rsp+592]
	mov	r14, QWORD PTR [rsp+600]
	mov	rsi, QWORD PTR [rsp+640]
	mov	rbx, QWORD PTR [rsp+624]
	lea	rcx, QWORD PTR fn$[rsp]
	mov	r8, rax
	lea	rdx, QWORD PTR fn$[rsp]
	sub	r8, rcx
	npad	11
$LL9@GenerateNa:
	movzx	ecx, BYTE PTR [rdx]
	lea	rdx, QWORD PTR [rdx+1]
	mov	BYTE PTR [r8+rdx-1], cl
	test	cl, cl
	jne	SHORT $LL9@GenerateNa

; 242  : 	return out_name;
; 243  : }

	add	rsp, 616				; 00000268H
	ret	0
?GenerateName@EFS_Utils@@QEAAPEBDPEBD00PEAD@Z ENDP	; EFS_Utils::GenerateName
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@QEAA@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >::map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >, COMDAT

; 95   : 		{	// construct empty map from defaults

$LN16:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	xor	eax, eax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 95   : 		{	// construct empty map from defaults

	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree

; 569  : 		this->_Myhead = 0;

	mov	QWORD PTR [rcx], rax

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rcx+8], rax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> > const ,void * __ptr64>,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > > >::_Buyheadnode
	mov	QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\map

; 96   : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@QEAA@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >::map<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@1@AEBV?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$dead$ = 56
_Al$dead$ = 64
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@1@AEBV?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >,0> >, COMDAT

; 1066 : 		{	// construct empty tree

$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H

; 569  : 		this->_Myhead = 0;

	xor	eax, eax

; 1066 : 		{	// construct empty tree

	mov	rbx, rcx

; 569  : 		this->_Myhead = 0;

	mov	QWORD PTR [rcx], rax

; 570  : 		this->_Mysize = 0;

	mov	QWORD PTR [rcx+8], rax

; 571  : 		}
; 572  : 
; 573  : 	enum _Redbl
; 574  : 		{	// colors for link to parent
; 575  : 		_Red, _Black};
; 576  : 
; 577  : 	static char& _Color(_Nodeptr _Pnode)
; 578  : 		{	// return reference to color in node
; 579  : 		return ((char&)_Pnode->_Color);
; 580  : 		}
; 581  : 
; 582  : 	static char& _Isnil(_Nodeptr _Pnode)
; 583  : 		{	// return reference to nil flag in node
; 584  : 		return ((char&)_Pnode->_Isnil);
; 585  : 		}
; 586  : 
; 587  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 588  : 		{	// return reference to left pointer in node
; 589  : 		return ((_Nodepref)_Pnode->_Left);
; 590  : 		}
; 591  : 
; 592  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 593  : 		{	// return reference to parent pointer in node
; 594  : 		return ((_Nodepref)_Pnode->_Parent);
; 595  : 		}
; 596  : 
; 597  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 598  : 		{	// return reference to right pointer in node
; 599  : 		return ((_Nodepref)_Pnode->_Right);
; 600  : 		}
; 601  : 
; 602  : 	static reference _Myval(_Nodeptr _Pnode)
; 603  : 		{	// return reference to value in node
; 604  : 		return ((reference)_Pnode->_Myval);
; 605  : 		}
; 606  : 
; 607  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 608  : 		{	// return rightmost node in subtree at _Pnode
; 609  : 		while (!_Isnil(_Right(_Pnode)))
; 610  : 			_Pnode = _Right(_Pnode);
; 611  : 		return (_Pnode);
; 612  : 		}
; 613  : 
; 614  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 615  : 		{	// return leftmost node in subtree at _Pnode
; 616  : 		while (!_Isnil(_Left(_Pnode)))
; 617  : 			_Pnode = _Left(_Pnode);
; 618  : 		return (_Pnode);
; 619  : 		}
; 620  : 
; 621  : 	_Nodeptr _Myhead;	// pointer to head node
; 622  : 	size_type _Mysize;	// number of elements
; 623  : 	};
; 624  : 
; 625  : 		// TEMPLATE CLASS _Tree_alloc
; 626  : template<bool _Al_has_storage,
; 627  : 	class _Alloc_types>
; 628  : 	class _Tree_alloc
; 629  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 630  : 	{	// base class for tree to hold allocator with storage
; 631  : public:
; 632  : 	typename _Alloc_types::_Alnod_type _Alnod;	// allocator object
; 633  : 
; 634  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 635  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 636  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 637  : 	typedef typename _Alloc_types::_Node _Node;
; 638  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 639  : 
; 640  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 641  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 642  : 		: _Alnod(_Al)
; 643  : 		{	// construct head node, allocator from _Al
; 644  : 		this->_Myhead = _Buyheadnode();
; 645  : 		}
; 646  : 
; 647  : 	~_Tree_alloc() _NOEXCEPT
; 648  : 		{	// destroy head node
; 649  : 		_Freeheadnode(this->_Myhead);
; 650  : 		}
; 651  : 
; 652  : 	void _Change_alloc(const _Alty& _Al)
; 653  : 		{	// replace old allocator
; 654  : 		this->_Alnod = _Al;
; 655  : 		}
; 656  : 
; 657  : 	void _Swap_alloc(_Myt& _Right)
; 658  : 		{	// swap allocators
; 659  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 660  : 		}
; 661  : 
; 662  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 663  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 664  : 		: _Alnod(_Al)
; 665  : 		{	// construct allocators from _Al
; 666  : 		this->_Myhead = _Buyheadnode();
; 667  : 		_TRY_BEGIN
; 668  : 		_Alloc_proxy();
; 669  : 		_CATCH_ALL
; 670  : 		_Freeheadnode(this->_Myhead);
; 671  : 		_RERAISE;
; 672  : 		_CATCH_END
; 673  : 		}
; 674  : 
; 675  : 	~_Tree_alloc() _NOEXCEPT
; 676  : 		{	// destroy proxy
; 677  : 		_Freeheadnode(this->_Myhead);
; 678  : 		_Free_proxy();
; 679  : 		}
; 680  : 
; 681  : 	void _Change_alloc(const _Alty& _Al)
; 682  : 		{	// replace old allocator
; 683  : 		_Free_proxy();
; 684  : 		this->_Alnod = _Al;
; 685  : 		_Alloc_proxy();
; 686  : 		}
; 687  : 
; 688  : 	void _Swap_alloc(_Myt& _Right)
; 689  : 		{	// swap allocators
; 690  : 		_Swap_adl(this->_Alnod, _Right._Alnod);
; 691  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 692  : 		}
; 693  : 
; 694  : 	void _Alloc_proxy()
; 695  : 		{	// construct proxy from _Alnod
; 696  : 		typename _Alty::template rebind<_Container_proxy>::other
; 697  : 			_Alproxy(this->_Alnod);
; 698  : 		this->_Myproxy = _Alproxy.allocate(1);
; 699  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 700  : 		this->_Myproxy->_Mycont = this;
; 701  : 		}
; 702  : 
; 703  : 	void _Free_proxy()
; 704  : 		{	// destroy proxy
; 705  : 		typename _Alty::template rebind<_Container_proxy>::other
; 706  : 			_Alproxy(this->_Alnod);
; 707  : 		this->_Orphan_all();
; 708  : 		_Alproxy.destroy(this->_Myproxy);
; 709  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 710  : 		this->_Myproxy = 0;
; 711  : 		}
; 712  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 713  : 
; 714  : 	_Nodeptr _Buyheadnode()
; 715  : 		{	// get head node using current allocator
; 716  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);
; 717  : 
; 718  : 		_TRY_BEGIN
; 719  : 		this->_Alnod.construct(
; 720  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 721  : 		this->_Alnod.construct(
; 722  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 723  : 		this->_Alnod.construct(
; 724  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 725  : 		_CATCH_ALL
; 726  : 		this->_Alnod.deallocate(_Pnode, 1);
; 727  : 		_RERAISE;
; 728  : 		_CATCH_END
; 729  : 
; 730  : 		this->_Color(_Pnode) = this->_Black;
; 731  : 		this->_Isnil(_Pnode) = true;
; 732  : 		return (_Pnode);
; 733  : 		}
; 734  : 
; 735  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 736  : 		{	// free head node using current allocator
; 737  : 		this->_Alnod.destroy(
; 738  : 			_STD addressof(this->_Left(_Pnode)));
; 739  : 		this->_Alnod.destroy(
; 740  : 			_STD addressof(this->_Parent(_Pnode)));
; 741  : 		this->_Alnod.destroy(
; 742  : 			_STD addressof(this->_Right(_Pnode)));
; 743  : 		this->_Alnod.deallocate(_Pnode, 1);
; 744  : 		}
; 745  : 
; 746  : 	_Alty& _Getal()
; 747  : 		{	// get reference to allocator
; 748  : 		return (this->_Alnod);
; 749  : 		}
; 750  : 
; 751  : 	const _Alty& _Getal() const
; 752  : 		{	// get reference to allocator
; 753  : 		return (this->_Alnod);
; 754  : 		}
; 755  : 	};
; 756  : 
; 757  : 		// TEMPLATE CLASS _Tree_alloc
; 758  : template<class _Alloc_types>
; 759  : 	class _Tree_alloc<false, _Alloc_types>
; 760  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 761  : 	{	// base class for tree to hold allocator with no storage
; 762  : public:
; 763  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 764  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 765  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 766  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 767  : 	typedef typename _Alloc_types::_Node _Node;
; 768  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 769  : 
; 770  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 771  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 772  : 		{	// construct head node, allocator from _Al
; 773  : 		this->_Myhead = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> > const ,void * __ptr64>,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> > > >::_Buyheadnode
	mov	QWORD PTR [rbx], rax

; 1067 : 		}

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAXU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@2@V?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@$0A@@std@@@std@@QEAA@AEBU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@@1@AEBV?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64,std::less<std::basic_string<char,std::char_traits<char>,xalloc<char> > >,xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_stl_extensions.h
;	COMDAT ??0?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@QEAA@XZ PROC ; xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >::xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >, COMDAT

; 76   : 													xalloc			()										{	}

	mov	rax, rcx
	ret	0
??0?$xalloc@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@PEAX@std@@@@QEAA@XZ ENDP ; xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >::xalloc<std::pair<std::basic_string<char,std::char_traits<char>,xalloc<char> >,void * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$xalloc@D@@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@0@$$QEAV10@PEBD@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$xalloc@D@@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@0@$$QEAV10@PEBD@Z PROC ; std::operator+<char,std::char_traits<char>,xalloc<char> >, COMDAT

; 2448 : 	{	// return string + NTCS

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	cmp	BYTE PTR [r8], 0
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 2448 : 	{	// return string + NTCS

	mov	rax, r8
	mov	r9, rdx
	mov	rbx, rcx
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

	jne	SHORT $LN7@operator
	xor	r8d, r8d
	jmp	SHORT $LN8@operator
$LN7@operator:
	or	r8, -1
	npad	2
$LL11@operator:
	inc	r8
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL11@operator
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\xstring

; 1087 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	rdx, rax
	mov	rcx, r9
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::append

; 2449 : 	return (_STD move(_Left.append(_Right)));

	mov	rcx, rbx
	mov	rdx, rax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,xalloc<char> >::basic_string<char,std::char_traits<char>,xalloc<char> >
	mov	rax, rbx

; 2450 : 	}

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$?HDU?$char_traits@D@std@@V?$xalloc@D@@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$xalloc@D@@@0@$$QEAV10@PEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,xalloc<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ?strconcat@@YAPEBDHPEADPEBD11@Z
_TEXT	SEGMENT
dest_sz$dead$ = 48
dest$ = 56
S1$ = 64
S2$ = 72
S3$ = 80
?strconcat@@YAPEBDHPEADPEBD11@Z PROC			; strconcat, COMDAT

; 181  : {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 191  : 
; 192  : // dest = S1+S2+S3+S4
; 193  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 194  : {
; 195  : 	u32 l1 = xr_strlen(S1);
; 196  : 	u32 l2 = xr_strlen(S2);
; 197  : 	u32 l3 = xr_strlen(S3);
; 198  : 	strcpy_s(dest,dest_sz,S1);
; 199  : 	strcat_s(dest,dest_sz-l1,S2);
; 200  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 201  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 202  : 
; 203  : 	return dest;
; 204  : //.	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4);
; 205  : }
; 206  : 
; 207  : // dest = S1+S2+S3+S4+S5
; 208  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 209  : {
; 210  : 	u32 l1 = xr_strlen(S1);
; 211  : 	u32 l2 = xr_strlen(S2);
; 212  : 	u32 l3 = xr_strlen(S3);
; 213  : 	u32 l4 = xr_strlen(S4);
; 214  : 	strcpy_s(dest,dest_sz,S1);
; 215  : 	strcat_s(dest,dest_sz-l1,S2);
; 216  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 217  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 218  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 219  : 
; 220  : 	return dest;
; 221  : //.	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5);
; 222  : }
; 223  : 
; 224  : // dest = S1+S2+S3+S4+S5+S6
; 225  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 226  : {
; 227  : 	u32 l1 = xr_strlen(S1);
; 228  : 	u32 l2 = xr_strlen(S2);
; 229  : 	u32 l3 = xr_strlen(S3);
; 230  : 	u32 l4 = xr_strlen(S4);
; 231  : 	u32 l5 = xr_strlen(S5);
; 232  : 	strcpy_s(dest,dest_sz,S1);
; 233  : 	strcat_s(dest,dest_sz-l1,S2);
; 234  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 235  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 236  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 237  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4-l5,S6);
; 238  : 
; 239  : 	return dest;
; 240  : 	//.	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6);
; 241  : }
; 242  : 
; 243  : #else
; 244  : 
; 245  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2)
; 246  : {	return strcat(strcpy(dest,S1),S2); }
; 247  : 
; 248  : // dest = S1+S2+S3
; 249  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3)
; 250  : {	return strcat(strcat(strcpy(dest,S1),S2),S3); }
; 251  : 
; 252  : // dest = S1+S2+S3+S4
; 253  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 254  : {	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4); }
; 255  : 
; 256  : // dest = S1+S2+S3+S4+S5
; 257  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 258  : {	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5); }
; 259  : 
; 260  : // dest = S1+S2+S3+S4+S5+S6
; 261  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 262  : {	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6); }
; 263  : 
; 264  : #endif
; 265  : // return pointer to ".ext"
; 266  : IC char*						strext					( const char* S )
; 267  : {	return (char*) strrchr(S,'.');	}
; 268  : 
; 269  : IC u32							xr_strlen				( const char* S )
; 270  : {	return (u32)strlen(S);			}

	or	rbx, -1

; 181  : {

	mov	rbp, r9
	mov	r14, rdx

; 191  : 
; 192  : // dest = S1+S2+S3+S4
; 193  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 194  : {
; 195  : 	u32 l1 = xr_strlen(S1);
; 196  : 	u32 l2 = xr_strlen(S2);
; 197  : 	u32 l3 = xr_strlen(S3);
; 198  : 	strcpy_s(dest,dest_sz,S1);
; 199  : 	strcat_s(dest,dest_sz-l1,S2);
; 200  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 201  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 202  : 
; 203  : 	return dest;
; 204  : //.	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4);
; 205  : }
; 206  : 
; 207  : // dest = S1+S2+S3+S4+S5
; 208  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 209  : {
; 210  : 	u32 l1 = xr_strlen(S1);
; 211  : 	u32 l2 = xr_strlen(S2);
; 212  : 	u32 l3 = xr_strlen(S3);
; 213  : 	u32 l4 = xr_strlen(S4);
; 214  : 	strcpy_s(dest,dest_sz,S1);
; 215  : 	strcat_s(dest,dest_sz-l1,S2);
; 216  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 217  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 218  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 219  : 
; 220  : 	return dest;
; 221  : //.	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5);
; 222  : }
; 223  : 
; 224  : // dest = S1+S2+S3+S4+S5+S6
; 225  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 226  : {
; 227  : 	u32 l1 = xr_strlen(S1);
; 228  : 	u32 l2 = xr_strlen(S2);
; 229  : 	u32 l3 = xr_strlen(S3);
; 230  : 	u32 l4 = xr_strlen(S4);
; 231  : 	u32 l5 = xr_strlen(S5);
; 232  : 	strcpy_s(dest,dest_sz,S1);
; 233  : 	strcat_s(dest,dest_sz-l1,S2);
; 234  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 235  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 236  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 237  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4-l5,S6);
; 238  : 
; 239  : 	return dest;
; 240  : 	//.	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6);
; 241  : }
; 242  : 
; 243  : #else
; 244  : 
; 245  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2)
; 246  : {	return strcat(strcpy(dest,S1),S2); }
; 247  : 
; 248  : // dest = S1+S2+S3
; 249  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3)
; 250  : {	return strcat(strcat(strcpy(dest,S1),S2),S3); }
; 251  : 
; 252  : // dest = S1+S2+S3+S4
; 253  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 254  : {	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4); }
; 255  : 
; 256  : // dest = S1+S2+S3+S4+S5
; 257  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 258  : {	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5); }
; 259  : 
; 260  : // dest = S1+S2+S3+S4+S5+S6
; 261  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 262  : {	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6); }
; 263  : 
; 264  : #endif
; 265  : // return pointer to ".ext"
; 266  : IC char*						strext					( const char* S )
; 267  : {	return (char*) strrchr(S,'.');	}
; 268  : 
; 269  : IC u32							xr_strlen				( const char* S )
; 270  : {	return (u32)strlen(S);			}

	mov	rsi, rbx
	npad	9
$LL8@strconcat:
	inc	rsi
	cmp	BYTE PTR [r8+rsi], 0
	jne	SHORT $LL8@strconcat
	npad	6
$LL7@strconcat:
	inc	rbx
	cmp	BYTE PTR [rbx+r9], 0
	jne	SHORT $LL7@strconcat

; 182  : 	u32 l1 = xr_strlen(S1);
; 183  : 	u32 l2 = xr_strlen(S2);
; 184  : 	strcpy_s(dest,dest_sz,S1);

	mov	edi, 520				; 00000208H
	mov	rcx, r14
	mov	edx, edi
	call	QWORD PTR __imp_strcpy_s

; 185  : 	strcat_s(dest,dest_sz-l1,S2);

	mov	edx, edi
	mov	r8, rbp
	sub	edx, esi
	mov	rcx, r14
	call	QWORD PTR __imp_strcat_s

; 186  : 	strcat_s(dest,dest_sz-l1-l2,S3);

	mov	r8, QWORD PTR S3$[rsp]
	sub	edi, ebx
	sub	edi, esi
	mov	rcx, r14
	mov	edx, edi
	call	QWORD PTR __imp_strcat_s

; 187  : 
; 188  : 	return dest;
; 189  : //.	return strcat(strcat(strcpy(dest,S1),S2),S3);
; 190  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	mov	rax, r14
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?strconcat@@YAPEBDHPEADPEBD11@Z ENDP			; strconcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ?strconcat@@YAPEBDHPEADPEBD111@Z
_TEXT	SEGMENT
dest_sz$ = 64
dest$ = 72
S1$ = 80
S2$ = 88
S3$ = 96
S4$ = 104
?strconcat@@YAPEBDHPEADPEBD111@Z PROC			; strconcat, COMDAT

; 194  : {

$LN13:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 206  : 
; 207  : // dest = S1+S2+S3+S4+S5
; 208  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 209  : {
; 210  : 	u32 l1 = xr_strlen(S1);
; 211  : 	u32 l2 = xr_strlen(S2);
; 212  : 	u32 l3 = xr_strlen(S3);
; 213  : 	u32 l4 = xr_strlen(S4);
; 214  : 	strcpy_s(dest,dest_sz,S1);
; 215  : 	strcat_s(dest,dest_sz-l1,S2);
; 216  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 217  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 218  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 219  : 
; 220  : 	return dest;
; 221  : //.	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5);
; 222  : }
; 223  : 
; 224  : // dest = S1+S2+S3+S4+S5+S6
; 225  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 226  : {
; 227  : 	u32 l1 = xr_strlen(S1);
; 228  : 	u32 l2 = xr_strlen(S2);
; 229  : 	u32 l3 = xr_strlen(S3);
; 230  : 	u32 l4 = xr_strlen(S4);
; 231  : 	u32 l5 = xr_strlen(S5);
; 232  : 	strcpy_s(dest,dest_sz,S1);
; 233  : 	strcat_s(dest,dest_sz-l1,S2);
; 234  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 235  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 236  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 237  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4-l5,S6);
; 238  : 
; 239  : 	return dest;
; 240  : 	//.	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6);
; 241  : }
; 242  : 
; 243  : #else
; 244  : 
; 245  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2)
; 246  : {	return strcat(strcpy(dest,S1),S2); }
; 247  : 
; 248  : // dest = S1+S2+S3
; 249  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3)
; 250  : {	return strcat(strcat(strcpy(dest,S1),S2),S3); }
; 251  : 
; 252  : // dest = S1+S2+S3+S4
; 253  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 254  : {	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4); }
; 255  : 
; 256  : // dest = S1+S2+S3+S4+S5
; 257  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 258  : {	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5); }
; 259  : 
; 260  : // dest = S1+S2+S3+S4+S5+S6
; 261  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 262  : {	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6); }
; 263  : 
; 264  : #endif
; 265  : // return pointer to ".ext"
; 266  : IC char*						strext					( const char* S )
; 267  : {	return (char*) strrchr(S,'.');	}
; 268  : 
; 269  : IC u32							xr_strlen				( const char* S )
; 270  : {	return (u32)strlen(S);			}

	or	rbx, -1

; 194  : {

	mov	r14, r9
	mov	r12, rdx

; 206  : 
; 207  : // dest = S1+S2+S3+S4+S5
; 208  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 209  : {
; 210  : 	u32 l1 = xr_strlen(S1);
; 211  : 	u32 l2 = xr_strlen(S2);
; 212  : 	u32 l3 = xr_strlen(S3);
; 213  : 	u32 l4 = xr_strlen(S4);
; 214  : 	strcpy_s(dest,dest_sz,S1);
; 215  : 	strcat_s(dest,dest_sz-l1,S2);
; 216  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 217  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 218  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 219  : 
; 220  : 	return dest;
; 221  : //.	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5);
; 222  : }
; 223  : 
; 224  : // dest = S1+S2+S3+S4+S5+S6
; 225  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 226  : {
; 227  : 	u32 l1 = xr_strlen(S1);
; 228  : 	u32 l2 = xr_strlen(S2);
; 229  : 	u32 l3 = xr_strlen(S3);
; 230  : 	u32 l4 = xr_strlen(S4);
; 231  : 	u32 l5 = xr_strlen(S5);
; 232  : 	strcpy_s(dest,dest_sz,S1);
; 233  : 	strcat_s(dest,dest_sz-l1,S2);
; 234  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 235  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 236  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 237  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4-l5,S6);
; 238  : 
; 239  : 	return dest;
; 240  : 	//.	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6);
; 241  : }
; 242  : 
; 243  : #else
; 244  : 
; 245  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2)
; 246  : {	return strcat(strcpy(dest,S1),S2); }
; 247  : 
; 248  : // dest = S1+S2+S3
; 249  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3)
; 250  : {	return strcat(strcat(strcpy(dest,S1),S2),S3); }
; 251  : 
; 252  : // dest = S1+S2+S3+S4
; 253  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 254  : {	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4); }
; 255  : 
; 256  : // dest = S1+S2+S3+S4+S5
; 257  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 258  : {	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5); }
; 259  : 
; 260  : // dest = S1+S2+S3+S4+S5+S6
; 261  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 262  : {	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6); }
; 263  : 
; 264  : #endif
; 265  : // return pointer to ".ext"
; 266  : IC char*						strext					( const char* S )
; 267  : {	return (char*) strrchr(S,'.');	}
; 268  : 
; 269  : IC u32							xr_strlen				( const char* S )
; 270  : {	return (u32)strlen(S);			}

	mov	rdi, rbx

; 194  : {

	movsxd	r15, ecx
	npad	2
$LL11@strconcat:

; 206  : 
; 207  : // dest = S1+S2+S3+S4+S5
; 208  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 209  : {
; 210  : 	u32 l1 = xr_strlen(S1);
; 211  : 	u32 l2 = xr_strlen(S2);
; 212  : 	u32 l3 = xr_strlen(S3);
; 213  : 	u32 l4 = xr_strlen(S4);
; 214  : 	strcpy_s(dest,dest_sz,S1);
; 215  : 	strcat_s(dest,dest_sz-l1,S2);
; 216  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 217  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 218  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 219  : 
; 220  : 	return dest;
; 221  : //.	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5);
; 222  : }
; 223  : 
; 224  : // dest = S1+S2+S3+S4+S5+S6
; 225  : IC LPCSTR						strconcat				( int dest_sz, char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 226  : {
; 227  : 	u32 l1 = xr_strlen(S1);
; 228  : 	u32 l2 = xr_strlen(S2);
; 229  : 	u32 l3 = xr_strlen(S3);
; 230  : 	u32 l4 = xr_strlen(S4);
; 231  : 	u32 l5 = xr_strlen(S5);
; 232  : 	strcpy_s(dest,dest_sz,S1);
; 233  : 	strcat_s(dest,dest_sz-l1,S2);
; 234  : 	strcat_s(dest,dest_sz-l1-l2,S3);
; 235  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);
; 236  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4,S5);
; 237  : 	strcat_s(dest,dest_sz-l1-l2-l3-l4-l5,S6);
; 238  : 
; 239  : 	return dest;
; 240  : 	//.	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6);
; 241  : }
; 242  : 
; 243  : #else
; 244  : 
; 245  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2)
; 246  : {	return strcat(strcpy(dest,S1),S2); }
; 247  : 
; 248  : // dest = S1+S2+S3
; 249  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3)
; 250  : {	return strcat(strcat(strcpy(dest,S1),S2),S3); }
; 251  : 
; 252  : // dest = S1+S2+S3+S4
; 253  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4)
; 254  : {	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4); }
; 255  : 
; 256  : // dest = S1+S2+S3+S4+S5
; 257  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5)
; 258  : {	return strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5); }
; 259  : 
; 260  : // dest = S1+S2+S3+S4+S5+S6
; 261  : IC char*						strconcat				( int dest_sz,  char* dest, const char* S1, const char* S2, const char* S3, const char* S4, const char* S5, const char* S6)
; 262  : {	return strcat(strcat(strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4),S5),S6); }
; 263  : 
; 264  : #endif
; 265  : // return pointer to ".ext"
; 266  : IC char*						strext					( const char* S )
; 267  : {	return (char*) strrchr(S,'.');	}
; 268  : 
; 269  : IC u32							xr_strlen				( const char* S )
; 270  : {	return (u32)strlen(S);			}

	inc	rdi
	cmp	BYTE PTR [r8+rdi], 0
	jne	SHORT $LL11@strconcat
	mov	rsi, rbx
	npad	3
$LL10@strconcat:
	inc	rsi
	cmp	BYTE PTR [r9+rsi], 0
	jne	SHORT $LL10@strconcat
	mov	rbp, QWORD PTR S3$[rsp]
	npad	1
$LL9@strconcat:
	inc	rbx
	cmp	BYTE PTR [rbx+rbp], 0
	jne	SHORT $LL9@strconcat

; 195  : 	u32 l1 = xr_strlen(S1);
; 196  : 	u32 l2 = xr_strlen(S2);
; 197  : 	u32 l3 = xr_strlen(S3);
; 198  : 	strcpy_s(dest,dest_sz,S1);

	mov	rdx, r15
	mov	rcx, r12
	call	QWORD PTR __imp_strcpy_s

; 199  : 	strcat_s(dest,dest_sz-l1,S2);

	mov	edx, r15d
	mov	r8, r14
	sub	edx, edi
	mov	rcx, r12
	call	QWORD PTR __imp_strcat_s

; 200  : 	strcat_s(dest,dest_sz-l1-l2,S3);

	mov	edx, r15d
	mov	r8, rbp
	sub	edx, esi
	mov	rcx, r12
	sub	edx, edi
	call	QWORD PTR __imp_strcat_s

; 201  : 	strcat_s(dest,dest_sz-l1-l2-l3,S4);

	mov	r8, QWORD PTR S4$[rsp]
	sub	r15d, ebx
	sub	r15d, esi
	mov	rcx, r12
	sub	r15d, edi
	mov	edx, r15d
	call	QWORD PTR __imp_strcat_s

; 202  : 
; 203  : 	return dest;
; 204  : //.	return strcat(strcat(strcat(strcpy(dest,S1),S2),S3),S4);
; 205  : }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	mov	rax, r12
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
?strconcat@@YAPEBDHPEADPEBD111@Z ENDP			; strconcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\nummer\documents\github\olr-3.0\src\xray\xrcore\_std_extensions.h
;	COMDAT ?strext@@YAPEADPEBD@Z
_TEXT	SEGMENT
S$ = 8
?strext@@YAPEADPEBD@Z PROC				; strext, COMDAT

; 267  : {	return (char*) strrchr(S,'.');	}

	mov	edx, 46					; 0000002eH
	rex_jmp	QWORD PTR __imp_strrchr
?strext@@YAPEADPEBD@Z ENDP				; strext
_TEXT	ENDS
END
